; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\motor.o --asm_dir=.\OBJ\ --list_dir=.\OBJ\ --depend=.\obj\motor.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I.\CORE -I.\USER -I.\HALLIB\STM32F4xx_HAL_Driver\Inc -I.\SYSTEM -I.\Hardware -I.\App -I.\DSP_LIB\Include -I.\FreeRTOS -I.\MPU9250\DMP -I.\MPU9250 -I.\RTE\_Project -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=526 -DSTM32F427xx -DSTM32F4 -DUSE_HAL_DRIVER -DSTM32F427xx -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=.\obj\motor.crf App\Motor.c]
                          THUMB

                          AREA ||i.HAL_CAN_RxCpltCallback||, CODE, READONLY, ALIGN=2

                  HAL_CAN_RxCpltCallback PROC
;;;69     float ZGyroModuleAngle;
;;;70     void HAL_CAN_RxCpltCallback(CAN_HandleTypeDef* _hcan)
000000  b530              PUSH     {r4,r5,lr}
;;;71     {
000002  4604              MOV      r4,r0
;;;72     	u8 i;
;;;73     	switch(_hcan->pRxMsg->StdId)
000004  6b60              LDR      r0,[r4,#0x34]
000006  6800              LDR      r0,[r0,#0]
000008  f2402205          MOV      r2,#0x205
00000c  1a81              SUBS     r1,r0,r2
00000e  4290              CMP      r0,r2
000010  d018              BEQ      |L1.68|
000012  dc09              BGT      |L1.40|
000014  f2a02001          SUB      r0,r0,#0x201
000018  b180              CBZ      r0,|L1.60|
00001a  2801              CMP      r0,#1
00001c  d00f              BEQ      |L1.62|
00001e  2802              CMP      r0,#2
000020  d00e              BEQ      |L1.64|
000022  2803              CMP      r0,#3
000024  d175              BNE      |L1.274|
000026  e00c              B        |L1.66|
                  |L1.40|
000028  2901              CMP      r1,#1
00002a  d00c              BEQ      |L1.70|
00002c  2902              CMP      r1,#2
00002e  d00b              BEQ      |L1.72|
000030  2903              CMP      r1,#3
000032  d00a              BEQ      |L1.74|
000034  f5b17ffe          CMP      r1,#0x1fc
000038  d16b              BNE      |L1.274|
00003a  e035              B        |L1.168|
                  |L1.60|
;;;74     	{
;;;75     		case CAN_3510Moto1_ID:
;;;76     		case CAN_3510Moto2_ID:
00003c  bf00              NOP      
                  |L1.62|
;;;77     		case CAN_3510Moto3_ID:
00003e  bf00              NOP      
                  |L1.64|
;;;78     		case CAN_3510Moto4_ID:
000040  bf00              NOP      
                  |L1.66|
;;;79     		case CAN_3510Moto5_ID:
000042  bf00              NOP      
                  |L1.68|
;;;80     		case CAN_3510Moto6_ID:
000044  bf00              NOP      
                  |L1.70|
;;;81     		case CAN_3510Moto7_ID:
000046  bf00              NOP      
                  |L1.72|
;;;82     		case CAN_3510Moto8_ID:
000048  bf00              NOP      
                  |L1.74|
;;;83     		{
;;;84     				i = _hcan->pRxMsg->StdId - CAN_3510Moto1_ID;
00004a  6b60              LDR      r0,[r4,#0x34]
00004c  7800              LDRB     r0,[r0,#0]
00004e  1e40              SUBS     r0,r0,#1
000050  b2c5              UXTB     r5,r0
;;;85     				moto_chassis[i].msg_cnt++ <= 50	?	get_moto_offset(&moto_chassis[i], _hcan) : get_moto_measure(&moto_chassis[i], _hcan);
000052  eb050085          ADD      r0,r5,r5,LSL #2
000056  4938              LDR      r1,|L1.312|
000058  eb0100c0          ADD      r0,r1,r0,LSL #3
00005c  6a41              LDR      r1,[r0,#0x24]
00005e  eb050085          ADD      r0,r5,r5,LSL #2
000062  4a35              LDR      r2,|L1.312|
000064  eb0200c0          ADD      r0,r2,r0,LSL #3
000068  6a40              LDR      r0,[r0,#0x24]
00006a  1c40              ADDS     r0,r0,#1
00006c  eb050285          ADD      r2,r5,r5,LSL #2
000070  4b31              LDR      r3,|L1.312|
000072  eb0302c2          ADD      r2,r3,r2,LSL #3
000076  6250              STR      r0,[r2,#0x24]
000078  2932              CMP      r1,#0x32
00007a  d808              BHI      |L1.142|
00007c  eb050185          ADD      r1,r5,r5,LSL #2
000080  461a              MOV      r2,r3
000082  eb0200c1          ADD      r0,r2,r1,LSL #3
000086  4621              MOV      r1,r4
000088  f7fffffe          BL       get_moto_offset
00008c  e007              B        |L1.158|
                  |L1.142|
00008e  eb050185          ADD      r1,r5,r5,LSL #2
000092  4a29              LDR      r2,|L1.312|
000094  eb0200c1          ADD      r0,r2,r1,LSL #3
000098  4621              MOV      r1,r4
00009a  f7fffffe          BL       get_moto_measure
                  |L1.158|
;;;86     				get_moto_measure(&moto_info,_hcan);
00009e  4621              MOV      r1,r4
0000a0  4826              LDR      r0,|L1.316|
0000a2  f7fffffe          BL       get_moto_measure
;;;87     				break;
0000a6  e034              B        |L1.274|
                  |L1.168|
;;;88     		}
;;;89     		case SINGLE_GYRO_ID:
;;;90     		{
;;;91     			single_gyro.angle = 0.001f * ((int32_t)( (_hcan->pRxMsg->Data[0] << 24) | (_hcan->pRxMsg->Data[1] << 16) | (_hcan->pRxMsg->Data[2] << 8) | (_hcan->pRxMsg->Data[3]) ) );
0000a8  6b60              LDR      r0,[r4,#0x34]
0000aa  7d00              LDRB     r0,[r0,#0x14]
0000ac  0601              LSLS     r1,r0,#24
0000ae  6b60              LDR      r0,[r4,#0x34]
0000b0  7d40              LDRB     r0,[r0,#0x15]
0000b2  ea414100          ORR      r1,r1,r0,LSL #16
0000b6  6b60              LDR      r0,[r4,#0x34]
0000b8  7d80              LDRB     r0,[r0,#0x16]
0000ba  ea412000          ORR      r0,r1,r0,LSL #8
0000be  6b61              LDR      r1,[r4,#0x34]
0000c0  7dc9              LDRB     r1,[r1,#0x17]
0000c2  4308              ORRS     r0,r0,r1
0000c4  ee000a10          VMOV     s0,r0
0000c8  eeb80ac0          VCVT.F32.S32 s0,s0
0000cc  eddf0a1c          VLDR     s1,|L1.320|
0000d0  ee200a20          VMUL.F32 s0,s0,s1
0000d4  ee100a10          VMOV     r0,s0
0000d8  491a              LDR      r1,|L1.324|
0000da  6008              STR      r0,[r1,#0]  ; single_gyro
;;;92           single_gyro.gyro = 0.001f * ((int32_t)( (_hcan->pRxMsg->Data[4] << 24) | (_hcan->pRxMsg->Data[5] << 16) | (_hcan->pRxMsg->Data[6] << 8) | (_hcan->pRxMsg->Data[7]) ) );
0000dc  6b60              LDR      r0,[r4,#0x34]
0000de  7e00              LDRB     r0,[r0,#0x18]
0000e0  0601              LSLS     r1,r0,#24
0000e2  6b60              LDR      r0,[r4,#0x34]
0000e4  7e40              LDRB     r0,[r0,#0x19]
0000e6  ea414100          ORR      r1,r1,r0,LSL #16
0000ea  6b60              LDR      r0,[r4,#0x34]
0000ec  7e80              LDRB     r0,[r0,#0x1a]
0000ee  ea412000          ORR      r0,r1,r0,LSL #8
0000f2  6b61              LDR      r1,[r4,#0x34]
0000f4  7ec9              LDRB     r1,[r1,#0x1b]
0000f6  4308              ORRS     r0,r0,r1
0000f8  ee000a10          VMOV     s0,r0
0000fc  eeb80ac0          VCVT.F32.S32 s0,s0
000100  eddf0a0f          VLDR     s1,|L1.320|
000104  ee200a20          VMUL.F32 s0,s0,s1
000108  ee100a10          VMOV     r0,s0
00010c  490d              LDR      r1,|L1.324|
00010e  6048              STR      r0,[r1,#4]  ; single_gyro
;;;93           break;
000110  bf00              NOP      
                  |L1.274|
000112  bf00              NOP                            ;87
;;;94     		}
;;;95     	}
;;;96     	__HAL_CAN_ENABLE_IT(&hcan1, CAN_IT_FMP0);
000114  480c              LDR      r0,|L1.328|
000116  6800              LDR      r0,[r0,#0]  ; hcan1
000118  6940              LDR      r0,[r0,#0x14]
00011a  f0400002          ORR      r0,r0,#2
00011e  490a              LDR      r1,|L1.328|
000120  6809              LDR      r1,[r1,#0]  ; hcan1
000122  6148              STR      r0,[r1,#0x14]
;;;97     	__HAL_CAN_ENABLE_IT(&hcan2, CAN_IT_FMP0);
000124  4809              LDR      r0,|L1.332|
000126  6800              LDR      r0,[r0,#0]  ; hcan2
000128  6940              LDR      r0,[r0,#0x14]
00012a  f0400002          ORR      r0,r0,#2
00012e  4907              LDR      r1,|L1.332|
000130  6809              LDR      r1,[r1,#0]  ; hcan2
000132  6148              STR      r0,[r1,#0x14]
;;;98     }
000134  bd30              POP      {r4,r5,pc}
;;;99     void get_moto_measure(moto_measure_t *ptr, CAN_HandleTypeDef* hcan)
                          ENDP

000136  0000              DCW      0x0000
                  |L1.312|
                          DCD      moto_chassis
                  |L1.316|
                          DCD      moto_info
                  |L1.320|
000140  3a83126f          DCFS     0x3a83126f ; 0.0010000000474974513
                  |L1.324|
                          DCD      single_gyro
                  |L1.328|
                          DCD      hcan1
                  |L1.332|
                          DCD      hcan2

                          AREA ||i.Motor_Init||, CODE, READONLY, ALIGN=2

                  Motor_Init PROC
;;;11     void get_moto_offset(moto_measure_t *ptr, CAN_HandleTypeDef* hcan);
;;;12     void Motor_Init(void)
000000  b510              PUSH     {r4,lr}
;;;13     {
;;;14     	my_can_filter_init_recv_all(&hcan1);
000002  4807              LDR      r0,|L2.32|
000004  f7fffffe          BL       my_can_filter_init_recv_all
;;;15     	my_can_filter_init_recv_all(&hcan2);
000008  4806              LDR      r0,|L2.36|
00000a  f7fffffe          BL       my_can_filter_init_recv_all
;;;16     	HAL_CAN_Receive_IT(&hcan1, CAN_FIFO0);
00000e  2100              MOVS     r1,#0
000010  4803              LDR      r0,|L2.32|
000012  f7fffffe          BL       HAL_CAN_Receive_IT
;;;17     	HAL_CAN_Receive_IT(&hcan2, CAN_FIFO1);
000016  2101              MOVS     r1,#1
000018  4802              LDR      r0,|L2.36|
00001a  f7fffffe          BL       HAL_CAN_Receive_IT
;;;18     }
00001e  bd10              POP      {r4,pc}
;;;19     void my_can_filter_init_recv_all(CAN_HandleTypeDef* _hcan)
                          ENDP

                  |L2.32|
                          DCD      hcan1
                  |L2.36|
                          DCD      hcan2

                          AREA ||i.can_filter_recv_special||, CODE, READONLY, ALIGN=1

                  can_filter_recv_special PROC
;;;49     }
;;;50     void can_filter_recv_special(CAN_HandleTypeDef* hcan, uint8_t filter_number, uint16_t filtered_id)
000000  b570              PUSH     {r4-r6,lr}
;;;51     {
000002  b08a              SUB      sp,sp,#0x28
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4614              MOV      r4,r2
;;;52     	CAN_FilterConfTypeDef cf;
;;;53     	cf.FilterNumber = filter_number;
00000a  9505              STR      r5,[sp,#0x14]
;;;54     	cf.FilterMode = CAN_FILTERMODE_IDMASK;
00000c  2000              MOVS     r0,#0
00000e  9006              STR      r0,[sp,#0x18]
;;;55     	cf.FilterScale = CAN_FILTERSCALE_32BIT;
000010  2001              MOVS     r0,#1
000012  9007              STR      r0,[sp,#0x1c]
;;;56     	cf.FilterIdHigh = (filtered_id<<21)>>16;
000014  0160              LSLS     r0,r4,#5
000016  b200              SXTH     r0,r0
000018  9000              STR      r0,[sp,#0]
;;;57     	cf.FilterIdLow = filtered_id<<21;
00001a  0560              LSLS     r0,r4,#21
00001c  9001              STR      r0,[sp,#4]
;;;58     	cf.FilterMaskIdHigh = 0xFFFF;
00001e  f64f70ff          MOV      r0,#0xffff
000022  9002              STR      r0,[sp,#8]
;;;59     	cf.FilterMaskIdLow = 0xFFF8;
000024  1fc0              SUBS     r0,r0,#7
000026  9003              STR      r0,[sp,#0xc]
;;;60     	cf.FilterFIFOAssignment = CAN_FilterFIFO0;
000028  2000              MOVS     r0,#0
00002a  9004              STR      r0,[sp,#0x10]
;;;61     	cf.BankNumber = 14;
00002c  200e              MOVS     r0,#0xe
00002e  9009              STR      r0,[sp,#0x24]
;;;62     	cf.FilterActivation = ENABLE;
000030  2001              MOVS     r0,#1
000032  9008              STR      r0,[sp,#0x20]
;;;63     	HAL_CAN_ConfigFilter(hcan, &cf);
000034  4669              MOV      r1,sp
000036  4630              MOV      r0,r6
000038  f7fffffe          BL       HAL_CAN_ConfigFilter
;;;64     } 
00003c  b00a              ADD      sp,sp,#0x28
00003e  bd70              POP      {r4-r6,pc}
;;;65     HAL_StatusTypeDef can_send_msg()
                          ENDP


                          AREA ||i.can_send_msg||, CODE, READONLY, ALIGN=1

                  can_send_msg PROC
;;;64     } 
;;;65     HAL_StatusTypeDef can_send_msg()
000000  2000              MOVS     r0,#0
;;;66     { 
;;;67     	return HAL_OK;
;;;68     }
000002  4770              BX       lr
;;;69     float ZGyroModuleAngle;
                          ENDP


                          AREA ||i.get_moto_measure||, CODE, READONLY, ALIGN=1

                  get_moto_measure PROC
;;;98     }
;;;99     void get_moto_measure(moto_measure_t *ptr, CAN_HandleTypeDef* hcan)
000000  8902              LDRH     r2,[r0,#8]
;;;100    {
;;;101    	ptr->last_angle = ptr->angle;
000002  8142              STRH     r2,[r0,#0xa]
;;;102    	ptr->angle = (uint16_t)(hcan->pRxMsg->Data[0]<<8 | hcan->pRxMsg->Data[1]) ;
000004  6b4a              LDR      r2,[r1,#0x34]
000006  7d52              LDRB     r2,[r2,#0x15]
000008  6b4b              LDR      r3,[r1,#0x34]
00000a  7d1b              LDRB     r3,[r3,#0x14]
00000c  ea422203          ORR      r2,r2,r3,LSL #8
000010  8102              STRH     r2,[r0,#8]
;;;103    	ptr->real_current  = (int16_t)(hcan->pRxMsg->Data[2]<<8 | hcan->pRxMsg->Data[3]);
000012  6b4a              LDR      r2,[r1,#0x34]
000014  7dd3              LDRB     r3,[r2,#0x17]
000016  7d92              LDRB     r2,[r2,#0x16]
000018  ea432202          ORR      r2,r3,r2,LSL #8
00001c  b212              SXTH     r2,r2
00001e  8042              STRH     r2,[r0,#2]
;;;104    	ptr->speed_rpm = ptr->real_current;
000020  8842              LDRH     r2,[r0,#2]
000022  8002              STRH     r2,[r0,#0]
;;;105    	ptr->given_current = (int16_t)(hcan->pRxMsg->Data[4]<<8 | hcan->pRxMsg->Data[5])/-5;
000024  6b4a              LDR      r2,[r1,#0x34]
000026  7e53              LDRB     r3,[r2,#0x19]
000028  7e12              LDRB     r2,[r2,#0x18]
00002a  ea432202          ORR      r2,r3,r2,LSL #8
00002e  b212              SXTH     r2,r2
000030  f06f0304          MVN      r3,#4
000034  fb92f2f3          SDIV     r2,r2,r3
000038  b212              SXTH     r2,r2
00003a  8082              STRH     r2,[r0,#4]
;;;106    	ptr->hall = hcan->pRxMsg->Data[6];
00003c  6b4a              LDR      r2,[r1,#0x34]
00003e  7e92              LDRB     r2,[r2,#0x1a]
000040  7182              STRB     r2,[r0,#6]
;;;107    	if(ptr->angle - ptr->last_angle > 4096)
000042  8902              LDRH     r2,[r0,#8]
000044  8943              LDRH     r3,[r0,#0xa]
000046  1ad2              SUBS     r2,r2,r3
000048  f5b25f80          CMP      r2,#0x1000
00004c  dd05              BLE      |L5.90|
;;;108    		ptr->round_cnt --;
00004e  f8d0200e          LDR      r2,[r0,#0xe]
000052  1e52              SUBS     r2,r2,#1
000054  f8c0200e          STR      r2,[r0,#0xe]
000058  e00a              B        |L5.112|
                  |L5.90|
;;;109    	else if (ptr->angle - ptr->last_angle < -4096)
00005a  8902              LDRH     r2,[r0,#8]
00005c  8943              LDRH     r3,[r0,#0xa]
00005e  1ad2              SUBS     r2,r2,r3
000060  f5125f80          CMN      r2,#0x1000
000064  da04              BGE      |L5.112|
;;;110    		ptr->round_cnt ++;
000066  f8d0200e          LDR      r2,[r0,#0xe]
00006a  1c52              ADDS     r2,r2,#1
00006c  f8c0200e          STR      r2,[r0,#0xe]
                  |L5.112|
;;;111    	ptr->total_angle = ptr->round_cnt * 8192 + ptr->angle - ptr->offset_angle;
000070  8903              LDRH     r3,[r0,#8]
000072  f8d0200e          LDR      r2,[r0,#0xe]
000076  eb033242          ADD      r2,r3,r2,LSL #13
00007a  8983              LDRH     r3,[r0,#0xc]
00007c  1ad2              SUBS     r2,r2,r3
00007e  f8c02012          STR      r2,[r0,#0x12]
;;;112    }
000082  4770              BX       lr
;;;113    void get_moto_offset(moto_measure_t *ptr, CAN_HandleTypeDef* hcan)
                          ENDP


                          AREA ||i.get_moto_offset||, CODE, READONLY, ALIGN=1

                  get_moto_offset PROC
;;;112    }
;;;113    void get_moto_offset(moto_measure_t *ptr, CAN_HandleTypeDef* hcan)
000000  6b4a              LDR      r2,[r1,#0x34]
;;;114    {
;;;115    	ptr->angle = (uint16_t)(hcan->pRxMsg->Data[0]<<8 | hcan->pRxMsg->Data[1]) ;
000002  7d52              LDRB     r2,[r2,#0x15]
000004  6b4b              LDR      r3,[r1,#0x34]
000006  7d1b              LDRB     r3,[r3,#0x14]
000008  ea422203          ORR      r2,r2,r3,LSL #8
00000c  8102              STRH     r2,[r0,#8]
;;;116    	ptr->offset_angle = ptr->angle;
00000e  8902              LDRH     r2,[r0,#8]
000010  8182              STRH     r2,[r0,#0xc]
;;;117    }
000012  4770              BX       lr
;;;118    
                          ENDP


                          AREA ||i.get_total_angle||, CODE, READONLY, ALIGN=1

                  get_total_angle PROC
;;;119    #define ABS(x)	( (x>0) ? (x) : (-x) )
;;;120    void get_total_angle(moto_measure_t *p)
000000  b530              PUSH     {r4,r5,lr}
;;;121    {
;;;122    	int res1, res2, delta;
;;;123    	if(p->angle < p->last_angle)
000002  8904              LDRH     r4,[r0,#8]
000004  8945              LDRH     r5,[r0,#0xa]
000006  42ac              CMP      r4,r5
000008  da08              BGE      |L7.28|
;;;124    	{
;;;125    		res1 = p->angle + 8192 - p->last_angle;
00000a  8904              LDRH     r4,[r0,#8]
00000c  f5045400          ADD      r4,r4,#0x2000
000010  8945              LDRH     r5,[r0,#0xa]
000012  1b61              SUBS     r1,r4,r5
;;;126    		res2 = p->angle - p->last_angle;
000014  8904              LDRH     r4,[r0,#8]
000016  8945              LDRH     r5,[r0,#0xa]
000018  1b62              SUBS     r2,r4,r5
00001a  e007              B        |L7.44|
                  |L7.28|
;;;127    	}
;;;128    	else
;;;129    	{
;;;130    		res1 = p->angle - 8192 - p->last_angle;
00001c  8904              LDRH     r4,[r0,#8]
00001e  f5a45400          SUB      r4,r4,#0x2000
000022  8945              LDRH     r5,[r0,#0xa]
000024  1b61              SUBS     r1,r4,r5
;;;131    		res2 = p->angle - p->last_angle;
000026  8904              LDRH     r4,[r0,#8]
000028  8945              LDRH     r5,[r0,#0xa]
00002a  1b62              SUBS     r2,r4,r5
                  |L7.44|
;;;132    	}
;;;133    	if(ABS(res1)<ABS(res2))
00002c  2900              CMP      r1,#0
00002e  dd01              BLE      |L7.52|
000030  460c              MOV      r4,r1
000032  e000              B        |L7.54|
                  |L7.52|
000034  424c              RSBS     r4,r1,#0
                  |L7.54|
000036  2a00              CMP      r2,#0
000038  dd01              BLE      |L7.62|
00003a  4615              MOV      r5,r2
00003c  e000              B        |L7.64|
                  |L7.62|
00003e  4255              RSBS     r5,r2,#0
                  |L7.64|
000040  42ac              CMP      r4,r5
000042  da01              BGE      |L7.72|
;;;134    		delta = res1;
000044  460b              MOV      r3,r1
000046  e000              B        |L7.74|
                  |L7.72|
;;;135    	else
;;;136    		delta = res2;
000048  4613              MOV      r3,r2
                  |L7.74|
;;;137    	p->total_angle += delta;
00004a  f8d04012          LDR      r4,[r0,#0x12]
00004e  441c              ADD      r4,r4,r3
000050  f8c04012          STR      r4,[r0,#0x12]
;;;138    	p->last_angle = p->angle;
000054  8904              LDRH     r4,[r0,#8]
000056  8144              STRH     r4,[r0,#0xa]
;;;139    }
000058  bd30              POP      {r4,r5,pc}
;;;140    void set_moto_current(CAN_HandleTypeDef* hcan, s16 iq1, s16 iq2, s16 iq3, s16 iq4,u32 Motor_ID)
                          ENDP


                          AREA ||i.my_can_filter_init_recv_all||, CODE, READONLY, ALIGN=2

                  my_can_filter_init_recv_all PROC
;;;18     }
;;;19     void my_can_filter_init_recv_all(CAN_HandleTypeDef* _hcan)
000000  b510              PUSH     {r4,lr}
;;;20     {
000002  b08a              SUB      sp,sp,#0x28
000004  4604              MOV      r4,r0
;;;21     	CAN_FilterConfTypeDef		CAN_FilterConfigStructure;
;;;22     	static CanTxMsgTypeDef		Tx1Message;
;;;23     	static CanRxMsgTypeDef 		Rx1Message;
;;;24     	static CanTxMsgTypeDef		Tx2Message;
;;;25     	static CanRxMsgTypeDef 		Rx2Message;
;;;26     	CAN_FilterConfigStructure.FilterNumber = 0;
000006  2000              MOVS     r0,#0
000008  9005              STR      r0,[sp,#0x14]
;;;27     	CAN_FilterConfigStructure.FilterMode = CAN_FILTERMODE_IDMASK;
00000a  9006              STR      r0,[sp,#0x18]
;;;28     	CAN_FilterConfigStructure.FilterScale = CAN_FILTERSCALE_32BIT;
00000c  2001              MOVS     r0,#1
00000e  9007              STR      r0,[sp,#0x1c]
;;;29     	CAN_FilterConfigStructure.FilterIdHigh = 0x0000;
000010  2000              MOVS     r0,#0
000012  9000              STR      r0,[sp,#0]
;;;30     	CAN_FilterConfigStructure.FilterIdLow = 0x0000;
000014  9001              STR      r0,[sp,#4]
;;;31     	CAN_FilterConfigStructure.FilterMaskIdHigh = 0x0000;
000016  9002              STR      r0,[sp,#8]
;;;32     	CAN_FilterConfigStructure.FilterMaskIdLow = 0x0000;
000018  9003              STR      r0,[sp,#0xc]
;;;33     	CAN_FilterConfigStructure.FilterFIFOAssignment = CAN_FilterFIFO0;
00001a  9004              STR      r0,[sp,#0x10]
;;;34     	CAN_FilterConfigStructure.BankNumber = 14;
00001c  200e              MOVS     r0,#0xe
00001e  9009              STR      r0,[sp,#0x24]
;;;35     	CAN_FilterConfigStructure.FilterActivation = ENABLE;
000020  2001              MOVS     r0,#1
000022  9008              STR      r0,[sp,#0x20]
;;;36     	HAL_CAN_ConfigFilter(_hcan, &CAN_FilterConfigStructure);
000024  4669              MOV      r1,sp
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_CAN_ConfigFilter
;;;37     	CAN_FilterConfigStructure.FilterNumber = 14;
00002c  200e              MOVS     r0,#0xe
00002e  9005              STR      r0,[sp,#0x14]
;;;38     	HAL_CAN_ConfigFilter(_hcan, &CAN_FilterConfigStructure);
000030  4669              MOV      r1,sp
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       HAL_CAN_ConfigFilter
;;;39     	if(_hcan == &hcan1)
000038  4807              LDR      r0,|L8.88|
00003a  4284              CMP      r4,r0
00003c  d103              BNE      |L8.70|
;;;40     	{
;;;41     		_hcan->pTxMsg = &Tx1Message;
00003e  4807              LDR      r0,|L8.92|
000040  6320              STR      r0,[r4,#0x30]
;;;42     		_hcan->pRxMsg = &Rx1Message;
000042  4807              LDR      r0,|L8.96|
000044  6360              STR      r0,[r4,#0x34]
                  |L8.70|
;;;43     	}
;;;44     	if(_hcan == &hcan2)
000046  4807              LDR      r0,|L8.100|
000048  4284              CMP      r4,r0
00004a  d103              BNE      |L8.84|
;;;45     	{
;;;46     		_hcan->pTxMsg = &Tx2Message;
00004c  4806              LDR      r0,|L8.104|
00004e  6320              STR      r0,[r4,#0x30]
;;;47     		_hcan->pRxMsg = &Rx2Message;
000050  4806              LDR      r0,|L8.108|
000052  6360              STR      r0,[r4,#0x34]
                  |L8.84|
;;;48     	}
;;;49     }
000054  b00a              ADD      sp,sp,#0x28
000056  bd10              POP      {r4,pc}
;;;50     void can_filter_recv_special(CAN_HandleTypeDef* hcan, uint8_t filter_number, uint16_t filtered_id)
                          ENDP

                  |L8.88|
                          DCD      hcan1
                  |L8.92|
                          DCD      Tx1Message
                  |L8.96|
                          DCD      Rx1Message
                  |L8.100|
                          DCD      hcan2
                  |L8.104|
                          DCD      Tx2Message
                  |L8.108|
                          DCD      Rx2Message

                          AREA ||i.set_moto_current||, CODE, READONLY, ALIGN=1

                  set_moto_current PROC
;;;139    }
;;;140    void set_moto_current(CAN_HandleTypeDef* hcan, s16 iq1, s16 iq2, s16 iq3, s16 iq4,u32 Motor_ID)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;141    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  e9dd8908          LDRD     r8,r9,[sp,#0x20]
;;;142    	hcan->pTxMsg->StdId = Motor_ID;
000010  6b20              LDR      r0,[r4,#0x30]
000012  f8c09000          STR      r9,[r0,#0]
;;;143    	hcan->pTxMsg->IDE = CAN_ID_STD;
000016  2000              MOVS     r0,#0
000018  6b21              LDR      r1,[r4,#0x30]
00001a  6088              STR      r0,[r1,#8]
;;;144    	hcan->pTxMsg->RTR = CAN_RTR_DATA;
00001c  6b21              LDR      r1,[r4,#0x30]
00001e  60c8              STR      r0,[r1,#0xc]
;;;145    	hcan->pTxMsg->DLC = 0x08;
000020  2008              MOVS     r0,#8
000022  6b21              LDR      r1,[r4,#0x30]
000024  6108              STR      r0,[r1,#0x10]
;;;146    	hcan->pTxMsg->Data[0] = iq1 >> 8;
000026  0a28              LSRS     r0,r5,#8
000028  6b21              LDR      r1,[r4,#0x30]
00002a  7508              STRB     r0,[r1,#0x14]
;;;147    	hcan->pTxMsg->Data[1] = iq1;
00002c  6b20              LDR      r0,[r4,#0x30]
00002e  7545              STRB     r5,[r0,#0x15]
;;;148    	hcan->pTxMsg->Data[2] = iq2 >> 8;
000030  0a31              LSRS     r1,r6,#8
000032  6b20              LDR      r0,[r4,#0x30]
000034  7581              STRB     r1,[r0,#0x16]
;;;149    	hcan->pTxMsg->Data[3] = iq2;
000036  6b20              LDR      r0,[r4,#0x30]
000038  75c6              STRB     r6,[r0,#0x17]
;;;150    	hcan->pTxMsg->Data[4] = iq3 >> 8;
00003a  0a39              LSRS     r1,r7,#8
00003c  6b20              LDR      r0,[r4,#0x30]
00003e  7601              STRB     r1,[r0,#0x18]
;;;151    	hcan->pTxMsg->Data[5] = iq3;
000040  6b20              LDR      r0,[r4,#0x30]
000042  7647              STRB     r7,[r0,#0x19]
;;;152    	hcan->pTxMsg->Data[6] = iq4 >> 8;
000044  ea4f2118          LSR      r1,r8,#8
000048  6b20              LDR      r0,[r4,#0x30]
00004a  7681              STRB     r1,[r0,#0x1a]
;;;153    	hcan->pTxMsg->Data[7] = iq4;
00004c  6b20              LDR      r0,[r4,#0x30]
00004e  f880801b          STRB     r8,[r0,#0x1b]
;;;154    	HAL_CAN_Transmit(hcan, 1000);
000052  f44f717a          MOV      r1,#0x3e8
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       HAL_CAN_Transmit
;;;155    }	
00005c  e8bd87f0          POP      {r4-r10,pc}
;;;156    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  moto_chassis
                          %        320
                  moto_info
                          %        40
                  Tx1Message
                          %        28
                  Rx1Message
                          %        36
                  Tx2Message
                          %        28
                  Rx2Message
                          %        36

                          AREA ||.data||, DATA, ALIGN=2

                  single_gyro
                          %        8
                  ZGyroModuleAngle
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "App\\Motor.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_Motor_c_56dfef2b____REV16|
#line 388 ".\\CORE\\cmsis_armcc.h"
|__asm___7_Motor_c_56dfef2b____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_Motor_c_56dfef2b____REVSH|
#line 402
|__asm___7_Motor_c_56dfef2b____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___7_Motor_c_56dfef2b____RRX|
#line 587
|__asm___7_Motor_c_56dfef2b____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
