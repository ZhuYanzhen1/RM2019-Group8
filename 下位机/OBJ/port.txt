; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\port.o --asm_dir=.\OBJ\ --list_dir=.\OBJ\ --depend=.\obj\port.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I.\CORE -I.\USER -I.\HALLIB\STM32F4xx_HAL_Driver\Inc -I.\SYSTEM -I.\Hardware -I.\App -I.\DSP_LIB\Include -I.\FreeRTOS -I.\MPU9250\DMP -I.\MPU9250 -I.\RTE\_Project -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=526 -DSTM32F427xx -DSTM32F4 -DUSE_HAL_DRIVER -DSTM32F427xx -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=.\obj\port.crf FreeRTOS\port.c]
                          THUMB

                          AREA ||i.SysTick_Handler||, CODE, READONLY, ALIGN=2

                  SysTick_Handler PROC
;;;500    
;;;501    void xPortSysTickHandler( void )
000000  b510              PUSH     {r4,lr}
;;;502    {
;;;503    	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
;;;504    	executes all interrupts must be unmasked.  There is therefore no need to
;;;505    	save and then restore the interrupt mask value as its value is already
;;;506    	known - therefore the slightly faster vPortRaiseBASEPRI() function is used
;;;507    	in place of portSET_INTERRUPT_MASK_FROM_ISR(). */
;;;508    	vPortRaiseBASEPRI();
000002  bf00              NOP      
000004  2040              MOVS     r0,#0x40
000006  f3808811          MSR      BASEPRI,r0
00000a  f3bf8f4f          DSB      
00000e  f3bf8f6f          ISB      
000012  bf00              NOP      
;;;509    	{
;;;510    		/* Increment the RTOS tick. */
;;;511    		if( xTaskIncrementTick() != pdFALSE )
000014  f7fffffe          BL       xTaskIncrementTick
000018  b118              CBZ      r0,|L1.34|
;;;512    		{
;;;513    			/* A context switch is required.  Context switching is performed in
;;;514    			the PendSV interrupt.  Pend the PendSV interrupt. */
;;;515    			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
00001a  f04f5080          MOV      r0,#0x10000000
00001e  4904              LDR      r1,|L1.48|
000020  6008              STR      r0,[r1,#0]
                  |L1.34|
;;;516    		}
;;;517    	}
;;;518    	vPortClearBASEPRIFromISR();
000022  bf00              NOP      
000024  2000              MOVS     r0,#0
000026  f3808811          MSR      BASEPRI,r0
00002a  bf00              NOP      
;;;519    }
00002c  bd10              POP      {r4,pc}
;;;520    /*-----------------------------------------------------------*/
                          ENDP

00002e  0000              DCW      0x0000
                  |L1.48|
                          DCD      0xe000ed04

                          AREA ||i.prvTaskExitError||, CODE, READONLY, ALIGN=2

                  prvTaskExitError PROC
;;;220    
;;;221    static void prvTaskExitError( void )
000000  480e              LDR      r0,|L2.60|
;;;222    {
;;;223    	/* A function that implements a task must not exit or attempt to return to
;;;224    	its caller as there is nothing to return to.  If a task wants to exit it
;;;225    	should instead call vTaskDelete( NULL ).
;;;226    
;;;227    	Artificially force an assert() to be triggered if configASSERT() is
;;;228    	defined, then stop here so application writers can catch the error. */
;;;229    	configASSERT( uxCriticalNesting == ~0UL );
000002  6800              LDR      r0,[r0,#0]  ; uxCriticalNesting
000004  1c40              ADDS     r0,r0,#1
000006  b908              CBNZ     r0,|L2.12|
000008  2001              MOVS     r0,#1
00000a  e000              B        |L2.14|
                  |L2.12|
00000c  2000              MOVS     r0,#0
                  |L2.14|
00000e  b950              CBNZ     r0,|L2.38|
000010  bf00              NOP      
000012  2040              MOVS     r0,#0x40
000014  f3808811          MSR      BASEPRI,r0
000018  f3bf8f4f          DSB      
00001c  f3bf8f6f          ISB      
000020  bf00              NOP      
000022  bf00              NOP      
                  |L2.36|
000024  e7fe              B        |L2.36|
                  |L2.38|
;;;230    	portDISABLE_INTERRUPTS();
000026  bf00              NOP      
000028  2040              MOVS     r0,#0x40
00002a  f3808811          MSR      BASEPRI,r0
00002e  f3bf8f4f          DSB      
000032  f3bf8f6f          ISB      
000036  bf00              NOP      
;;;231    	for( ;; );
000038  bf00              NOP      
                  |L2.58|
00003a  e7fe              B        |L2.58|
;;;232    }
;;;233    /*-----------------------------------------------------------*/
                          ENDP

                  |L2.60|
                          DCD      uxCriticalNesting

                          AREA ||i.pxPortInitialiseStack||, CODE, READONLY, ALIGN=2

                  pxPortInitialiseStack PROC
;;;190     */
;;;191    StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
000000  1f00              SUBS     r0,r0,#4
;;;192    {
;;;193    	/* Simulate the stack frame as it would be created by a context switch
;;;194    	interrupt. */
;;;195    
;;;196    	/* Offset added to account for the way the MCU uses the stack on entry/exit
;;;197    	of interrupts, and to ensure alignment. */
;;;198    	pxTopOfStack--;
;;;199    
;;;200    	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
000002  f04f7380          MOV      r3,#0x1000000
000006  6003              STR      r3,[r0,#0]
;;;201    	pxTopOfStack--;
000008  1f00              SUBS     r0,r0,#4
;;;202    	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
00000a  f0210301          BIC      r3,r1,#1
00000e  6003              STR      r3,[r0,#0]
;;;203    	pxTopOfStack--;
000010  1f00              SUBS     r0,r0,#4
;;;204    	*pxTopOfStack = ( StackType_t ) prvTaskExitError;	/* LR */
000012  4b05              LDR      r3,|L3.40|
000014  6003              STR      r3,[r0,#0]
;;;205    
;;;206    	/* Save code space by skipping register initialisation. */
;;;207    	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
000016  3814              SUBS     r0,r0,#0x14
;;;208    	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
000018  6002              STR      r2,[r0,#0]
;;;209    
;;;210    	/* A save method is being used that requires each task to maintain its
;;;211    	own exec return value. */
;;;212    	pxTopOfStack--;
00001a  1f00              SUBS     r0,r0,#4
;;;213    	*pxTopOfStack = portINITIAL_EXC_RETURN;
00001c  f06f0302          MVN      r3,#2
000020  6003              STR      r3,[r0,#0]
;;;214    
;;;215    	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
000022  3820              SUBS     r0,r0,#0x20
;;;216    
;;;217    	return pxTopOfStack;
;;;218    }
000024  4770              BX       lr
;;;219    /*-----------------------------------------------------------*/
                          ENDP

000026  0000              DCW      0x0000
                  |L3.40|
                          DCD      prvTaskExitError

                          AREA ||i.vPortEndScheduler||, CODE, READONLY, ALIGN=2

                  vPortEndScheduler PROC
;;;402    
;;;403    void vPortEndScheduler( void )
000000  480a              LDR      r0,|L4.44|
;;;404    {
;;;405    	/* Not implemented in ports where there is nothing to return to.
;;;406    	Artificially force an assert. */
;;;407    	configASSERT( uxCriticalNesting == 1000UL );
000002  6800              LDR      r0,[r0,#0]  ; uxCriticalNesting
000004  f5b07f7a          CMP      r0,#0x3e8
000008  d101              BNE      |L4.14|
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L4.16|
                  |L4.14|
00000e  2000              MOVS     r0,#0
                  |L4.16|
000010  b950              CBNZ     r0,|L4.40|
000012  bf00              NOP      
000014  2040              MOVS     r0,#0x40
000016  f3808811          MSR      BASEPRI,r0
00001a  f3bf8f4f          DSB      
00001e  f3bf8f6f          ISB      
000022  bf00              NOP      
000024  bf00              NOP      
                  |L4.38|
000026  e7fe              B        |L4.38|
                  |L4.40|
;;;408    }
000028  4770              BX       lr
;;;409    /*-----------------------------------------------------------*/
                          ENDP

00002a  0000              DCW      0x0000
                  |L4.44|
                          DCD      uxCriticalNesting

                          AREA ||i.vPortEnterCritical||, CODE, READONLY, ALIGN=2

                  vPortEnterCritical PROC
;;;410    
;;;411    void vPortEnterCritical( void )
000000  bf00              NOP      
000002  2040              MOVS     r0,#0x40
000004  f3808811          MSR      BASEPRI,r0
000008  f3bf8f4f          DSB      
00000c  f3bf8f6f          ISB      
000010  bf00              NOP      
;;;412    {
;;;413    	portDISABLE_INTERRUPTS();
;;;414    	uxCriticalNesting++;
000012  480e              LDR      r0,|L5.76|
000014  6800              LDR      r0,[r0,#0]  ; uxCriticalNesting
000016  1c40              ADDS     r0,r0,#1
000018  490c              LDR      r1,|L5.76|
00001a  6008              STR      r0,[r1,#0]  ; uxCriticalNesting
;;;415    
;;;416    	/* This is not the interrupt safe version of the enter critical function so
;;;417    	assert() if it is being called from an interrupt context.  Only API
;;;418    	functions that end in "FromISR" can be used in an interrupt.  Only assert if
;;;419    	the critical nesting count is 1 to protect against recursive calls if the
;;;420    	assert function also uses a critical section. */
;;;421    	if( uxCriticalNesting == 1 )
00001c  4608              MOV      r0,r1
00001e  6800              LDR      r0,[r0,#0]  ; uxCriticalNesting
000020  2801              CMP      r0,#1
000022  d112              BNE      |L5.74|
;;;422    	{
;;;423    		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
000024  480a              LDR      r0,|L5.80|
000026  6800              LDR      r0,[r0,#0]
000028  b2c0              UXTB     r0,r0
00002a  b908              CBNZ     r0,|L5.48|
00002c  2001              MOVS     r0,#1
00002e  e000              B        |L5.50|
                  |L5.48|
000030  2000              MOVS     r0,#0
                  |L5.50|
000032  b950              CBNZ     r0,|L5.74|
000034  bf00              NOP      
000036  2040              MOVS     r0,#0x40
000038  f3808811          MSR      BASEPRI,r0
00003c  f3bf8f4f          DSB      
000040  f3bf8f6f          ISB      
000044  bf00              NOP      
000046  bf00              NOP      
                  |L5.72|
000048  e7fe              B        |L5.72|
                  |L5.74|
;;;424    	}
;;;425    }
00004a  4770              BX       lr
;;;426    /*-----------------------------------------------------------*/
                          ENDP

                  |L5.76|
                          DCD      uxCriticalNesting
                  |L5.80|
                          DCD      0xe000ed04

                          AREA ||i.vPortExitCritical||, CODE, READONLY, ALIGN=2

                  vPortExitCritical PROC
;;;427    
;;;428    void vPortExitCritical( void )
000000  480d              LDR      r0,|L6.56|
;;;429    {
;;;430    	configASSERT( uxCriticalNesting );
000002  6800              LDR      r0,[r0,#0]  ; uxCriticalNesting
000004  b950              CBNZ     r0,|L6.28|
000006  bf00              NOP      
000008  2040              MOVS     r0,#0x40
00000a  f3808811          MSR      BASEPRI,r0
00000e  f3bf8f4f          DSB      
000012  f3bf8f6f          ISB      
000016  bf00              NOP      
000018  bf00              NOP      
                  |L6.26|
00001a  e7fe              B        |L6.26|
                  |L6.28|
;;;431    	uxCriticalNesting--;
00001c  4806              LDR      r0,|L6.56|
00001e  6800              LDR      r0,[r0,#0]  ; uxCriticalNesting
000020  1e40              SUBS     r0,r0,#1
000022  4905              LDR      r1,|L6.56|
000024  6008              STR      r0,[r1,#0]  ; uxCriticalNesting
;;;432    	if( uxCriticalNesting == 0 )
000026  4608              MOV      r0,r1
000028  6800              LDR      r0,[r0,#0]  ; uxCriticalNesting
00002a  b920              CBNZ     r0,|L6.54|
;;;433    	{
;;;434    		portENABLE_INTERRUPTS();
00002c  2000              MOVS     r0,#0
00002e  f3808811          MSR      BASEPRI,r0
000032  bf00              NOP      
000034  bf00              NOP      
                  |L6.54|
;;;435    	}
;;;436    }
000036  4770              BX       lr
;;;437    /*-----------------------------------------------------------*/
                          ENDP

                  |L6.56|
                          DCD      uxCriticalNesting

                          AREA ||i.vPortSetupTimerInterrupt||, CODE, READONLY, ALIGN=2

                  vPortSetupTimerInterrupt PROC
;;;695    
;;;696    	void vPortSetupTimerInterrupt( void )
000000  2000              MOVS     r0,#0
;;;697    	{
;;;698    		/* Calculate the constants required to configure the tick interrupt. */
;;;699    		#if( configUSE_TICKLESS_IDLE == 1 )
;;;700    		{
;;;701    			ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
;;;702    			xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
;;;703    			ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
;;;704    		}
;;;705    		#endif /* configUSE_TICKLESS_IDLE */
;;;706    
;;;707    		/* Stop and clear the SysTick. */
;;;708    		portNVIC_SYSTICK_CTRL_REG = 0UL;
000002  f04f21e0          MOV      r1,#0xe000e000
000006  6108              STR      r0,[r1,#0x10]
;;;709    		portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
000008  6188              STR      r0,[r1,#0x18]
;;;710    
;;;711    		/* Configure SysTick to interrupt at the requested rate. */
;;;712    		portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
00000a  4802              LDR      r0,|L7.20|
00000c  6148              STR      r0,[r1,#0x14]
;;;713    		portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
00000e  2007              MOVS     r0,#7
000010  6108              STR      r0,[r1,#0x10]
;;;714    	}
000012  4770              BX       lr
;;;715    
                          ENDP

                  |L7.20|
                          DCD      0x0002bf1f

                          AREA ||i.vPortValidateInterruptPriority||, CODE, READONLY, ALIGN=2

                  vPortValidateInterruptPriority PROC
;;;729    
;;;730    	void vPortValidateInterruptPriority( void )
000000  b570              PUSH     {r4-r6,lr}
;;;731    	{
;;;732    	uint32_t ulCurrentInterrupt;
;;;733    	uint8_t ucCurrentPriority;
;;;734    
;;;735    		/* Obtain the number of the currently executing interrupt. */
;;;736    		ulCurrentInterrupt = vPortGetIPSR();
000002  f7fffffe          BL       vPortGetIPSR
000006  4604              MOV      r4,r0
;;;737    
;;;738    		/* Is the interrupt number a user defined interrupt? */
;;;739    		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
000008  2c10              CMP      r4,#0x10
00000a  d316              BCC      |L8.58|
;;;740    		{
;;;741    			/* Look up the interrupt's priority. */
;;;742    			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
00000c  f10420e0          ADD      r0,r4,#0xe000e000
000010  f89053f0          LDRB     r5,[r0,#0x3f0]
;;;743    
;;;744    			/* The following assertion will fail if a service routine (ISR) for
;;;745    			an interrupt that has been assigned a priority above
;;;746    			configMAX_SYSCALL_INTERRUPT_PRIORITY calls an ISR safe FreeRTOS API
;;;747    			function.  ISR safe FreeRTOS API functions must *only* be called
;;;748    			from interrupts that have been assigned a priority at or below
;;;749    			configMAX_SYSCALL_INTERRUPT_PRIORITY.
;;;750    
;;;751    			Numerically low interrupt priority numbers represent logically high
;;;752    			interrupt priorities, therefore the priority of the interrupt must
;;;753    			be set to a value equal to or numerically *higher* than
;;;754    			configMAX_SYSCALL_INTERRUPT_PRIORITY.
;;;755    
;;;756    			Interrupts that	use the FreeRTOS API must not be left at their
;;;757    			default priority of	zero as that is the highest possible priority,
;;;758    			which is guaranteed to be above configMAX_SYSCALL_INTERRUPT_PRIORITY,
;;;759    			and	therefore also guaranteed to be invalid.
;;;760    
;;;761    			FreeRTOS maintains separate thread and ISR API functions to ensure
;;;762    			interrupt entry is as fast and simple as possible.
;;;763    
;;;764    			The following links provide detailed information:
;;;765    			http://www.freertos.org/RTOS-Cortex-M3-M4.html
;;;766    			http://www.freertos.org/FAQHelp.html */
;;;767    			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
000014  4815              LDR      r0,|L8.108|
000016  7800              LDRB     r0,[r0,#0]  ; ucMaxSysCallPriority
000018  4285              CMP      r5,r0
00001a  db01              BLT      |L8.32|
00001c  2001              MOVS     r0,#1
00001e  e000              B        |L8.34|
                  |L8.32|
000020  2000              MOVS     r0,#0
                  |L8.34|
000022  b950              CBNZ     r0,|L8.58|
000024  bf00              NOP      
000026  2040              MOVS     r0,#0x40
000028  f3808811          MSR      BASEPRI,r0
00002c  f3bf8f4f          DSB      
000030  f3bf8f6f          ISB      
000034  bf00              NOP      
000036  bf00              NOP      
                  |L8.56|
000038  e7fe              B        |L8.56|
                  |L8.58|
;;;768    		}
;;;769    
;;;770    		/* Priority grouping:  The interrupt controller (NVIC) allows the bits
;;;771    		that define each interrupt's priority to be split between bits that
;;;772    		define the interrupt's pre-emption priority bits and bits that define
;;;773    		the interrupt's sub-priority.  For simplicity all bits must be defined
;;;774    		to be pre-emption priority bits.  The following assertion will fail if
;;;775    		this is not the case (if some bits represent a sub-priority).
;;;776    
;;;777    		If the application only uses CMSIS libraries for interrupt
;;;778    		configuration then the correct setting can be achieved on all Cortex-M
;;;779    		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
;;;780    		scheduler.  Note however that some vendor specific peripheral libraries
;;;781    		assume a non-zero priority group setting, in which cases using a value
;;;782    		of zero will result in unpredictable behaviour. */
;;;783    		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
00003a  480d              LDR      r0,|L8.112|
00003c  6800              LDR      r0,[r0,#0]
00003e  f40060e0          AND      r0,r0,#0x700
000042  490c              LDR      r1,|L8.116|
000044  6809              LDR      r1,[r1,#0]  ; ulMaxPRIGROUPValue
000046  4288              CMP      r0,r1
000048  d801              BHI      |L8.78|
00004a  2001              MOVS     r0,#1
00004c  e000              B        |L8.80|
                  |L8.78|
00004e  2000              MOVS     r0,#0
                  |L8.80|
000050  b950              CBNZ     r0,|L8.104|
000052  bf00              NOP      
000054  2040              MOVS     r0,#0x40
000056  f3808811          MSR      BASEPRI,r0
00005a  f3bf8f4f          DSB      
00005e  f3bf8f6f          ISB      
000062  bf00              NOP      
000064  bf00              NOP      
                  |L8.102|
000066  e7fe              B        |L8.102|
                  |L8.104|
;;;784    	}
000068  bd70              POP      {r4-r6,pc}
;;;785    
                          ENDP

00006a  0000              DCW      0x0000
                  |L8.108|
                          DCD      ucMaxSysCallPriority
                  |L8.112|
                          DCD      0xe000ed0c
                  |L8.116|
                          DCD      ulMaxPRIGROUPValue

                          AREA ||i.xPortStartScheduler||, CODE, READONLY, ALIGN=2

                  xPortStartScheduler PROC
;;;299     */
;;;300    BaseType_t xPortStartScheduler( void )
000000  b51c              PUSH     {r2-r4,lr}
;;;301    {
;;;302    	/* configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.
;;;303    	See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
;;;304    	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );
;;;305    
;;;306    	/* This port can be used on all revisions of the Cortex-M7 core other than
;;;307    	the r0p1 parts.  r0p1 parts should use the port from the
;;;308    	/source/portable/GCC/ARM_CM7/r0p1 directory. */
;;;309    	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
000002  4852              LDR      r0,|L9.332|
000004  6800              LDR      r0,[r0,#0]
000006  4952              LDR      r1,|L9.336|
000008  4288              CMP      r0,r1
00000a  d001              BEQ      |L9.16|
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L9.18|
                  |L9.16|
000010  2000              MOVS     r0,#0
                  |L9.18|
000012  b950              CBNZ     r0,|L9.42|
000014  bf00              NOP      
000016  2040              MOVS     r0,#0x40
000018  f3808811          MSR      BASEPRI,r0
00001c  f3bf8f4f          DSB      
000020  f3bf8f6f          ISB      
000024  bf00              NOP      
000026  bf00              NOP      
                  |L9.40|
000028  e7fe              B        |L9.40|
                  |L9.42|
;;;310    	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
00002a  4848              LDR      r0,|L9.332|
00002c  6800              LDR      r0,[r0,#0]
00002e  4948              LDR      r1,|L9.336|
000030  1e49              SUBS     r1,r1,#1
000032  4288              CMP      r0,r1
000034  d001              BEQ      |L9.58|
000036  2001              MOVS     r0,#1
000038  e000              B        |L9.60|
                  |L9.58|
00003a  2000              MOVS     r0,#0
                  |L9.60|
00003c  b950              CBNZ     r0,|L9.84|
00003e  bf00              NOP      
000040  2040              MOVS     r0,#0x40
000042  f3808811          MSR      BASEPRI,r0
000046  f3bf8f4f          DSB      
00004a  f3bf8f6f          ISB      
00004e  bf00              NOP      
000050  bf00              NOP      
                  |L9.82|
000052  e7fe              B        |L9.82|
                  |L9.84|
;;;311    
;;;312    	#if( configASSERT_DEFINED == 1 )
;;;313    	{
;;;314    		volatile uint32_t ulOriginalPriority;
;;;315    		volatile uint8_t * const pucFirstUserPriorityRegister = ( uint8_t * ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
000054  493f              LDR      r1,|L9.340|
;;;316    		volatile uint8_t ucMaxPriorityValue;
;;;317    
;;;318    		/* Determine the maximum priority from which ISR safe FreeRTOS API
;;;319    		functions can be called.  ISR safe functions are those that end in
;;;320    		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
;;;321    		ensure interrupt entry is as fast and simple as possible.
;;;322    
;;;323    		Save the interrupt priority value that is about to be clobbered. */
;;;324    		ulOriginalPriority = *pucFirstUserPriorityRegister;
000056  4608              MOV      r0,r1
000058  7800              LDRB     r0,[r0,#0]
00005a  9001              STR      r0,[sp,#4]
;;;325    
;;;326    		/* Determine the number of priority bits available.  First write to all
;;;327    		possible bits. */
;;;328    		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
00005c  20ff              MOVS     r0,#0xff
00005e  460a              MOV      r2,r1
000060  7010              STRB     r0,[r2,#0]
;;;329    
;;;330    		/* Read the value back to see how many bits stuck. */
;;;331    		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
000062  4608              MOV      r0,r1
000064  7800              LDRB     r0,[r0,#0]
000066  9000              STR      r0,[sp,#0]
;;;332    
;;;333    		/* The kernel interrupt priority should be set to the lowest
;;;334    		priority. */
;;;335    		configASSERT( ucMaxPriorityValue == ( configKERNEL_INTERRUPT_PRIORITY & ucMaxPriorityValue ) );
000068  f89d0000          LDRB     r0,[sp,#0]
00006c  f00000f0          AND      r0,r0,#0xf0
000070  f89d2000          LDRB     r2,[sp,#0]
000074  4290              CMP      r0,r2
000076  d101              BNE      |L9.124|
000078  2001              MOVS     r0,#1
00007a  e000              B        |L9.126|
                  |L9.124|
00007c  2000              MOVS     r0,#0
                  |L9.126|
00007e  b950              CBNZ     r0,|L9.150|
000080  bf00              NOP      
000082  2040              MOVS     r0,#0x40
000084  f3808811          MSR      BASEPRI,r0
000088  f3bf8f4f          DSB      
00008c  f3bf8f6f          ISB      
000090  bf00              NOP      
000092  bf00              NOP      
                  |L9.148|
000094  e7fe              B        |L9.148|
                  |L9.150|
;;;336    
;;;337    		/* Use the same mask on the maximum system call priority. */
;;;338    		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
000096  f89d0000          LDRB     r0,[sp,#0]
00009a  f0000040          AND      r0,r0,#0x40
00009e  4a2e              LDR      r2,|L9.344|
0000a0  7010              STRB     r0,[r2,#0]
;;;339    
;;;340    		/* Calculate the maximum acceptable priority group value for the number
;;;341    		of bits read back. */
;;;342    		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
0000a2  2007              MOVS     r0,#7
0000a4  4a2d              LDR      r2,|L9.348|
0000a6  6010              STR      r0,[r2,#0]  ; ulMaxPRIGROUPValue
;;;343    		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
0000a8  e009              B        |L9.190|
                  |L9.170|
;;;344    		{
;;;345    			ulMaxPRIGROUPValue--;
0000aa  482c              LDR      r0,|L9.348|
0000ac  6800              LDR      r0,[r0,#0]  ; ulMaxPRIGROUPValue
0000ae  1e40              SUBS     r0,r0,#1
0000b0  4a2a              LDR      r2,|L9.348|
0000b2  6010              STR      r0,[r2,#0]  ; ulMaxPRIGROUPValue
;;;346    			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
0000b4  f89d0000          LDRB     r0,[sp,#0]
0000b8  0640              LSLS     r0,r0,#25
0000ba  0e00              LSRS     r0,r0,#24
0000bc  9000              STR      r0,[sp,#0]
                  |L9.190|
0000be  f89d0000          LDRB     r0,[sp,#0]            ;343
0000c2  f0000080          AND      r0,r0,#0x80           ;343
0000c6  2880              CMP      r0,#0x80              ;343
0000c8  d0ef              BEQ      |L9.170|
;;;347    		}
;;;348    
;;;349    		#ifdef __NVIC_PRIO_BITS
;;;350    		{
;;;351    			/* Check the CMSIS configuration that defines the number of
;;;352    			priority bits matches the number of priority bits actually queried
;;;353    			from the hardware. */
;;;354    			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == __NVIC_PRIO_BITS );
;;;355    		}
;;;356    		#endif
;;;357    
;;;358    		#ifdef configPRIO_BITS
;;;359    		{
;;;360    			/* Check the FreeRTOS configuration that defines the number of
;;;361    			priority bits matches the number of priority bits actually queried
;;;362    			from the hardware. */
;;;363    			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
0000ca  4824              LDR      r0,|L9.348|
0000cc  6800              LDR      r0,[r0,#0]  ; ulMaxPRIGROUPValue
0000ce  f1c00007          RSB      r0,r0,#7
0000d2  2804              CMP      r0,#4
0000d4  d101              BNE      |L9.218|
0000d6  2001              MOVS     r0,#1
0000d8  e000              B        |L9.220|
                  |L9.218|
0000da  2000              MOVS     r0,#0
                  |L9.220|
0000dc  b950              CBNZ     r0,|L9.244|
0000de  bf00              NOP      
0000e0  2040              MOVS     r0,#0x40
0000e2  f3808811          MSR      BASEPRI,r0
0000e6  f3bf8f4f          DSB      
0000ea  f3bf8f6f          ISB      
0000ee  bf00              NOP      
0000f0  bf00              NOP      
                  |L9.242|
0000f2  e7fe              B        |L9.242|
                  |L9.244|
;;;364    		}
;;;365    		#endif
;;;366    
;;;367    		/* Shift the priority group value back to its position within the AIRCR
;;;368    		register. */
;;;369    		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
0000f4  4819              LDR      r0,|L9.348|
0000f6  6800              LDR      r0,[r0,#0]  ; ulMaxPRIGROUPValue
0000f8  0200              LSLS     r0,r0,#8
0000fa  4a18              LDR      r2,|L9.348|
0000fc  6010              STR      r0,[r2,#0]  ; ulMaxPRIGROUPValue
;;;370    		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
0000fe  4610              MOV      r0,r2
000100  8800              LDRH     r0,[r0,#0]  ; ulMaxPRIGROUPValue
000102  f40060e0          AND      r0,r0,#0x700
000106  6010              STR      r0,[r2,#0]  ; ulMaxPRIGROUPValue
;;;371    
;;;372    		/* Restore the clobbered interrupt priority register to its original
;;;373    		value. */
;;;374    		*pucFirstUserPriorityRegister = ulOriginalPriority;
000108  4a12              LDR      r2,|L9.340|
00010a  9801              LDR      r0,[sp,#4]
00010c  7010              STRB     r0,[r2,#0]
;;;375    	}
;;;376    	#endif /* conifgASSERT_DEFINED */
;;;377    
;;;378    	/* Make PendSV and SysTick the lowest priority interrupts. */
;;;379    	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
00010e  480f              LDR      r0,|L9.332|
000110  3020              ADDS     r0,r0,#0x20
000112  6800              LDR      r0,[r0,#0]
000114  f4400070          ORR      r0,r0,#0xf00000
000118  490c              LDR      r1,|L9.332|
00011a  3120              ADDS     r1,r1,#0x20
00011c  6008              STR      r0,[r1,#0]
;;;380    	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
00011e  4608              MOV      r0,r1
000120  6800              LDR      r0,[r0,#0]
000122  f0404070          ORR      r0,r0,#0xf0000000
000126  6008              STR      r0,[r1,#0]
;;;381    
;;;382    	/* Start the timer that generates the tick ISR.  Interrupts are disabled
;;;383    	here already. */
;;;384    	vPortSetupTimerInterrupt();
000128  f7fffffe          BL       vPortSetupTimerInterrupt
;;;385    
;;;386    	/* Initialise the critical nesting count ready for the first task. */
;;;387    	uxCriticalNesting = 0;
00012c  2000              MOVS     r0,#0
00012e  490c              LDR      r1,|L9.352|
000130  6008              STR      r0,[r1,#0]  ; uxCriticalNesting
;;;388    
;;;389    	/* Ensure the VFP is enabled - it should be anyway. */
;;;390    	prvEnableVFP();
000132  f7fffffe          BL       __asm___6_port_c_39a90d8d__prvEnableVFP
;;;391    
;;;392    	/* Lazy save always. */
;;;393    	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
000136  480b              LDR      r0,|L9.356|
000138  6800              LDR      r0,[r0,#0]
00013a  f0404040          ORR      r0,r0,#0xc0000000
00013e  4909              LDR      r1,|L9.356|
000140  6008              STR      r0,[r1,#0]
;;;394    
;;;395    	/* Start the first task. */
;;;396    	prvStartFirstTask();
000142  f7fffffe          BL       __asm___6_port_c_39a90d8d__prvStartFirstTask
;;;397    
;;;398    	/* Should not get here! */
;;;399    	return 0;
000146  2000              MOVS     r0,#0
;;;400    }
000148  bd1c              POP      {r2-r4,pc}
;;;401    /*-----------------------------------------------------------*/
                          ENDP

00014a  0000              DCW      0x0000
                  |L9.332|
                          DCD      0xe000ed00
                  |L9.336|
                          DCD      0x410fc271
                  |L9.340|
                          DCD      0xe000e400
                  |L9.344|
                          DCD      ucMaxSysCallPriority
                  |L9.348|
                          DCD      ulMaxPRIGROUPValue
                  |L9.352|
                          DCD      uxCriticalNesting
                  |L9.356|
                          DCD      0xe000ef34

                          AREA ||.data||, DATA, ALIGN=2

                  uxCriticalNesting
                          DCD      0xaaaaaaaa
                  ucMaxSysCallPriority
000004  00000000          DCB      0x00,0x00,0x00,0x00
                  ulMaxPRIGROUPValue
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "FreeRTOS\\port.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |SVC_Handler|
#line 235
|SVC_Handler| PROC
#line 236

 PRESERVE8

 
 ldr r3, =pxCurrentTCB
 ldr r1, [r3]
 ldr r0, [r1]
 
 ldmia r0!, {r4-r11, r14}
 msr psp, r0
 isb
 mov r0, #0
 msr basepri, r0
 bx r14
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___6_port_c_39a90d8d__prvStartFirstTask|
#line 253
|__asm___6_port_c_39a90d8d__prvStartFirstTask| PROC
#line 254

 PRESERVE8

 
 ldr r0, =0xE000ED08
 ldr r0, [r0]
 ldr r0, [r0]
 
 msr msp, r0
#line 266
 
 mov r0, #0
 msr control, r0
 
 cpsie i
 cpsie f
 dsb
 isb
 
 svc 0
 nop
 nop
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___6_port_c_39a90d8d__prvEnableVFP|
#line 281
|__asm___6_port_c_39a90d8d__prvEnableVFP| PROC
#line 282

 PRESERVE8

 
 ldr.w r0, =0xE000ED88
 ldr r1, [r0]

 
 orr r1, r1, #( 0xf << 20 )
 str r1, [r0]
 bx r14
 nop
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |PendSV_Handler|
#line 439
|PendSV_Handler| PROC
#line 440

 extern uxCriticalNesting
 extern pxCurrentTCB
 extern vTaskSwitchContext

 PRESERVE8

 mrs r0, psp
 isb
 
 ldr r3, =pxCurrentTCB
 ldr r2, [r3]

 
 tst r14, #0x10
 it eq
 vstmdbeq r0!, {s16-s31}

 
 stmdb r0!, {r4-r11, r14}

 
 str r0, [r2]

 stmdb sp!, {r0, r3}
 mov r0, #( 4 << (8 - 4) )
 msr basepri, r0
 dsb
 isb
 bl vTaskSwitchContext
 mov r0, #0
 msr basepri, r0
 ldmia sp!, {r0, r3}

 
 ldr r1, [r3]
 ldr r0, [r1]

 
 ldmia r0!, {r4-r11, r14}

#line 482
 
 tst r14, #0x10
 it eq
 vldmiaeq r0!, {s16-s31}

 msr psp, r0
 isb
 
#line 496

 bx r14
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |vPortGetIPSR|
#line 719
|vPortGetIPSR| PROC
#line 720

 PRESERVE8

 mrs r0, ipsr
 bx r14
	ENDP

;*** End   embedded assembler ***
