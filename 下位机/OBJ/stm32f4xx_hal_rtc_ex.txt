; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\stm32f4xx_hal_rtc_ex.o --asm_dir=.\OBJ\ --list_dir=.\OBJ\ --depend=.\obj\stm32f4xx_hal_rtc_ex.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I.\CORE -I.\USER -I.\HALLIB\STM32F4xx_HAL_Driver\Inc -I.\SYSTEM -I.\Hardware -I.\App -I.\DSP_LIB\Include -I.\FreeRTOS -I.\MPU9250\DMP -I.\MPU9250 -I.\RTE\_Project -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=526 -DSTM32F427xx -DSTM32F4 -DUSE_HAL_DRIVER -DSTM32F427xx -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=.\obj\stm32f4xx_hal_rtc_ex.crf HALLIB\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_rtc_ex.c]
                          THUMB

                          AREA ||i.HAL_RTCEx_AlarmBEventCallback||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_AlarmBEventCallback PROC
;;;1702     */
;;;1703   __weak void HAL_RTCEx_AlarmBEventCallback(RTC_HandleTypeDef *hrtc)
000000  4770              BX       lr
;;;1704   {
;;;1705     /* Prevent unused argument(s) compilation warning */
;;;1706     UNUSED(hrtc);
;;;1707     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1708               the HAL_RTC_AlarmBEventCallback could be implemented in the user file
;;;1709      */
;;;1710   }
;;;1711   
                          ENDP


                          AREA ||i.HAL_RTCEx_BKUPRead||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_BKUPRead PROC
;;;1129     */
;;;1130   uint32_t HAL_RTCEx_BKUPRead(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister)
000000  4602              MOV      r2,r0
;;;1131   {
;;;1132     uint32_t tmp = 0;
000002  2300              MOVS     r3,#0
;;;1133     
;;;1134     /* Check the parameters */
;;;1135     assert_param(IS_RTC_BKP(BackupRegister));
;;;1136   
;;;1137     tmp = (uint32_t)&(hrtc->Instance->BKP0R);
000004  6810              LDR      r0,[r2,#0]
000006  f1000350          ADD      r3,r0,#0x50
;;;1138     tmp += (BackupRegister * 4);
00000a  eb030381          ADD      r3,r3,r1,LSL #2
;;;1139     
;;;1140     /* Read the specified register */
;;;1141     return (*(__IO uint32_t *)tmp);
00000e  6818              LDR      r0,[r3,#0]
;;;1142   }
000010  4770              BX       lr
;;;1143         
                          ENDP


                          AREA ||i.HAL_RTCEx_BKUPWrite||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_BKUPWrite PROC
;;;1106     */
;;;1107   void HAL_RTCEx_BKUPWrite(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister, uint32_t Data)
000000  b510              PUSH     {r4,lr}
;;;1108   {
;;;1109     uint32_t tmp = 0;
000002  2300              MOVS     r3,#0
;;;1110     
;;;1111     /* Check the parameters */
;;;1112     assert_param(IS_RTC_BKP(BackupRegister));
;;;1113     
;;;1114     tmp = (uint32_t)&(hrtc->Instance->BKP0R);
000004  6804              LDR      r4,[r0,#0]
000006  f1040350          ADD      r3,r4,#0x50
;;;1115     tmp += (BackupRegister * 4);
00000a  eb030381          ADD      r3,r3,r1,LSL #2
;;;1116     
;;;1117     /* Write the specified register */
;;;1118     *(__IO uint32_t *)tmp = (uint32_t)Data;
00000e  601a              STR      r2,[r3,#0]
;;;1119   }
000010  bd10              POP      {r4,pc}
;;;1120   
                          ENDP


                          AREA ||i.HAL_RTCEx_DeactivateCalibrationOutPut||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_DeactivateCalibrationOutPut PROC
;;;1487     */
;;;1488   HAL_StatusTypeDef HAL_RTCEx_DeactivateCalibrationOutPut(RTC_HandleTypeDef* hrtc)
000000  4601              MOV      r1,r0
;;;1489   {
;;;1490     /* Process Locked */ 
;;;1491     __HAL_LOCK(hrtc);
000002  bf00              NOP      
000004  7f08              LDRB     r0,[r1,#0x1c]
000006  2801              CMP      r0,#1
000008  d101              BNE      |L4.14|
00000a  2002              MOVS     r0,#2
                  |L4.12|
;;;1492     
;;;1493     hrtc->State = HAL_RTC_STATE_BUSY;
;;;1494     
;;;1495     /* Disable the write protection for RTC registers */
;;;1496     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;1497     
;;;1498     __HAL_RTC_CALIBRATION_OUTPUT_DISABLE(hrtc);
;;;1499       
;;;1500     /* Enable the write protection for RTC registers */
;;;1501     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1502     
;;;1503     /* Change RTC state */
;;;1504     hrtc->State = HAL_RTC_STATE_READY; 
;;;1505     
;;;1506     /* Process Unlocked */ 
;;;1507     __HAL_UNLOCK(hrtc);
;;;1508     
;;;1509     return HAL_OK;
;;;1510   }
00000c  4770              BX       lr
                  |L4.14|
00000e  2001              MOVS     r0,#1                 ;1491
000010  7708              STRB     r0,[r1,#0x1c]         ;1491
000012  bf00              NOP                            ;1491
000014  2002              MOVS     r0,#2                 ;1493
000016  7748              STRB     r0,[r1,#0x1d]         ;1493
000018  bf00              NOP                            ;1496
00001a  20ca              MOVS     r0,#0xca              ;1496
00001c  680a              LDR      r2,[r1,#0]            ;1496
00001e  6250              STR      r0,[r2,#0x24]         ;1496
000020  2053              MOVS     r0,#0x53              ;1496
000022  680a              LDR      r2,[r1,#0]            ;1496
000024  6250              STR      r0,[r2,#0x24]         ;1496
000026  bf00              NOP                            ;1496
000028  6808              LDR      r0,[r1,#0]            ;1498
00002a  6880              LDR      r0,[r0,#8]            ;1498
00002c  f4200000          BIC      r0,r0,#0x800000       ;1498
000030  680a              LDR      r2,[r1,#0]            ;1498
000032  6090              STR      r0,[r2,#8]            ;1498
000034  bf00              NOP                            ;1501
000036  20ff              MOVS     r0,#0xff              ;1501
000038  680a              LDR      r2,[r1,#0]            ;1501
00003a  6250              STR      r0,[r2,#0x24]         ;1501
00003c  bf00              NOP                            ;1501
00003e  2001              MOVS     r0,#1                 ;1504
000040  7748              STRB     r0,[r1,#0x1d]         ;1504
000042  bf00              NOP                            ;1507
000044  2000              MOVS     r0,#0                 ;1507
000046  7708              STRB     r0,[r1,#0x1c]         ;1507
000048  bf00              NOP                            ;1507
00004a  bf00              NOP                            ;1509
00004c  e7de              B        |L4.12|
;;;1511   
                          ENDP


                          AREA ||i.HAL_RTCEx_DeactivateCoarseCalib||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_DeactivateCoarseCalib PROC
;;;1218     */
;;;1219   HAL_StatusTypeDef HAL_RTCEx_DeactivateCoarseCalib(RTC_HandleTypeDef* hrtc)
000000  b510              PUSH     {r4,lr}
;;;1220   { 
000002  4604              MOV      r4,r0
;;;1221     /* Process Locked */ 
;;;1222     __HAL_LOCK(hrtc);
000004  bf00              NOP      
000006  7f20              LDRB     r0,[r4,#0x1c]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L5.16|
00000c  2002              MOVS     r0,#2
                  |L5.14|
;;;1223     
;;;1224     hrtc->State = HAL_RTC_STATE_BUSY;
;;;1225     
;;;1226     /* Disable the write protection for RTC registers */
;;;1227     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;1228   
;;;1229     /* Set Initialization mode */
;;;1230     if(RTC_EnterInitMode(hrtc) != HAL_OK)
;;;1231     {
;;;1232       /* Enable the write protection for RTC registers */
;;;1233       __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); 
;;;1234       
;;;1235       /* Set RTC state*/
;;;1236       hrtc->State = HAL_RTC_STATE_ERROR;
;;;1237       
;;;1238       /* Process Unlocked */ 
;;;1239       __HAL_UNLOCK(hrtc);
;;;1240       
;;;1241       return HAL_ERROR;
;;;1242     } 
;;;1243     else
;;;1244     { 
;;;1245       /* Enable the Coarse Calibration */
;;;1246       __HAL_RTC_COARSE_CALIB_DISABLE(hrtc);
;;;1247       
;;;1248       /* Exit Initialization mode */
;;;1249       hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT; 
;;;1250     } 
;;;1251   
;;;1252     /* Enable the write protection for RTC registers */
;;;1253     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1254     
;;;1255     /* Change state */
;;;1256     hrtc->State = HAL_RTC_STATE_READY; 
;;;1257     
;;;1258     /* Process Unlocked */ 
;;;1259     __HAL_UNLOCK(hrtc);
;;;1260     
;;;1261     return HAL_OK;
;;;1262   }
00000e  bd10              POP      {r4,pc}
                  |L5.16|
000010  2001              MOVS     r0,#1                 ;1222
000012  7720              STRB     r0,[r4,#0x1c]         ;1222
000014  bf00              NOP                            ;1222
000016  2002              MOVS     r0,#2                 ;1224
000018  7760              STRB     r0,[r4,#0x1d]         ;1224
00001a  bf00              NOP                            ;1227
00001c  20ca              MOVS     r0,#0xca              ;1227
00001e  6821              LDR      r1,[r4,#0]            ;1227
000020  6248              STR      r0,[r1,#0x24]         ;1227
000022  2053              MOVS     r0,#0x53              ;1227
000024  6821              LDR      r1,[r4,#0]            ;1227
000026  6248              STR      r0,[r1,#0x24]         ;1227
000028  bf00              NOP                            ;1227
00002a  4620              MOV      r0,r4                 ;1230
00002c  f7fffffe          BL       RTC_EnterInitMode
000030  b160              CBZ      r0,|L5.76|
000032  bf00              NOP                            ;1233
000034  20ff              MOVS     r0,#0xff              ;1233
000036  6821              LDR      r1,[r4,#0]            ;1233
000038  6248              STR      r0,[r1,#0x24]         ;1233
00003a  bf00              NOP                            ;1233
00003c  2004              MOVS     r0,#4                 ;1236
00003e  7760              STRB     r0,[r4,#0x1d]         ;1236
000040  bf00              NOP                            ;1239
000042  2000              MOVS     r0,#0                 ;1239
000044  7720              STRB     r0,[r4,#0x1c]         ;1239
000046  bf00              NOP                            ;1239
000048  2001              MOVS     r0,#1                 ;1241
00004a  e7e0              B        |L5.14|
                  |L5.76|
00004c  6820              LDR      r0,[r4,#0]            ;1246
00004e  6880              LDR      r0,[r0,#8]            ;1246
000050  f0200080          BIC      r0,r0,#0x80           ;1246
000054  6821              LDR      r1,[r4,#0]            ;1246
000056  6088              STR      r0,[r1,#8]            ;1246
000058  6820              LDR      r0,[r4,#0]            ;1249
00005a  68c0              LDR      r0,[r0,#0xc]          ;1249
00005c  f0200080          BIC      r0,r0,#0x80           ;1249
000060  6821              LDR      r1,[r4,#0]            ;1249
000062  60c8              STR      r0,[r1,#0xc]          ;1249
000064  bf00              NOP                            ;1253
000066  20ff              MOVS     r0,#0xff              ;1253
000068  6821              LDR      r1,[r4,#0]            ;1253
00006a  6248              STR      r0,[r1,#0x24]         ;1253
00006c  bf00              NOP                            ;1253
00006e  2001              MOVS     r0,#1                 ;1256
000070  7760              STRB     r0,[r4,#0x1d]         ;1256
000072  bf00              NOP                            ;1259
000074  2000              MOVS     r0,#0                 ;1259
000076  7720              STRB     r0,[r4,#0x1c]         ;1259
000078  bf00              NOP                            ;1259
00007a  bf00              NOP                            ;1261
00007c  e7c7              B        |L5.14|
;;;1263   
                          ENDP


                          AREA ||i.HAL_RTCEx_DeactivateRefClock||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_DeactivateRefClock PROC
;;;1567     */
;;;1568   HAL_StatusTypeDef HAL_RTCEx_DeactivateRefClock(RTC_HandleTypeDef* hrtc)
000000  b510              PUSH     {r4,lr}
;;;1569   { 
000002  4604              MOV      r4,r0
;;;1570     /* Process Locked */ 
;;;1571     __HAL_LOCK(hrtc);
000004  bf00              NOP      
000006  7f20              LDRB     r0,[r4,#0x1c]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L6.16|
00000c  2002              MOVS     r0,#2
                  |L6.14|
;;;1572     
;;;1573     hrtc->State = HAL_RTC_STATE_BUSY;
;;;1574     
;;;1575     /* Disable the write protection for RTC registers */
;;;1576     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;1577     
;;;1578     /* Set Initialization mode */
;;;1579     if(RTC_EnterInitMode(hrtc) != HAL_OK)
;;;1580     {
;;;1581       /* Enable the write protection for RTC registers */
;;;1582       __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); 
;;;1583       
;;;1584       /* Set RTC state*/
;;;1585       hrtc->State = HAL_RTC_STATE_ERROR;
;;;1586       
;;;1587       /* Process Unlocked */ 
;;;1588       __HAL_UNLOCK(hrtc);
;;;1589       
;;;1590       return HAL_ERROR;
;;;1591     } 
;;;1592     else
;;;1593     {
;;;1594       __HAL_RTC_CLOCKREF_DETECTION_DISABLE(hrtc);
;;;1595       
;;;1596       /* Exit Initialization mode */
;;;1597       hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT; 
;;;1598     }
;;;1599     
;;;1600     /* Enable the write protection for RTC registers */
;;;1601     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1602     
;;;1603     /* Change RTC state */
;;;1604     hrtc->State = HAL_RTC_STATE_READY; 
;;;1605     
;;;1606     /* Process Unlocked */ 
;;;1607     __HAL_UNLOCK(hrtc);
;;;1608     
;;;1609     return HAL_OK;
;;;1610   }
00000e  bd10              POP      {r4,pc}
                  |L6.16|
000010  2001              MOVS     r0,#1                 ;1571
000012  7720              STRB     r0,[r4,#0x1c]         ;1571
000014  bf00              NOP                            ;1571
000016  2002              MOVS     r0,#2                 ;1573
000018  7760              STRB     r0,[r4,#0x1d]         ;1573
00001a  bf00              NOP                            ;1576
00001c  20ca              MOVS     r0,#0xca              ;1576
00001e  6821              LDR      r1,[r4,#0]            ;1576
000020  6248              STR      r0,[r1,#0x24]         ;1576
000022  2053              MOVS     r0,#0x53              ;1576
000024  6821              LDR      r1,[r4,#0]            ;1576
000026  6248              STR      r0,[r1,#0x24]         ;1576
000028  bf00              NOP                            ;1576
00002a  4620              MOV      r0,r4                 ;1579
00002c  f7fffffe          BL       RTC_EnterInitMode
000030  b160              CBZ      r0,|L6.76|
000032  bf00              NOP                            ;1582
000034  20ff              MOVS     r0,#0xff              ;1582
000036  6821              LDR      r1,[r4,#0]            ;1582
000038  6248              STR      r0,[r1,#0x24]         ;1582
00003a  bf00              NOP                            ;1582
00003c  2004              MOVS     r0,#4                 ;1585
00003e  7760              STRB     r0,[r4,#0x1d]         ;1585
000040  bf00              NOP                            ;1588
000042  2000              MOVS     r0,#0                 ;1588
000044  7720              STRB     r0,[r4,#0x1c]         ;1588
000046  bf00              NOP                            ;1588
000048  2001              MOVS     r0,#1                 ;1590
00004a  e7e0              B        |L6.14|
                  |L6.76|
00004c  6820              LDR      r0,[r4,#0]            ;1594
00004e  6880              LDR      r0,[r0,#8]            ;1594
000050  f0200010          BIC      r0,r0,#0x10           ;1594
000054  6821              LDR      r1,[r4,#0]            ;1594
000056  6088              STR      r0,[r1,#8]            ;1594
000058  6820              LDR      r0,[r4,#0]            ;1597
00005a  68c0              LDR      r0,[r0,#0xc]          ;1597
00005c  f0200080          BIC      r0,r0,#0x80           ;1597
000060  6821              LDR      r1,[r4,#0]            ;1597
000062  60c8              STR      r0,[r1,#0xc]          ;1597
000064  bf00              NOP                            ;1601
000066  20ff              MOVS     r0,#0xff              ;1601
000068  6821              LDR      r1,[r4,#0]            ;1601
00006a  6248              STR      r0,[r1,#0x24]         ;1601
00006c  bf00              NOP                            ;1601
00006e  2001              MOVS     r0,#1                 ;1604
000070  7760              STRB     r0,[r4,#0x1d]         ;1604
000072  bf00              NOP                            ;1607
000074  2000              MOVS     r0,#0                 ;1607
000076  7720              STRB     r0,[r4,#0x1c]         ;1607
000078  bf00              NOP                            ;1607
00007a  bf00              NOP                            ;1609
00007c  e7c7              B        |L6.14|
;;;1611   
                          ENDP


                          AREA ||i.HAL_RTCEx_DeactivateTamper||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_DeactivateTamper PROC
;;;476      */
;;;477    HAL_StatusTypeDef HAL_RTCEx_DeactivateTamper(RTC_HandleTypeDef *hrtc, uint32_t Tamper)
000000  4602              MOV      r2,r0
;;;478    {
;;;479      assert_param(IS_RTC_TAMPER(Tamper)); 
;;;480      
;;;481      /* Process Locked */ 
;;;482      __HAL_LOCK(hrtc);
000002  bf00              NOP      
000004  7f10              LDRB     r0,[r2,#0x1c]
000006  2801              CMP      r0,#1
000008  d101              BNE      |L7.14|
00000a  2002              MOVS     r0,#2
                  |L7.12|
;;;483          
;;;484      hrtc->State = HAL_RTC_STATE_BUSY;
;;;485      
;;;486      /* Disable the selected Tamper pin */
;;;487      hrtc->Instance->TAFCR &= (uint32_t)~Tamper;  
;;;488      
;;;489      hrtc->State = HAL_RTC_STATE_READY;   
;;;490      
;;;491      /* Process Unlocked */  
;;;492      __HAL_UNLOCK(hrtc);
;;;493      
;;;494      return HAL_OK; 
;;;495    }
00000c  4770              BX       lr
                  |L7.14|
00000e  2001              MOVS     r0,#1                 ;482
000010  7710              STRB     r0,[r2,#0x1c]         ;482
000012  bf00              NOP                            ;482
000014  2002              MOVS     r0,#2                 ;484
000016  7750              STRB     r0,[r2,#0x1d]         ;484
000018  6810              LDR      r0,[r2,#0]            ;487
00001a  6c00              LDR      r0,[r0,#0x40]         ;487
00001c  4388              BICS     r0,r0,r1              ;487
00001e  6813              LDR      r3,[r2,#0]            ;487
000020  6418              STR      r0,[r3,#0x40]         ;487
000022  2001              MOVS     r0,#1                 ;489
000024  7750              STRB     r0,[r2,#0x1d]         ;489
000026  bf00              NOP                            ;492
000028  2000              MOVS     r0,#0                 ;492
00002a  7710              STRB     r0,[r2,#0x1c]         ;492
00002c  bf00              NOP                            ;492
00002e  bf00              NOP                            ;494
000030  e7ec              B        |L7.12|
;;;496    
                          ENDP


                          AREA ||i.HAL_RTCEx_DeactivateTimeStamp||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_DeactivateTimeStamp PROC
;;;271      */
;;;272    HAL_StatusTypeDef HAL_RTCEx_DeactivateTimeStamp(RTC_HandleTypeDef *hrtc)
000000  4601              MOV      r1,r0
;;;273    {
;;;274      uint32_t tmpreg = 0;
000002  2200              MOVS     r2,#0
;;;275      
;;;276      /* Process Locked */ 
;;;277      __HAL_LOCK(hrtc);
000004  bf00              NOP      
000006  7f08              LDRB     r0,[r1,#0x1c]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L8.16|
00000c  2002              MOVS     r0,#2
                  |L8.14|
;;;278      
;;;279      hrtc->State = HAL_RTC_STATE_BUSY;
;;;280      
;;;281      /* Disable the write protection for RTC registers */
;;;282      __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;283      
;;;284      /* In case of interrupt mode is used, the interrupt source must disabled */ 
;;;285      __HAL_RTC_TIMESTAMP_DISABLE_IT(hrtc, RTC_IT_TS);
;;;286      
;;;287      /* Get the RTC_CR register and clear the bits to be configured */
;;;288      tmpreg = (uint32_t)(hrtc->Instance->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
;;;289      
;;;290      /* Configure the Time Stamp TSEDGE and Enable bits */
;;;291      hrtc->Instance->CR = (uint32_t)tmpreg;
;;;292      
;;;293      /* Enable the write protection for RTC registers */
;;;294      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;295     
;;;296      hrtc->State = HAL_RTC_STATE_READY;  
;;;297      
;;;298      /* Process Unlocked */ 
;;;299      __HAL_UNLOCK(hrtc);
;;;300      
;;;301      return HAL_OK;
;;;302    }
00000e  4770              BX       lr
                  |L8.16|
000010  2001              MOVS     r0,#1                 ;277
000012  7708              STRB     r0,[r1,#0x1c]         ;277
000014  bf00              NOP                            ;277
000016  2002              MOVS     r0,#2                 ;279
000018  7748              STRB     r0,[r1,#0x1d]         ;279
00001a  bf00              NOP                            ;282
00001c  20ca              MOVS     r0,#0xca              ;282
00001e  680b              LDR      r3,[r1,#0]            ;282
000020  6258              STR      r0,[r3,#0x24]         ;282
000022  2053              MOVS     r0,#0x53              ;282
000024  680b              LDR      r3,[r1,#0]            ;282
000026  6258              STR      r0,[r3,#0x24]         ;282
000028  bf00              NOP                            ;282
00002a  6808              LDR      r0,[r1,#0]            ;285
00002c  6880              LDR      r0,[r0,#8]            ;285
00002e  f4204000          BIC      r0,r0,#0x8000         ;285
000032  680b              LDR      r3,[r1,#0]            ;285
000034  6098              STR      r0,[r3,#8]            ;285
000036  6808              LDR      r0,[r1,#0]            ;288
000038  6880              LDR      r0,[r0,#8]            ;288
00003a  f6400308          MOV      r3,#0x808             ;288
00003e  ea200203          BIC      r2,r0,r3              ;288
000042  6808              LDR      r0,[r1,#0]            ;291
000044  6082              STR      r2,[r0,#8]            ;291
000046  bf00              NOP                            ;294
000048  20ff              MOVS     r0,#0xff              ;294
00004a  680b              LDR      r3,[r1,#0]            ;294
00004c  6258              STR      r0,[r3,#0x24]         ;294
00004e  bf00              NOP                            ;294
000050  2001              MOVS     r0,#1                 ;296
000052  7748              STRB     r0,[r1,#0x1d]         ;296
000054  bf00              NOP                            ;299
000056  2000              MOVS     r0,#0                 ;299
000058  7708              STRB     r0,[r1,#0x1c]         ;299
00005a  bf00              NOP                            ;299
00005c  bf00              NOP                            ;301
00005e  e7d6              B        |L8.14|
;;;303    
                          ENDP


                          AREA ||i.HAL_RTCEx_DeactivateWakeUpTimer||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_DeactivateWakeUpTimer PROC
;;;925      */
;;;926    uint32_t HAL_RTCEx_DeactivateWakeUpTimer(RTC_HandleTypeDef *hrtc)
000000  b570              PUSH     {r4-r6,lr}
;;;927    {
000002  4604              MOV      r4,r0
;;;928      uint32_t tickstart = 0;
000004  2500              MOVS     r5,#0
;;;929      
;;;930      /* Process Locked */ 
;;;931      __HAL_LOCK(hrtc);
000006  bf00              NOP      
000008  7f20              LDRB     r0,[r4,#0x1c]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L9.18|
00000e  2002              MOVS     r0,#2
                  |L9.16|
;;;932      
;;;933      hrtc->State = HAL_RTC_STATE_BUSY;
;;;934      
;;;935      /* Disable the write protection for RTC registers */
;;;936      __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;937      
;;;938      /* Disable the Wake-up Timer */
;;;939      __HAL_RTC_WAKEUPTIMER_DISABLE(hrtc);
;;;940      
;;;941      /* In case of interrupt mode is used, the interrupt source must disabled */ 
;;;942      __HAL_RTC_WAKEUPTIMER_DISABLE_IT(hrtc,RTC_IT_WUT);
;;;943    
;;;944      /* Get tick */
;;;945      tickstart = HAL_GetTick();
;;;946    
;;;947      /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
;;;948      while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == RESET)
;;;949      {
;;;950        if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
;;;951        {
;;;952          /* Enable the write protection for RTC registers */
;;;953          __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;954          
;;;955          hrtc->State = HAL_RTC_STATE_TIMEOUT; 
;;;956          
;;;957          /* Process Unlocked */ 
;;;958          __HAL_UNLOCK(hrtc);
;;;959          
;;;960          return HAL_TIMEOUT;
;;;961        }   
;;;962      }
;;;963      
;;;964      /* Enable the write protection for RTC registers */
;;;965      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;966      
;;;967      hrtc->State = HAL_RTC_STATE_READY;   
;;;968      
;;;969      /* Process Unlocked */ 
;;;970      __HAL_UNLOCK(hrtc);
;;;971      
;;;972      return HAL_OK;
;;;973    }
000010  bd70              POP      {r4-r6,pc}
                  |L9.18|
000012  2001              MOVS     r0,#1                 ;931
000014  7720              STRB     r0,[r4,#0x1c]         ;931
000016  bf00              NOP                            ;931
000018  2002              MOVS     r0,#2                 ;933
00001a  7760              STRB     r0,[r4,#0x1d]         ;933
00001c  bf00              NOP                            ;936
00001e  20ca              MOVS     r0,#0xca              ;936
000020  6821              LDR      r1,[r4,#0]            ;936
000022  6248              STR      r0,[r1,#0x24]         ;936
000024  2053              MOVS     r0,#0x53              ;936
000026  6821              LDR      r1,[r4,#0]            ;936
000028  6248              STR      r0,[r1,#0x24]         ;936
00002a  bf00              NOP                            ;936
00002c  6820              LDR      r0,[r4,#0]            ;939
00002e  6880              LDR      r0,[r0,#8]            ;939
000030  f4206080          BIC      r0,r0,#0x400          ;939
000034  6821              LDR      r1,[r4,#0]            ;939
000036  6088              STR      r0,[r1,#8]            ;939
000038  6820              LDR      r0,[r4,#0]            ;942
00003a  6880              LDR      r0,[r0,#8]            ;942
00003c  f4204080          BIC      r0,r0,#0x4000         ;942
000040  6821              LDR      r1,[r4,#0]            ;942
000042  6088              STR      r0,[r1,#8]            ;942
000044  f7fffffe          BL       HAL_GetTick
000048  4605              MOV      r5,r0                 ;945
00004a  e012              B        |L9.114|
                  |L9.76|
00004c  f7fffffe          BL       HAL_GetTick
000050  1b40              SUBS     r0,r0,r5              ;950
000052  f5b07f7a          CMP      r0,#0x3e8             ;950
000056  d90c              BLS      |L9.114|
000058  bf00              NOP                            ;953
00005a  20ff              MOVS     r0,#0xff              ;953
00005c  6821              LDR      r1,[r4,#0]            ;953
00005e  6248              STR      r0,[r1,#0x24]         ;953
000060  bf00              NOP                            ;953
000062  2003              MOVS     r0,#3                 ;955
000064  7760              STRB     r0,[r4,#0x1d]         ;955
000066  bf00              NOP                            ;958
000068  2000              MOVS     r0,#0                 ;958
00006a  7720              STRB     r0,[r4,#0x1c]         ;958
00006c  bf00              NOP                            ;958
00006e  2003              MOVS     r0,#3                 ;960
000070  e7ce              B        |L9.16|
                  |L9.114|
000072  6820              LDR      r0,[r4,#0]            ;948
000074  68c0              LDR      r0,[r0,#0xc]          ;948
000076  f3c00080          UBFX     r0,r0,#2,#1           ;948
00007a  2800              CMP      r0,#0                 ;948
00007c  d0e6              BEQ      |L9.76|
00007e  bf00              NOP                            ;965
000080  20ff              MOVS     r0,#0xff              ;965
000082  6821              LDR      r1,[r4,#0]            ;965
000084  6248              STR      r0,[r1,#0x24]         ;965
000086  bf00              NOP                            ;965
000088  2001              MOVS     r0,#1                 ;967
00008a  7760              STRB     r0,[r4,#0x1d]         ;967
00008c  bf00              NOP                            ;970
00008e  2000              MOVS     r0,#0                 ;970
000090  7720              STRB     r0,[r4,#0x1c]         ;970
000092  bf00              NOP                            ;970
000094  bf00              NOP                            ;972
000096  e7bb              B        |L9.16|
;;;974    
                          ENDP


                          AREA ||i.HAL_RTCEx_DisableBypassShadow||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_DisableBypassShadow PROC
;;;1652     */
;;;1653   HAL_StatusTypeDef HAL_RTCEx_DisableBypassShadow(RTC_HandleTypeDef* hrtc)
000000  4601              MOV      r1,r0
;;;1654   {
;;;1655     /* Process Locked */ 
;;;1656     __HAL_LOCK(hrtc);
000002  bf00              NOP      
000004  7f08              LDRB     r0,[r1,#0x1c]
000006  2801              CMP      r0,#1
000008  d101              BNE      |L10.14|
00000a  2002              MOVS     r0,#2
                  |L10.12|
;;;1657     
;;;1658     hrtc->State = HAL_RTC_STATE_BUSY;
;;;1659     
;;;1660     /* Disable the write protection for RTC registers */
;;;1661     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;1662     
;;;1663     /* Reset the BYPSHAD bit */
;;;1664     hrtc->Instance->CR &= (uint8_t)~RTC_CR_BYPSHAD;
;;;1665     
;;;1666     /* Enable the write protection for RTC registers */
;;;1667     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1668     
;;;1669     /* Change RTC state */
;;;1670     hrtc->State = HAL_RTC_STATE_READY; 
;;;1671     
;;;1672     /* Process Unlocked */ 
;;;1673     __HAL_UNLOCK(hrtc);
;;;1674     
;;;1675     return HAL_OK;
;;;1676   }
00000c  4770              BX       lr
                  |L10.14|
00000e  2001              MOVS     r0,#1                 ;1656
000010  7708              STRB     r0,[r1,#0x1c]         ;1656
000012  bf00              NOP                            ;1656
000014  2002              MOVS     r0,#2                 ;1658
000016  7748              STRB     r0,[r1,#0x1d]         ;1658
000018  bf00              NOP                            ;1661
00001a  20ca              MOVS     r0,#0xca              ;1661
00001c  680a              LDR      r2,[r1,#0]            ;1661
00001e  6250              STR      r0,[r2,#0x24]         ;1661
000020  2053              MOVS     r0,#0x53              ;1661
000022  680a              LDR      r2,[r1,#0]            ;1661
000024  6250              STR      r0,[r2,#0x24]         ;1661
000026  bf00              NOP                            ;1661
000028  6808              LDR      r0,[r1,#0]            ;1664
00002a  6880              LDR      r0,[r0,#8]            ;1664
00002c  f00000df          AND      r0,r0,#0xdf           ;1664
000030  680a              LDR      r2,[r1,#0]            ;1664
000032  6090              STR      r0,[r2,#8]            ;1664
000034  bf00              NOP                            ;1667
000036  20ff              MOVS     r0,#0xff              ;1667
000038  680a              LDR      r2,[r1,#0]            ;1667
00003a  6250              STR      r0,[r2,#0x24]         ;1667
00003c  bf00              NOP                            ;1667
00003e  2001              MOVS     r0,#1                 ;1670
000040  7748              STRB     r0,[r1,#0x1d]         ;1670
000042  bf00              NOP                            ;1673
000044  2000              MOVS     r0,#0                 ;1673
000046  7708              STRB     r0,[r1,#0x1c]         ;1673
000048  bf00              NOP                            ;1673
00004a  bf00              NOP                            ;1675
00004c  e7de              B        |L10.12|
;;;1677   
                          ENDP


                          AREA ||i.HAL_RTCEx_EnableBypassShadow||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_EnableBypassShadow PROC
;;;1619     */
;;;1620   HAL_StatusTypeDef HAL_RTCEx_EnableBypassShadow(RTC_HandleTypeDef* hrtc)
000000  4601              MOV      r1,r0
;;;1621   {
;;;1622     /* Process Locked */ 
;;;1623     __HAL_LOCK(hrtc);
000002  bf00              NOP      
000004  7f08              LDRB     r0,[r1,#0x1c]
000006  2801              CMP      r0,#1
000008  d101              BNE      |L11.14|
00000a  2002              MOVS     r0,#2
                  |L11.12|
;;;1624     
;;;1625     hrtc->State = HAL_RTC_STATE_BUSY;
;;;1626     
;;;1627     /* Disable the write protection for RTC registers */
;;;1628     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;1629     
;;;1630     /* Set the BYPSHAD bit */
;;;1631     hrtc->Instance->CR |= (uint8_t)RTC_CR_BYPSHAD;
;;;1632     
;;;1633     /* Enable the write protection for RTC registers */
;;;1634     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1635     
;;;1636     /* Change RTC state */
;;;1637     hrtc->State = HAL_RTC_STATE_READY; 
;;;1638     
;;;1639     /* Process Unlocked */ 
;;;1640     __HAL_UNLOCK(hrtc);
;;;1641     
;;;1642     return HAL_OK;
;;;1643   }
00000c  4770              BX       lr
                  |L11.14|
00000e  2001              MOVS     r0,#1                 ;1623
000010  7708              STRB     r0,[r1,#0x1c]         ;1623
000012  bf00              NOP                            ;1623
000014  2002              MOVS     r0,#2                 ;1625
000016  7748              STRB     r0,[r1,#0x1d]         ;1625
000018  bf00              NOP                            ;1628
00001a  20ca              MOVS     r0,#0xca              ;1628
00001c  680a              LDR      r2,[r1,#0]            ;1628
00001e  6250              STR      r0,[r2,#0x24]         ;1628
000020  2053              MOVS     r0,#0x53              ;1628
000022  680a              LDR      r2,[r1,#0]            ;1628
000024  6250              STR      r0,[r2,#0x24]         ;1628
000026  bf00              NOP                            ;1628
000028  6808              LDR      r0,[r1,#0]            ;1631
00002a  6880              LDR      r0,[r0,#8]            ;1631
00002c  f0400020          ORR      r0,r0,#0x20           ;1631
000030  680a              LDR      r2,[r1,#0]            ;1631
000032  6090              STR      r0,[r2,#8]            ;1631
000034  bf00              NOP                            ;1634
000036  20ff              MOVS     r0,#0xff              ;1634
000038  680a              LDR      r2,[r1,#0]            ;1634
00003a  6250              STR      r0,[r2,#0x24]         ;1634
00003c  bf00              NOP                            ;1634
00003e  2001              MOVS     r0,#1                 ;1637
000040  7748              STRB     r0,[r1,#0x1d]         ;1637
000042  bf00              NOP                            ;1640
000044  2000              MOVS     r0,#0                 ;1640
000046  7708              STRB     r0,[r1,#0x1c]         ;1640
000048  bf00              NOP                            ;1640
00004a  bf00              NOP                            ;1642
00004c  e7de              B        |L11.12|
;;;1644   
                          ENDP


                          AREA ||i.HAL_RTCEx_GetTimeStamp||, CODE, READONLY, ALIGN=2

                  HAL_RTCEx_GetTimeStamp PROC
;;;315      */
;;;316    HAL_StatusTypeDef HAL_RTCEx_GetTimeStamp(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef* sTimeStamp, RTC_DateTypeDef* sTimeStampDate, uint32_t Format)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;317    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  4699              MOV      r9,r3
;;;318      uint32_t tmptime = 0, tmpdate = 0;
00000c  2700              MOVS     r7,#0
00000e  46b8              MOV      r8,r7
;;;319    
;;;320      /* Check the parameters */
;;;321      assert_param(IS_RTC_FORMAT(Format));
;;;322    
;;;323      /* Get the TimeStamp time and date registers values */
;;;324      tmptime = (uint32_t)(hrtc->Instance->TSTR & RTC_TR_RESERVED_MASK);
000010  6830              LDR      r0,[r6,#0]
000012  6b00              LDR      r0,[r0,#0x30]
000014  4924              LDR      r1,|L12.168|
000016  ea000701          AND      r7,r0,r1
;;;325      tmpdate = (uint32_t)(hrtc->Instance->TSDR & RTC_DR_RESERVED_MASK);
00001a  6830              LDR      r0,[r6,#0]
00001c  6b40              LDR      r0,[r0,#0x34]
00001e  4923              LDR      r1,|L12.172|
000020  ea000801          AND      r8,r0,r1
;;;326    
;;;327      /* Fill the Time structure fields with the read parameters */
;;;328      sTimeStamp->Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16);
000024  f3c74005          UBFX     r0,r7,#16,#6
000028  7020              STRB     r0,[r4,#0]
;;;329      sTimeStamp->Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
00002a  f3c72006          UBFX     r0,r7,#8,#7
00002e  7060              STRB     r0,[r4,#1]
;;;330      sTimeStamp->Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
000030  f007007f          AND      r0,r7,#0x7f
000034  70a0              STRB     r0,[r4,#2]
;;;331      sTimeStamp->TimeFormat = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);  
000036  f4070080          AND      r0,r7,#0x400000
00003a  0c00              LSRS     r0,r0,#16
00003c  70e0              STRB     r0,[r4,#3]
;;;332      sTimeStamp->SubSeconds = (uint32_t) hrtc->Instance->TSSSR;
00003e  6830              LDR      r0,[r6,#0]
000040  6b80              LDR      r0,[r0,#0x38]
000042  6060              STR      r0,[r4,#4]
;;;333      
;;;334      /* Fill the Date structure fields with the read parameters */
;;;335      sTimeStampDate->Year = 0;
000044  2000              MOVS     r0,#0
000046  70e8              STRB     r0,[r5,#3]
;;;336      sTimeStampDate->Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8);
000048  f3c82004          UBFX     r0,r8,#8,#5
00004c  7068              STRB     r0,[r5,#1]
;;;337      sTimeStampDate->Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
00004e  f008003f          AND      r0,r8,#0x3f
000052  70a8              STRB     r0,[r5,#2]
;;;338      sTimeStampDate->WeekDay = (uint8_t)((tmpdate & (RTC_DR_WDU)) >> 13);
000054  f3c83042          UBFX     r0,r8,#13,#3
000058  7028              STRB     r0,[r5,#0]
;;;339    
;;;340      /* Check the input parameters format */
;;;341      if(Format == RTC_FORMAT_BIN)
00005a  f1b90f00          CMP      r9,#0
00005e  d117              BNE      |L12.144|
;;;342      {
;;;343        /* Convert the TimeStamp structure parameters to Binary format */
;;;344        sTimeStamp->Hours = (uint8_t)RTC_Bcd2ToByte(sTimeStamp->Hours);
000060  7820              LDRB     r0,[r4,#0]
000062  f7fffffe          BL       RTC_Bcd2ToByte
000066  7020              STRB     r0,[r4,#0]
;;;345        sTimeStamp->Minutes = (uint8_t)RTC_Bcd2ToByte(sTimeStamp->Minutes);
000068  7860              LDRB     r0,[r4,#1]
00006a  f7fffffe          BL       RTC_Bcd2ToByte
00006e  7060              STRB     r0,[r4,#1]
;;;346        sTimeStamp->Seconds = (uint8_t)RTC_Bcd2ToByte(sTimeStamp->Seconds);
000070  78a0              LDRB     r0,[r4,#2]
000072  f7fffffe          BL       RTC_Bcd2ToByte
000076  70a0              STRB     r0,[r4,#2]
;;;347        
;;;348        /* Convert the DateTimeStamp structure parameters to Binary format */
;;;349        sTimeStampDate->Month = (uint8_t)RTC_Bcd2ToByte(sTimeStampDate->Month);
000078  7868              LDRB     r0,[r5,#1]
00007a  f7fffffe          BL       RTC_Bcd2ToByte
00007e  7068              STRB     r0,[r5,#1]
;;;350        sTimeStampDate->Date = (uint8_t)RTC_Bcd2ToByte(sTimeStampDate->Date);
000080  78a8              LDRB     r0,[r5,#2]
000082  f7fffffe          BL       RTC_Bcd2ToByte
000086  70a8              STRB     r0,[r5,#2]
;;;351        sTimeStampDate->WeekDay = (uint8_t)RTC_Bcd2ToByte(sTimeStampDate->WeekDay);
000088  7828              LDRB     r0,[r5,#0]
00008a  f7fffffe          BL       RTC_Bcd2ToByte
00008e  7028              STRB     r0,[r5,#0]
                  |L12.144|
;;;352      }
;;;353      
;;;354      /* Clear the TIMESTAMP Flag */
;;;355      __HAL_RTC_TIMESTAMP_CLEAR_FLAG(hrtc, RTC_FLAG_TSF);
000090  6830              LDR      r0,[r6,#0]
000092  68c0              LDR      r0,[r0,#0xc]
000094  f0000080          AND      r0,r0,#0x80
000098  f4606008          ORN      r0,r0,#0x880
00009c  6831              LDR      r1,[r6,#0]
00009e  60c8              STR      r0,[r1,#0xc]
;;;356        
;;;357      return HAL_OK;
0000a0  2000              MOVS     r0,#0
;;;358    }
0000a2  e8bd87f0          POP      {r4-r10,pc}
;;;359    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L12.168|
                          DCD      0x007f7f7f
                  |L12.172|
                          DCD      0x00ffff3f

                          AREA ||i.HAL_RTCEx_GetWakeUpTimer||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_GetWakeUpTimer PROC
;;;980      */
;;;981    uint32_t HAL_RTCEx_GetWakeUpTimer(RTC_HandleTypeDef *hrtc)
000000  4601              MOV      r1,r0
;;;982    {
;;;983      /* Get the counter value */
;;;984      return ((uint32_t)(hrtc->Instance->WUTR & RTC_WUTR_WUT)); 
000002  6808              LDR      r0,[r1,#0]
000004  6940              LDR      r0,[r0,#0x14]
000006  b280              UXTH     r0,r0
;;;985    }
000008  4770              BX       lr
;;;986    
                          ENDP


                          AREA ||i.HAL_RTCEx_PollForAlarmBEvent||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_PollForAlarmBEvent PROC
;;;1718     */
;;;1719   HAL_StatusTypeDef HAL_RTCEx_PollForAlarmBEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;1720   {  
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1721     uint32_t tickstart = 0; 
000006  2600              MOVS     r6,#0
;;;1722   
;;;1723     /* Get tick */
;;;1724     tickstart = HAL_GetTick();
000008  f7fffffe          BL       HAL_GetTick
00000c  4606              MOV      r6,r0
;;;1725   
;;;1726     while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBF) == RESET)
00000e  e00a              B        |L14.38|
                  |L14.16|
;;;1727     {
;;;1728       if(Timeout != HAL_MAX_DELAY)
000010  1c68              ADDS     r0,r5,#1
000012  b140              CBZ      r0,|L14.38|
;;;1729       {
;;;1730         if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
000014  b125              CBZ      r5,|L14.32|
000016  f7fffffe          BL       HAL_GetTick
00001a  1b80              SUBS     r0,r0,r6
00001c  42a8              CMP      r0,r5
00001e  d902              BLS      |L14.38|
                  |L14.32|
;;;1731         {
;;;1732           hrtc->State = HAL_RTC_STATE_TIMEOUT;
000020  2003              MOVS     r0,#3
000022  7760              STRB     r0,[r4,#0x1d]
                  |L14.36|
;;;1733           return HAL_TIMEOUT;
;;;1734         }
;;;1735       }
;;;1736     }
;;;1737     
;;;1738     /* Clear the Alarm Flag */
;;;1739     __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRBF);
;;;1740     
;;;1741     /* Change RTC state */
;;;1742     hrtc->State = HAL_RTC_STATE_READY; 
;;;1743     
;;;1744     return HAL_OK; 
;;;1745   }
000024  bd70              POP      {r4-r6,pc}
                  |L14.38|
000026  6820              LDR      r0,[r4,#0]            ;1726
000028  68c0              LDR      r0,[r0,#0xc]          ;1726
00002a  f3c02040          UBFX     r0,r0,#9,#1           ;1726
00002e  2800              CMP      r0,#0                 ;1726
000030  d0ee              BEQ      |L14.16|
000032  6820              LDR      r0,[r4,#0]            ;1739
000034  68c0              LDR      r0,[r0,#0xc]          ;1739
000036  f0000080          AND      r0,r0,#0x80           ;1739
00003a  f4607020          ORN      r0,r0,#0x280          ;1739
00003e  6821              LDR      r1,[r4,#0]            ;1739
000040  60c8              STR      r0,[r1,#0xc]          ;1739
000042  2001              MOVS     r0,#1                 ;1742
000044  7760              STRB     r0,[r4,#0x1d]         ;1742
000046  2000              MOVS     r0,#0                 ;1744
000048  e7ec              B        |L14.36|
;;;1746   
                          ENDP


                          AREA ||i.HAL_RTCEx_PollForTamper1Event||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_PollForTamper1Event PROC
;;;646      */
;;;647    HAL_StatusTypeDef HAL_RTCEx_PollForTamper1Event(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;648    {  
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;649      uint32_t tickstart = 0; 
000006  2600              MOVS     r6,#0
;;;650    
;;;651      /* Get tick */
;;;652      tickstart = HAL_GetTick();
000008  f7fffffe          BL       HAL_GetTick
00000c  4606              MOV      r6,r0
;;;653      
;;;654      /* Get the status of the Interrupt */
;;;655      while(__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP1F)== RESET)
00000e  e00a              B        |L15.38|
                  |L15.16|
;;;656      {
;;;657        if(Timeout != HAL_MAX_DELAY)
000010  1c68              ADDS     r0,r5,#1
000012  b140              CBZ      r0,|L15.38|
;;;658        {
;;;659          if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
000014  b125              CBZ      r5,|L15.32|
000016  f7fffffe          BL       HAL_GetTick
00001a  1b80              SUBS     r0,r0,r6
00001c  42a8              CMP      r0,r5
00001e  d902              BLS      |L15.38|
                  |L15.32|
;;;660          {
;;;661            hrtc->State = HAL_RTC_STATE_TIMEOUT;
000020  2003              MOVS     r0,#3
000022  7760              STRB     r0,[r4,#0x1d]
                  |L15.36|
;;;662            return HAL_TIMEOUT;
;;;663          }
;;;664        }
;;;665      }
;;;666      
;;;667      /* Clear the Tamper Flag */
;;;668      __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc,RTC_FLAG_TAMP1F);
;;;669      
;;;670      /* Change RTC state */
;;;671      hrtc->State = HAL_RTC_STATE_READY;
;;;672      
;;;673      return HAL_OK; 
;;;674    }
000024  bd70              POP      {r4-r6,pc}
                  |L15.38|
000026  6820              LDR      r0,[r4,#0]            ;655
000028  68c0              LDR      r0,[r0,#0xc]          ;655
00002a  f3c03040          UBFX     r0,r0,#13,#1          ;655
00002e  2800              CMP      r0,#0                 ;655
000030  d0ee              BEQ      |L15.16|
000032  6820              LDR      r0,[r4,#0]            ;668
000034  68c0              LDR      r0,[r0,#0xc]          ;668
000036  f0000080          AND      r0,r0,#0x80           ;668
00003a  f4605002          ORN      r0,r0,#0x2080         ;668
00003e  6821              LDR      r1,[r4,#0]            ;668
000040  60c8              STR      r0,[r1,#0xc]          ;668
000042  2001              MOVS     r0,#1                 ;671
000044  7760              STRB     r0,[r4,#0x1d]         ;671
000046  2000              MOVS     r0,#0                 ;673
000048  e7ec              B        |L15.36|
;;;675    
                          ENDP


                          AREA ||i.HAL_RTCEx_PollForTamper2Event||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_PollForTamper2Event PROC
;;;682      */
;;;683    HAL_StatusTypeDef HAL_RTCEx_PollForTamper2Event(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;684    {  
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;685      uint32_t tickstart = 0; 
000006  2600              MOVS     r6,#0
;;;686    
;;;687      /* Get tick */
;;;688      tickstart = HAL_GetTick();
000008  f7fffffe          BL       HAL_GetTick
00000c  4606              MOV      r6,r0
;;;689      
;;;690      /* Get the status of the Interrupt */
;;;691      while(__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP2F) == RESET)
00000e  e00a              B        |L16.38|
                  |L16.16|
;;;692      {
;;;693        if(Timeout != HAL_MAX_DELAY)
000010  1c68              ADDS     r0,r5,#1
000012  b140              CBZ      r0,|L16.38|
;;;694        {
;;;695          if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
000014  b125              CBZ      r5,|L16.32|
000016  f7fffffe          BL       HAL_GetTick
00001a  1b80              SUBS     r0,r0,r6
00001c  42a8              CMP      r0,r5
00001e  d902              BLS      |L16.38|
                  |L16.32|
;;;696          {
;;;697            hrtc->State = HAL_RTC_STATE_TIMEOUT;
000020  2003              MOVS     r0,#3
000022  7760              STRB     r0,[r4,#0x1d]
                  |L16.36|
;;;698            return HAL_TIMEOUT;
;;;699          }
;;;700        }
;;;701      }
;;;702      
;;;703      /* Clear the Tamper Flag */
;;;704      __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc,RTC_FLAG_TAMP2F);
;;;705      
;;;706      /* Change RTC state */
;;;707      hrtc->State = HAL_RTC_STATE_READY;
;;;708      
;;;709      return HAL_OK;
;;;710    }
000024  bd70              POP      {r4-r6,pc}
                  |L16.38|
000026  6820              LDR      r0,[r4,#0]            ;691
000028  68c0              LDR      r0,[r0,#0xc]          ;691
00002a  f3c03080          UBFX     r0,r0,#14,#1          ;691
00002e  2800              CMP      r0,#0                 ;691
000030  d0ee              BEQ      |L16.16|
000032  6820              LDR      r0,[r4,#0]            ;704
000034  68c0              LDR      r0,[r0,#0xc]          ;704
000036  f0000080          AND      r0,r0,#0x80           ;704
00003a  f4604081          ORN      r0,r0,#0x4080         ;704
00003e  6821              LDR      r1,[r4,#0]            ;704
000040  60c8              STR      r0,[r1,#0xc]          ;704
000042  2001              MOVS     r0,#1                 ;707
000044  7760              STRB     r0,[r4,#0x1d]         ;707
000046  2000              MOVS     r0,#0                 ;709
000048  e7ec              B        |L16.36|
;;;711    
                          ENDP


                          AREA ||i.HAL_RTCEx_PollForTimeStampEvent||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_PollForTimeStampEvent PROC
;;;603      */
;;;604    HAL_StatusTypeDef HAL_RTCEx_PollForTimeStampEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;605    { 
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;606      uint32_t tickstart = 0; 
000006  2600              MOVS     r6,#0
;;;607    
;;;608      /* Get tick */
;;;609      tickstart = HAL_GetTick();
000008  f7fffffe          BL       HAL_GetTick
00000c  4606              MOV      r6,r0
;;;610    
;;;611      while(__HAL_RTC_TIMESTAMP_GET_FLAG(hrtc, RTC_FLAG_TSF) == RESET)
00000e  e01b              B        |L17.72|
                  |L17.16|
;;;612      {
;;;613        if(__HAL_RTC_TIMESTAMP_GET_FLAG(hrtc, RTC_FLAG_TSOVF) != RESET)
000010  6820              LDR      r0,[r4,#0]
000012  68c0              LDR      r0,[r0,#0xc]
000014  f3c03000          UBFX     r0,r0,#12,#1
000018  b158              CBZ      r0,|L17.50|
;;;614        {
;;;615          /* Clear the TIMESTAMP Overrun Flag */
;;;616          __HAL_RTC_TIMESTAMP_CLEAR_FLAG(hrtc, RTC_FLAG_TSOVF);
00001a  6820              LDR      r0,[r4,#0]
00001c  68c0              LDR      r0,[r0,#0xc]
00001e  f0000080          AND      r0,r0,#0x80
000022  f4605084          ORN      r0,r0,#0x1080
000026  6821              LDR      r1,[r4,#0]
000028  60c8              STR      r0,[r1,#0xc]
;;;617          
;;;618          /* Change TIMESTAMP state */
;;;619          hrtc->State = HAL_RTC_STATE_ERROR; 
00002a  2004              MOVS     r0,#4
00002c  7760              STRB     r0,[r4,#0x1d]
;;;620          
;;;621          return HAL_ERROR; 
00002e  2001              MOVS     r0,#1
                  |L17.48|
;;;622        }
;;;623        
;;;624        if(Timeout != HAL_MAX_DELAY)
;;;625        {
;;;626          if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
;;;627          {
;;;628            hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;629            return HAL_TIMEOUT;
;;;630          }
;;;631        }
;;;632      }
;;;633      
;;;634      /* Change RTC state */
;;;635      hrtc->State = HAL_RTC_STATE_READY; 
;;;636      
;;;637      return HAL_OK; 
;;;638    }
000030  bd70              POP      {r4-r6,pc}
                  |L17.50|
000032  1c68              ADDS     r0,r5,#1              ;624
000034  b140              CBZ      r0,|L17.72|
000036  b125              CBZ      r5,|L17.66|
000038  f7fffffe          BL       HAL_GetTick
00003c  1b80              SUBS     r0,r0,r6              ;626
00003e  42a8              CMP      r0,r5                 ;626
000040  d902              BLS      |L17.72|
                  |L17.66|
000042  2003              MOVS     r0,#3                 ;628
000044  7760              STRB     r0,[r4,#0x1d]         ;628
000046  e7f3              B        |L17.48|
                  |L17.72|
000048  6820              LDR      r0,[r4,#0]            ;611
00004a  68c0              LDR      r0,[r0,#0xc]          ;611
00004c  f3c020c0          UBFX     r0,r0,#11,#1          ;611
000050  2800              CMP      r0,#0                 ;611
000052  d0dd              BEQ      |L17.16|
000054  2001              MOVS     r0,#1                 ;635
000056  7760              STRB     r0,[r4,#0x1d]         ;635
000058  2000              MOVS     r0,#0                 ;637
00005a  e7e9              B        |L17.48|
;;;639      
                          ENDP


                          AREA ||i.HAL_RTCEx_PollForWakeUpTimerEvent||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_PollForWakeUpTimerEvent PROC
;;;1036     */
;;;1037   HAL_StatusTypeDef HAL_RTCEx_PollForWakeUpTimerEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;1038   {  
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1039     uint32_t tickstart = 0; 
000006  2600              MOVS     r6,#0
;;;1040   
;;;1041     /* Get tick */
;;;1042     tickstart = HAL_GetTick();
000008  f7fffffe          BL       HAL_GetTick
00000c  4606              MOV      r6,r0
;;;1043   
;;;1044     while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTF) == RESET)
00000e  e00a              B        |L18.38|
                  |L18.16|
;;;1045     {
;;;1046       if(Timeout != HAL_MAX_DELAY)
000010  1c68              ADDS     r0,r5,#1
000012  b140              CBZ      r0,|L18.38|
;;;1047       {
;;;1048         if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
000014  b125              CBZ      r5,|L18.32|
000016  f7fffffe          BL       HAL_GetTick
00001a  1b80              SUBS     r0,r0,r6
00001c  42a8              CMP      r0,r5
00001e  d902              BLS      |L18.38|
                  |L18.32|
;;;1049         {
;;;1050           hrtc->State = HAL_RTC_STATE_TIMEOUT;
000020  2003              MOVS     r0,#3
000022  7760              STRB     r0,[r4,#0x1d]
                  |L18.36|
;;;1051         
;;;1052           return HAL_TIMEOUT;
;;;1053         }
;;;1054       }
;;;1055     }
;;;1056     
;;;1057     /* Clear the WAKEUPTIMER Flag */
;;;1058     __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(hrtc, RTC_FLAG_WUTF);
;;;1059     
;;;1060     /* Change RTC state */
;;;1061     hrtc->State = HAL_RTC_STATE_READY;
;;;1062     
;;;1063     return HAL_OK; 
;;;1064   }
000024  bd70              POP      {r4-r6,pc}
                  |L18.38|
000026  6820              LDR      r0,[r4,#0]            ;1044
000028  68c0              LDR      r0,[r0,#0xc]          ;1044
00002a  f3c02080          UBFX     r0,r0,#10,#1          ;1044
00002e  2800              CMP      r0,#0                 ;1044
000030  d0ee              BEQ      |L18.16|
000032  6820              LDR      r0,[r4,#0]            ;1058
000034  68c0              LDR      r0,[r0,#0xc]          ;1058
000036  f0000080          AND      r0,r0,#0x80           ;1058
00003a  f4606090          ORN      r0,r0,#0x480          ;1058
00003e  6821              LDR      r1,[r4,#0]            ;1058
000040  60c8              STR      r0,[r1,#0xc]          ;1058
000042  2001              MOVS     r0,#1                 ;1061
000044  7760              STRB     r0,[r4,#0x1d]         ;1061
000046  2000              MOVS     r0,#0                 ;1063
000048  e7ec              B        |L18.36|
;;;1065   
                          ENDP


                          AREA ||i.HAL_RTCEx_SetCalibrationOutPut||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_SetCalibrationOutPut PROC
;;;1448     */
;;;1449   HAL_StatusTypeDef HAL_RTCEx_SetCalibrationOutPut(RTC_HandleTypeDef* hrtc, uint32_t CalibOutput)
000000  4602              MOV      r2,r0
;;;1450   {
;;;1451     /* Check the parameters */
;;;1452     assert_param(IS_RTC_CALIB_OUTPUT(CalibOutput));
;;;1453     
;;;1454     /* Process Locked */ 
;;;1455     __HAL_LOCK(hrtc);
000002  bf00              NOP      
000004  7f10              LDRB     r0,[r2,#0x1c]
000006  2801              CMP      r0,#1
000008  d101              BNE      |L19.14|
00000a  2002              MOVS     r0,#2
                  |L19.12|
;;;1456     
;;;1457     hrtc->State = HAL_RTC_STATE_BUSY;
;;;1458   
;;;1459     /* Disable the write protection for RTC registers */
;;;1460     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;1461     
;;;1462     /* Clear flags before config */
;;;1463     hrtc->Instance->CR &= (uint32_t)~RTC_CR_COSEL;
;;;1464     
;;;1465     /* Configure the RTC_CR register */
;;;1466     hrtc->Instance->CR |= (uint32_t)CalibOutput;
;;;1467     
;;;1468     __HAL_RTC_CALIBRATION_OUTPUT_ENABLE(hrtc);
;;;1469     
;;;1470     /* Enable the write protection for RTC registers */
;;;1471     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1472     
;;;1473     /* Change RTC state */
;;;1474     hrtc->State = HAL_RTC_STATE_READY; 
;;;1475     
;;;1476     /* Process Unlocked */ 
;;;1477     __HAL_UNLOCK(hrtc);
;;;1478     
;;;1479     return HAL_OK;
;;;1480   }
00000c  4770              BX       lr
                  |L19.14|
00000e  2001              MOVS     r0,#1                 ;1455
000010  7710              STRB     r0,[r2,#0x1c]         ;1455
000012  bf00              NOP                            ;1455
000014  2002              MOVS     r0,#2                 ;1457
000016  7750              STRB     r0,[r2,#0x1d]         ;1457
000018  bf00              NOP                            ;1460
00001a  20ca              MOVS     r0,#0xca              ;1460
00001c  6813              LDR      r3,[r2,#0]            ;1460
00001e  6258              STR      r0,[r3,#0x24]         ;1460
000020  2053              MOVS     r0,#0x53              ;1460
000022  6813              LDR      r3,[r2,#0]            ;1460
000024  6258              STR      r0,[r3,#0x24]         ;1460
000026  bf00              NOP                            ;1460
000028  6810              LDR      r0,[r2,#0]            ;1463
00002a  6880              LDR      r0,[r0,#8]            ;1463
00002c  f4202000          BIC      r0,r0,#0x80000        ;1463
000030  6813              LDR      r3,[r2,#0]            ;1463
000032  6098              STR      r0,[r3,#8]            ;1463
000034  6810              LDR      r0,[r2,#0]            ;1466
000036  6880              LDR      r0,[r0,#8]            ;1466
000038  4308              ORRS     r0,r0,r1              ;1466
00003a  6813              LDR      r3,[r2,#0]            ;1466
00003c  6098              STR      r0,[r3,#8]            ;1466
00003e  6810              LDR      r0,[r2,#0]            ;1468
000040  6880              LDR      r0,[r0,#8]            ;1468
000042  f4400000          ORR      r0,r0,#0x800000       ;1468
000046  6813              LDR      r3,[r2,#0]            ;1468
000048  6098              STR      r0,[r3,#8]            ;1468
00004a  bf00              NOP                            ;1471
00004c  20ff              MOVS     r0,#0xff              ;1471
00004e  6813              LDR      r3,[r2,#0]            ;1471
000050  6258              STR      r0,[r3,#0x24]         ;1471
000052  bf00              NOP                            ;1471
000054  2001              MOVS     r0,#1                 ;1474
000056  7750              STRB     r0,[r2,#0x1d]         ;1474
000058  bf00              NOP                            ;1477
00005a  2000              MOVS     r0,#0                 ;1477
00005c  7710              STRB     r0,[r2,#0x1c]         ;1477
00005e  bf00              NOP                            ;1477
000060  bf00              NOP                            ;1479
000062  e7d3              B        |L19.12|
;;;1481   
                          ENDP


                          AREA ||i.HAL_RTCEx_SetCoarseCalib||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_SetCoarseCalib PROC
;;;1160     */
;;;1161   HAL_StatusTypeDef HAL_RTCEx_SetCoarseCalib(RTC_HandleTypeDef* hrtc, uint32_t CalibSign, uint32_t Value)
000000  b570              PUSH     {r4-r6,lr}
;;;1162   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;1163     /* Check the parameters */
;;;1164     assert_param(IS_RTC_CALIB_SIGN(CalibSign));
;;;1165     assert_param(IS_RTC_CALIB_VALUE(Value)); 
;;;1166     
;;;1167     /* Process Locked */ 
;;;1168     __HAL_LOCK(hrtc);
000008  bf00              NOP      
00000a  7f20              LDRB     r0,[r4,#0x1c]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L20.20|
000010  2002              MOVS     r0,#2
                  |L20.18|
;;;1169     
;;;1170     hrtc->State = HAL_RTC_STATE_BUSY;
;;;1171   
;;;1172     /* Disable the write protection for RTC registers */
;;;1173     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;1174   
;;;1175     /* Set Initialization mode */
;;;1176     if(RTC_EnterInitMode(hrtc) != HAL_OK)
;;;1177     {
;;;1178       /* Enable the write protection for RTC registers */
;;;1179       __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); 
;;;1180       
;;;1181       /* Set RTC state*/
;;;1182       hrtc->State = HAL_RTC_STATE_ERROR;
;;;1183       
;;;1184       /* Process Unlocked */ 
;;;1185       __HAL_UNLOCK(hrtc);
;;;1186       
;;;1187       return HAL_ERROR;
;;;1188     } 
;;;1189     else
;;;1190     { 
;;;1191       /* Enable the Coarse Calibration */
;;;1192       __HAL_RTC_COARSE_CALIB_ENABLE(hrtc);
;;;1193       
;;;1194       /* Set the coarse calibration value */
;;;1195       hrtc->Instance->CALIBR = (uint32_t)(CalibSign|Value);
;;;1196       
;;;1197       /* Exit Initialization mode */
;;;1198       hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT; 
;;;1199     } 
;;;1200   
;;;1201     /* Enable the write protection for RTC registers */
;;;1202     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1203     
;;;1204     /* Change state */
;;;1205     hrtc->State = HAL_RTC_STATE_READY; 
;;;1206     
;;;1207     /* Process Unlocked */ 
;;;1208     __HAL_UNLOCK(hrtc);
;;;1209     
;;;1210     return HAL_OK;
;;;1211   }
000012  bd70              POP      {r4-r6,pc}
                  |L20.20|
000014  2001              MOVS     r0,#1                 ;1168
000016  7720              STRB     r0,[r4,#0x1c]         ;1168
000018  bf00              NOP                            ;1168
00001a  2002              MOVS     r0,#2                 ;1170
00001c  7760              STRB     r0,[r4,#0x1d]         ;1170
00001e  bf00              NOP                            ;1173
000020  20ca              MOVS     r0,#0xca              ;1173
000022  6821              LDR      r1,[r4,#0]            ;1173
000024  6248              STR      r0,[r1,#0x24]         ;1173
000026  2053              MOVS     r0,#0x53              ;1173
000028  6821              LDR      r1,[r4,#0]            ;1173
00002a  6248              STR      r0,[r1,#0x24]         ;1173
00002c  bf00              NOP                            ;1173
00002e  4620              MOV      r0,r4                 ;1176
000030  f7fffffe          BL       RTC_EnterInitMode
000034  b160              CBZ      r0,|L20.80|
000036  bf00              NOP                            ;1179
000038  20ff              MOVS     r0,#0xff              ;1179
00003a  6821              LDR      r1,[r4,#0]            ;1179
00003c  6248              STR      r0,[r1,#0x24]         ;1179
00003e  bf00              NOP                            ;1179
000040  2004              MOVS     r0,#4                 ;1182
000042  7760              STRB     r0,[r4,#0x1d]         ;1182
000044  bf00              NOP                            ;1185
000046  2000              MOVS     r0,#0                 ;1185
000048  7720              STRB     r0,[r4,#0x1c]         ;1185
00004a  bf00              NOP                            ;1185
00004c  2001              MOVS     r0,#1                 ;1187
00004e  e7e0              B        |L20.18|
                  |L20.80|
000050  6820              LDR      r0,[r4,#0]            ;1192
000052  6880              LDR      r0,[r0,#8]            ;1192
000054  f0400080          ORR      r0,r0,#0x80           ;1192
000058  6821              LDR      r1,[r4,#0]            ;1192
00005a  6088              STR      r0,[r1,#8]            ;1192
00005c  ea460005          ORR      r0,r6,r5              ;1195
000060  6821              LDR      r1,[r4,#0]            ;1195
000062  6188              STR      r0,[r1,#0x18]         ;1195
000064  6820              LDR      r0,[r4,#0]            ;1198
000066  68c0              LDR      r0,[r0,#0xc]          ;1198
000068  f0200080          BIC      r0,r0,#0x80           ;1198
00006c  6821              LDR      r1,[r4,#0]            ;1198
00006e  60c8              STR      r0,[r1,#0xc]          ;1198
000070  bf00              NOP                            ;1202
000072  20ff              MOVS     r0,#0xff              ;1202
000074  6821              LDR      r1,[r4,#0]            ;1202
000076  6248              STR      r0,[r1,#0x24]         ;1202
000078  bf00              NOP                            ;1202
00007a  2001              MOVS     r0,#1                 ;1205
00007c  7760              STRB     r0,[r4,#0x1d]         ;1205
00007e  bf00              NOP                            ;1208
000080  2000              MOVS     r0,#0                 ;1208
000082  7720              STRB     r0,[r4,#0x1c]         ;1208
000084  bf00              NOP                            ;1208
000086  bf00              NOP                            ;1210
000088  e7c3              B        |L20.18|
;;;1212   
                          ENDP


                          AREA ||i.HAL_RTCEx_SetRefClock||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_SetRefClock PROC
;;;1517     */
;;;1518   HAL_StatusTypeDef HAL_RTCEx_SetRefClock(RTC_HandleTypeDef* hrtc)
000000  b510              PUSH     {r4,lr}
;;;1519   {
000002  4604              MOV      r4,r0
;;;1520     /* Process Locked */ 
;;;1521     __HAL_LOCK(hrtc);
000004  bf00              NOP      
000006  7f20              LDRB     r0,[r4,#0x1c]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L21.16|
00000c  2002              MOVS     r0,#2
                  |L21.14|
;;;1522     
;;;1523     hrtc->State = HAL_RTC_STATE_BUSY;
;;;1524     
;;;1525     /* Disable the write protection for RTC registers */
;;;1526     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;1527     
;;;1528     /* Set Initialization mode */
;;;1529     if(RTC_EnterInitMode(hrtc) != HAL_OK)
;;;1530     {
;;;1531       /* Enable the write protection for RTC registers */
;;;1532       __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); 
;;;1533       
;;;1534       /* Set RTC state*/
;;;1535       hrtc->State = HAL_RTC_STATE_ERROR;
;;;1536       
;;;1537       /* Process Unlocked */ 
;;;1538       __HAL_UNLOCK(hrtc);
;;;1539       
;;;1540       return HAL_ERROR;
;;;1541     } 
;;;1542     else
;;;1543     {
;;;1544       __HAL_RTC_CLOCKREF_DETECTION_ENABLE(hrtc);
;;;1545   
;;;1546       /* Exit Initialization mode */
;;;1547       hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT; 
;;;1548     }
;;;1549     
;;;1550     /* Enable the write protection for RTC registers */
;;;1551     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1552     
;;;1553      /* Change RTC state */
;;;1554     hrtc->State = HAL_RTC_STATE_READY; 
;;;1555     
;;;1556     /* Process Unlocked */ 
;;;1557     __HAL_UNLOCK(hrtc);
;;;1558     
;;;1559     return HAL_OK;
;;;1560   }
00000e  bd10              POP      {r4,pc}
                  |L21.16|
000010  2001              MOVS     r0,#1                 ;1521
000012  7720              STRB     r0,[r4,#0x1c]         ;1521
000014  bf00              NOP                            ;1521
000016  2002              MOVS     r0,#2                 ;1523
000018  7760              STRB     r0,[r4,#0x1d]         ;1523
00001a  bf00              NOP                            ;1526
00001c  20ca              MOVS     r0,#0xca              ;1526
00001e  6821              LDR      r1,[r4,#0]            ;1526
000020  6248              STR      r0,[r1,#0x24]         ;1526
000022  2053              MOVS     r0,#0x53              ;1526
000024  6821              LDR      r1,[r4,#0]            ;1526
000026  6248              STR      r0,[r1,#0x24]         ;1526
000028  bf00              NOP                            ;1526
00002a  4620              MOV      r0,r4                 ;1529
00002c  f7fffffe          BL       RTC_EnterInitMode
000030  b160              CBZ      r0,|L21.76|
000032  bf00              NOP                            ;1532
000034  20ff              MOVS     r0,#0xff              ;1532
000036  6821              LDR      r1,[r4,#0]            ;1532
000038  6248              STR      r0,[r1,#0x24]         ;1532
00003a  bf00              NOP                            ;1532
00003c  2004              MOVS     r0,#4                 ;1535
00003e  7760              STRB     r0,[r4,#0x1d]         ;1535
000040  bf00              NOP                            ;1538
000042  2000              MOVS     r0,#0                 ;1538
000044  7720              STRB     r0,[r4,#0x1c]         ;1538
000046  bf00              NOP                            ;1538
000048  2001              MOVS     r0,#1                 ;1540
00004a  e7e0              B        |L21.14|
                  |L21.76|
00004c  6820              LDR      r0,[r4,#0]            ;1544
00004e  6880              LDR      r0,[r0,#8]            ;1544
000050  f0400010          ORR      r0,r0,#0x10           ;1544
000054  6821              LDR      r1,[r4,#0]            ;1544
000056  6088              STR      r0,[r1,#8]            ;1544
000058  6820              LDR      r0,[r4,#0]            ;1547
00005a  68c0              LDR      r0,[r0,#0xc]          ;1547
00005c  f0200080          BIC      r0,r0,#0x80           ;1547
000060  6821              LDR      r1,[r4,#0]            ;1547
000062  60c8              STR      r0,[r1,#0xc]          ;1547
000064  bf00              NOP                            ;1551
000066  20ff              MOVS     r0,#0xff              ;1551
000068  6821              LDR      r1,[r4,#0]            ;1551
00006a  6248              STR      r0,[r1,#0x24]         ;1551
00006c  bf00              NOP                            ;1551
00006e  2001              MOVS     r0,#1                 ;1554
000070  7760              STRB     r0,[r4,#0x1d]         ;1554
000072  bf00              NOP                            ;1557
000074  2000              MOVS     r0,#0                 ;1557
000076  7720              STRB     r0,[r4,#0x1c]         ;1557
000078  bf00              NOP                            ;1557
00007a  bf00              NOP                            ;1559
00007c  e7c7              B        |L21.14|
;;;1561   
                          ENDP


                          AREA ||i.HAL_RTCEx_SetSmoothCalib||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_SetSmoothCalib PROC
;;;1283     */
;;;1284   HAL_StatusTypeDef HAL_RTCEx_SetSmoothCalib(RTC_HandleTypeDef* hrtc, uint32_t SmoothCalibPeriod, uint32_t SmoothCalibPlusPulses, uint32_t SmouthCalibMinusPulsesValue)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1285   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1286     uint32_t tickstart = 0;
00000c  f04f0800          MOV      r8,#0
;;;1287     
;;;1288     /* Check the parameters */
;;;1289     assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(SmoothCalibPeriod));
;;;1290     assert_param(IS_RTC_SMOOTH_CALIB_PLUS(SmoothCalibPlusPulses));
;;;1291     assert_param(IS_RTC_SMOOTH_CALIB_MINUS(SmouthCalibMinusPulsesValue));
;;;1292     
;;;1293     /* Process Locked */ 
;;;1294     __HAL_LOCK(hrtc);
000010  bf00              NOP      
000012  7f20              LDRB     r0,[r4,#0x1c]
000014  2801              CMP      r0,#1
000016  d102              BNE      |L22.30|
000018  2002              MOVS     r0,#2
                  |L22.26|
;;;1295     
;;;1296     hrtc->State = HAL_RTC_STATE_BUSY;
;;;1297     
;;;1298     /* Disable the write protection for RTC registers */
;;;1299     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;1300     
;;;1301     /* check if a calibration is pending*/
;;;1302     if((hrtc->Instance->ISR & RTC_ISR_RECALPF) != RESET)
;;;1303     {
;;;1304     /* Get tick */
;;;1305     tickstart = HAL_GetTick();
;;;1306   
;;;1307       /* check if a calibration is pending*/
;;;1308       while((hrtc->Instance->ISR & RTC_ISR_RECALPF) != RESET)
;;;1309       {
;;;1310         if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
;;;1311         {
;;;1312           /* Enable the write protection for RTC registers */
;;;1313           __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1314           
;;;1315           /* Change RTC state */
;;;1316           hrtc->State = HAL_RTC_STATE_TIMEOUT; 
;;;1317           
;;;1318           /* Process Unlocked */ 
;;;1319           __HAL_UNLOCK(hrtc);
;;;1320           
;;;1321           return HAL_TIMEOUT;
;;;1322         }
;;;1323       }
;;;1324     }
;;;1325     
;;;1326     /* Configure the Smooth calibration settings */
;;;1327     hrtc->Instance->CALR = (uint32_t)((uint32_t)SmoothCalibPeriod | (uint32_t)SmoothCalibPlusPulses | (uint32_t)SmouthCalibMinusPulsesValue);
;;;1328     
;;;1329     /* Enable the write protection for RTC registers */
;;;1330     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1331     
;;;1332     /* Change RTC state */
;;;1333     hrtc->State = HAL_RTC_STATE_READY; 
;;;1334     
;;;1335     /* Process Unlocked */ 
;;;1336     __HAL_UNLOCK(hrtc);
;;;1337     
;;;1338     return HAL_OK;
;;;1339   }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L22.30|
00001e  2001              MOVS     r0,#1                 ;1294
000020  7720              STRB     r0,[r4,#0x1c]         ;1294
000022  bf00              NOP                            ;1294
000024  2002              MOVS     r0,#2                 ;1296
000026  7760              STRB     r0,[r4,#0x1d]         ;1296
000028  bf00              NOP                            ;1299
00002a  20ca              MOVS     r0,#0xca              ;1299
00002c  6821              LDR      r1,[r4,#0]            ;1299
00002e  6248              STR      r0,[r1,#0x24]         ;1299
000030  2053              MOVS     r0,#0x53              ;1299
000032  6821              LDR      r1,[r4,#0]            ;1299
000034  6248              STR      r0,[r1,#0x24]         ;1299
000036  bf00              NOP                            ;1299
000038  6820              LDR      r0,[r4,#0]            ;1302
00003a  68c0              LDR      r0,[r0,#0xc]          ;1302
00003c  f4003080          AND      r0,r0,#0x10000        ;1302
000040  b1e8              CBZ      r0,|L22.126|
000042  f7fffffe          BL       HAL_GetTick
000046  4680              MOV      r8,r0                 ;1305
000048  e013              B        |L22.114|
                  |L22.74|
00004a  f7fffffe          BL       HAL_GetTick
00004e  eba00008          SUB      r0,r0,r8              ;1310
000052  f5b07f7a          CMP      r0,#0x3e8             ;1310
000056  d90c              BLS      |L22.114|
000058  bf00              NOP                            ;1313
00005a  20ff              MOVS     r0,#0xff              ;1313
00005c  6821              LDR      r1,[r4,#0]            ;1313
00005e  6248              STR      r0,[r1,#0x24]         ;1313
000060  bf00              NOP                            ;1313
000062  2003              MOVS     r0,#3                 ;1316
000064  7760              STRB     r0,[r4,#0x1d]         ;1316
000066  bf00              NOP                            ;1319
000068  2000              MOVS     r0,#0                 ;1319
00006a  7720              STRB     r0,[r4,#0x1c]         ;1319
00006c  bf00              NOP                            ;1319
00006e  2003              MOVS     r0,#3                 ;1321
000070  e7d3              B        |L22.26|
                  |L22.114|
000072  6820              LDR      r0,[r4,#0]            ;1308
000074  68c0              LDR      r0,[r0,#0xc]          ;1308
000076  f4003080          AND      r0,r0,#0x10000        ;1308
00007a  2800              CMP      r0,#0                 ;1308
00007c  d1e5              BNE      |L22.74|
                  |L22.126|
00007e  ea450006          ORR      r0,r5,r6              ;1327
000082  4338              ORRS     r0,r0,r7              ;1327
000084  6821              LDR      r1,[r4,#0]            ;1327
000086  63c8              STR      r0,[r1,#0x3c]         ;1327
000088  bf00              NOP                            ;1330
00008a  20ff              MOVS     r0,#0xff              ;1330
00008c  6821              LDR      r1,[r4,#0]            ;1330
00008e  6248              STR      r0,[r1,#0x24]         ;1330
000090  bf00              NOP                            ;1330
000092  2001              MOVS     r0,#1                 ;1333
000094  7760              STRB     r0,[r4,#0x1d]         ;1333
000096  bf00              NOP                            ;1336
000098  2000              MOVS     r0,#0                 ;1336
00009a  7720              STRB     r0,[r4,#0x1c]         ;1336
00009c  bf00              NOP                            ;1336
00009e  bf00              NOP                            ;1338
0000a0  e7bb              B        |L22.26|
;;;1340   
                          ENDP


                          AREA ||i.HAL_RTCEx_SetSynchroShift||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_SetSynchroShift PROC
;;;1353     */
;;;1354   HAL_StatusTypeDef HAL_RTCEx_SetSynchroShift(RTC_HandleTypeDef* hrtc, uint32_t ShiftAdd1S, uint32_t ShiftSubFS)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1355   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;1356     uint32_t tickstart = 0;
00000a  2700              MOVS     r7,#0
;;;1357   
;;;1358     /* Check the parameters */
;;;1359     assert_param(IS_RTC_SHIFT_ADD1S(ShiftAdd1S));
;;;1360     assert_param(IS_RTC_SHIFT_SUBFS(ShiftSubFS));
;;;1361   
;;;1362     /* Process Locked */ 
;;;1363     __HAL_LOCK(hrtc);
00000c  bf00              NOP      
00000e  7f20              LDRB     r0,[r4,#0x1c]
000010  2801              CMP      r0,#1
000012  d102              BNE      |L23.26|
000014  2002              MOVS     r0,#2
                  |L23.22|
;;;1364     
;;;1365     hrtc->State = HAL_RTC_STATE_BUSY;
;;;1366   
;;;1367     /* Disable the write protection for RTC registers */
;;;1368     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;1369   
;;;1370     /* Get tick */
;;;1371     tickstart = HAL_GetTick();
;;;1372   
;;;1373       /* Wait until the shift is completed*/
;;;1374       while((hrtc->Instance->ISR & RTC_ISR_SHPF) != RESET)
;;;1375       {
;;;1376         if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
;;;1377         {  
;;;1378           /* Enable the write protection for RTC registers */
;;;1379           __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);  
;;;1380           
;;;1381           hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;1382           
;;;1383           /* Process Unlocked */ 
;;;1384           __HAL_UNLOCK(hrtc);
;;;1385           
;;;1386           return HAL_TIMEOUT;
;;;1387         }
;;;1388       }
;;;1389     
;;;1390       /* Check if the reference clock detection is disabled */
;;;1391       if((hrtc->Instance->CR & RTC_CR_REFCKON) == RESET)
;;;1392       {
;;;1393         /* Configure the Shift settings */
;;;1394         hrtc->Instance->SHIFTR = (uint32_t)(uint32_t)(ShiftSubFS) | (uint32_t)(ShiftAdd1S);
;;;1395         
;;;1396         /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
;;;1397         if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
;;;1398         {
;;;1399           if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
;;;1400           {
;;;1401             /* Enable the write protection for RTC registers */
;;;1402             __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);  
;;;1403             
;;;1404             hrtc->State = HAL_RTC_STATE_ERROR;
;;;1405             
;;;1406             /* Process Unlocked */ 
;;;1407             __HAL_UNLOCK(hrtc);
;;;1408             
;;;1409             return HAL_ERROR;
;;;1410           }
;;;1411         }
;;;1412       }
;;;1413       else
;;;1414       {
;;;1415         /* Enable the write protection for RTC registers */
;;;1416         __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1417         
;;;1418         /* Change RTC state */
;;;1419         hrtc->State = HAL_RTC_STATE_ERROR; 
;;;1420         
;;;1421         /* Process Unlocked */ 
;;;1422         __HAL_UNLOCK(hrtc);
;;;1423         
;;;1424         return HAL_ERROR;
;;;1425       }
;;;1426     
;;;1427     /* Enable the write protection for RTC registers */
;;;1428     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1429     
;;;1430     /* Change RTC state */
;;;1431     hrtc->State = HAL_RTC_STATE_READY; 
;;;1432     
;;;1433     /* Process Unlocked */ 
;;;1434     __HAL_UNLOCK(hrtc);
;;;1435     
;;;1436     return HAL_OK;
;;;1437   }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L23.26|
00001a  2001              MOVS     r0,#1                 ;1363
00001c  7720              STRB     r0,[r4,#0x1c]         ;1363
00001e  bf00              NOP                            ;1363
000020  2002              MOVS     r0,#2                 ;1365
000022  7760              STRB     r0,[r4,#0x1d]         ;1365
000024  bf00              NOP                            ;1368
000026  20ca              MOVS     r0,#0xca              ;1368
000028  6821              LDR      r1,[r4,#0]            ;1368
00002a  6248              STR      r0,[r1,#0x24]         ;1368
00002c  2053              MOVS     r0,#0x53              ;1368
00002e  6821              LDR      r1,[r4,#0]            ;1368
000030  6248              STR      r0,[r1,#0x24]         ;1368
000032  bf00              NOP                            ;1368
000034  f7fffffe          BL       HAL_GetTick
000038  4607              MOV      r7,r0                 ;1371
00003a  e012              B        |L23.98|
                  |L23.60|
00003c  f7fffffe          BL       HAL_GetTick
000040  1bc0              SUBS     r0,r0,r7              ;1376
000042  f5b07f7a          CMP      r0,#0x3e8             ;1376
000046  d90c              BLS      |L23.98|
000048  bf00              NOP                            ;1379
00004a  20ff              MOVS     r0,#0xff              ;1379
00004c  6821              LDR      r1,[r4,#0]            ;1379
00004e  6248              STR      r0,[r1,#0x24]         ;1379
000050  bf00              NOP                            ;1379
000052  2003              MOVS     r0,#3                 ;1381
000054  7760              STRB     r0,[r4,#0x1d]         ;1381
000056  bf00              NOP                            ;1384
000058  2000              MOVS     r0,#0                 ;1384
00005a  7720              STRB     r0,[r4,#0x1c]         ;1384
00005c  bf00              NOP                            ;1384
00005e  2003              MOVS     r0,#3                 ;1386
000060  e7d9              B        |L23.22|
                  |L23.98|
000062  6820              LDR      r0,[r4,#0]            ;1374
000064  68c0              LDR      r0,[r0,#0xc]          ;1374
000066  f0000008          AND      r0,r0,#8              ;1374
00006a  2800              CMP      r0,#0                 ;1374
00006c  d1e6              BNE      |L23.60|
00006e  6820              LDR      r0,[r4,#0]            ;1391
000070  6880              LDR      r0,[r0,#8]            ;1391
000072  f0000010          AND      r0,r0,#0x10           ;1391
000076  b9c8              CBNZ     r0,|L23.172|
000078  ea460005          ORR      r0,r6,r5              ;1394
00007c  6821              LDR      r1,[r4,#0]            ;1394
00007e  62c8              STR      r0,[r1,#0x2c]         ;1394
000080  6820              LDR      r0,[r4,#0]            ;1397
000082  6880              LDR      r0,[r0,#8]            ;1397
000084  f0000020          AND      r0,r0,#0x20           ;1397
000088  b9e8              CBNZ     r0,|L23.198|
00008a  4620              MOV      r0,r4                 ;1399
00008c  f7fffffe          BL       HAL_RTC_WaitForSynchro
000090  b1c8              CBZ      r0,|L23.198|
000092  bf00              NOP                            ;1402
000094  20ff              MOVS     r0,#0xff              ;1402
000096  6821              LDR      r1,[r4,#0]            ;1402
000098  6248              STR      r0,[r1,#0x24]         ;1402
00009a  bf00              NOP                            ;1402
00009c  2004              MOVS     r0,#4                 ;1404
00009e  7760              STRB     r0,[r4,#0x1d]         ;1404
0000a0  bf00              NOP                            ;1407
0000a2  2000              MOVS     r0,#0                 ;1407
0000a4  7720              STRB     r0,[r4,#0x1c]         ;1407
0000a6  bf00              NOP                            ;1407
0000a8  2001              MOVS     r0,#1                 ;1409
0000aa  e7b4              B        |L23.22|
                  |L23.172|
0000ac  bf00              NOP                            ;1416
0000ae  20ff              MOVS     r0,#0xff              ;1416
0000b0  6821              LDR      r1,[r4,#0]            ;1416
0000b2  6248              STR      r0,[r1,#0x24]         ;1416
0000b4  bf00              NOP                            ;1416
0000b6  2004              MOVS     r0,#4                 ;1419
0000b8  7760              STRB     r0,[r4,#0x1d]         ;1419
0000ba  bf00              NOP                            ;1422
0000bc  2000              MOVS     r0,#0                 ;1422
0000be  7720              STRB     r0,[r4,#0x1c]         ;1422
0000c0  bf00              NOP                            ;1422
0000c2  2001              MOVS     r0,#1                 ;1424
0000c4  e7a7              B        |L23.22|
                  |L23.198|
0000c6  bf00              NOP                            ;1428
0000c8  20ff              MOVS     r0,#0xff              ;1428
0000ca  6821              LDR      r1,[r4,#0]            ;1428
0000cc  6248              STR      r0,[r1,#0x24]         ;1428
0000ce  bf00              NOP                            ;1428
0000d0  2001              MOVS     r0,#1                 ;1431
0000d2  7760              STRB     r0,[r4,#0x1d]         ;1431
0000d4  bf00              NOP                            ;1434
0000d6  2000              MOVS     r0,#0                 ;1434
0000d8  7720              STRB     r0,[r4,#0x1c]         ;1434
0000da  bf00              NOP                            ;1434
0000dc  bf00              NOP                            ;1436
0000de  e79a              B        |L23.22|
;;;1438   
                          ENDP


                          AREA ||i.HAL_RTCEx_SetTamper||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_SetTamper PROC
;;;367      */
;;;368    HAL_StatusTypeDef HAL_RTCEx_SetTamper(RTC_HandleTypeDef *hrtc, RTC_TamperTypeDef* sTamper)
000000  b510              PUSH     {r4,lr}
;;;369    {
000002  4602              MOV      r2,r0
;;;370      uint32_t tmpreg = 0;
000004  2300              MOVS     r3,#0
;;;371      
;;;372      /* Check the parameters */
;;;373      assert_param(IS_RTC_TAMPER(sTamper->Tamper)); 
;;;374      assert_param(IS_RTC_TAMPER_PIN(sTamper->PinSelection));
;;;375      assert_param(IS_RTC_TAMPER_TRIGGER(sTamper->Trigger));
;;;376      assert_param(IS_RTC_TAMPER_FILTER(sTamper->Filter));
;;;377      assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(sTamper->SamplingFrequency));         
;;;378      assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(sTamper->PrechargeDuration));
;;;379      assert_param(IS_RTC_TAMPER_PULLUP_STATE(sTamper->TamperPullUp));
;;;380      assert_param(IS_RTC_TAMPER_TIMESTAMPONTAMPER_DETECTION(sTamper->TimeStampOnTamperDetection));
;;;381     
;;;382      /* Process Locked */ 
;;;383      __HAL_LOCK(hrtc);
000006  bf00              NOP      
000008  7f10              LDRB     r0,[r2,#0x1c]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L24.18|
00000e  2002              MOVS     r0,#2
                  |L24.16|
;;;384        
;;;385      hrtc->State = HAL_RTC_STATE_BUSY;
;;;386    
;;;387      if(sTamper->Trigger != RTC_TAMPERTRIGGER_RISINGEDGE)
;;;388      { 
;;;389        sTamper->Trigger = (uint32_t)(sTamper->Tamper << 1); 
;;;390      } 
;;;391            
;;;392      tmpreg = ((uint32_t)sTamper->Tamper | (uint32_t)sTamper->PinSelection | (uint32_t)sTamper->Trigger  |\
;;;393                (uint32_t)sTamper->Filter | (uint32_t)sTamper->SamplingFrequency | (uint32_t)sTamper->PrechargeDuration |\
;;;394                (uint32_t)sTamper->TamperPullUp | sTamper->TimeStampOnTamperDetection);
;;;395      
;;;396      hrtc->Instance->TAFCR &= (uint32_t)~((uint32_t)sTamper->Tamper | (uint32_t)(sTamper->Tamper << 1) | (uint32_t)RTC_TAFCR_TAMPTS |\
;;;397                                           (uint32_t)RTC_TAFCR_TAMPFREQ | (uint32_t)RTC_TAFCR_TAMPFLT | (uint32_t)RTC_TAFCR_TAMPPRCH |\
;;;398                                           (uint32_t)RTC_TAFCR_TAMPPUDIS | (uint32_t)RTC_TAFCR_TAMPINSEL | (uint32_t)RTC_TAFCR_TAMPIE);
;;;399    
;;;400      hrtc->Instance->TAFCR |= tmpreg;
;;;401      
;;;402      hrtc->State = HAL_RTC_STATE_READY; 
;;;403    
;;;404      /* Process Unlocked */ 
;;;405      __HAL_UNLOCK(hrtc);
;;;406        
;;;407      return HAL_OK;
;;;408    }
000010  bd10              POP      {r4,pc}
                  |L24.18|
000012  2001              MOVS     r0,#1                 ;383
000014  7710              STRB     r0,[r2,#0x1c]         ;383
000016  bf00              NOP                            ;383
000018  2002              MOVS     r0,#2                 ;385
00001a  7750              STRB     r0,[r2,#0x1d]         ;385
00001c  6888              LDR      r0,[r1,#8]            ;387
00001e  b110              CBZ      r0,|L24.38|
000020  6808              LDR      r0,[r1,#0]            ;389
000022  0040              LSLS     r0,r0,#1              ;389
000024  6088              STR      r0,[r1,#8]            ;389
                  |L24.38|
000026  e9d10400          LDRD     r0,r4,[r1,#0]         ;392
00002a  4320              ORRS     r0,r0,r4              ;392
00002c  688c              LDR      r4,[r1,#8]            ;392
00002e  4320              ORRS     r0,r0,r4              ;392
000030  68cc              LDR      r4,[r1,#0xc]          ;392
000032  4320              ORRS     r0,r0,r4              ;392
000034  690c              LDR      r4,[r1,#0x10]         ;392
000036  4320              ORRS     r0,r0,r4              ;392
000038  694c              LDR      r4,[r1,#0x14]         ;392
00003a  4320              ORRS     r0,r0,r4              ;392
00003c  698c              LDR      r4,[r1,#0x18]         ;392
00003e  4320              ORRS     r0,r0,r4              ;392
000040  69cc              LDR      r4,[r1,#0x1c]         ;392
000042  ea400304          ORR      r3,r0,r4              ;392
000046  6808              LDR      r0,[r1,#0]            ;396
000048  ea400040          ORR      r0,r0,r0,LSL #1       ;396
00004c  f44040ff          ORR      r0,r0,#0x7f80         ;396
000050  f44030c0          ORR      r0,r0,#0x18000        ;396
000054  f0400404          ORR      r4,r0,#4              ;396
000058  6810              LDR      r0,[r2,#0]            ;396
00005a  6c00              LDR      r0,[r0,#0x40]         ;396
00005c  43a0              BICS     r0,r0,r4              ;396
00005e  6814              LDR      r4,[r2,#0]            ;396
000060  6420              STR      r0,[r4,#0x40]         ;396
000062  6810              LDR      r0,[r2,#0]            ;400
000064  6c00              LDR      r0,[r0,#0x40]         ;400
000066  4318              ORRS     r0,r0,r3              ;400
000068  6814              LDR      r4,[r2,#0]            ;400
00006a  6420              STR      r0,[r4,#0x40]         ;400
00006c  2001              MOVS     r0,#1                 ;402
00006e  7750              STRB     r0,[r2,#0x1d]         ;402
000070  bf00              NOP                            ;405
000072  2000              MOVS     r0,#0                 ;405
000074  7710              STRB     r0,[r2,#0x1c]         ;405
000076  bf00              NOP                            ;405
000078  bf00              NOP                            ;407
00007a  e7c9              B        |L24.16|
;;;409    
                          ENDP


                          AREA ||i.HAL_RTCEx_SetTamper_IT||, CODE, READONLY, ALIGN=2

                  HAL_RTCEx_SetTamper_IT PROC
;;;417      */
;;;418    HAL_StatusTypeDef HAL_RTCEx_SetTamper_IT(RTC_HandleTypeDef *hrtc, RTC_TamperTypeDef* sTamper)
000000  b510              PUSH     {r4,lr}
;;;419    {
000002  4602              MOV      r2,r0
;;;420      uint32_t tmpreg = 0;
000004  2300              MOVS     r3,#0
;;;421      
;;;422      /* Check the parameters */
;;;423      assert_param(IS_RTC_TAMPER(sTamper->Tamper)); 
;;;424      assert_param(IS_RTC_TAMPER_PIN(sTamper->PinSelection));
;;;425      assert_param(IS_RTC_TAMPER_TRIGGER(sTamper->Trigger));
;;;426      assert_param(IS_RTC_TAMPER_FILTER(sTamper->Filter));
;;;427      assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(sTamper->SamplingFrequency));         
;;;428      assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(sTamper->PrechargeDuration));
;;;429      assert_param(IS_RTC_TAMPER_PULLUP_STATE(sTamper->TamperPullUp));
;;;430      assert_param(IS_RTC_TAMPER_TIMESTAMPONTAMPER_DETECTION(sTamper->TimeStampOnTamperDetection));
;;;431     
;;;432      /* Process Locked */ 
;;;433      __HAL_LOCK(hrtc);
000006  bf00              NOP      
000008  7f10              LDRB     r0,[r2,#0x1c]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L25.18|
00000e  2002              MOVS     r0,#2
                  |L25.16|
;;;434          
;;;435      hrtc->State = HAL_RTC_STATE_BUSY;
;;;436      
;;;437      /* Configure the tamper trigger */
;;;438      if(sTamper->Trigger != RTC_TAMPERTRIGGER_RISINGEDGE)
;;;439      { 
;;;440        sTamper->Trigger = (uint32_t)(sTamper->Tamper << 1); 
;;;441      } 
;;;442           
;;;443      tmpreg = ((uint32_t)sTamper->Tamper | (uint32_t)sTamper->PinSelection | (uint32_t)sTamper->Trigger  |\
;;;444                (uint32_t)sTamper->Filter | (uint32_t)sTamper->SamplingFrequency | (uint32_t)sTamper->PrechargeDuration |\
;;;445                (uint32_t)sTamper->TamperPullUp | sTamper->TimeStampOnTamperDetection);
;;;446      
;;;447      hrtc->Instance->TAFCR &= (uint32_t)~((uint32_t)sTamper->Tamper | (uint32_t)(sTamper->Tamper << 1) | (uint32_t)RTC_TAFCR_TAMPTS |\
;;;448                                           (uint32_t)RTC_TAFCR_TAMPFREQ | (uint32_t)RTC_TAFCR_TAMPFLT | (uint32_t)RTC_TAFCR_TAMPPRCH |\
;;;449                                           (uint32_t)RTC_TAFCR_TAMPPUDIS | (uint32_t)RTC_TAFCR_TAMPINSEL);
;;;450        
;;;451      hrtc->Instance->TAFCR |= tmpreg;
;;;452      
;;;453      /* Configure the Tamper Interrupt in the RTC_TAFCR */
;;;454      hrtc->Instance->TAFCR |= (uint32_t)RTC_TAFCR_TAMPIE;
;;;455      
;;;456      /* RTC Tamper Interrupt Configuration: EXTI configuration */
;;;457      __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_IT();
;;;458      
;;;459      EXTI->RTSR |= RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT;
;;;460      
;;;461      hrtc->State = HAL_RTC_STATE_READY;   
;;;462      
;;;463      /* Process Unlocked */ 
;;;464      __HAL_UNLOCK(hrtc);
;;;465      
;;;466      return HAL_OK;
;;;467    }
000010  bd10              POP      {r4,pc}
                  |L25.18|
000012  2001              MOVS     r0,#1                 ;433
000014  7710              STRB     r0,[r2,#0x1c]         ;433
000016  bf00              NOP                            ;433
000018  2002              MOVS     r0,#2                 ;435
00001a  7750              STRB     r0,[r2,#0x1d]         ;435
00001c  6888              LDR      r0,[r1,#8]            ;438
00001e  b110              CBZ      r0,|L25.38|
000020  6808              LDR      r0,[r1,#0]            ;440
000022  0040              LSLS     r0,r0,#1              ;440
000024  6088              STR      r0,[r1,#8]            ;440
                  |L25.38|
000026  e9d10400          LDRD     r0,r4,[r1,#0]         ;443
00002a  4320              ORRS     r0,r0,r4              ;443
00002c  688c              LDR      r4,[r1,#8]            ;443
00002e  4320              ORRS     r0,r0,r4              ;443
000030  68cc              LDR      r4,[r1,#0xc]          ;443
000032  4320              ORRS     r0,r0,r4              ;443
000034  690c              LDR      r4,[r1,#0x10]         ;443
000036  4320              ORRS     r0,r0,r4              ;443
000038  694c              LDR      r4,[r1,#0x14]         ;443
00003a  4320              ORRS     r0,r0,r4              ;443
00003c  698c              LDR      r4,[r1,#0x18]         ;443
00003e  4320              ORRS     r0,r0,r4              ;443
000040  69cc              LDR      r4,[r1,#0x1c]         ;443
000042  ea400304          ORR      r3,r0,r4              ;443
000046  6808              LDR      r0,[r1,#0]            ;447
000048  ea400040          ORR      r0,r0,r0,LSL #1       ;447
00004c  f44040ff          ORR      r0,r0,#0x7f80         ;447
000050  f44034c0          ORR      r4,r0,#0x18000        ;447
000054  6810              LDR      r0,[r2,#0]            ;447
000056  6c00              LDR      r0,[r0,#0x40]         ;447
000058  43a0              BICS     r0,r0,r4              ;447
00005a  6814              LDR      r4,[r2,#0]            ;447
00005c  6420              STR      r0,[r4,#0x40]         ;447
00005e  6810              LDR      r0,[r2,#0]            ;451
000060  6c00              LDR      r0,[r0,#0x40]         ;451
000062  4318              ORRS     r0,r0,r3              ;451
000064  6814              LDR      r4,[r2,#0]            ;451
000066  6420              STR      r0,[r4,#0x40]         ;451
000068  6810              LDR      r0,[r2,#0]            ;454
00006a  6c00              LDR      r0,[r0,#0x40]         ;454
00006c  f0400004          ORR      r0,r0,#4              ;454
000070  6814              LDR      r4,[r2,#0]            ;454
000072  6420              STR      r0,[r4,#0x40]         ;454
000074  480a              LDR      r0,|L25.160|
000076  6800              LDR      r0,[r0,#0]            ;457
000078  f4401000          ORR      r0,r0,#0x200000       ;457
00007c  4c08              LDR      r4,|L25.160|
00007e  6020              STR      r0,[r4,#0]            ;457
000080  4807              LDR      r0,|L25.160|
000082  3008              ADDS     r0,r0,#8              ;459
000084  6800              LDR      r0,[r0,#0]            ;459
000086  f4401000          ORR      r0,r0,#0x200000       ;459
00008a  4c05              LDR      r4,|L25.160|
00008c  3408              ADDS     r4,r4,#8              ;459
00008e  6020              STR      r0,[r4,#0]            ;459
000090  2001              MOVS     r0,#1                 ;461
000092  7750              STRB     r0,[r2,#0x1d]         ;461
000094  bf00              NOP                            ;464
000096  2000              MOVS     r0,#0                 ;464
000098  7710              STRB     r0,[r2,#0x1c]         ;464
00009a  bf00              NOP                            ;464
00009c  bf00              NOP                            ;466
00009e  e7b7              B        |L25.16|
;;;468    
                          ENDP

                  |L25.160|
                          DCD      0x40013c00

                          AREA ||i.HAL_RTCEx_SetTimeStamp||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_SetTimeStamp PROC
;;;157      */
;;;158    HAL_StatusTypeDef HAL_RTCEx_SetTimeStamp(RTC_HandleTypeDef *hrtc, uint32_t TimeStampEdge, uint32_t RTC_TimeStampPin)
000000  b530              PUSH     {r4,r5,lr}
;;;159    {
000002  4603              MOV      r3,r0
;;;160      uint32_t tmpreg = 0;
000004  2400              MOVS     r4,#0
;;;161      
;;;162      /* Check the parameters */
;;;163      assert_param(IS_TIMESTAMP_EDGE(TimeStampEdge));
;;;164      assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));
;;;165      
;;;166      /* Process Locked */ 
;;;167      __HAL_LOCK(hrtc);
000006  bf00              NOP      
000008  7f18              LDRB     r0,[r3,#0x1c]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L26.18|
00000e  2002              MOVS     r0,#2
                  |L26.16|
;;;168      
;;;169      hrtc->State = HAL_RTC_STATE_BUSY;
;;;170      
;;;171      /* Get the RTC_CR register and clear the bits to be configured */
;;;172      tmpreg = (uint32_t)(hrtc->Instance->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
;;;173        
;;;174      tmpreg|= TimeStampEdge;
;;;175      
;;;176      /* Disable the write protection for RTC registers */
;;;177      __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;178      
;;;179      hrtc->Instance->TAFCR &= (uint32_t)~RTC_TAFCR_TSINSEL;
;;;180      hrtc->Instance->TAFCR |= (uint32_t)(RTC_TimeStampPin); 
;;;181      
;;;182      /* Configure the Time Stamp TSEDGE and Enable bits */
;;;183      hrtc->Instance->CR = (uint32_t)tmpreg;
;;;184      
;;;185      __HAL_RTC_TIMESTAMP_ENABLE(hrtc);
;;;186      
;;;187      /* Enable the write protection for RTC registers */
;;;188      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);    
;;;189      
;;;190      /* Change RTC state */
;;;191      hrtc->State = HAL_RTC_STATE_READY; 
;;;192      
;;;193      /* Process Unlocked */ 
;;;194      __HAL_UNLOCK(hrtc);
;;;195      
;;;196      return HAL_OK;
;;;197    }
000010  bd30              POP      {r4,r5,pc}
                  |L26.18|
000012  2001              MOVS     r0,#1                 ;167
000014  7718              STRB     r0,[r3,#0x1c]         ;167
000016  bf00              NOP                            ;167
000018  2002              MOVS     r0,#2                 ;169
00001a  7758              STRB     r0,[r3,#0x1d]         ;169
00001c  6818              LDR      r0,[r3,#0]            ;172
00001e  6880              LDR      r0,[r0,#8]            ;172
000020  f6400508          MOV      r5,#0x808             ;172
000024  ea200405          BIC      r4,r0,r5              ;172
000028  430c              ORRS     r4,r4,r1              ;174
00002a  bf00              NOP                            ;177
00002c  20ca              MOVS     r0,#0xca              ;177
00002e  681d              LDR      r5,[r3,#0]            ;177
000030  6268              STR      r0,[r5,#0x24]         ;177
000032  2053              MOVS     r0,#0x53              ;177
000034  681d              LDR      r5,[r3,#0]            ;177
000036  6268              STR      r0,[r5,#0x24]         ;177
000038  bf00              NOP                            ;177
00003a  6818              LDR      r0,[r3,#0]            ;179
00003c  6c00              LDR      r0,[r0,#0x40]         ;179
00003e  f4203000          BIC      r0,r0,#0x20000        ;179
000042  681d              LDR      r5,[r3,#0]            ;179
000044  6428              STR      r0,[r5,#0x40]         ;179
000046  6818              LDR      r0,[r3,#0]            ;180
000048  6c00              LDR      r0,[r0,#0x40]         ;180
00004a  4310              ORRS     r0,r0,r2              ;180
00004c  681d              LDR      r5,[r3,#0]            ;180
00004e  6428              STR      r0,[r5,#0x40]         ;180
000050  6818              LDR      r0,[r3,#0]            ;183
000052  6084              STR      r4,[r0,#8]            ;183
000054  6818              LDR      r0,[r3,#0]            ;185
000056  6880              LDR      r0,[r0,#8]            ;185
000058  f4406000          ORR      r0,r0,#0x800          ;185
00005c  681d              LDR      r5,[r3,#0]            ;185
00005e  60a8              STR      r0,[r5,#8]            ;185
000060  bf00              NOP                            ;188
000062  20ff              MOVS     r0,#0xff              ;188
000064  681d              LDR      r5,[r3,#0]            ;188
000066  6268              STR      r0,[r5,#0x24]         ;188
000068  bf00              NOP                            ;188
00006a  2001              MOVS     r0,#1                 ;191
00006c  7758              STRB     r0,[r3,#0x1d]         ;191
00006e  bf00              NOP                            ;194
000070  2000              MOVS     r0,#0                 ;194
000072  7718              STRB     r0,[r3,#0x1c]         ;194
000074  bf00              NOP                            ;194
000076  bf00              NOP                            ;196
000078  e7ca              B        |L26.16|
;;;198    
                          ENDP


                          AREA ||i.HAL_RTCEx_SetTimeStamp_IT||, CODE, READONLY, ALIGN=2

                  HAL_RTCEx_SetTimeStamp_IT PROC
;;;217      */
;;;218    HAL_StatusTypeDef HAL_RTCEx_SetTimeStamp_IT(RTC_HandleTypeDef *hrtc, uint32_t TimeStampEdge, uint32_t RTC_TimeStampPin)
000000  b530              PUSH     {r4,r5,lr}
;;;219    {
000002  4603              MOV      r3,r0
;;;220      uint32_t tmpreg = 0;
000004  2400              MOVS     r4,#0
;;;221      
;;;222      /* Check the parameters */
;;;223      assert_param(IS_TIMESTAMP_EDGE(TimeStampEdge));
;;;224      assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));
;;;225      
;;;226      /* Process Locked */ 
;;;227      __HAL_LOCK(hrtc);
000006  bf00              NOP      
000008  7f18              LDRB     r0,[r3,#0x1c]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L27.18|
00000e  2002              MOVS     r0,#2
                  |L27.16|
;;;228      
;;;229      hrtc->State = HAL_RTC_STATE_BUSY;
;;;230      
;;;231      /* Get the RTC_CR register and clear the bits to be configured */
;;;232      tmpreg = (uint32_t)(hrtc->Instance->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
;;;233      
;;;234      tmpreg |= TimeStampEdge;
;;;235      
;;;236      /* Disable the write protection for RTC registers */
;;;237      __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;238      
;;;239      /* Configure the Time Stamp TSEDGE and Enable bits */
;;;240      hrtc->Instance->CR = (uint32_t)tmpreg;
;;;241      
;;;242      hrtc->Instance->TAFCR &= (uint32_t)~RTC_TAFCR_TSINSEL;
;;;243      hrtc->Instance->TAFCR |= (uint32_t)(RTC_TimeStampPin); 
;;;244      
;;;245      __HAL_RTC_TIMESTAMP_ENABLE(hrtc);
;;;246      
;;;247      /* Enable IT timestamp */ 
;;;248      __HAL_RTC_TIMESTAMP_ENABLE_IT(hrtc,RTC_IT_TS);
;;;249      
;;;250      /* RTC timestamp Interrupt Configuration: EXTI configuration */
;;;251      __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_IT();
;;;252      
;;;253      EXTI->RTSR |= RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT;
;;;254      
;;;255      /* Enable the write protection for RTC registers */
;;;256      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);  
;;;257      
;;;258      hrtc->State = HAL_RTC_STATE_READY;  
;;;259      
;;;260      /* Process Unlocked */ 
;;;261      __HAL_UNLOCK(hrtc);
;;;262      
;;;263      return HAL_OK;
;;;264    }
000010  bd30              POP      {r4,r5,pc}
                  |L27.18|
000012  2001              MOVS     r0,#1                 ;227
000014  7718              STRB     r0,[r3,#0x1c]         ;227
000016  bf00              NOP                            ;227
000018  2002              MOVS     r0,#2                 ;229
00001a  7758              STRB     r0,[r3,#0x1d]         ;229
00001c  6818              LDR      r0,[r3,#0]            ;232
00001e  6880              LDR      r0,[r0,#8]            ;232
000020  f6400508          MOV      r5,#0x808             ;232
000024  ea200405          BIC      r4,r0,r5              ;232
000028  430c              ORRS     r4,r4,r1              ;234
00002a  bf00              NOP                            ;237
00002c  20ca              MOVS     r0,#0xca              ;237
00002e  681d              LDR      r5,[r3,#0]            ;237
000030  6268              STR      r0,[r5,#0x24]         ;237
000032  2053              MOVS     r0,#0x53              ;237
000034  681d              LDR      r5,[r3,#0]            ;237
000036  6268              STR      r0,[r5,#0x24]         ;237
000038  bf00              NOP                            ;237
00003a  6818              LDR      r0,[r3,#0]            ;240
00003c  6084              STR      r4,[r0,#8]            ;240
00003e  6818              LDR      r0,[r3,#0]            ;242
000040  6c00              LDR      r0,[r0,#0x40]         ;242
000042  f4203000          BIC      r0,r0,#0x20000        ;242
000046  681d              LDR      r5,[r3,#0]            ;242
000048  6428              STR      r0,[r5,#0x40]         ;242
00004a  6818              LDR      r0,[r3,#0]            ;243
00004c  6c00              LDR      r0,[r0,#0x40]         ;243
00004e  4310              ORRS     r0,r0,r2              ;243
000050  681d              LDR      r5,[r3,#0]            ;243
000052  6428              STR      r0,[r5,#0x40]         ;243
000054  6818              LDR      r0,[r3,#0]            ;245
000056  6880              LDR      r0,[r0,#8]            ;245
000058  f4406000          ORR      r0,r0,#0x800          ;245
00005c  681d              LDR      r5,[r3,#0]            ;245
00005e  60a8              STR      r0,[r5,#8]            ;245
000060  6818              LDR      r0,[r3,#0]            ;248
000062  6880              LDR      r0,[r0,#8]            ;248
000064  f4404000          ORR      r0,r0,#0x8000         ;248
000068  681d              LDR      r5,[r3,#0]            ;248
00006a  60a8              STR      r0,[r5,#8]            ;248
00006c  480d              LDR      r0,|L27.164|
00006e  6800              LDR      r0,[r0,#0]            ;251
000070  f4401000          ORR      r0,r0,#0x200000       ;251
000074  4d0b              LDR      r5,|L27.164|
000076  6028              STR      r0,[r5,#0]            ;251
000078  480a              LDR      r0,|L27.164|
00007a  3008              ADDS     r0,r0,#8              ;253
00007c  6800              LDR      r0,[r0,#0]            ;253
00007e  f4401000          ORR      r0,r0,#0x200000       ;253
000082  4d08              LDR      r5,|L27.164|
000084  3508              ADDS     r5,r5,#8              ;253
000086  6028              STR      r0,[r5,#0]            ;253
000088  bf00              NOP                            ;256
00008a  20ff              MOVS     r0,#0xff              ;256
00008c  681d              LDR      r5,[r3,#0]            ;256
00008e  6268              STR      r0,[r5,#0x24]         ;256
000090  bf00              NOP                            ;256
000092  2001              MOVS     r0,#1                 ;258
000094  7758              STRB     r0,[r3,#0x1d]         ;258
000096  bf00              NOP                            ;261
000098  2000              MOVS     r0,#0                 ;261
00009a  7718              STRB     r0,[r3,#0x1c]         ;261
00009c  bf00              NOP                            ;261
00009e  bf00              NOP                            ;263
0000a0  e7b6              B        |L27.16|
;;;265    
                          ENDP

0000a2  0000              DCW      0x0000
                  |L27.164|
                          DCD      0x40013c00

                          AREA ||i.HAL_RTCEx_SetWakeUpTimer||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_SetWakeUpTimer PROC
;;;737      */
;;;738    HAL_StatusTypeDef HAL_RTCEx_SetWakeUpTimer(RTC_HandleTypeDef *hrtc, uint32_t WakeUpCounter, uint32_t WakeUpClock)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;739    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;740      uint32_t tickstart = 0;
00000a  2700              MOVS     r7,#0
;;;741    
;;;742      /* Check the parameters */
;;;743      assert_param(IS_RTC_WAKEUP_CLOCK(WakeUpClock));
;;;744      assert_param(IS_RTC_WAKEUP_COUNTER(WakeUpCounter));
;;;745     
;;;746      /* Process Locked */ 
;;;747      __HAL_LOCK(hrtc);
00000c  bf00              NOP      
00000e  7f20              LDRB     r0,[r4,#0x1c]
000010  2801              CMP      r0,#1
000012  d102              BNE      |L28.26|
000014  2002              MOVS     r0,#2
                  |L28.22|
;;;748        
;;;749      hrtc->State = HAL_RTC_STATE_BUSY;
;;;750      
;;;751      /* Disable the write protection for RTC registers */
;;;752      __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;753    
;;;754      /*Check RTC WUTWF flag is reset only when wake up timer enabled*/
;;;755      if((hrtc->Instance->CR & RTC_CR_WUTE) != RESET)
;;;756      {
;;;757        tickstart = HAL_GetTick();
;;;758    
;;;759        /* Wait till RTC WUTWF flag is reset and if Time out is reached exit */
;;;760        while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == SET)
;;;761        {
;;;762          if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
;;;763          {
;;;764            /* Enable the write protection for RTC registers */
;;;765            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;766            
;;;767            hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;768    
;;;769            /* Process Unlocked */ 
;;;770            __HAL_UNLOCK(hrtc);
;;;771    
;;;772            return HAL_TIMEOUT;
;;;773          }
;;;774        }
;;;775      }
;;;776    
;;;777      __HAL_RTC_WAKEUPTIMER_DISABLE(hrtc);
;;;778    
;;;779      tickstart = HAL_GetTick();
;;;780    
;;;781      /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
;;;782      while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == RESET)
;;;783      {
;;;784        if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
;;;785        {
;;;786          /* Enable the write protection for RTC registers */
;;;787          __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;788    
;;;789          hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;790    
;;;791          /* Process Unlocked */ 
;;;792          __HAL_UNLOCK(hrtc);
;;;793    
;;;794          return HAL_TIMEOUT;
;;;795        }
;;;796      }
;;;797      
;;;798      /* Clear the Wake-up Timer clock source bits in CR register */
;;;799      hrtc->Instance->CR &= (uint32_t)~RTC_CR_WUCKSEL;
;;;800      
;;;801      /* Configure the clock source */
;;;802      hrtc->Instance->CR |= (uint32_t)WakeUpClock;
;;;803      
;;;804      /* Configure the Wake-up Timer counter */
;;;805      hrtc->Instance->WUTR = (uint32_t)WakeUpCounter;
;;;806      
;;;807       /* Enable the Wake-up Timer */
;;;808      __HAL_RTC_WAKEUPTIMER_ENABLE(hrtc);   
;;;809      
;;;810      /* Enable the write protection for RTC registers */
;;;811      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); 
;;;812      
;;;813      hrtc->State = HAL_RTC_STATE_READY;   
;;;814      
;;;815      /* Process Unlocked */ 
;;;816      __HAL_UNLOCK(hrtc);
;;;817      
;;;818      return HAL_OK;
;;;819    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L28.26|
00001a  2001              MOVS     r0,#1                 ;747
00001c  7720              STRB     r0,[r4,#0x1c]         ;747
00001e  bf00              NOP                            ;747
000020  2002              MOVS     r0,#2                 ;749
000022  7760              STRB     r0,[r4,#0x1d]         ;749
000024  bf00              NOP                            ;752
000026  20ca              MOVS     r0,#0xca              ;752
000028  6821              LDR      r1,[r4,#0]            ;752
00002a  6248              STR      r0,[r1,#0x24]         ;752
00002c  2053              MOVS     r0,#0x53              ;752
00002e  6821              LDR      r1,[r4,#0]            ;752
000030  6248              STR      r0,[r1,#0x24]         ;752
000032  bf00              NOP                            ;752
000034  6820              LDR      r0,[r4,#0]            ;755
000036  6880              LDR      r0,[r0,#8]            ;755
000038  f4006080          AND      r0,r0,#0x400          ;755
00003c  b1e0              CBZ      r0,|L28.120|
00003e  f7fffffe          BL       HAL_GetTick
000042  4607              MOV      r7,r0                 ;757
000044  e012              B        |L28.108|
                  |L28.70|
000046  f7fffffe          BL       HAL_GetTick
00004a  1bc0              SUBS     r0,r0,r7              ;762
00004c  f5b07f7a          CMP      r0,#0x3e8             ;762
000050  d90c              BLS      |L28.108|
000052  bf00              NOP                            ;765
000054  20ff              MOVS     r0,#0xff              ;765
000056  6821              LDR      r1,[r4,#0]            ;765
000058  6248              STR      r0,[r1,#0x24]         ;765
00005a  bf00              NOP                            ;765
00005c  2003              MOVS     r0,#3                 ;767
00005e  7760              STRB     r0,[r4,#0x1d]         ;767
000060  bf00              NOP                            ;770
000062  2000              MOVS     r0,#0                 ;770
000064  7720              STRB     r0,[r4,#0x1c]         ;770
000066  bf00              NOP                            ;770
000068  2003              MOVS     r0,#3                 ;772
00006a  e7d4              B        |L28.22|
                  |L28.108|
00006c  6820              LDR      r0,[r4,#0]            ;760
00006e  68c0              LDR      r0,[r0,#0xc]          ;760
000070  f3c00080          UBFX     r0,r0,#2,#1           ;760
000074  2800              CMP      r0,#0                 ;760
000076  d1e6              BNE      |L28.70|
                  |L28.120|
000078  6820              LDR      r0,[r4,#0]            ;777
00007a  6880              LDR      r0,[r0,#8]            ;777
00007c  f4206080          BIC      r0,r0,#0x400          ;777
000080  6821              LDR      r1,[r4,#0]            ;777
000082  6088              STR      r0,[r1,#8]            ;777
000084  f7fffffe          BL       HAL_GetTick
000088  4607              MOV      r7,r0                 ;779
00008a  e012              B        |L28.178|
                  |L28.140|
00008c  f7fffffe          BL       HAL_GetTick
000090  1bc0              SUBS     r0,r0,r7              ;784
000092  f5b07f7a          CMP      r0,#0x3e8             ;784
000096  d90c              BLS      |L28.178|
000098  bf00              NOP                            ;787
00009a  20ff              MOVS     r0,#0xff              ;787
00009c  6821              LDR      r1,[r4,#0]            ;787
00009e  6248              STR      r0,[r1,#0x24]         ;787
0000a0  bf00              NOP                            ;787
0000a2  2003              MOVS     r0,#3                 ;789
0000a4  7760              STRB     r0,[r4,#0x1d]         ;789
0000a6  bf00              NOP                            ;792
0000a8  2000              MOVS     r0,#0                 ;792
0000aa  7720              STRB     r0,[r4,#0x1c]         ;792
0000ac  bf00              NOP                            ;792
0000ae  2003              MOVS     r0,#3                 ;794
0000b0  e7b1              B        |L28.22|
                  |L28.178|
0000b2  6820              LDR      r0,[r4,#0]            ;782
0000b4  68c0              LDR      r0,[r0,#0xc]          ;782
0000b6  f3c00080          UBFX     r0,r0,#2,#1           ;782
0000ba  2800              CMP      r0,#0                 ;782
0000bc  d0e6              BEQ      |L28.140|
0000be  6820              LDR      r0,[r4,#0]            ;799
0000c0  6880              LDR      r0,[r0,#8]            ;799
0000c2  f0200007          BIC      r0,r0,#7              ;799
0000c6  6821              LDR      r1,[r4,#0]            ;799
0000c8  6088              STR      r0,[r1,#8]            ;799
0000ca  6820              LDR      r0,[r4,#0]            ;802
0000cc  6880              LDR      r0,[r0,#8]            ;802
0000ce  4330              ORRS     r0,r0,r6              ;802
0000d0  6821              LDR      r1,[r4,#0]            ;802
0000d2  6088              STR      r0,[r1,#8]            ;802
0000d4  6820              LDR      r0,[r4,#0]            ;805
0000d6  6145              STR      r5,[r0,#0x14]         ;805
0000d8  6820              LDR      r0,[r4,#0]            ;808
0000da  6880              LDR      r0,[r0,#8]            ;808
0000dc  f4406080          ORR      r0,r0,#0x400          ;808
0000e0  6821              LDR      r1,[r4,#0]            ;808
0000e2  6088              STR      r0,[r1,#8]            ;808
0000e4  bf00              NOP                            ;811
0000e6  20ff              MOVS     r0,#0xff              ;811
0000e8  6821              LDR      r1,[r4,#0]            ;811
0000ea  6248              STR      r0,[r1,#0x24]         ;811
0000ec  bf00              NOP                            ;811
0000ee  2001              MOVS     r0,#1                 ;813
0000f0  7760              STRB     r0,[r4,#0x1d]         ;813
0000f2  bf00              NOP                            ;816
0000f4  2000              MOVS     r0,#0                 ;816
0000f6  7720              STRB     r0,[r4,#0x1c]         ;816
0000f8  bf00              NOP                            ;816
0000fa  bf00              NOP                            ;818
0000fc  e78b              B        |L28.22|
;;;820    
                          ENDP


                          AREA ||i.HAL_RTCEx_SetWakeUpTimer_IT||, CODE, READONLY, ALIGN=2

                  HAL_RTCEx_SetWakeUpTimer_IT PROC
;;;828      */
;;;829    HAL_StatusTypeDef HAL_RTCEx_SetWakeUpTimer_IT(RTC_HandleTypeDef *hrtc, uint32_t WakeUpCounter, uint32_t WakeUpClock)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;830    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;831      uint32_t tickstart = 0;
00000a  2700              MOVS     r7,#0
;;;832      
;;;833      /* Check the parameters */
;;;834      assert_param(IS_RTC_WAKEUP_CLOCK(WakeUpClock));
;;;835      assert_param(IS_RTC_WAKEUP_COUNTER(WakeUpCounter));
;;;836      
;;;837      /* Process Locked */ 
;;;838      __HAL_LOCK(hrtc);
00000c  bf00              NOP      
00000e  7f20              LDRB     r0,[r4,#0x1c]
000010  2801              CMP      r0,#1
000012  d102              BNE      |L29.26|
000014  2002              MOVS     r0,#2
                  |L29.22|
;;;839      
;;;840      hrtc->State = HAL_RTC_STATE_BUSY;
;;;841      
;;;842      /* Disable the write protection for RTC registers */
;;;843      __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;844    
;;;845      /*Check RTC WUTWF flag is reset only when wake up timer enabled*/
;;;846      if((hrtc->Instance->CR & RTC_CR_WUTE) != RESET)
;;;847      {
;;;848        tickstart = HAL_GetTick();
;;;849     
;;;850        /* Wait till RTC WUTWF flag is reset and if Time out is reached exit */
;;;851        while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == SET)
;;;852        {
;;;853          if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
;;;854          {
;;;855           /* Enable the write protection for RTC registers */
;;;856           __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;857    
;;;858           hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;859    
;;;860           /* Process Unlocked */ 
;;;861           __HAL_UNLOCK(hrtc);
;;;862    
;;;863           return HAL_TIMEOUT;
;;;864          }
;;;865        }
;;;866      }
;;;867    
;;;868      __HAL_RTC_WAKEUPTIMER_DISABLE(hrtc);
;;;869    
;;;870      tickstart = HAL_GetTick();
;;;871    
;;;872      /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
;;;873      while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == RESET)
;;;874      {
;;;875        if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
;;;876        {
;;;877          /* Enable the write protection for RTC registers */
;;;878          __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;879    
;;;880          hrtc->State = HAL_RTC_STATE_TIMEOUT; 
;;;881    
;;;882          /* Process Unlocked */ 
;;;883          __HAL_UNLOCK(hrtc);
;;;884    
;;;885          return HAL_TIMEOUT;
;;;886        }
;;;887      }
;;;888      
;;;889      /* Configure the Wake-up Timer counter */
;;;890      hrtc->Instance->WUTR = (uint32_t)WakeUpCounter;
;;;891    
;;;892      /* Clear the Wake-up Timer clock source bits in CR register */
;;;893      hrtc->Instance->CR &= (uint32_t)~RTC_CR_WUCKSEL;
;;;894    
;;;895      /* Configure the clock source */
;;;896      hrtc->Instance->CR |= (uint32_t)WakeUpClock;
;;;897      
;;;898      /* RTC WakeUpTimer Interrupt Configuration: EXTI configuration */
;;;899      __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_IT();
;;;900      
;;;901      EXTI->RTSR |= RTC_EXTI_LINE_WAKEUPTIMER_EVENT;
;;;902      
;;;903      /* Configure the Interrupt in the RTC_CR register */
;;;904      __HAL_RTC_WAKEUPTIMER_ENABLE_IT(hrtc,RTC_IT_WUT);
;;;905      
;;;906      /* Enable the Wake-up Timer */
;;;907      __HAL_RTC_WAKEUPTIMER_ENABLE(hrtc);
;;;908        
;;;909      /* Enable the write protection for RTC registers */
;;;910      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); 
;;;911      
;;;912      hrtc->State = HAL_RTC_STATE_READY;   
;;;913      
;;;914      /* Process Unlocked */ 
;;;915      __HAL_UNLOCK(hrtc);
;;;916     
;;;917      return HAL_OK;
;;;918    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L29.26|
00001a  2001              MOVS     r0,#1                 ;838
00001c  7720              STRB     r0,[r4,#0x1c]         ;838
00001e  bf00              NOP                            ;838
000020  2002              MOVS     r0,#2                 ;840
000022  7760              STRB     r0,[r4,#0x1d]         ;840
000024  bf00              NOP                            ;843
000026  20ca              MOVS     r0,#0xca              ;843
000028  6821              LDR      r1,[r4,#0]            ;843
00002a  6248              STR      r0,[r1,#0x24]         ;843
00002c  2053              MOVS     r0,#0x53              ;843
00002e  6821              LDR      r1,[r4,#0]            ;843
000030  6248              STR      r0,[r1,#0x24]         ;843
000032  bf00              NOP                            ;843
000034  6820              LDR      r0,[r4,#0]            ;846
000036  6880              LDR      r0,[r0,#8]            ;846
000038  f4006080          AND      r0,r0,#0x400          ;846
00003c  b1e0              CBZ      r0,|L29.120|
00003e  f7fffffe          BL       HAL_GetTick
000042  4607              MOV      r7,r0                 ;848
000044  e012              B        |L29.108|
                  |L29.70|
000046  f7fffffe          BL       HAL_GetTick
00004a  1bc0              SUBS     r0,r0,r7              ;853
00004c  f5b07f7a          CMP      r0,#0x3e8             ;853
000050  d90c              BLS      |L29.108|
000052  bf00              NOP                            ;856
000054  20ff              MOVS     r0,#0xff              ;856
000056  6821              LDR      r1,[r4,#0]            ;856
000058  6248              STR      r0,[r1,#0x24]         ;856
00005a  bf00              NOP                            ;856
00005c  2003              MOVS     r0,#3                 ;858
00005e  7760              STRB     r0,[r4,#0x1d]         ;858
000060  bf00              NOP                            ;861
000062  2000              MOVS     r0,#0                 ;861
000064  7720              STRB     r0,[r4,#0x1c]         ;861
000066  bf00              NOP                            ;861
000068  2003              MOVS     r0,#3                 ;863
00006a  e7d4              B        |L29.22|
                  |L29.108|
00006c  6820              LDR      r0,[r4,#0]            ;851
00006e  68c0              LDR      r0,[r0,#0xc]          ;851
000070  f3c00080          UBFX     r0,r0,#2,#1           ;851
000074  2800              CMP      r0,#0                 ;851
000076  d1e6              BNE      |L29.70|
                  |L29.120|
000078  6820              LDR      r0,[r4,#0]            ;868
00007a  6880              LDR      r0,[r0,#8]            ;868
00007c  f4206080          BIC      r0,r0,#0x400          ;868
000080  6821              LDR      r1,[r4,#0]            ;868
000082  6088              STR      r0,[r1,#8]            ;868
000084  f7fffffe          BL       HAL_GetTick
000088  4607              MOV      r7,r0                 ;870
00008a  e012              B        |L29.178|
                  |L29.140|
00008c  f7fffffe          BL       HAL_GetTick
000090  1bc0              SUBS     r0,r0,r7              ;875
000092  f5b07f7a          CMP      r0,#0x3e8             ;875
000096  d90c              BLS      |L29.178|
000098  bf00              NOP                            ;878
00009a  20ff              MOVS     r0,#0xff              ;878
00009c  6821              LDR      r1,[r4,#0]            ;878
00009e  6248              STR      r0,[r1,#0x24]         ;878
0000a0  bf00              NOP                            ;878
0000a2  2003              MOVS     r0,#3                 ;880
0000a4  7760              STRB     r0,[r4,#0x1d]         ;880
0000a6  bf00              NOP                            ;883
0000a8  2000              MOVS     r0,#0                 ;883
0000aa  7720              STRB     r0,[r4,#0x1c]         ;883
0000ac  bf00              NOP                            ;883
0000ae  2003              MOVS     r0,#3                 ;885
0000b0  e7b1              B        |L29.22|
                  |L29.178|
0000b2  6820              LDR      r0,[r4,#0]            ;873
0000b4  68c0              LDR      r0,[r0,#0xc]          ;873
0000b6  f3c00080          UBFX     r0,r0,#2,#1           ;873
0000ba  2800              CMP      r0,#0                 ;873
0000bc  d0e6              BEQ      |L29.140|
0000be  6820              LDR      r0,[r4,#0]            ;890
0000c0  6145              STR      r5,[r0,#0x14]         ;890
0000c2  6820              LDR      r0,[r4,#0]            ;893
0000c4  6880              LDR      r0,[r0,#8]            ;893
0000c6  f0200007          BIC      r0,r0,#7              ;893
0000ca  6821              LDR      r1,[r4,#0]            ;893
0000cc  6088              STR      r0,[r1,#8]            ;893
0000ce  6820              LDR      r0,[r4,#0]            ;896
0000d0  6880              LDR      r0,[r0,#8]            ;896
0000d2  4330              ORRS     r0,r0,r6              ;896
0000d4  6821              LDR      r1,[r4,#0]            ;896
0000d6  6088              STR      r0,[r1,#8]            ;896
0000d8  4813              LDR      r0,|L29.296|
0000da  6800              LDR      r0,[r0,#0]            ;899
0000dc  f4400080          ORR      r0,r0,#0x400000       ;899
0000e0  4911              LDR      r1,|L29.296|
0000e2  6008              STR      r0,[r1,#0]            ;899
0000e4  4810              LDR      r0,|L29.296|
0000e6  3008              ADDS     r0,r0,#8              ;901
0000e8  6800              LDR      r0,[r0,#0]            ;901
0000ea  f4400080          ORR      r0,r0,#0x400000       ;901
0000ee  490e              LDR      r1,|L29.296|
0000f0  3108              ADDS     r1,r1,#8              ;901
0000f2  6008              STR      r0,[r1,#0]            ;901
0000f4  6820              LDR      r0,[r4,#0]            ;904
0000f6  6880              LDR      r0,[r0,#8]            ;904
0000f8  f4404080          ORR      r0,r0,#0x4000         ;904
0000fc  6821              LDR      r1,[r4,#0]            ;904
0000fe  6088              STR      r0,[r1,#8]            ;904
000100  6820              LDR      r0,[r4,#0]            ;907
000102  6880              LDR      r0,[r0,#8]            ;907
000104  f4406080          ORR      r0,r0,#0x400          ;907
000108  6821              LDR      r1,[r4,#0]            ;907
00010a  6088              STR      r0,[r1,#8]            ;907
00010c  bf00              NOP                            ;910
00010e  20ff              MOVS     r0,#0xff              ;910
000110  6821              LDR      r1,[r4,#0]            ;910
000112  6248              STR      r0,[r1,#0x24]         ;910
000114  bf00              NOP                            ;910
000116  2001              MOVS     r0,#1                 ;912
000118  7760              STRB     r0,[r4,#0x1d]         ;912
00011a  bf00              NOP                            ;915
00011c  2000              MOVS     r0,#0                 ;915
00011e  7720              STRB     r0,[r4,#0x1c]         ;915
000120  bf00              NOP                            ;915
000122  bf00              NOP                            ;917
000124  e777              B        |L29.22|
;;;919    
                          ENDP

000126  0000              DCW      0x0000
                  |L29.296|
                          DCD      0x40013c00

                          AREA ||i.HAL_RTCEx_Tamper1EventCallback||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_Tamper1EventCallback PROC
;;;572      */
;;;573    __weak void HAL_RTCEx_Tamper1EventCallback(RTC_HandleTypeDef *hrtc)
000000  4770              BX       lr
;;;574    {
;;;575      /* Prevent unused argument(s) compilation warning */
;;;576      UNUSED(hrtc);
;;;577      /* NOTE : This function Should not be modified, when the callback is needed,
;;;578                the HAL_RTC_Tamper1EventCallback could be implemented in the user file
;;;579       */
;;;580    }
;;;581    
                          ENDP


                          AREA ||i.HAL_RTCEx_Tamper2EventCallback||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_Tamper2EventCallback PROC
;;;587      */
;;;588    __weak void HAL_RTCEx_Tamper2EventCallback(RTC_HandleTypeDef *hrtc)
000000  4770              BX       lr
;;;589    {
;;;590      /* Prevent unused argument(s) compilation warning */
;;;591      UNUSED(hrtc);
;;;592      /* NOTE : This function Should not be modified, when the callback is needed,
;;;593                the HAL_RTC_Tamper2EventCallback could be implemented in the user file
;;;594       */
;;;595    }
;;;596    
                          ENDP


                          AREA ||i.HAL_RTCEx_TamperTimeStampIRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_RTCEx_TamperTimeStampIRQHandler PROC
;;;502      */
;;;503    void HAL_RTCEx_TamperTimeStampIRQHandler(RTC_HandleTypeDef *hrtc)
000000  b510              PUSH     {r4,lr}
;;;504    {  
000002  4604              MOV      r4,r0
;;;505      if(__HAL_RTC_TIMESTAMP_GET_IT(hrtc, RTC_IT_TS))
000004  6820              LDR      r0,[r4,#0]
000006  68c0              LDR      r0,[r0,#0xc]
000008  f3c020c0          UBFX     r0,r0,#11,#1
00000c  b178              CBZ      r0,|L32.46|
;;;506      {
;;;507        /* Get the status of the Interrupt */
;;;508        if((uint32_t)(hrtc->Instance->CR & RTC_IT_TS) != (uint32_t)RESET)
00000e  6820              LDR      r0,[r4,#0]
000010  6880              LDR      r0,[r0,#8]
000012  f4004000          AND      r0,r0,#0x8000
000016  b150              CBZ      r0,|L32.46|
;;;509        {
;;;510          /* TIMESTAMP callback */ 
;;;511          HAL_RTCEx_TimeStampEventCallback(hrtc);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       HAL_RTCEx_TimeStampEventCallback
;;;512      
;;;513          /* Clear the TIMESTAMP interrupt pending bit */
;;;514          __HAL_RTC_TIMESTAMP_CLEAR_FLAG(hrtc,RTC_FLAG_TSF);
00001e  6820              LDR      r0,[r4,#0]
000020  68c0              LDR      r0,[r0,#0xc]
000022  f0000080          AND      r0,r0,#0x80
000026  f4606008          ORN      r0,r0,#0x880
00002a  6821              LDR      r1,[r4,#0]
00002c  60c8              STR      r0,[r1,#0xc]
                  |L32.46|
;;;515        }
;;;516      }
;;;517      
;;;518      /* Get the status of the Interrupt */
;;;519      if(__HAL_RTC_TAMPER_GET_IT(hrtc,RTC_IT_TAMP1))
00002e  6820              LDR      r0,[r4,#0]
000030  68c0              LDR      r0,[r0,#0xc]
000032  f3c03040          UBFX     r0,r0,#13,#1
000036  b178              CBZ      r0,|L32.88|
;;;520      {
;;;521        /* Get the TAMPER Interrupt enable bit and pending bit */
;;;522        if(((hrtc->Instance->TAFCR & (RTC_TAFCR_TAMPIE))) != (uint32_t)RESET) 
000038  6820              LDR      r0,[r4,#0]
00003a  6c00              LDR      r0,[r0,#0x40]
00003c  f0000004          AND      r0,r0,#4
000040  b150              CBZ      r0,|L32.88|
;;;523        {
;;;524          /* Tamper callback */ 
;;;525          HAL_RTCEx_Tamper1EventCallback(hrtc);
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       HAL_RTCEx_Tamper1EventCallback
;;;526      
;;;527          /* Clear the Tamper interrupt pending bit */
;;;528          __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc,RTC_FLAG_TAMP1F);
000048  6820              LDR      r0,[r4,#0]
00004a  68c0              LDR      r0,[r0,#0xc]
00004c  f0000080          AND      r0,r0,#0x80
000050  f4605002          ORN      r0,r0,#0x2080
000054  6821              LDR      r1,[r4,#0]
000056  60c8              STR      r0,[r1,#0xc]
                  |L32.88|
;;;529        }
;;;530      }
;;;531      
;;;532      /* Get the status of the Interrupt */
;;;533      if(__HAL_RTC_TAMPER_GET_IT(hrtc, RTC_IT_TAMP2))
000058  6820              LDR      r0,[r4,#0]
00005a  68c0              LDR      r0,[r0,#0xc]
00005c  f3c03080          UBFX     r0,r0,#14,#1
000060  b178              CBZ      r0,|L32.130|
;;;534      {
;;;535        /* Get the TAMPER Interrupt enable bit and pending bit */
;;;536        if(((hrtc->Instance->TAFCR & RTC_TAFCR_TAMPIE)) != (uint32_t)RESET) 
000062  6820              LDR      r0,[r4,#0]
000064  6c00              LDR      r0,[r0,#0x40]
000066  f0000004          AND      r0,r0,#4
00006a  b150              CBZ      r0,|L32.130|
;;;537        {
;;;538          /* Tamper callback */ 
;;;539          HAL_RTCEx_Tamper2EventCallback(hrtc);
00006c  4620              MOV      r0,r4
00006e  f7fffffe          BL       HAL_RTCEx_Tamper2EventCallback
;;;540      
;;;541          /* Clear the Tamper interrupt pending bit */
;;;542          __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP2F);
000072  6820              LDR      r0,[r4,#0]
000074  68c0              LDR      r0,[r0,#0xc]
000076  f0000080          AND      r0,r0,#0x80
00007a  f4604081          ORN      r0,r0,#0x4080
00007e  6821              LDR      r1,[r4,#0]
000080  60c8              STR      r0,[r1,#0xc]
                  |L32.130|
;;;543        }
;;;544      }
;;;545      /* Clear the EXTI's Flag for RTC TimeStamp and Tamper */
;;;546      __HAL_RTC_TAMPER_TIMESTAMP_EXTI_CLEAR_FLAG();
000082  f44f1000          MOV      r0,#0x200000
000086  4902              LDR      r1,|L32.144|
000088  6008              STR      r0,[r1,#0]
;;;547      
;;;548      /* Change RTC state */
;;;549      hrtc->State = HAL_RTC_STATE_READY; 
00008a  2001              MOVS     r0,#1
00008c  7760              STRB     r0,[r4,#0x1d]
;;;550    }
00008e  bd10              POP      {r4,pc}
;;;551    
                          ENDP

                  |L32.144|
                          DCD      0x40013c14

                          AREA ||i.HAL_RTCEx_TimeStampEventCallback||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_TimeStampEventCallback PROC
;;;557      */
;;;558    __weak void HAL_RTCEx_TimeStampEventCallback(RTC_HandleTypeDef *hrtc)
000000  4770              BX       lr
;;;559    {
;;;560      /* Prevent unused argument(s) compilation warning */
;;;561      UNUSED(hrtc);
;;;562      /* NOTE : This function Should not be modified, when the callback is needed,
;;;563                the HAL_RTC_TimeStampEventCallback could be implemented in the user file
;;;564      */
;;;565    }
;;;566    
                          ENDP


                          AREA ||i.HAL_RTCEx_WakeUpTimerEventCallback||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_WakeUpTimerEventCallback PROC
;;;1020     */
;;;1021   __weak void HAL_RTCEx_WakeUpTimerEventCallback(RTC_HandleTypeDef *hrtc)
000000  4770              BX       lr
;;;1022   {
;;;1023     /* Prevent unused argument(s) compilation warning */
;;;1024     UNUSED(hrtc);
;;;1025     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1026               the HAL_RTC_WakeUpTimerEventCallback could be implemented in the user file
;;;1027      */
;;;1028   }
;;;1029   
                          ENDP


                          AREA ||i.HAL_RTCEx_WakeUpTimerIRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_RTCEx_WakeUpTimerIRQHandler PROC
;;;992      */
;;;993    void HAL_RTCEx_WakeUpTimerIRQHandler(RTC_HandleTypeDef *hrtc)
000000  b510              PUSH     {r4,lr}
;;;994    {  
000002  4604              MOV      r4,r0
;;;995      if(__HAL_RTC_WAKEUPTIMER_GET_IT(hrtc, RTC_IT_WUT))
000004  6820              LDR      r0,[r4,#0]
000006  68c0              LDR      r0,[r0,#0xc]
000008  f3c02080          UBFX     r0,r0,#10,#1
00000c  b178              CBZ      r0,|L35.46|
;;;996      {
;;;997        /* Get the status of the Interrupt */
;;;998        if((uint32_t)(hrtc->Instance->CR & RTC_IT_WUT) != (uint32_t)RESET)
00000e  6820              LDR      r0,[r4,#0]
000010  6880              LDR      r0,[r0,#8]
000012  f4004080          AND      r0,r0,#0x4000
000016  b150              CBZ      r0,|L35.46|
;;;999        {
;;;1000         /* WAKEUPTIMER callback */ 
;;;1001         HAL_RTCEx_WakeUpTimerEventCallback(hrtc);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       HAL_RTCEx_WakeUpTimerEventCallback
;;;1002         
;;;1003         /* Clear the WAKEUPTIMER interrupt pending bit */
;;;1004         __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(hrtc, RTC_FLAG_WUTF);
00001e  6820              LDR      r0,[r4,#0]
000020  68c0              LDR      r0,[r0,#0xc]
000022  f0000080          AND      r0,r0,#0x80
000026  f4606090          ORN      r0,r0,#0x480
00002a  6821              LDR      r1,[r4,#0]
00002c  60c8              STR      r0,[r1,#0xc]
                  |L35.46|
;;;1005       }
;;;1006     }
;;;1007     
;;;1008     /* Clear the EXTI's line Flag for RTC WakeUpTimer */
;;;1009     __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG();
00002e  f44f0080          MOV      r0,#0x400000
000032  4902              LDR      r1,|L35.60|
000034  6008              STR      r0,[r1,#0]
;;;1010   
;;;1011     /* Change RTC state */
;;;1012     hrtc->State = HAL_RTC_STATE_READY; 
000036  2001              MOVS     r0,#1
000038  7760              STRB     r0,[r4,#0x1d]
;;;1013   }
00003a  bd10              POP      {r4,pc}
;;;1014   
                          ENDP

                  |L35.60|
                          DCD      0x40013c14

;*** Start embedded assembler ***

#line 1 "HALLIB\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_rtc_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f4xx_hal_rtc_ex_c_7fcc3a7e____REV16|
#line 388 ".\\CORE\\cmsis_armcc.h"
|__asm___22_stm32f4xx_hal_rtc_ex_c_7fcc3a7e____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f4xx_hal_rtc_ex_c_7fcc3a7e____REVSH|
#line 402
|__asm___22_stm32f4xx_hal_rtc_ex_c_7fcc3a7e____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f4xx_hal_rtc_ex_c_7fcc3a7e____RRX|
#line 587
|__asm___22_stm32f4xx_hal_rtc_ex_c_7fcc3a7e____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
