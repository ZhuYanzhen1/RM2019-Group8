; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\stm32f4xx_hal_uart.o --asm_dir=.\OBJ\ --list_dir=.\OBJ\ --depend=.\obj\stm32f4xx_hal_uart.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I.\CORE -I.\USER -I.\HALLIB\STM32F4xx_HAL_Driver\Inc -I.\SYSTEM -I.\Hardware -I.\App -I.\DSP_LIB\Include -I.\FreeRTOS -I.\MPU9250\DMP -I.\MPU9250 -I.\RTE\_Project -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=526 -DSTM32F427xx -DSTM32F4 -DUSE_HAL_DRIVER -DSTM32F427xx -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=.\obj\stm32f4xx_hal_uart.crf HALLIB\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_uart.c]
                          THUMB

                          AREA ||i.HAL_HalfDuplex_EnableReceiver||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableReceiver PROC
;;;1446     */
;;;1447   HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;1448   {
;;;1449     uint32_t tmpreg = 0x00;
000002  2200              MOVS     r2,#0
;;;1450   
;;;1451     /* Process Locked */
;;;1452     __HAL_LOCK(huart);
000004  bf00              NOP      
000006  f8910038          LDRB     r0,[r1,#0x38]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L1.18|
00000e  2002              MOVS     r0,#2
                  |L1.16|
;;;1453     
;;;1454     huart->State = HAL_UART_STATE_BUSY;
;;;1455   
;;;1456     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;1457     tmpreg = huart->Instance->CR1;
;;;1458     
;;;1459     /* Clear TE and RE bits */
;;;1460     tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_TE | USART_CR1_RE));
;;;1461     
;;;1462     /* Enable the USART's receive interface by setting the RE bit in the USART CR1 register */
;;;1463     tmpreg |= (uint32_t)USART_CR1_RE;
;;;1464     
;;;1465     /* Write to USART CR1 */
;;;1466     huart->Instance->CR1 = (uint32_t)tmpreg;
;;;1467     
;;;1468     huart->State = HAL_UART_STATE_READY;
;;;1469     
;;;1470     /* Process Unlocked */
;;;1471     __HAL_UNLOCK(huart);
;;;1472     
;;;1473     return HAL_OK; 
;;;1474   }
000010  4770              BX       lr
                  |L1.18|
000012  2001              MOVS     r0,#1                 ;1452
000014  f8810038          STRB     r0,[r1,#0x38]         ;1452
000018  bf00              NOP                            ;1452
00001a  2002              MOVS     r0,#2                 ;1454
00001c  f8810039          STRB     r0,[r1,#0x39]         ;1454
000020  6808              LDR      r0,[r1,#0]            ;1457
000022  68c2              LDR      r2,[r0,#0xc]          ;1457
000024  f022020c          BIC      r2,r2,#0xc            ;1460
000028  f0420204          ORR      r2,r2,#4              ;1463
00002c  6808              LDR      r0,[r1,#0]            ;1466
00002e  60c2              STR      r2,[r0,#0xc]          ;1466
000030  2001              MOVS     r0,#1                 ;1468
000032  f8810039          STRB     r0,[r1,#0x39]         ;1468
000036  bf00              NOP                            ;1471
000038  2000              MOVS     r0,#0                 ;1471
00003a  f8810038          STRB     r0,[r1,#0x38]         ;1471
00003e  bf00              NOP                            ;1471
000040  bf00              NOP                            ;1473
000042  e7e5              B        |L1.16|
;;;1475   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_EnableTransmitter||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableTransmitter PROC
;;;1411     */
;;;1412   HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;1413   {
;;;1414     uint32_t tmpreg = 0x00;
000002  2200              MOVS     r2,#0
;;;1415   
;;;1416     /* Process Locked */
;;;1417     __HAL_LOCK(huart);
000004  bf00              NOP      
000006  f8910038          LDRB     r0,[r1,#0x38]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L2.18|
00000e  2002              MOVS     r0,#2
                  |L2.16|
;;;1418     
;;;1419     huart->State = HAL_UART_STATE_BUSY;
;;;1420   
;;;1421     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;1422     tmpreg = huart->Instance->CR1;
;;;1423     
;;;1424     /* Clear TE and RE bits */
;;;1425     tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_TE | USART_CR1_RE));
;;;1426     
;;;1427     /* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register */
;;;1428     tmpreg |= (uint32_t)USART_CR1_TE;
;;;1429     
;;;1430     /* Write to USART CR1 */
;;;1431     huart->Instance->CR1 = (uint32_t)tmpreg;
;;;1432    
;;;1433     huart->State = HAL_UART_STATE_READY;
;;;1434     
;;;1435     /* Process Unlocked */
;;;1436     __HAL_UNLOCK(huart);
;;;1437     
;;;1438     return HAL_OK; 
;;;1439   }
000010  4770              BX       lr
                  |L2.18|
000012  2001              MOVS     r0,#1                 ;1417
000014  f8810038          STRB     r0,[r1,#0x38]         ;1417
000018  bf00              NOP                            ;1417
00001a  2002              MOVS     r0,#2                 ;1419
00001c  f8810039          STRB     r0,[r1,#0x39]         ;1419
000020  6808              LDR      r0,[r1,#0]            ;1422
000022  68c2              LDR      r2,[r0,#0xc]          ;1422
000024  f022020c          BIC      r2,r2,#0xc            ;1425
000028  f0420208          ORR      r2,r2,#8              ;1428
00002c  6808              LDR      r0,[r1,#0]            ;1431
00002e  60c2              STR      r2,[r0,#0xc]          ;1431
000030  2001              MOVS     r0,#1                 ;1433
000032  f8810039          STRB     r0,[r1,#0x39]         ;1433
000036  bf00              NOP                            ;1436
000038  2000              MOVS     r0,#0                 ;1436
00003a  f8810038          STRB     r0,[r1,#0x38]         ;1436
00003e  bf00              NOP                            ;1436
000040  bf00              NOP                            ;1438
000042  e7e5              B        |L2.16|
;;;1440   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_Init||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_Init PROC
;;;300      */
;;;301    HAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;302    {
000002  4604              MOV      r4,r0
;;;303      /* Check the UART handle allocation */
;;;304      if(huart == NULL)
000004  b90c              CBNZ     r4,|L3.10|
;;;305      {
;;;306        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L3.8|
;;;307      }
;;;308     
;;;309      /* Check the parameters */ 
;;;310      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;311      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;312      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;313    
;;;314      if(huart->State == HAL_UART_STATE_RESET)
;;;315      { 
;;;316        /* Allocate lock resource and initialize it */
;;;317        huart->Lock = HAL_UNLOCKED;
;;;318        /* Init the low level hardware */
;;;319        HAL_UART_MspInit(huart);
;;;320      }
;;;321    
;;;322      huart->State = HAL_UART_STATE_BUSY;
;;;323    
;;;324      /* Disable the peripheral */
;;;325      __HAL_UART_DISABLE(huart);
;;;326      
;;;327      /* Set the UART Communication parameters */
;;;328      UART_SetConfig(huart);
;;;329      
;;;330      /* In half-duplex mode, the following bits must be kept cleared: 
;;;331         - LINEN and CLKEN bits in the USART_CR2 register,
;;;332         - SCEN and IREN bits in the USART_CR3 register.*/
;;;333      huart->Instance->CR2 &= ~(USART_CR2_LINEN | USART_CR2_CLKEN);
;;;334      huart->Instance->CR3 &= ~(USART_CR3_IREN | USART_CR3_SCEN);
;;;335      
;;;336      /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;337      huart->Instance->CR3 |= USART_CR3_HDSEL;
;;;338     
;;;339      /* Enable the peripheral */
;;;340      __HAL_UART_ENABLE(huart);
;;;341      
;;;342      /* Initialize the UART state*/
;;;343      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;344      huart->State= HAL_UART_STATE_READY;
;;;345      
;;;346      return HAL_OK;
;;;347    }
000008  bd10              POP      {r4,pc}
                  |L3.10|
00000a  f8940039          LDRB     r0,[r4,#0x39]         ;314
00000e  b928              CBNZ     r0,|L3.28|
000010  2000              MOVS     r0,#0                 ;317
000012  f8840038          STRB     r0,[r4,#0x38]         ;317
000016  4620              MOV      r0,r4                 ;319
000018  f7fffffe          BL       HAL_UART_MspInit
                  |L3.28|
00001c  2002              MOVS     r0,#2                 ;322
00001e  f8840039          STRB     r0,[r4,#0x39]         ;322
000022  6820              LDR      r0,[r4,#0]            ;325
000024  68c0              LDR      r0,[r0,#0xc]          ;325
000026  f4205000          BIC      r0,r0,#0x2000         ;325
00002a  6821              LDR      r1,[r4,#0]            ;325
00002c  60c8              STR      r0,[r1,#0xc]          ;325
00002e  4620              MOV      r0,r4                 ;328
000030  f7fffffe          BL       UART_SetConfig
000034  6820              LDR      r0,[r4,#0]            ;333
000036  6900              LDR      r0,[r0,#0x10]         ;333
000038  f4204090          BIC      r0,r0,#0x4800         ;333
00003c  6821              LDR      r1,[r4,#0]            ;333
00003e  6108              STR      r0,[r1,#0x10]         ;333
000040  6820              LDR      r0,[r4,#0]            ;334
000042  6940              LDR      r0,[r0,#0x14]         ;334
000044  f0200022          BIC      r0,r0,#0x22           ;334
000048  6821              LDR      r1,[r4,#0]            ;334
00004a  6148              STR      r0,[r1,#0x14]         ;334
00004c  6820              LDR      r0,[r4,#0]            ;337
00004e  6940              LDR      r0,[r0,#0x14]         ;337
000050  f0400008          ORR      r0,r0,#8              ;337
000054  6821              LDR      r1,[r4,#0]            ;337
000056  6148              STR      r0,[r1,#0x14]         ;337
000058  6820              LDR      r0,[r4,#0]            ;340
00005a  68c0              LDR      r0,[r0,#0xc]          ;340
00005c  f4405000          ORR      r0,r0,#0x2000         ;340
000060  6821              LDR      r1,[r4,#0]            ;340
000062  60c8              STR      r0,[r1,#0xc]          ;340
000064  2000              MOVS     r0,#0                 ;343
000066  63e0              STR      r0,[r4,#0x3c]         ;343
000068  2001              MOVS     r0,#1                 ;344
00006a  f8840039          STRB     r0,[r4,#0x39]         ;344
00006e  2000              MOVS     r0,#0                 ;346
000070  e7ca              B        |L3.8|
;;;348    
                          ENDP


                          AREA ||i.HAL_LIN_Init||, CODE, READONLY, ALIGN=1

                  HAL_LIN_Init PROC
;;;359      */
;;;360    HAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength)
000000  b570              PUSH     {r4-r6,lr}
;;;361    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;362      /* Check the UART handle allocation */
;;;363      if(huart == NULL)
000006  b90c              CBNZ     r4,|L4.12|
;;;364      {
;;;365        return HAL_ERROR;
000008  2001              MOVS     r0,#1
                  |L4.10|
;;;366      }
;;;367       
;;;368      /* Check the parameters */
;;;369      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;370      assert_param(IS_UART_LIN_BREAK_DETECT_LENGTH(BreakDetectLength));
;;;371      assert_param(IS_UART_LIN_WORD_LENGTH(huart->Init.WordLength));
;;;372      assert_param(IS_UART_LIN_OVERSAMPLING(huart->Init.OverSampling));
;;;373      
;;;374      if(huart->State == HAL_UART_STATE_RESET)
;;;375      {
;;;376        /* Allocate lock resource and initialize it */
;;;377        huart->Lock = HAL_UNLOCKED;
;;;378        /* Init the low level hardware */
;;;379        HAL_UART_MspInit(huart);
;;;380      }
;;;381    
;;;382      huart->State = HAL_UART_STATE_BUSY;
;;;383    
;;;384      /* Disable the peripheral */
;;;385      __HAL_UART_DISABLE(huart);
;;;386      
;;;387      /* Set the UART Communication parameters */
;;;388      UART_SetConfig(huart);
;;;389      
;;;390      /* In LIN mode, the following bits must be kept cleared: 
;;;391         - LINEN and CLKEN bits in the USART_CR2 register,
;;;392         - SCEN and IREN bits in the USART_CR3 register.*/
;;;393      huart->Instance->CR2 &= ~(USART_CR2_CLKEN);
;;;394      huart->Instance->CR3 &= ~(USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN);
;;;395      
;;;396      /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;397      huart->Instance->CR2 |= USART_CR2_LINEN;
;;;398      
;;;399      /* Set the USART LIN Break detection length. */
;;;400      huart->Instance->CR2 &= ~(USART_CR2_LBDL);
;;;401      huart->Instance->CR2 |= BreakDetectLength; 
;;;402      
;;;403      /* Enable the peripheral */
;;;404      __HAL_UART_ENABLE(huart);
;;;405      
;;;406      /* Initialize the UART state*/
;;;407      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;408      huart->State= HAL_UART_STATE_READY;
;;;409      
;;;410      return HAL_OK;
;;;411    }
00000a  bd70              POP      {r4-r6,pc}
                  |L4.12|
00000c  f8940039          LDRB     r0,[r4,#0x39]         ;374
000010  b928              CBNZ     r0,|L4.30|
000012  2000              MOVS     r0,#0                 ;377
000014  f8840038          STRB     r0,[r4,#0x38]         ;377
000018  4620              MOV      r0,r4                 ;379
00001a  f7fffffe          BL       HAL_UART_MspInit
                  |L4.30|
00001e  2002              MOVS     r0,#2                 ;382
000020  f8840039          STRB     r0,[r4,#0x39]         ;382
000024  6820              LDR      r0,[r4,#0]            ;385
000026  68c0              LDR      r0,[r0,#0xc]          ;385
000028  f4205000          BIC      r0,r0,#0x2000         ;385
00002c  6821              LDR      r1,[r4,#0]            ;385
00002e  60c8              STR      r0,[r1,#0xc]          ;385
000030  4620              MOV      r0,r4                 ;388
000032  f7fffffe          BL       UART_SetConfig
000036  6820              LDR      r0,[r4,#0]            ;393
000038  6900              LDR      r0,[r0,#0x10]         ;393
00003a  f4206000          BIC      r0,r0,#0x800          ;393
00003e  6821              LDR      r1,[r4,#0]            ;393
000040  6108              STR      r0,[r1,#0x10]         ;393
000042  6820              LDR      r0,[r4,#0]            ;394
000044  6940              LDR      r0,[r0,#0x14]         ;394
000046  f020002a          BIC      r0,r0,#0x2a           ;394
00004a  6821              LDR      r1,[r4,#0]            ;394
00004c  6148              STR      r0,[r1,#0x14]         ;394
00004e  6820              LDR      r0,[r4,#0]            ;397
000050  6900              LDR      r0,[r0,#0x10]         ;397
000052  f4404080          ORR      r0,r0,#0x4000         ;397
000056  6821              LDR      r1,[r4,#0]            ;397
000058  6108              STR      r0,[r1,#0x10]         ;397
00005a  6820              LDR      r0,[r4,#0]            ;400
00005c  6900              LDR      r0,[r0,#0x10]         ;400
00005e  f0200020          BIC      r0,r0,#0x20           ;400
000062  6821              LDR      r1,[r4,#0]            ;400
000064  6108              STR      r0,[r1,#0x10]         ;400
000066  6820              LDR      r0,[r4,#0]            ;401
000068  6900              LDR      r0,[r0,#0x10]         ;401
00006a  4328              ORRS     r0,r0,r5              ;401
00006c  6821              LDR      r1,[r4,#0]            ;401
00006e  6108              STR      r0,[r1,#0x10]         ;401
000070  6820              LDR      r0,[r4,#0]            ;404
000072  68c0              LDR      r0,[r0,#0xc]          ;404
000074  f4405000          ORR      r0,r0,#0x2000         ;404
000078  6821              LDR      r1,[r4,#0]            ;404
00007a  60c8              STR      r0,[r1,#0xc]          ;404
00007c  2000              MOVS     r0,#0                 ;407
00007e  63e0              STR      r0,[r4,#0x3c]         ;407
000080  2001              MOVS     r0,#1                 ;408
000082  f8840039          STRB     r0,[r4,#0x39]         ;408
000086  2000              MOVS     r0,#0                 ;410
000088  e7bf              B        |L4.10|
;;;412    
                          ENDP


                          AREA ||i.HAL_LIN_SendBreak||, CODE, READONLY, ALIGN=1

                  HAL_LIN_SendBreak PROC
;;;1330     */
;;;1331   HAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;1332   {
;;;1333     /* Check the parameters */
;;;1334     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;1335     
;;;1336     /* Process Locked */
;;;1337     __HAL_LOCK(huart);
000002  bf00              NOP      
000004  f8910038          LDRB     r0,[r1,#0x38]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L5.16|
00000c  2002              MOVS     r0,#2
                  |L5.14|
;;;1338     
;;;1339     huart->State = HAL_UART_STATE_BUSY;
;;;1340     
;;;1341     /* Send break characters */
;;;1342     huart->Instance->CR1 |= USART_CR1_SBK;
;;;1343    
;;;1344     huart->State = HAL_UART_STATE_READY;
;;;1345     
;;;1346     /* Process Unlocked */
;;;1347     __HAL_UNLOCK(huart);
;;;1348     
;;;1349     return HAL_OK; 
;;;1350   }
00000e  4770              BX       lr
                  |L5.16|
000010  2001              MOVS     r0,#1                 ;1337
000012  f8810038          STRB     r0,[r1,#0x38]         ;1337
000016  bf00              NOP                            ;1337
000018  2002              MOVS     r0,#2                 ;1339
00001a  f8810039          STRB     r0,[r1,#0x39]         ;1339
00001e  6808              LDR      r0,[r1,#0]            ;1342
000020  68c0              LDR      r0,[r0,#0xc]          ;1342
000022  f0400001          ORR      r0,r0,#1              ;1342
000026  680a              LDR      r2,[r1,#0]            ;1342
000028  60d0              STR      r0,[r2,#0xc]          ;1342
00002a  2001              MOVS     r0,#1                 ;1344
00002c  f8810039          STRB     r0,[r1,#0x39]         ;1344
000030  bf00              NOP                            ;1347
000032  2000              MOVS     r0,#0                 ;1347
000034  f8810038          STRB     r0,[r1,#0x38]         ;1347
000038  bf00              NOP                            ;1347
00003a  bf00              NOP                            ;1349
00003c  e7e7              B        |L5.14|
;;;1351   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_EnterMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_EnterMuteMode PROC
;;;1357     */
;;;1358   HAL_StatusTypeDef HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;1359   {
;;;1360     /* Check the parameters */
;;;1361     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;1362     
;;;1363     /* Process Locked */
;;;1364     __HAL_LOCK(huart);
000002  bf00              NOP      
000004  f8910038          LDRB     r0,[r1,#0x38]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L6.16|
00000c  2002              MOVS     r0,#2
                  |L6.14|
;;;1365     
;;;1366     huart->State = HAL_UART_STATE_BUSY;
;;;1367     
;;;1368     /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
;;;1369     huart->Instance->CR1 |= USART_CR1_RWU;
;;;1370     
;;;1371     huart->State = HAL_UART_STATE_READY;
;;;1372     
;;;1373     /* Process Unlocked */
;;;1374     __HAL_UNLOCK(huart);
;;;1375     
;;;1376     return HAL_OK; 
;;;1377   }
00000e  4770              BX       lr
                  |L6.16|
000010  2001              MOVS     r0,#1                 ;1364
000012  f8810038          STRB     r0,[r1,#0x38]         ;1364
000016  bf00              NOP                            ;1364
000018  2002              MOVS     r0,#2                 ;1366
00001a  f8810039          STRB     r0,[r1,#0x39]         ;1366
00001e  6808              LDR      r0,[r1,#0]            ;1369
000020  68c0              LDR      r0,[r0,#0xc]          ;1369
000022  f0400002          ORR      r0,r0,#2              ;1369
000026  680a              LDR      r2,[r1,#0]            ;1369
000028  60d0              STR      r0,[r2,#0xc]          ;1369
00002a  2001              MOVS     r0,#1                 ;1371
00002c  f8810039          STRB     r0,[r1,#0x39]         ;1371
000030  bf00              NOP                            ;1374
000032  2000              MOVS     r0,#0                 ;1374
000034  f8810038          STRB     r0,[r1,#0x38]         ;1374
000038  bf00              NOP                            ;1374
00003a  bf00              NOP                            ;1376
00003c  e7e7              B        |L6.14|
;;;1378   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_ExitMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_ExitMuteMode PROC
;;;1384     */
;;;1385   HAL_StatusTypeDef HAL_MultiProcessor_ExitMuteMode(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;1386   {
;;;1387     /* Check the parameters */
;;;1388     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;1389     
;;;1390     /* Process Locked */
;;;1391     __HAL_LOCK(huart);
000002  bf00              NOP      
000004  f8910038          LDRB     r0,[r1,#0x38]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L7.16|
00000c  2002              MOVS     r0,#2
                  |L7.14|
;;;1392     
;;;1393     huart->State = HAL_UART_STATE_BUSY;
;;;1394     
;;;1395     /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
;;;1396     huart->Instance->CR1 &= (uint32_t)~((uint32_t)USART_CR1_RWU);
;;;1397     
;;;1398     huart->State = HAL_UART_STATE_READY;
;;;1399     
;;;1400     /* Process Unlocked */
;;;1401     __HAL_UNLOCK(huart);
;;;1402     
;;;1403     return HAL_OK; 
;;;1404   }
00000e  4770              BX       lr
                  |L7.16|
000010  2001              MOVS     r0,#1                 ;1391
000012  f8810038          STRB     r0,[r1,#0x38]         ;1391
000016  bf00              NOP                            ;1391
000018  2002              MOVS     r0,#2                 ;1393
00001a  f8810039          STRB     r0,[r1,#0x39]         ;1393
00001e  6808              LDR      r0,[r1,#0]            ;1396
000020  68c0              LDR      r0,[r0,#0xc]          ;1396
000022  f0200002          BIC      r0,r0,#2              ;1396
000026  680a              LDR      r2,[r1,#0]            ;1396
000028  60d0              STR      r0,[r2,#0xc]          ;1396
00002a  2001              MOVS     r0,#1                 ;1398
00002c  f8810039          STRB     r0,[r1,#0x39]         ;1398
000030  bf00              NOP                            ;1401
000032  2000              MOVS     r0,#0                 ;1401
000034  f8810038          STRB     r0,[r1,#0x38]         ;1401
000038  bf00              NOP                            ;1401
00003a  bf00              NOP                            ;1403
00003c  e7e7              B        |L7.14|
;;;1405   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_Init||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_Init PROC
;;;424      */
;;;425    HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)
000000  b570              PUSH     {r4-r6,lr}
;;;426    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;427      /* Check the UART handle allocation */
;;;428      if(huart == NULL)
000008  b90c              CBNZ     r4,|L8.14|
;;;429      {
;;;430        return HAL_ERROR;
00000a  2001              MOVS     r0,#1
                  |L8.12|
;;;431      }
;;;432    
;;;433      /* Check the parameters */
;;;434      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;435      assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));
;;;436      assert_param(IS_UART_ADDRESS(Address));
;;;437      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;438      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;439    
;;;440      if(huart->State == HAL_UART_STATE_RESET)
;;;441      {
;;;442        /* Allocate lock resource and initialize it */
;;;443        huart->Lock = HAL_UNLOCKED;
;;;444        /* Init the low level hardware */
;;;445        HAL_UART_MspInit(huart);
;;;446      }
;;;447    
;;;448      huart->State = HAL_UART_STATE_BUSY;
;;;449    
;;;450      /* Disable the peripheral */
;;;451      __HAL_UART_DISABLE(huart);
;;;452      
;;;453      /* Set the UART Communication parameters */
;;;454      UART_SetConfig(huart);
;;;455      
;;;456      /* In Multi-Processor mode, the following bits must be kept cleared: 
;;;457         - LINEN and CLKEN bits in the USART_CR2 register,
;;;458         - SCEN, HDSEL and IREN  bits in the USART_CR3 register */
;;;459      huart->Instance->CR2 &= ~(USART_CR2_LINEN | USART_CR2_CLKEN);
;;;460      huart->Instance->CR3 &= ~(USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN);
;;;461      
;;;462      /* Clear the USART address */
;;;463      huart->Instance->CR2 &= ~(USART_CR2_ADD);
;;;464      /* Set the USART address node */
;;;465      huart->Instance->CR2 |= Address;
;;;466      
;;;467      /* Set the wake up method by setting the WAKE bit in the CR1 register */
;;;468      huart->Instance->CR1 &= ~(USART_CR1_WAKE);
;;;469      huart->Instance->CR1 |= WakeUpMethod;
;;;470      
;;;471      /* Enable the peripheral */
;;;472      __HAL_UART_ENABLE(huart);
;;;473      
;;;474      /* Initialize the UART state */
;;;475      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;476      huart->State= HAL_UART_STATE_READY;
;;;477      
;;;478      return HAL_OK;
;;;479    }
00000c  bd70              POP      {r4-r6,pc}
                  |L8.14|
00000e  f8940039          LDRB     r0,[r4,#0x39]         ;440
000012  b928              CBNZ     r0,|L8.32|
000014  2000              MOVS     r0,#0                 ;443
000016  f8840038          STRB     r0,[r4,#0x38]         ;443
00001a  4620              MOV      r0,r4                 ;445
00001c  f7fffffe          BL       HAL_UART_MspInit
                  |L8.32|
000020  2002              MOVS     r0,#2                 ;448
000022  f8840039          STRB     r0,[r4,#0x39]         ;448
000026  6820              LDR      r0,[r4,#0]            ;451
000028  68c0              LDR      r0,[r0,#0xc]          ;451
00002a  f4205000          BIC      r0,r0,#0x2000         ;451
00002e  6821              LDR      r1,[r4,#0]            ;451
000030  60c8              STR      r0,[r1,#0xc]          ;451
000032  4620              MOV      r0,r4                 ;454
000034  f7fffffe          BL       UART_SetConfig
000038  6820              LDR      r0,[r4,#0]            ;459
00003a  6900              LDR      r0,[r0,#0x10]         ;459
00003c  f4204090          BIC      r0,r0,#0x4800         ;459
000040  6821              LDR      r1,[r4,#0]            ;459
000042  6108              STR      r0,[r1,#0x10]         ;459
000044  6820              LDR      r0,[r4,#0]            ;460
000046  6940              LDR      r0,[r0,#0x14]         ;460
000048  f020002a          BIC      r0,r0,#0x2a           ;460
00004c  6821              LDR      r1,[r4,#0]            ;460
00004e  6148              STR      r0,[r1,#0x14]         ;460
000050  6820              LDR      r0,[r4,#0]            ;463
000052  6900              LDR      r0,[r0,#0x10]         ;463
000054  f020000f          BIC      r0,r0,#0xf            ;463
000058  6821              LDR      r1,[r4,#0]            ;463
00005a  6108              STR      r0,[r1,#0x10]         ;463
00005c  6820              LDR      r0,[r4,#0]            ;465
00005e  6900              LDR      r0,[r0,#0x10]         ;465
000060  4328              ORRS     r0,r0,r5              ;465
000062  6821              LDR      r1,[r4,#0]            ;465
000064  6108              STR      r0,[r1,#0x10]         ;465
000066  6820              LDR      r0,[r4,#0]            ;468
000068  68c0              LDR      r0,[r0,#0xc]          ;468
00006a  f4206000          BIC      r0,r0,#0x800          ;468
00006e  6821              LDR      r1,[r4,#0]            ;468
000070  60c8              STR      r0,[r1,#0xc]          ;468
000072  6820              LDR      r0,[r4,#0]            ;469
000074  68c0              LDR      r0,[r0,#0xc]          ;469
000076  4330              ORRS     r0,r0,r6              ;469
000078  6821              LDR      r1,[r4,#0]            ;469
00007a  60c8              STR      r0,[r1,#0xc]          ;469
00007c  6820              LDR      r0,[r4,#0]            ;472
00007e  68c0              LDR      r0,[r0,#0xc]          ;472
000080  f4405000          ORR      r0,r0,#0x2000         ;472
000084  6821              LDR      r1,[r4,#0]            ;472
000086  60c8              STR      r0,[r1,#0xc]          ;472
000088  2000              MOVS     r0,#0                 ;475
00008a  63e0              STR      r0,[r4,#0x3c]         ;475
00008c  2001              MOVS     r0,#1                 ;476
00008e  f8840039          STRB     r0,[r4,#0x39]         ;476
000092  2000              MOVS     r0,#0                 ;478
000094  e7ba              B        |L8.12|
;;;480    
                          ENDP


                          AREA ||i.HAL_UART_DMAPause||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAPause PROC
;;;1044     */
;;;1045   HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;1046   {
;;;1047     /* Process Locked */
;;;1048     __HAL_LOCK(huart);
000002  bf00              NOP      
000004  f8910038          LDRB     r0,[r1,#0x38]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L9.16|
00000c  2002              MOVS     r0,#2
                  |L9.14|
;;;1049     
;;;1050     if(huart->State == HAL_UART_STATE_BUSY_TX)
;;;1051     {
;;;1052       /* Disable the UART DMA Tx request */
;;;1053       huart->Instance->CR3 &= (uint32_t)(~USART_CR3_DMAT);
;;;1054     }
;;;1055     else if(huart->State == HAL_UART_STATE_BUSY_RX)
;;;1056     {
;;;1057       /* Disable the UART DMA Rx request */
;;;1058       huart->Instance->CR3 &= (uint32_t)(~USART_CR3_DMAR);
;;;1059     }
;;;1060     else if (huart->State == HAL_UART_STATE_BUSY_TX_RX)
;;;1061     {
;;;1062       /* Disable the UART DMA Tx & Rx requests */
;;;1063       huart->Instance->CR3 &= (uint32_t)(~USART_CR3_DMAT);
;;;1064       huart->Instance->CR3 &= (uint32_t)(~USART_CR3_DMAR);
;;;1065     }
;;;1066     
;;;1067     /* Process Unlocked */
;;;1068     __HAL_UNLOCK(huart);
;;;1069     
;;;1070     return HAL_OK; 
;;;1071   }
00000e  4770              BX       lr
                  |L9.16|
000010  2001              MOVS     r0,#1                 ;1048
000012  f8810038          STRB     r0,[r1,#0x38]         ;1048
000016  bf00              NOP                            ;1048
000018  f8910039          LDRB     r0,[r1,#0x39]         ;1050
00001c  2812              CMP      r0,#0x12              ;1050
00001e  d106              BNE      |L9.46|
000020  6808              LDR      r0,[r1,#0]            ;1053
000022  6940              LDR      r0,[r0,#0x14]         ;1053
000024  f0200080          BIC      r0,r0,#0x80           ;1053
000028  680a              LDR      r2,[r1,#0]            ;1053
00002a  6150              STR      r0,[r2,#0x14]         ;1053
00002c  e01a              B        |L9.100|
                  |L9.46|
00002e  f8910039          LDRB     r0,[r1,#0x39]         ;1055
000032  2822              CMP      r0,#0x22              ;1055
000034  d106              BNE      |L9.68|
000036  6808              LDR      r0,[r1,#0]            ;1058
000038  6940              LDR      r0,[r0,#0x14]         ;1058
00003a  f0200040          BIC      r0,r0,#0x40           ;1058
00003e  680a              LDR      r2,[r1,#0]            ;1058
000040  6150              STR      r0,[r2,#0x14]         ;1058
000042  e00f              B        |L9.100|
                  |L9.68|
000044  f8910039          LDRB     r0,[r1,#0x39]         ;1060
000048  2832              CMP      r0,#0x32              ;1060
00004a  d10b              BNE      |L9.100|
00004c  6808              LDR      r0,[r1,#0]            ;1063
00004e  6940              LDR      r0,[r0,#0x14]         ;1063
000050  f0200080          BIC      r0,r0,#0x80           ;1063
000054  680a              LDR      r2,[r1,#0]            ;1063
000056  6150              STR      r0,[r2,#0x14]         ;1063
000058  6808              LDR      r0,[r1,#0]            ;1064
00005a  6940              LDR      r0,[r0,#0x14]         ;1064
00005c  f0200040          BIC      r0,r0,#0x40           ;1064
000060  680a              LDR      r2,[r1,#0]            ;1064
000062  6150              STR      r0,[r2,#0x14]         ;1064
                  |L9.100|
000064  bf00              NOP                            ;1068
000066  2000              MOVS     r0,#0                 ;1068
000068  f8810038          STRB     r0,[r1,#0x38]         ;1068
00006c  bf00              NOP                            ;1068
00006e  bf00              NOP                            ;1070
000070  e7cd              B        |L9.14|
;;;1072   
                          ENDP


                          AREA ||i.HAL_UART_DMAResume||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAResume PROC
;;;1078     */
;;;1079   HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
000000  b508              PUSH     {r3,lr}
;;;1080   {
000002  4601              MOV      r1,r0
;;;1081     /* Process Locked */
;;;1082     __HAL_LOCK(huart);
000004  bf00              NOP      
000006  f8910038          LDRB     r0,[r1,#0x38]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L10.18|
00000e  2002              MOVS     r0,#2
                  |L10.16|
;;;1083     
;;;1084     if(huart->State == HAL_UART_STATE_BUSY_TX)
;;;1085     {
;;;1086       /* Enable the UART DMA Tx request */
;;;1087       huart->Instance->CR3 |= USART_CR3_DMAT;
;;;1088     }
;;;1089     else if(huart->State == HAL_UART_STATE_BUSY_RX)
;;;1090     {
;;;1091       /* Clear the Overrun flag before resuming the Rx transfer*/
;;;1092       __HAL_UART_CLEAR_OREFLAG(huart);
;;;1093       /* Enable the UART DMA Rx request */
;;;1094       huart->Instance->CR3 |= USART_CR3_DMAR;
;;;1095     }
;;;1096     else if(huart->State == HAL_UART_STATE_BUSY_TX_RX)
;;;1097     {
;;;1098       /* Clear the Overrun flag before resuming the Rx transfer*/
;;;1099       __HAL_UART_CLEAR_OREFLAG(huart);
;;;1100       /* Enable the UART DMA Tx & Rx request */
;;;1101       huart->Instance->CR3 |= USART_CR3_DMAT;
;;;1102       huart->Instance->CR3 |= USART_CR3_DMAR;
;;;1103     }
;;;1104     
;;;1105     /* Process Unlocked */
;;;1106     __HAL_UNLOCK(huart);
;;;1107     
;;;1108     return HAL_OK;
;;;1109   }
000010  bd08              POP      {r3,pc}
                  |L10.18|
000012  2001              MOVS     r0,#1                 ;1082
000014  f8810038          STRB     r0,[r1,#0x38]         ;1082
000018  bf00              NOP                            ;1082
00001a  f8910039          LDRB     r0,[r1,#0x39]         ;1084
00001e  2812              CMP      r0,#0x12              ;1084
000020  d106              BNE      |L10.48|
000022  6808              LDR      r0,[r1,#0]            ;1087
000024  6940              LDR      r0,[r0,#0x14]         ;1087
000026  f0400080          ORR      r0,r0,#0x80           ;1087
00002a  680a              LDR      r2,[r1,#0]            ;1087
00002c  6150              STR      r0,[r2,#0x14]         ;1087
00002e  e030              B        |L10.146|
                  |L10.48|
000030  f8910039          LDRB     r0,[r1,#0x39]         ;1089
000034  2822              CMP      r0,#0x22              ;1089
000036  d111              BNE      |L10.92|
000038  bf00              NOP                            ;1092
00003a  2000              MOVS     r0,#0                 ;1092
00003c  9000              STR      r0,[sp,#0]            ;1092
00003e  6808              LDR      r0,[r1,#0]            ;1092
000040  6800              LDR      r0,[r0,#0]            ;1092
000042  9000              STR      r0,[sp,#0]            ;1092
000044  6808              LDR      r0,[r1,#0]            ;1092
000046  6840              LDR      r0,[r0,#4]            ;1092
000048  9000              STR      r0,[sp,#0]            ;1092
00004a  bf00              NOP                            ;1092
00004c  bf00              NOP                            ;1092
00004e  6808              LDR      r0,[r1,#0]            ;1094
000050  6940              LDR      r0,[r0,#0x14]         ;1094
000052  f0400040          ORR      r0,r0,#0x40           ;1094
000056  680a              LDR      r2,[r1,#0]            ;1094
000058  6150              STR      r0,[r2,#0x14]         ;1094
00005a  e01a              B        |L10.146|
                  |L10.92|
00005c  f8910039          LDRB     r0,[r1,#0x39]         ;1096
000060  2832              CMP      r0,#0x32              ;1096
000062  d116              BNE      |L10.146|
000064  bf00              NOP                            ;1099
000066  2000              MOVS     r0,#0                 ;1099
000068  9000              STR      r0,[sp,#0]            ;1099
00006a  6808              LDR      r0,[r1,#0]            ;1099
00006c  6800              LDR      r0,[r0,#0]            ;1099
00006e  9000              STR      r0,[sp,#0]            ;1099
000070  6808              LDR      r0,[r1,#0]            ;1099
000072  6840              LDR      r0,[r0,#4]            ;1099
000074  9000              STR      r0,[sp,#0]            ;1099
000076  bf00              NOP                            ;1099
000078  bf00              NOP                            ;1099
00007a  6808              LDR      r0,[r1,#0]            ;1101
00007c  6940              LDR      r0,[r0,#0x14]         ;1101
00007e  f0400080          ORR      r0,r0,#0x80           ;1101
000082  680a              LDR      r2,[r1,#0]            ;1101
000084  6150              STR      r0,[r2,#0x14]         ;1101
000086  6808              LDR      r0,[r1,#0]            ;1102
000088  6940              LDR      r0,[r0,#0x14]         ;1102
00008a  f0400040          ORR      r0,r0,#0x40           ;1102
00008e  680a              LDR      r2,[r1,#0]            ;1102
000090  6150              STR      r0,[r2,#0x14]         ;1102
                  |L10.146|
000092  bf00              NOP                            ;1106
000094  2000              MOVS     r0,#0                 ;1106
000096  f8810038          STRB     r0,[r1,#0x38]         ;1106
00009a  bf00              NOP                            ;1106
00009c  bf00              NOP                            ;1108
00009e  e7b7              B        |L10.16|
;;;1110   
                          ENDP


                          AREA ||i.HAL_UART_DMAStop||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAStop PROC
;;;1116     */
;;;1117   HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1118   {
000002  4604              MOV      r4,r0
;;;1119     /* The Lock is not implemented on this API to allow the user application
;;;1120        to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback():
;;;1121        when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
;;;1122        and the correspond call back is executed HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback()
;;;1123        */
;;;1124     
;;;1125     /* Disable the UART Tx/Rx DMA requests */
;;;1126     huart->Instance->CR3 &= ~USART_CR3_DMAT;
000004  6820              LDR      r0,[r4,#0]
000006  6940              LDR      r0,[r0,#0x14]
000008  f0200080          BIC      r0,r0,#0x80
00000c  6821              LDR      r1,[r4,#0]
00000e  6148              STR      r0,[r1,#0x14]
;;;1127     huart->Instance->CR3 &= ~USART_CR3_DMAR;
000010  6820              LDR      r0,[r4,#0]
000012  6940              LDR      r0,[r0,#0x14]
000014  f0200040          BIC      r0,r0,#0x40
000018  6821              LDR      r1,[r4,#0]
00001a  6148              STR      r0,[r1,#0x14]
;;;1128     
;;;1129     /* Abort the UART DMA tx Stream */
;;;1130     if(huart->hdmatx != NULL)
00001c  6b20              LDR      r0,[r4,#0x30]
00001e  b110              CBZ      r0,|L11.38|
;;;1131     {
;;;1132       HAL_DMA_Abort(huart->hdmatx);
000020  6b20              LDR      r0,[r4,#0x30]
000022  f7fffffe          BL       HAL_DMA_Abort
                  |L11.38|
;;;1133     }
;;;1134     /* Abort the UART DMA rx Stream */
;;;1135     if(huart->hdmarx != NULL)
000026  6b60              LDR      r0,[r4,#0x34]
000028  b110              CBZ      r0,|L11.48|
;;;1136     {
;;;1137       HAL_DMA_Abort(huart->hdmarx);
00002a  6b60              LDR      r0,[r4,#0x34]
00002c  f7fffffe          BL       HAL_DMA_Abort
                  |L11.48|
;;;1138     }
;;;1139     
;;;1140     huart->State = HAL_UART_STATE_READY;
000030  2001              MOVS     r0,#1
000032  f8840039          STRB     r0,[r4,#0x39]
;;;1141     
;;;1142     return HAL_OK;
000036  2000              MOVS     r0,#0
;;;1143   }
000038  bd10              POP      {r4,pc}
;;;1144   
                          ENDP


                          AREA ||i.HAL_UART_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_DeInit PROC
;;;486      */
;;;487    HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;488    {
000002  4604              MOV      r4,r0
;;;489      /* Check the UART handle allocation */
;;;490      if(huart == NULL)
000004  b90c              CBNZ     r4,|L12.10|
;;;491      {
;;;492        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L12.8|
;;;493      }
;;;494      
;;;495      /* Check the parameters */
;;;496      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;497    
;;;498      huart->State = HAL_UART_STATE_BUSY;
;;;499      
;;;500      /* DeInit the low level hardware */
;;;501      HAL_UART_MspDeInit(huart);
;;;502      
;;;503      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;504      huart->State = HAL_UART_STATE_RESET;
;;;505    
;;;506      /* Process Lock */
;;;507      __HAL_UNLOCK(huart);
;;;508    
;;;509      return HAL_OK;
;;;510    }
000008  bd10              POP      {r4,pc}
                  |L12.10|
00000a  2002              MOVS     r0,#2                 ;498
00000c  f8840039          STRB     r0,[r4,#0x39]         ;498
000010  4620              MOV      r0,r4                 ;501
000012  f7fffffe          BL       HAL_UART_MspDeInit
000016  2000              MOVS     r0,#0                 ;503
000018  63e0              STR      r0,[r4,#0x3c]         ;503
00001a  f8840039          STRB     r0,[r4,#0x39]         ;504
00001e  bf00              NOP                            ;507
000020  f8840038          STRB     r0,[r4,#0x38]         ;507
000024  bf00              NOP                            ;507
000026  bf00              NOP                            ;509
000028  e7ee              B        |L12.8|
;;;511    
                          ENDP


                          AREA ||i.HAL_UART_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_ErrorCallback PROC
;;;1294     */
;;;1295    __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1296   {
;;;1297     /* Prevent unused argument(s) compilation warning */
;;;1298     UNUSED(huart); 
;;;1299     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1300              the HAL_UART_ErrorCallback could be implemented in the user file
;;;1301      */ 
;;;1302   }
;;;1303   
                          ENDP


                          AREA ||i.HAL_UART_GetError||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetError PROC
;;;1514   */
;;;1515   uint32_t HAL_UART_GetError(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;1516   {
;;;1517     return huart->ErrorCode;
000002  6bc8              LDR      r0,[r1,#0x3c]
;;;1518   }
000004  4770              BX       lr
;;;1519   
                          ENDP


                          AREA ||i.HAL_UART_GetState||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetState PROC
;;;1503     */
;;;1504   HAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;1505   {
;;;1506     return huart->State;
000002  f8910039          LDRB     r0,[r1,#0x39]
;;;1507   }
000006  4770              BX       lr
;;;1508   
                          ENDP


                          AREA ||i.HAL_UART_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_UART_IRQHandler PROC
;;;1150     */
;;;1151   void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1152   {
000002  4604              MOV      r4,r0
;;;1153     uint32_t tmp1 = 0, tmp2 = 0;
000004  2500              MOVS     r5,#0
000006  2600              MOVS     r6,#0
;;;1154   
;;;1155     tmp1 = __HAL_UART_GET_FLAG(huart, UART_FLAG_PE);
000008  6820              LDR      r0,[r4,#0]
00000a  6800              LDR      r0,[r0,#0]
00000c  f0000501          AND      r5,r0,#1
;;;1156     tmp2 = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_PE);  
000010  6820              LDR      r0,[r4,#0]
000012  68c0              LDR      r0,[r0,#0xc]
000014  f4007680          AND      r6,r0,#0x100
;;;1157     /* UART parity error interrupt occurred ------------------------------------*/
;;;1158     if((tmp1 != RESET) && (tmp2 != RESET))
000018  b17d              CBZ      r5,|L16.58|
00001a  b176              CBZ      r6,|L16.58|
;;;1159     { 
;;;1160       __HAL_UART_CLEAR_PEFLAG(huart);
00001c  bf00              NOP      
00001e  2000              MOVS     r0,#0
000020  9000              STR      r0,[sp,#0]
000022  6820              LDR      r0,[r4,#0]
000024  6800              LDR      r0,[r0,#0]
000026  9000              STR      r0,[sp,#0]
000028  6820              LDR      r0,[r4,#0]
00002a  6840              LDR      r0,[r0,#4]
00002c  9000              STR      r0,[sp,#0]
00002e  bf00              NOP      
000030  bf00              NOP      
;;;1161       
;;;1162       huart->ErrorCode |= HAL_UART_ERROR_PE;
000032  6be0              LDR      r0,[r4,#0x3c]
000034  f0400001          ORR      r0,r0,#1
000038  63e0              STR      r0,[r4,#0x3c]
                  |L16.58|
;;;1163     }
;;;1164     
;;;1165     tmp1 = __HAL_UART_GET_FLAG(huart, UART_FLAG_FE);
00003a  6820              LDR      r0,[r4,#0]
00003c  6800              LDR      r0,[r0,#0]
00003e  f3c00540          UBFX     r5,r0,#1,#1
;;;1166     tmp2 = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_ERR);
000042  6820              LDR      r0,[r4,#0]
000044  6940              LDR      r0,[r0,#0x14]
000046  f0000601          AND      r6,r0,#1
;;;1167     /* UART frame error interrupt occurred -------------------------------------*/
;;;1168     if((tmp1 != RESET) && (tmp2 != RESET))
00004a  b17d              CBZ      r5,|L16.108|
00004c  b176              CBZ      r6,|L16.108|
;;;1169     { 
;;;1170       __HAL_UART_CLEAR_FEFLAG(huart);
00004e  bf00              NOP      
000050  2000              MOVS     r0,#0
000052  9000              STR      r0,[sp,#0]
000054  6820              LDR      r0,[r4,#0]
000056  6800              LDR      r0,[r0,#0]
000058  9000              STR      r0,[sp,#0]
00005a  6820              LDR      r0,[r4,#0]
00005c  6840              LDR      r0,[r0,#4]
00005e  9000              STR      r0,[sp,#0]
000060  bf00              NOP      
000062  bf00              NOP      
;;;1171       
;;;1172       huart->ErrorCode |= HAL_UART_ERROR_FE;
000064  6be0              LDR      r0,[r4,#0x3c]
000066  f0400004          ORR      r0,r0,#4
00006a  63e0              STR      r0,[r4,#0x3c]
                  |L16.108|
;;;1173     }
;;;1174     
;;;1175     tmp1 = __HAL_UART_GET_FLAG(huart, UART_FLAG_NE);
00006c  6820              LDR      r0,[r4,#0]
00006e  6800              LDR      r0,[r0,#0]
000070  f3c00580          UBFX     r5,r0,#2,#1
;;;1176     tmp2 = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_ERR);
000074  6820              LDR      r0,[r4,#0]
000076  6940              LDR      r0,[r0,#0x14]
000078  f0000601          AND      r6,r0,#1
;;;1177     /* UART noise error interrupt occurred -------------------------------------*/
;;;1178     if((tmp1 != RESET) && (tmp2 != RESET))
00007c  b17d              CBZ      r5,|L16.158|
00007e  b176              CBZ      r6,|L16.158|
;;;1179     { 
;;;1180       __HAL_UART_CLEAR_NEFLAG(huart);
000080  bf00              NOP      
000082  2000              MOVS     r0,#0
000084  9000              STR      r0,[sp,#0]
000086  6820              LDR      r0,[r4,#0]
000088  6800              LDR      r0,[r0,#0]
00008a  9000              STR      r0,[sp,#0]
00008c  6820              LDR      r0,[r4,#0]
00008e  6840              LDR      r0,[r0,#4]
000090  9000              STR      r0,[sp,#0]
000092  bf00              NOP      
000094  bf00              NOP      
;;;1181       
;;;1182       huart->ErrorCode |= HAL_UART_ERROR_NE;
000096  6be0              LDR      r0,[r4,#0x3c]
000098  f0400002          ORR      r0,r0,#2
00009c  63e0              STR      r0,[r4,#0x3c]
                  |L16.158|
;;;1183     }
;;;1184     
;;;1185     tmp1 = __HAL_UART_GET_FLAG(huart, UART_FLAG_ORE);
00009e  6820              LDR      r0,[r4,#0]
0000a0  6800              LDR      r0,[r0,#0]
0000a2  f3c005c0          UBFX     r5,r0,#3,#1
;;;1186     tmp2 = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_ERR);
0000a6  6820              LDR      r0,[r4,#0]
0000a8  6940              LDR      r0,[r0,#0x14]
0000aa  f0000601          AND      r6,r0,#1
;;;1187     /* UART Over-Run interrupt occurred ----------------------------------------*/
;;;1188     if((tmp1 != RESET) && (tmp2 != RESET))
0000ae  b17d              CBZ      r5,|L16.208|
0000b0  b176              CBZ      r6,|L16.208|
;;;1189     { 
;;;1190       __HAL_UART_CLEAR_OREFLAG(huart);
0000b2  bf00              NOP      
0000b4  2000              MOVS     r0,#0
0000b6  9000              STR      r0,[sp,#0]
0000b8  6820              LDR      r0,[r4,#0]
0000ba  6800              LDR      r0,[r0,#0]
0000bc  9000              STR      r0,[sp,#0]
0000be  6820              LDR      r0,[r4,#0]
0000c0  6840              LDR      r0,[r0,#4]
0000c2  9000              STR      r0,[sp,#0]
0000c4  bf00              NOP      
0000c6  bf00              NOP      
;;;1191       
;;;1192       huart->ErrorCode |= HAL_UART_ERROR_ORE;
0000c8  6be0              LDR      r0,[r4,#0x3c]
0000ca  f0400008          ORR      r0,r0,#8
0000ce  63e0              STR      r0,[r4,#0x3c]
                  |L16.208|
;;;1193     }
;;;1194     
;;;1195     tmp1 = __HAL_UART_GET_FLAG(huart, UART_FLAG_RXNE);
0000d0  6820              LDR      r0,[r4,#0]
0000d2  6800              LDR      r0,[r0,#0]
0000d4  f3c01540          UBFX     r5,r0,#5,#1
;;;1196     tmp2 = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_RXNE);
0000d8  6820              LDR      r0,[r4,#0]
0000da  68c0              LDR      r0,[r0,#0xc]
0000dc  f0000620          AND      r6,r0,#0x20
;;;1197     /* UART in mode Receiver ---------------------------------------------------*/
;;;1198     if((tmp1 != RESET) && (tmp2 != RESET))
0000e0  b11d              CBZ      r5,|L16.234|
0000e2  b116              CBZ      r6,|L16.234|
;;;1199     { 
;;;1200       UART_Receive_IT(huart);
0000e4  4620              MOV      r0,r4
0000e6  f7fffffe          BL       UART_Receive_IT
                  |L16.234|
;;;1201     }
;;;1202     
;;;1203     tmp1 = __HAL_UART_GET_FLAG(huart, UART_FLAG_TXE);
0000ea  6820              LDR      r0,[r4,#0]
0000ec  6800              LDR      r0,[r0,#0]
0000ee  f3c015c0          UBFX     r5,r0,#7,#1
;;;1204     tmp2 = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_TXE);
0000f2  6820              LDR      r0,[r4,#0]
0000f4  68c0              LDR      r0,[r0,#0xc]
0000f6  f0000680          AND      r6,r0,#0x80
;;;1205     /* UART in mode Transmitter ------------------------------------------------*/
;;;1206     if((tmp1 != RESET) && (tmp2 != RESET))
0000fa  b11d              CBZ      r5,|L16.260|
0000fc  b116              CBZ      r6,|L16.260|
;;;1207     {
;;;1208       UART_Transmit_IT(huart);
0000fe  4620              MOV      r0,r4
000100  f7fffffe          BL       UART_Transmit_IT
                  |L16.260|
;;;1209     }
;;;1210     
;;;1211     tmp1 = __HAL_UART_GET_FLAG(huart, UART_FLAG_TC);
000104  6820              LDR      r0,[r4,#0]
000106  6800              LDR      r0,[r0,#0]
000108  f3c01580          UBFX     r5,r0,#6,#1
;;;1212     tmp2 = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_TC);
00010c  6820              LDR      r0,[r4,#0]
00010e  68c0              LDR      r0,[r0,#0xc]
000110  f0000640          AND      r6,r0,#0x40
;;;1213     /* UART in mode Transmitter end --------------------------------------------*/
;;;1214     if((tmp1 != RESET) && (tmp2 != RESET))
000114  b11d              CBZ      r5,|L16.286|
000116  b116              CBZ      r6,|L16.286|
;;;1215     {
;;;1216       UART_EndTransmit_IT(huart);
000118  4620              MOV      r0,r4
00011a  f7fffffe          BL       UART_EndTransmit_IT
                  |L16.286|
;;;1217     }
;;;1218   
;;;1219     if(huart->ErrorCode != HAL_UART_ERROR_NONE)
00011e  6be0              LDR      r0,[r4,#0x3c]
000120  b128              CBZ      r0,|L16.302|
;;;1220     {
;;;1221       /* Set the UART state ready to be able to start again the process */
;;;1222       huart->State = HAL_UART_STATE_READY;
000122  2001              MOVS     r0,#1
000124  f8840039          STRB     r0,[r4,#0x39]
;;;1223       
;;;1224       HAL_UART_ErrorCallback(huart);
000128  4620              MOV      r0,r4
00012a  f7fffffe          BL       HAL_UART_ErrorCallback
                  |L16.302|
;;;1225     }  
;;;1226   }
00012e  bdf8              POP      {r3-r7,pc}
;;;1227   
                          ENDP


                          AREA ||i.HAL_UART_Init||, CODE, READONLY, ALIGN=1

                  HAL_UART_Init PROC
;;;239      */
;;;240    HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;241    {
000002  4604              MOV      r4,r0
;;;242      /* Check the UART handle allocation */
;;;243      if(huart == NULL)
000004  b90c              CBNZ     r4,|L17.10|
;;;244      {
;;;245        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L17.8|
;;;246      }
;;;247    
;;;248      /* Check the parameters */
;;;249      if(huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
;;;250      { 
;;;251        /* The hardware flow control is available only for USART1, USART2, USART3 and USART6 */
;;;252        assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
;;;253        assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
;;;254      }
;;;255      else
;;;256      {
;;;257        assert_param(IS_UART_INSTANCE(huart->Instance));
;;;258      }
;;;259      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;260      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;261      
;;;262      if(huart->State == HAL_UART_STATE_RESET)
;;;263      {  
;;;264        /* Allocate lock resource and initialize it */
;;;265        huart->Lock = HAL_UNLOCKED;
;;;266        /* Init the low level hardware */
;;;267        HAL_UART_MspInit(huart);
;;;268      }
;;;269    
;;;270      huart->State = HAL_UART_STATE_BUSY;
;;;271    
;;;272      /* Disable the peripheral */
;;;273      __HAL_UART_DISABLE(huart);
;;;274      
;;;275      /* Set the UART Communication parameters */
;;;276      UART_SetConfig(huart);
;;;277      
;;;278      /* In asynchronous mode, the following bits must be kept cleared: 
;;;279         - LINEN and CLKEN bits in the USART_CR2 register,
;;;280         - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
;;;281      huart->Instance->CR2 &= ~(USART_CR2_LINEN | USART_CR2_CLKEN);
;;;282      huart->Instance->CR3 &= ~(USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN);
;;;283      
;;;284      /* Enable the peripheral */
;;;285      __HAL_UART_ENABLE(huart);
;;;286      
;;;287      /* Initialize the UART state */
;;;288      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;289      huart->State= HAL_UART_STATE_READY;
;;;290      
;;;291      return HAL_OK;
;;;292    }
000008  bd10              POP      {r4,pc}
                  |L17.10|
00000a  69a0              LDR      r0,[r4,#0x18]         ;249
00000c  b100              CBZ      r0,|L17.16|
00000e  e000              B        |L17.18|
                  |L17.16|
000010  bf00              NOP                            ;257
                  |L17.18|
000012  f8940039          LDRB     r0,[r4,#0x39]         ;262
000016  b928              CBNZ     r0,|L17.36|
000018  2000              MOVS     r0,#0                 ;265
00001a  f8840038          STRB     r0,[r4,#0x38]         ;265
00001e  4620              MOV      r0,r4                 ;267
000020  f7fffffe          BL       HAL_UART_MspInit
                  |L17.36|
000024  2002              MOVS     r0,#2                 ;270
000026  f8840039          STRB     r0,[r4,#0x39]         ;270
00002a  6820              LDR      r0,[r4,#0]            ;273
00002c  68c0              LDR      r0,[r0,#0xc]          ;273
00002e  f4205000          BIC      r0,r0,#0x2000         ;273
000032  6821              LDR      r1,[r4,#0]            ;273
000034  60c8              STR      r0,[r1,#0xc]          ;273
000036  4620              MOV      r0,r4                 ;276
000038  f7fffffe          BL       UART_SetConfig
00003c  6820              LDR      r0,[r4,#0]            ;281
00003e  6900              LDR      r0,[r0,#0x10]         ;281
000040  f4204090          BIC      r0,r0,#0x4800         ;281
000044  6821              LDR      r1,[r4,#0]            ;281
000046  6108              STR      r0,[r1,#0x10]         ;281
000048  6820              LDR      r0,[r4,#0]            ;282
00004a  6940              LDR      r0,[r0,#0x14]         ;282
00004c  f020002a          BIC      r0,r0,#0x2a           ;282
000050  6821              LDR      r1,[r4,#0]            ;282
000052  6148              STR      r0,[r1,#0x14]         ;282
000054  6820              LDR      r0,[r4,#0]            ;285
000056  68c0              LDR      r0,[r0,#0xc]          ;285
000058  f4405000          ORR      r0,r0,#0x2000         ;285
00005c  6821              LDR      r1,[r4,#0]            ;285
00005e  60c8              STR      r0,[r1,#0xc]          ;285
000060  2000              MOVS     r0,#0                 ;288
000062  63e0              STR      r0,[r4,#0x3c]         ;288
000064  2001              MOVS     r0,#1                 ;289
000066  f8840039          STRB     r0,[r4,#0x39]         ;289
00006a  2000              MOVS     r0,#0                 ;291
00006c  e7cc              B        |L17.8|
;;;293    
                          ENDP


                          AREA ||i.HAL_UART_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspDeInit PROC
;;;532      */
;;;533     __weak void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;534    {
;;;535      /* Prevent unused argument(s) compilation warning */
;;;536      UNUSED(huart);
;;;537      /* NOTE: This function Should not be modified, when the callback is needed,
;;;538               the HAL_UART_MspDeInit could be implemented in the user file
;;;539       */ 
;;;540    }
;;;541    
                          ENDP


                          AREA ||i.HAL_UART_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspInit PROC
;;;517      */
;;;518     __weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;519    {
;;;520       /* Prevent unused argument(s) compilation warning */
;;;521      UNUSED(huart);
;;;522      /* NOTE: This function Should not be modified, when the callback is needed,
;;;523               the HAL_UART_MspInit could be implemented in the user file
;;;524       */ 
;;;525    }
;;;526    
                          ENDP


                          AREA ||i.HAL_UART_Receive||, CODE, READONLY, ALIGN=1

                  HAL_UART_Receive PROC
;;;700      */
;;;701    HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;702    { 
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  4699              MOV      r9,r3
;;;703      uint16_t* tmp;
;;;704      uint32_t tmp1 = 0;
00000c  f04f0800          MOV      r8,#0
;;;705      
;;;706      tmp1 = huart->State;
000010  f8948039          LDRB     r8,[r4,#0x39]
;;;707      if((tmp1 == HAL_UART_STATE_READY) || (tmp1 == HAL_UART_STATE_BUSY_TX))
000014  f1b80f01          CMP      r8,#1
000018  d002              BEQ      |L20.32|
00001a  f1b80f12          CMP      r8,#0x12
00001e  d169              BNE      |L20.244|
                  |L20.32|
;;;708      { 
;;;709        if((pData == NULL ) || (Size == 0)) 
000020  b105              CBZ      r5,|L20.36|
000022  b916              CBNZ     r6,|L20.42|
                  |L20.36|
;;;710        {
;;;711          return  HAL_ERROR;
000024  2001              MOVS     r0,#1
                  |L20.38|
;;;712        }
;;;713        
;;;714        /* Process Locked */
;;;715        __HAL_LOCK(huart);
;;;716        
;;;717        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;718        /* Check if a non-blocking transmit process is ongoing or not */
;;;719        if(huart->State == HAL_UART_STATE_BUSY_TX) 
;;;720        {
;;;721          huart->State = HAL_UART_STATE_BUSY_TX_RX;
;;;722        }
;;;723        else
;;;724        {
;;;725          huart->State = HAL_UART_STATE_BUSY_RX;
;;;726        }
;;;727        
;;;728        huart->RxXferSize = Size; 
;;;729        huart->RxXferCount = Size;
;;;730        
;;;731        /* Check the remain data to be received */
;;;732        while(huart->RxXferCount > 0)
;;;733        {
;;;734          huart->RxXferCount--;
;;;735          if(huart->Init.WordLength == UART_WORDLENGTH_9B)
;;;736          {
;;;737            if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, Timeout) != HAL_OK)
;;;738            { 
;;;739              return HAL_TIMEOUT;
;;;740            }
;;;741            tmp = (uint16_t*) pData ;
;;;742            if(huart->Init.Parity == UART_PARITY_NONE)
;;;743            {
;;;744              *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
;;;745              pData +=2;
;;;746            }
;;;747            else
;;;748            {
;;;749              *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
;;;750              pData +=1;
;;;751            }
;;;752    
;;;753          } 
;;;754          else
;;;755          {
;;;756            if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, Timeout) != HAL_OK)
;;;757            { 
;;;758              return HAL_TIMEOUT;
;;;759            }
;;;760            if(huart->Init.Parity == UART_PARITY_NONE)
;;;761            {
;;;762              *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
;;;763            }
;;;764            else
;;;765            {
;;;766              *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
;;;767            }
;;;768            
;;;769          }
;;;770        }
;;;771        
;;;772        /* Check if a non-blocking transmit process is ongoing or not */
;;;773        if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
;;;774        {
;;;775          huart->State = HAL_UART_STATE_BUSY_TX;
;;;776        }
;;;777        else
;;;778        {
;;;779          huart->State = HAL_UART_STATE_READY;
;;;780        } 
;;;781        /* Process Unlocked */
;;;782        __HAL_UNLOCK(huart);
;;;783        
;;;784        return HAL_OK;
;;;785      }
;;;786      else
;;;787      {
;;;788        return HAL_BUSY;   
;;;789      }
;;;790    }
000026  e8bd87f0          POP      {r4-r10,pc}
                  |L20.42|
00002a  bf00              NOP                            ;715
00002c  f8940038          LDRB     r0,[r4,#0x38]         ;715
000030  2801              CMP      r0,#1                 ;715
000032  d101              BNE      |L20.56|
000034  2002              MOVS     r0,#2                 ;715
000036  e7f6              B        |L20.38|
                  |L20.56|
000038  2001              MOVS     r0,#1                 ;715
00003a  f8840038          STRB     r0,[r4,#0x38]         ;715
00003e  bf00              NOP                            ;715
000040  2000              MOVS     r0,#0                 ;717
000042  63e0              STR      r0,[r4,#0x3c]         ;717
000044  f8940039          LDRB     r0,[r4,#0x39]         ;719
000048  2812              CMP      r0,#0x12              ;719
00004a  d103              BNE      |L20.84|
00004c  2032              MOVS     r0,#0x32              ;721
00004e  f8840039          STRB     r0,[r4,#0x39]         ;721
000052  e002              B        |L20.90|
                  |L20.84|
000054  2022              MOVS     r0,#0x22              ;725
000056  f8840039          STRB     r0,[r4,#0x39]         ;725
                  |L20.90|
00005a  85a6              STRH     r6,[r4,#0x2c]         ;728
00005c  85e6              STRH     r6,[r4,#0x2e]         ;729
00005e  e035              B        |L20.204|
                  |L20.96|
000060  8de0              LDRH     r0,[r4,#0x2e]         ;734
000062  1e40              SUBS     r0,r0,#1              ;734
000064  85e0              STRH     r0,[r4,#0x2e]         ;734
000066  68a0              LDR      r0,[r4,#8]            ;735
000068  f5b05f80          CMP      r0,#0x1000            ;735
00006c  d118              BNE      |L20.160|
00006e  464b              MOV      r3,r9                 ;737
000070  2200              MOVS     r2,#0                 ;737
000072  2120              MOVS     r1,#0x20              ;737
000074  4620              MOV      r0,r4                 ;737
000076  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
00007a  b108              CBZ      r0,|L20.128|
00007c  2003              MOVS     r0,#3                 ;739
00007e  e7d2              B        |L20.38|
                  |L20.128|
000080  462f              MOV      r7,r5                 ;741
000082  6920              LDR      r0,[r4,#0x10]         ;742
000084  b930              CBNZ     r0,|L20.148|
000086  6820              LDR      r0,[r4,#0]            ;744
000088  6840              LDR      r0,[r0,#4]            ;744
00008a  f3c00008          UBFX     r0,r0,#0,#9           ;744
00008e  8038              STRH     r0,[r7,#0]            ;744
000090  1cad              ADDS     r5,r5,#2              ;745
000092  e01b              B        |L20.204|
                  |L20.148|
000094  6820              LDR      r0,[r4,#0]            ;749
000096  6840              LDR      r0,[r0,#4]            ;749
000098  b2c0              UXTB     r0,r0                 ;749
00009a  8038              STRH     r0,[r7,#0]            ;749
00009c  1c6d              ADDS     r5,r5,#1              ;750
00009e  e015              B        |L20.204|
                  |L20.160|
0000a0  464b              MOV      r3,r9                 ;756
0000a2  2200              MOVS     r2,#0                 ;756
0000a4  2120              MOVS     r1,#0x20              ;756
0000a6  4620              MOV      r0,r4                 ;756
0000a8  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
0000ac  b108              CBZ      r0,|L20.178|
0000ae  2003              MOVS     r0,#3                 ;758
0000b0  e7b9              B        |L20.38|
                  |L20.178|
0000b2  6920              LDR      r0,[r4,#0x10]         ;760
0000b4  b920              CBNZ     r0,|L20.192|
0000b6  6820              LDR      r0,[r4,#0]            ;762
0000b8  6840              LDR      r0,[r0,#4]            ;762
0000ba  f8050b01          STRB     r0,[r5],#1            ;762
0000be  e005              B        |L20.204|
                  |L20.192|
0000c0  6820              LDR      r0,[r4,#0]            ;766
0000c2  6840              LDR      r0,[r0,#4]            ;766
0000c4  f000007f          AND      r0,r0,#0x7f           ;766
0000c8  f8050b01          STRB     r0,[r5],#1            ;766
                  |L20.204|
0000cc  8de0              LDRH     r0,[r4,#0x2e]         ;732
0000ce  2800              CMP      r0,#0                 ;732
0000d0  dcc6              BGT      |L20.96|
0000d2  f8940039          LDRB     r0,[r4,#0x39]         ;773
0000d6  2832              CMP      r0,#0x32              ;773
0000d8  d103              BNE      |L20.226|
0000da  2012              MOVS     r0,#0x12              ;775
0000dc  f8840039          STRB     r0,[r4,#0x39]         ;775
0000e0  e002              B        |L20.232|
                  |L20.226|
0000e2  2001              MOVS     r0,#1                 ;779
0000e4  f8840039          STRB     r0,[r4,#0x39]         ;779
                  |L20.232|
0000e8  bf00              NOP                            ;782
0000ea  2000              MOVS     r0,#0                 ;782
0000ec  f8840038          STRB     r0,[r4,#0x38]         ;782
0000f0  bf00              NOP                            ;782
0000f2  e798              B        |L20.38|
                  |L20.244|
0000f4  2002              MOVS     r0,#2                 ;788
0000f6  e796              B        |L20.38|
;;;791    
                          ENDP


                          AREA ||i.HAL_UART_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Receive_DMA PROC
;;;980      */
;;;981    HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;982    {
000002  4604              MOV      r4,r0
000004  4615              MOV      r5,r2
;;;983      uint32_t *tmp;
;;;984      uint32_t tmp1 = 0;
000006  2700              MOVS     r7,#0
;;;985      
;;;986      tmp1 = huart->State;    
000008  f8947039          LDRB     r7,[r4,#0x39]
;;;987      if((tmp1 == HAL_UART_STATE_READY) || (tmp1 == HAL_UART_STATE_BUSY_TX))
00000c  2f01              CMP      r7,#1
00000e  d001              BEQ      |L21.20|
000010  2f12              CMP      r7,#0x12
000012  d13c              BNE      |L21.142|
                  |L21.20|
;;;988      {
;;;989        if((pData == NULL ) || (Size == 0)) 
000014  9801              LDR      r0,[sp,#4]
000016  b100              CBZ      r0,|L21.26|
000018  b90d              CBNZ     r5,|L21.30|
                  |L21.26|
;;;990        {
;;;991          return HAL_ERROR;
00001a  2001              MOVS     r0,#1
                  |L21.28|
;;;992        }
;;;993        
;;;994        /* Process Locked */
;;;995        __HAL_LOCK(huart);
;;;996        
;;;997        huart->pRxBuffPtr = pData;
;;;998        huart->RxXferSize = Size;
;;;999        
;;;1000       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1001       /* Check if a transmit process is ongoing or not */
;;;1002       if(huart->State == HAL_UART_STATE_BUSY_TX) 
;;;1003       {
;;;1004         huart->State = HAL_UART_STATE_BUSY_TX_RX;
;;;1005       }
;;;1006       else
;;;1007       {
;;;1008         huart->State = HAL_UART_STATE_BUSY_RX;
;;;1009       }
;;;1010       
;;;1011       /* Set the UART DMA transfer complete callback */
;;;1012       huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
;;;1013       
;;;1014       /* Set the UART DMA Half transfer complete callback */
;;;1015       huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
;;;1016       
;;;1017       /* Set the DMA error callback */
;;;1018       huart->hdmarx->XferErrorCallback = UART_DMAError;
;;;1019   
;;;1020       /* Enable the DMA Stream */
;;;1021       tmp = (uint32_t*)&pData;
;;;1022       HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->DR, *(uint32_t*)tmp, Size);
;;;1023       
;;;1024       /* Enable the DMA transfer for the receiver request by setting the DMAR bit 
;;;1025       in the UART CR3 register */
;;;1026       huart->Instance->CR3 |= USART_CR3_DMAR;
;;;1027       
;;;1028       /* Process Unlocked */
;;;1029       __HAL_UNLOCK(huart);
;;;1030       
;;;1031       return HAL_OK;
;;;1032     }
;;;1033     else
;;;1034     {
;;;1035       return HAL_BUSY; 
;;;1036     }
;;;1037   }
00001c  bdfe              POP      {r1-r7,pc}
                  |L21.30|
00001e  bf00              NOP                            ;995
000020  f8940038          LDRB     r0,[r4,#0x38]         ;995
000024  2801              CMP      r0,#1                 ;995
000026  d101              BNE      |L21.44|
000028  2002              MOVS     r0,#2                 ;995
00002a  e7f7              B        |L21.28|
                  |L21.44|
00002c  2001              MOVS     r0,#1                 ;995
00002e  f8840038          STRB     r0,[r4,#0x38]         ;995
000032  bf00              NOP                            ;995
000034  9801              LDR      r0,[sp,#4]            ;997
000036  62a0              STR      r0,[r4,#0x28]         ;997
000038  85a5              STRH     r5,[r4,#0x2c]         ;998
00003a  2000              MOVS     r0,#0                 ;1000
00003c  63e0              STR      r0,[r4,#0x3c]         ;1000
00003e  f8940039          LDRB     r0,[r4,#0x39]         ;1002
000042  2812              CMP      r0,#0x12              ;1002
000044  d103              BNE      |L21.78|
000046  2032              MOVS     r0,#0x32              ;1004
000048  f8840039          STRB     r0,[r4,#0x39]         ;1004
00004c  e002              B        |L21.84|
                  |L21.78|
00004e  2022              MOVS     r0,#0x22              ;1008
000050  f8840039          STRB     r0,[r4,#0x39]         ;1008
                  |L21.84|
000054  480f              LDR      r0,|L21.148|
000056  6b61              LDR      r1,[r4,#0x34]         ;1012
000058  63c8              STR      r0,[r1,#0x3c]         ;1012
00005a  480f              LDR      r0,|L21.152|
00005c  6b61              LDR      r1,[r4,#0x34]         ;1015
00005e  6408              STR      r0,[r1,#0x40]         ;1015
000060  480e              LDR      r0,|L21.156|
000062  6b61              LDR      r1,[r4,#0x34]         ;1018
000064  6488              STR      r0,[r1,#0x48]         ;1018
000066  ae01              ADD      r6,sp,#4              ;1021
000068  6832              LDR      r2,[r6,#0]            ;1022
00006a  6823              LDR      r3,[r4,#0]            ;1022
00006c  1d19              ADDS     r1,r3,#4              ;1022
00006e  462b              MOV      r3,r5                 ;1022
000070  6b60              LDR      r0,[r4,#0x34]         ;1022
000072  f7fffffe          BL       HAL_DMA_Start_IT
000076  6820              LDR      r0,[r4,#0]            ;1026
000078  6940              LDR      r0,[r0,#0x14]         ;1026
00007a  f0400040          ORR      r0,r0,#0x40           ;1026
00007e  6821              LDR      r1,[r4,#0]            ;1026
000080  6148              STR      r0,[r1,#0x14]         ;1026
000082  bf00              NOP                            ;1029
000084  2000              MOVS     r0,#0                 ;1029
000086  f8840038          STRB     r0,[r4,#0x38]         ;1029
00008a  bf00              NOP                            ;1029
00008c  e7c6              B        |L21.28|
                  |L21.142|
00008e  2002              MOVS     r0,#2                 ;1035
000090  e7c4              B        |L21.28|
;;;1038       
                          ENDP

000092  0000              DCW      0x0000
                  |L21.148|
                          DCD      UART_DMAReceiveCplt
                  |L21.152|
                          DCD      UART_DMARxHalfCplt
                  |L21.156|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Receive_IT||, CODE, READONLY, ALIGN=1

                  HAL_UART_Receive_IT PROC
;;;851      */
;;;852    HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b530              PUSH     {r4,r5,lr}
;;;853    {
000002  4603              MOV      r3,r0
;;;854      uint32_t tmp = 0;
000004  2400              MOVS     r4,#0
;;;855      
;;;856      tmp = huart->State;  
000006  f8934039          LDRB     r4,[r3,#0x39]
;;;857      if((tmp == HAL_UART_STATE_READY) || (tmp == HAL_UART_STATE_BUSY_TX))
00000a  2c01              CMP      r4,#1
00000c  d001              BEQ      |L22.18|
00000e  2c12              CMP      r4,#0x12
000010  d137              BNE      |L22.130|
                  |L22.18|
;;;858      {
;;;859        if((pData == NULL ) || (Size == 0)) 
000012  b101              CBZ      r1,|L22.22|
000014  b90a              CBNZ     r2,|L22.26|
                  |L22.22|
;;;860        {
;;;861          return HAL_ERROR;
000016  2001              MOVS     r0,#1
                  |L22.24|
;;;862        }
;;;863        
;;;864        /* Process Locked */
;;;865        __HAL_LOCK(huart);
;;;866        
;;;867        huart->pRxBuffPtr = pData;
;;;868        huart->RxXferSize = Size;
;;;869        huart->RxXferCount = Size;
;;;870        
;;;871        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;872        /* Check if a transmit process is ongoing or not */
;;;873        if(huart->State == HAL_UART_STATE_BUSY_TX) 
;;;874        {
;;;875          huart->State = HAL_UART_STATE_BUSY_TX_RX;
;;;876        }
;;;877        else
;;;878        {
;;;879          huart->State = HAL_UART_STATE_BUSY_RX;
;;;880        }
;;;881        
;;;882        /* Enable the UART Parity Error Interrupt */
;;;883        __HAL_UART_ENABLE_IT(huart, UART_IT_PE);
;;;884        
;;;885        /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;886        __HAL_UART_ENABLE_IT(huart, UART_IT_ERR);
;;;887        
;;;888        /* Process Unlocked */
;;;889        __HAL_UNLOCK(huart);
;;;890        
;;;891        /* Enable the UART Data Register not empty Interrupt */
;;;892        __HAL_UART_ENABLE_IT(huart, UART_IT_RXNE);
;;;893        
;;;894        return HAL_OK;
;;;895      }
;;;896      else
;;;897      {
;;;898        return HAL_BUSY; 
;;;899      }
;;;900    }
000018  bd30              POP      {r4,r5,pc}
                  |L22.26|
00001a  bf00              NOP                            ;865
00001c  f8930038          LDRB     r0,[r3,#0x38]         ;865
000020  2801              CMP      r0,#1                 ;865
000022  d101              BNE      |L22.40|
000024  2002              MOVS     r0,#2                 ;865
000026  e7f7              B        |L22.24|
                  |L22.40|
000028  2001              MOVS     r0,#1                 ;865
00002a  f8830038          STRB     r0,[r3,#0x38]         ;865
00002e  bf00              NOP                            ;865
000030  6299              STR      r1,[r3,#0x28]         ;867
000032  859a              STRH     r2,[r3,#0x2c]         ;868
000034  85da              STRH     r2,[r3,#0x2e]         ;869
000036  2000              MOVS     r0,#0                 ;871
000038  63d8              STR      r0,[r3,#0x3c]         ;871
00003a  f8930039          LDRB     r0,[r3,#0x39]         ;873
00003e  2812              CMP      r0,#0x12              ;873
000040  d103              BNE      |L22.74|
000042  2032              MOVS     r0,#0x32              ;875
000044  f8830039          STRB     r0,[r3,#0x39]         ;875
000048  e002              B        |L22.80|
                  |L22.74|
00004a  2022              MOVS     r0,#0x22              ;879
00004c  f8830039          STRB     r0,[r3,#0x39]         ;879
                  |L22.80|
000050  6818              LDR      r0,[r3,#0]            ;883
000052  68c0              LDR      r0,[r0,#0xc]          ;883
000054  f4407080          ORR      r0,r0,#0x100          ;883
000058  681d              LDR      r5,[r3,#0]            ;883
00005a  60e8              STR      r0,[r5,#0xc]          ;883
00005c  6818              LDR      r0,[r3,#0]            ;886
00005e  6940              LDR      r0,[r0,#0x14]         ;886
000060  f0400001          ORR      r0,r0,#1              ;886
000064  681d              LDR      r5,[r3,#0]            ;886
000066  6168              STR      r0,[r5,#0x14]         ;886
000068  bf00              NOP                            ;889
00006a  2000              MOVS     r0,#0                 ;889
00006c  f8830038          STRB     r0,[r3,#0x38]         ;889
000070  bf00              NOP                            ;889
000072  6818              LDR      r0,[r3,#0]            ;892
000074  68c0              LDR      r0,[r0,#0xc]          ;892
000076  f0400020          ORR      r0,r0,#0x20           ;892
00007a  681d              LDR      r5,[r3,#0]            ;892
00007c  60e8              STR      r0,[r5,#0xc]          ;892
00007e  2000              MOVS     r0,#0                 ;894
000080  e7ca              B        |L22.24|
                  |L22.130|
000082  2002              MOVS     r0,#2                 ;898
000084  e7c8              B        |L22.24|
;;;901    
                          ENDP


                          AREA ||i.HAL_UART_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxCpltCallback PROC
;;;1266   
;;;1267   __weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1268   {
;;;1269     UNUSED(huart);
;;;1270   }
;;;1271   
                          ENDP


                          AREA ||i.HAL_UART_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxHalfCpltCallback PROC
;;;1279     */
;;;1280   __weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1281   {
;;;1282     /* Prevent unused argument(s) compilation warning */
;;;1283     UNUSED(huart);
;;;1284     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1285              the HAL_UART_TxCpltCallback could be implemented in the user file
;;;1286      */
;;;1287   }
;;;1288   
                          ENDP


                          AREA ||i.HAL_UART_Transmit||, CODE, READONLY, ALIGN=1

                  HAL_UART_Transmit PROC
;;;606      */
;;;607    HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;608    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  4699              MOV      r9,r3
;;;609      uint16_t* tmp;
;;;610      uint32_t tmp1 = 0;
00000c  f04f0800          MOV      r8,#0
;;;611      
;;;612      tmp1 = huart->State;
000010  f8948039          LDRB     r8,[r4,#0x39]
;;;613      if((tmp1 == HAL_UART_STATE_READY) || (tmp1 == HAL_UART_STATE_BUSY_RX))
000014  f1b80f01          CMP      r8,#1
000018  d002              BEQ      |L25.32|
00001a  f1b80f22          CMP      r8,#0x22
00001e  d165              BNE      |L25.236|
                  |L25.32|
;;;614      {
;;;615        if((pData == NULL ) || (Size == 0)) 
000020  b105              CBZ      r5,|L25.36|
000022  b916              CBNZ     r6,|L25.42|
                  |L25.36|
;;;616        {
;;;617          return  HAL_ERROR;
000024  2001              MOVS     r0,#1
                  |L25.38|
;;;618        }
;;;619        
;;;620        /* Process Locked */
;;;621        __HAL_LOCK(huart);
;;;622        
;;;623        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;624        /* Check if a non-blocking receive process is ongoing or not */
;;;625        if(huart->State == HAL_UART_STATE_BUSY_RX) 
;;;626        {
;;;627          huart->State = HAL_UART_STATE_BUSY_TX_RX;
;;;628        }
;;;629        else
;;;630        {
;;;631          huart->State = HAL_UART_STATE_BUSY_TX;
;;;632        }
;;;633    
;;;634        huart->TxXferSize = Size;
;;;635        huart->TxXferCount = Size;
;;;636        while(huart->TxXferCount > 0)
;;;637        {
;;;638          huart->TxXferCount--;
;;;639          if(huart->Init.WordLength == UART_WORDLENGTH_9B)
;;;640          {
;;;641            if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, Timeout) != HAL_OK)
;;;642            { 
;;;643              return HAL_TIMEOUT;
;;;644            }
;;;645            tmp = (uint16_t*) pData;
;;;646            huart->Instance->DR = (*tmp & (uint16_t)0x01FF);
;;;647            if(huart->Init.Parity == UART_PARITY_NONE)
;;;648            {
;;;649              pData +=2;
;;;650            }
;;;651            else
;;;652            { 
;;;653              pData +=1;
;;;654            }
;;;655          } 
;;;656          else
;;;657          {
;;;658            if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, Timeout) != HAL_OK)
;;;659            {
;;;660              return HAL_TIMEOUT;
;;;661            }
;;;662            huart->Instance->DR = (*pData++ & (uint8_t)0xFF);
;;;663          } 
;;;664        }
;;;665        
;;;666        if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, Timeout) != HAL_OK)
;;;667        { 
;;;668          return HAL_TIMEOUT;
;;;669        }
;;;670        
;;;671        /* Check if a non-blocking receive process is ongoing or not */
;;;672        if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
;;;673        {
;;;674          huart->State = HAL_UART_STATE_BUSY_RX;
;;;675        }
;;;676        else
;;;677        {
;;;678          huart->State = HAL_UART_STATE_READY;
;;;679        }
;;;680        
;;;681        /* Process Unlocked */
;;;682        __HAL_UNLOCK(huart);
;;;683        
;;;684        return HAL_OK;
;;;685      }
;;;686      else
;;;687      {
;;;688        return HAL_BUSY;   
;;;689      }
;;;690    }
000026  e8bd87f0          POP      {r4-r10,pc}
                  |L25.42|
00002a  bf00              NOP                            ;621
00002c  f8940038          LDRB     r0,[r4,#0x38]         ;621
000030  2801              CMP      r0,#1                 ;621
000032  d101              BNE      |L25.56|
000034  2002              MOVS     r0,#2                 ;621
000036  e7f6              B        |L25.38|
                  |L25.56|
000038  2001              MOVS     r0,#1                 ;621
00003a  f8840038          STRB     r0,[r4,#0x38]         ;621
00003e  bf00              NOP                            ;621
000040  2000              MOVS     r0,#0                 ;623
000042  63e0              STR      r0,[r4,#0x3c]         ;623
000044  f8940039          LDRB     r0,[r4,#0x39]         ;625
000048  2822              CMP      r0,#0x22              ;625
00004a  d103              BNE      |L25.84|
00004c  2032              MOVS     r0,#0x32              ;627
00004e  f8840039          STRB     r0,[r4,#0x39]         ;627
000052  e002              B        |L25.90|
                  |L25.84|
000054  2012              MOVS     r0,#0x12              ;631
000056  f8840039          STRB     r0,[r4,#0x39]         ;631
                  |L25.90|
00005a  84a6              STRH     r6,[r4,#0x24]         ;634
00005c  84e6              STRH     r6,[r4,#0x26]         ;635
00005e  e028              B        |L25.178|
                  |L25.96|
000060  8ce0              LDRH     r0,[r4,#0x26]         ;638
000062  1e40              SUBS     r0,r0,#1              ;638
000064  84e0              STRH     r0,[r4,#0x26]         ;638
000066  68a0              LDR      r0,[r4,#8]            ;639
000068  f5b05f80          CMP      r0,#0x1000            ;639
00006c  d114              BNE      |L25.152|
00006e  464b              MOV      r3,r9                 ;641
000070  2200              MOVS     r2,#0                 ;641
000072  2180              MOVS     r1,#0x80              ;641
000074  4620              MOV      r0,r4                 ;641
000076  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
00007a  b108              CBZ      r0,|L25.128|
00007c  2003              MOVS     r0,#3                 ;643
00007e  e7d2              B        |L25.38|
                  |L25.128|
000080  462f              MOV      r7,r5                 ;645
000082  8838              LDRH     r0,[r7,#0]            ;646
000084  f3c00008          UBFX     r0,r0,#0,#9           ;646
000088  6821              LDR      r1,[r4,#0]            ;646
00008a  6048              STR      r0,[r1,#4]            ;646
00008c  6920              LDR      r0,[r4,#0x10]         ;647
00008e  b908              CBNZ     r0,|L25.148|
000090  1cad              ADDS     r5,r5,#2              ;649
000092  e00e              B        |L25.178|
                  |L25.148|
000094  1c6d              ADDS     r5,r5,#1              ;653
000096  e00c              B        |L25.178|
                  |L25.152|
000098  464b              MOV      r3,r9                 ;658
00009a  2200              MOVS     r2,#0                 ;658
00009c  2180              MOVS     r1,#0x80              ;658
00009e  4620              MOV      r0,r4                 ;658
0000a0  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
0000a4  b108              CBZ      r0,|L25.170|
0000a6  2003              MOVS     r0,#3                 ;660
0000a8  e7bd              B        |L25.38|
                  |L25.170|
0000aa  f8150b01          LDRB     r0,[r5],#1            ;662
0000ae  6821              LDR      r1,[r4,#0]            ;662
0000b0  6048              STR      r0,[r1,#4]            ;662
                  |L25.178|
0000b2  8ce0              LDRH     r0,[r4,#0x26]         ;636
0000b4  2800              CMP      r0,#0                 ;636
0000b6  dcd3              BGT      |L25.96|
0000b8  464b              MOV      r3,r9                 ;666
0000ba  2200              MOVS     r2,#0                 ;666
0000bc  2140              MOVS     r1,#0x40              ;666
0000be  4620              MOV      r0,r4                 ;666
0000c0  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
0000c4  b108              CBZ      r0,|L25.202|
0000c6  2003              MOVS     r0,#3                 ;668
0000c8  e7ad              B        |L25.38|
                  |L25.202|
0000ca  f8940039          LDRB     r0,[r4,#0x39]         ;672
0000ce  2832              CMP      r0,#0x32              ;672
0000d0  d103              BNE      |L25.218|
0000d2  2022              MOVS     r0,#0x22              ;674
0000d4  f8840039          STRB     r0,[r4,#0x39]         ;674
0000d8  e002              B        |L25.224|
                  |L25.218|
0000da  2001              MOVS     r0,#1                 ;678
0000dc  f8840039          STRB     r0,[r4,#0x39]         ;678
                  |L25.224|
0000e0  bf00              NOP                            ;682
0000e2  2000              MOVS     r0,#0                 ;682
0000e4  f8840038          STRB     r0,[r4,#0x38]         ;682
0000e8  bf00              NOP                            ;682
0000ea  e79c              B        |L25.38|
                  |L25.236|
0000ec  2002              MOVS     r0,#2                 ;688
0000ee  e79a              B        |L25.38|
;;;691    
                          ENDP


                          AREA ||i.HAL_UART_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Transmit_DMA PROC
;;;909      */
;;;910    HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;911    {
000002  4604              MOV      r4,r0
000004  4615              MOV      r5,r2
;;;912      uint32_t *tmp;
;;;913      uint32_t tmp1 = 0;
000006  2700              MOVS     r7,#0
;;;914      
;;;915      tmp1 = huart->State;  
000008  f8947039          LDRB     r7,[r4,#0x39]
;;;916      if((tmp1 == HAL_UART_STATE_READY) || (tmp1 == HAL_UART_STATE_BUSY_RX))
00000c  2f01              CMP      r7,#1
00000e  d001              BEQ      |L26.20|
000010  2f22              CMP      r7,#0x22
000012  d141              BNE      |L26.152|
                  |L26.20|
;;;917      {
;;;918        if((pData == NULL ) || (Size == 0)) 
000014  9801              LDR      r0,[sp,#4]
000016  b100              CBZ      r0,|L26.26|
000018  b90d              CBNZ     r5,|L26.30|
                  |L26.26|
;;;919        {
;;;920          return HAL_ERROR;
00001a  2001              MOVS     r0,#1
                  |L26.28|
;;;921        }
;;;922        
;;;923        /* Process Locked */
;;;924        __HAL_LOCK(huart);
;;;925        
;;;926        huart->pTxBuffPtr = pData;
;;;927        huart->TxXferSize = Size;
;;;928        huart->TxXferCount = Size;
;;;929        
;;;930        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;931        /* Check if a receive process is ongoing or not */
;;;932        if(huart->State == HAL_UART_STATE_BUSY_RX) 
;;;933        {
;;;934          huart->State = HAL_UART_STATE_BUSY_TX_RX;
;;;935        }
;;;936        else
;;;937        {
;;;938          huart->State = HAL_UART_STATE_BUSY_TX;
;;;939        }
;;;940        
;;;941        /* Set the UART DMA transfer complete callback */
;;;942        huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
;;;943        
;;;944        /* Set the UART DMA Half transfer complete callback */
;;;945        huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
;;;946        
;;;947        /* Set the DMA error callback */
;;;948        huart->hdmatx->XferErrorCallback = UART_DMAError;
;;;949    
;;;950        /* Enable the UART transmit DMA Stream */
;;;951        tmp = (uint32_t*)&pData;
;;;952        HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t*)tmp, (uint32_t)&huart->Instance->DR, Size);
;;;953        
;;;954        /* Clear the TC flag in the SR register by writing 0 to it */
;;;955        __HAL_UART_CLEAR_FLAG(huart, UART_FLAG_TC);
;;;956        
;;;957        /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;958           in the UART CR3 register */
;;;959        huart->Instance->CR3 |= USART_CR3_DMAT;
;;;960        
;;;961        /* Process Unlocked */
;;;962        __HAL_UNLOCK(huart);
;;;963        
;;;964        return HAL_OK;
;;;965      }
;;;966      else
;;;967      {
;;;968        return HAL_BUSY;   
;;;969      }
;;;970    }
00001c  bdfe              POP      {r1-r7,pc}
                  |L26.30|
00001e  bf00              NOP                            ;924
000020  f8940038          LDRB     r0,[r4,#0x38]         ;924
000024  2801              CMP      r0,#1                 ;924
000026  d101              BNE      |L26.44|
000028  2002              MOVS     r0,#2                 ;924
00002a  e7f7              B        |L26.28|
                  |L26.44|
00002c  2001              MOVS     r0,#1                 ;924
00002e  f8840038          STRB     r0,[r4,#0x38]         ;924
000032  bf00              NOP                            ;924
000034  9801              LDR      r0,[sp,#4]            ;926
000036  6220              STR      r0,[r4,#0x20]         ;926
000038  84a5              STRH     r5,[r4,#0x24]         ;927
00003a  84e5              STRH     r5,[r4,#0x26]         ;928
00003c  2000              MOVS     r0,#0                 ;930
00003e  63e0              STR      r0,[r4,#0x3c]         ;930
000040  f8940039          LDRB     r0,[r4,#0x39]         ;932
000044  2822              CMP      r0,#0x22              ;932
000046  d103              BNE      |L26.80|
000048  2032              MOVS     r0,#0x32              ;934
00004a  f8840039          STRB     r0,[r4,#0x39]         ;934
00004e  e002              B        |L26.86|
                  |L26.80|
000050  2012              MOVS     r0,#0x12              ;938
000052  f8840039          STRB     r0,[r4,#0x39]         ;938
                  |L26.86|
000056  4811              LDR      r0,|L26.156|
000058  6b21              LDR      r1,[r4,#0x30]         ;942
00005a  63c8              STR      r0,[r1,#0x3c]         ;942
00005c  4810              LDR      r0,|L26.160|
00005e  6b21              LDR      r1,[r4,#0x30]         ;945
000060  6408              STR      r0,[r1,#0x40]         ;945
000062  4810              LDR      r0,|L26.164|
000064  6b21              LDR      r1,[r4,#0x30]         ;948
000066  6488              STR      r0,[r1,#0x48]         ;948
000068  ae01              ADD      r6,sp,#4              ;951
00006a  6823              LDR      r3,[r4,#0]            ;952
00006c  1d1a              ADDS     r2,r3,#4              ;952
00006e  6831              LDR      r1,[r6,#0]            ;952
000070  462b              MOV      r3,r5                 ;952
000072  6b20              LDR      r0,[r4,#0x30]         ;952
000074  f7fffffe          BL       HAL_DMA_Start_IT
000078  f06f0040          MVN      r0,#0x40              ;955
00007c  6821              LDR      r1,[r4,#0]            ;955
00007e  6008              STR      r0,[r1,#0]            ;955
000080  6820              LDR      r0,[r4,#0]            ;959
000082  6940              LDR      r0,[r0,#0x14]         ;959
000084  f0400080          ORR      r0,r0,#0x80           ;959
000088  6821              LDR      r1,[r4,#0]            ;959
00008a  6148              STR      r0,[r1,#0x14]         ;959
00008c  bf00              NOP                            ;962
00008e  2000              MOVS     r0,#0                 ;962
000090  f8840038          STRB     r0,[r4,#0x38]         ;962
000094  bf00              NOP                            ;962
000096  e7c1              B        |L26.28|
                  |L26.152|
000098  2002              MOVS     r0,#2                 ;968
00009a  e7bf              B        |L26.28|
;;;971    
                          ENDP

                  |L26.156|
                          DCD      UART_DMATransmitCplt
                  |L26.160|
                          DCD      UART_DMATxHalfCplt
                  |L26.164|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  HAL_UART_Transmit_IT PROC
;;;799      */
;;;800    HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b530              PUSH     {r4,r5,lr}
;;;801    {
000002  4603              MOV      r3,r0
;;;802      uint32_t tmp = 0;
000004  2400              MOVS     r4,#0
;;;803      
;;;804      tmp = huart->State;
000006  f8934039          LDRB     r4,[r3,#0x39]
;;;805      if((tmp == HAL_UART_STATE_READY) || (tmp == HAL_UART_STATE_BUSY_RX))
00000a  2c01              CMP      r4,#1
00000c  d001              BEQ      |L27.18|
00000e  2c22              CMP      r4,#0x22
000010  d12b              BNE      |L27.106|
                  |L27.18|
;;;806      {
;;;807        if((pData == NULL ) || (Size == 0)) 
000012  b101              CBZ      r1,|L27.22|
000014  b90a              CBNZ     r2,|L27.26|
                  |L27.22|
;;;808        {
;;;809          return HAL_ERROR;
000016  2001              MOVS     r0,#1
                  |L27.24|
;;;810        }
;;;811        
;;;812        /* Process Locked */
;;;813        __HAL_LOCK(huart);
;;;814        
;;;815        huart->pTxBuffPtr = pData;
;;;816        huart->TxXferSize = Size;
;;;817        huart->TxXferCount = Size;
;;;818    
;;;819        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;820        /* Check if a receive process is ongoing or not */
;;;821        if(huart->State == HAL_UART_STATE_BUSY_RX) 
;;;822        {
;;;823          huart->State = HAL_UART_STATE_BUSY_TX_RX;
;;;824        }
;;;825        else
;;;826        {
;;;827          huart->State = HAL_UART_STATE_BUSY_TX;
;;;828        }
;;;829    
;;;830        /* Process Unlocked */
;;;831        __HAL_UNLOCK(huart);
;;;832    
;;;833        /* Enable the UART Transmit data register empty Interrupt */
;;;834        __HAL_UART_ENABLE_IT(huart, UART_IT_TXE);
;;;835        
;;;836        return HAL_OK;
;;;837      }
;;;838      else
;;;839      {
;;;840        return HAL_BUSY;   
;;;841      }
;;;842    }
000018  bd30              POP      {r4,r5,pc}
                  |L27.26|
00001a  bf00              NOP                            ;813
00001c  f8930038          LDRB     r0,[r3,#0x38]         ;813
000020  2801              CMP      r0,#1                 ;813
000022  d101              BNE      |L27.40|
000024  2002              MOVS     r0,#2                 ;813
000026  e7f7              B        |L27.24|
                  |L27.40|
000028  2001              MOVS     r0,#1                 ;813
00002a  f8830038          STRB     r0,[r3,#0x38]         ;813
00002e  bf00              NOP                            ;813
000030  6219              STR      r1,[r3,#0x20]         ;815
000032  849a              STRH     r2,[r3,#0x24]         ;816
000034  84da              STRH     r2,[r3,#0x26]         ;817
000036  2000              MOVS     r0,#0                 ;819
000038  63d8              STR      r0,[r3,#0x3c]         ;819
00003a  f8930039          LDRB     r0,[r3,#0x39]         ;821
00003e  2822              CMP      r0,#0x22              ;821
000040  d103              BNE      |L27.74|
000042  2032              MOVS     r0,#0x32              ;823
000044  f8830039          STRB     r0,[r3,#0x39]         ;823
000048  e002              B        |L27.80|
                  |L27.74|
00004a  2012              MOVS     r0,#0x12              ;827
00004c  f8830039          STRB     r0,[r3,#0x39]         ;827
                  |L27.80|
000050  bf00              NOP                            ;831
000052  2000              MOVS     r0,#0                 ;831
000054  f8830038          STRB     r0,[r3,#0x38]         ;831
000058  bf00              NOP                            ;831
00005a  6818              LDR      r0,[r3,#0]            ;834
00005c  68c0              LDR      r0,[r0,#0xc]          ;834
00005e  f0400080          ORR      r0,r0,#0x80           ;834
000062  681d              LDR      r5,[r3,#0]            ;834
000064  60e8              STR      r0,[r5,#0xc]          ;834
000066  2000              MOVS     r0,#0                 ;836
000068  e7d6              B        |L27.24|
                  |L27.106|
00006a  2002              MOVS     r0,#2                 ;840
00006c  e7d4              B        |L27.24|
;;;843    
                          ENDP


                          AREA ||i.HAL_UART_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxCpltCallback PROC
;;;1233     */
;;;1234    __weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1235   {
;;;1236     /* Prevent unused argument(s) compilation warning */
;;;1237     UNUSED(huart);
;;;1238     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1239              the HAL_UART_TxCpltCallback could be implemented in the user file
;;;1240      */ 
;;;1241   }
;;;1242   
                          ENDP


                          AREA ||i.HAL_UART_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxHalfCpltCallback PROC
;;;1248     */
;;;1249    __weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1250   {
;;;1251     /* Prevent unused argument(s) compilation warning */
;;;1252     UNUSED(huart);
;;;1253     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1254              the HAL_UART_TxCpltCallback could be implemented in the user file
;;;1255      */ 
;;;1256   }
;;;1257   
                          ENDP


                          AREA ||i.UART_DMAError||, CODE, READONLY, ALIGN=1

                  UART_DMAError PROC
;;;1611     */
;;;1612   static void UART_DMAError(DMA_HandleTypeDef *hdma)   
000000  b570              PUSH     {r4-r6,lr}
;;;1613   {
000002  4605              MOV      r5,r0
;;;1614     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;1615     huart->RxXferCount = 0;
000006  2000              MOVS     r0,#0
000008  85e0              STRH     r0,[r4,#0x2e]
;;;1616     huart->TxXferCount = 0;
00000a  84e0              STRH     r0,[r4,#0x26]
;;;1617     huart->State= HAL_UART_STATE_READY;
00000c  2001              MOVS     r0,#1
00000e  f8840039          STRB     r0,[r4,#0x39]
;;;1618     huart->ErrorCode |= HAL_UART_ERROR_DMA;
000012  6be0              LDR      r0,[r4,#0x3c]
000014  f0400010          ORR      r0,r0,#0x10
000018  63e0              STR      r0,[r4,#0x3c]
;;;1619     HAL_UART_ErrorCallback(huart);
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       HAL_UART_ErrorCallback
;;;1620   }
000020  bd70              POP      {r4-r6,pc}
;;;1621   
                          ENDP


                          AREA ||i.UART_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  UART_DMAReceiveCplt PROC
;;;1568     */
;;;1569   static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)  
000000  b570              PUSH     {r4-r6,lr}
;;;1570   {
000002  4605              MOV      r5,r0
;;;1571     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;1572     /* DMA Normal mode*/
;;;1573     if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
000006  6828              LDR      r0,[r5,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  f4007080          AND      r0,r0,#0x100
00000e  b990              CBNZ     r0,|L31.54|
;;;1574     {
;;;1575       huart->RxXferCount = 0;
000010  2000              MOVS     r0,#0
000012  85e0              STRH     r0,[r4,#0x2e]
;;;1576     
;;;1577       /* Disable the DMA transfer for the receiver request by setting the DMAR bit 
;;;1578          in the UART CR3 register */
;;;1579       huart->Instance->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DMAR);
000014  6820              LDR      r0,[r4,#0]
000016  6940              LDR      r0,[r0,#0x14]
000018  f0200040          BIC      r0,r0,#0x40
00001c  6821              LDR      r1,[r4,#0]
00001e  6148              STR      r0,[r1,#0x14]
;;;1580   
;;;1581       /* Check if a transmit process is ongoing or not */
;;;1582       if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
000020  f8940039          LDRB     r0,[r4,#0x39]
000024  2832              CMP      r0,#0x32
000026  d103              BNE      |L31.48|
;;;1583       {
;;;1584         huart->State = HAL_UART_STATE_BUSY_TX;
000028  2012              MOVS     r0,#0x12
00002a  f8840039          STRB     r0,[r4,#0x39]
00002e  e002              B        |L31.54|
                  |L31.48|
;;;1585       }
;;;1586       else
;;;1587       {
;;;1588         huart->State = HAL_UART_STATE_READY;
000030  2001              MOVS     r0,#1
000032  f8840039          STRB     r0,[r4,#0x39]
                  |L31.54|
;;;1589       }
;;;1590     }
;;;1591     HAL_UART_RxCpltCallback(huart);
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       HAL_UART_RxCpltCallback
;;;1592   }
00003c  bd70              POP      {r4-r6,pc}
;;;1593   
                          ENDP


                          AREA ||i.UART_DMARxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMARxHalfCplt PROC
;;;1599     */
;;;1600   static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1601   {
000002  4604              MOV      r4,r0
;;;1602     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000004  6ba5              LDR      r5,[r4,#0x38]
;;;1603   
;;;1604     HAL_UART_RxHalfCpltCallback(huart); 
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_UART_RxHalfCpltCallback
;;;1605   }
00000c  bd70              POP      {r4-r6,pc}
;;;1606   
                          ENDP


                          AREA ||i.UART_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATransmitCplt PROC
;;;1528     */
;;;1529   static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1530   {
000002  4605              MOV      r5,r0
;;;1531     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;1532     /* DMA Normal mode*/
;;;1533     if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
000006  6828              LDR      r0,[r5,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  f4007080          AND      r0,r0,#0x100
00000e  b970              CBNZ     r0,|L33.46|
;;;1534     {
;;;1535       huart->TxXferCount = 0;
000010  2000              MOVS     r0,#0
000012  84e0              STRH     r0,[r4,#0x26]
;;;1536   
;;;1537       /* Disable the DMA transfer for transmit request by setting the DMAT bit
;;;1538          in the UART CR3 register */
;;;1539       huart->Instance->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DMAT);
000014  6820              LDR      r0,[r4,#0]
000016  6940              LDR      r0,[r0,#0x14]
000018  f0200080          BIC      r0,r0,#0x80
00001c  6821              LDR      r1,[r4,#0]
00001e  6148              STR      r0,[r1,#0x14]
;;;1540   
;;;1541       /* Enable the UART Transmit Complete Interrupt */
;;;1542       __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
000020  6820              LDR      r0,[r4,#0]
000022  68c0              LDR      r0,[r0,#0xc]
000024  f0400040          ORR      r0,r0,#0x40
000028  6821              LDR      r1,[r4,#0]
00002a  60c8              STR      r0,[r1,#0xc]
00002c  e002              B        |L33.52|
                  |L33.46|
;;;1543     }
;;;1544     /* DMA Circular mode */
;;;1545     else
;;;1546     {
;;;1547       HAL_UART_TxCpltCallback(huart);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       HAL_UART_TxCpltCallback
                  |L33.52|
;;;1548     }
;;;1549   }
000034  bd70              POP      {r4-r6,pc}
;;;1550   
                          ENDP


                          AREA ||i.UART_DMATxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATxHalfCplt PROC
;;;1556     */
;;;1557   static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1558   {
000002  4604              MOV      r4,r0
;;;1559     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000004  6ba5              LDR      r5,[r4,#0x38]
;;;1560   
;;;1561     HAL_UART_TxHalfCpltCallback(huart);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_UART_TxHalfCpltCallback
;;;1562   }
00000c  bd70              POP      {r4-r6,pc}
;;;1563   
                          ENDP


                          AREA ||i.UART_EndTransmit_IT||, CODE, READONLY, ALIGN=1

                  UART_EndTransmit_IT PROC
;;;1746     */
;;;1747   static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1748   {
000002  4604              MOV      r4,r0
;;;1749     /* Disable the UART Transmit Complete Interrupt */    
;;;1750     __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
000004  6820              LDR      r0,[r4,#0]
000006  68c0              LDR      r0,[r0,#0xc]
000008  f0200040          BIC      r0,r0,#0x40
00000c  6821              LDR      r1,[r4,#0]
00000e  60c8              STR      r0,[r1,#0xc]
;;;1751     
;;;1752     /* Check if a receive process is ongoing or not */
;;;1753     if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
000010  f8940039          LDRB     r0,[r4,#0x39]
000014  2832              CMP      r0,#0x32
000016  d103              BNE      |L35.32|
;;;1754     {
;;;1755       huart->State = HAL_UART_STATE_BUSY_RX;
000018  2022              MOVS     r0,#0x22
00001a  f8840039          STRB     r0,[r4,#0x39]
00001e  e002              B        |L35.38|
                  |L35.32|
;;;1756     }
;;;1757     else
;;;1758     {
;;;1759       huart->State = HAL_UART_STATE_READY;
000020  2001              MOVS     r0,#1
000022  f8840039          STRB     r0,[r4,#0x39]
                  |L35.38|
;;;1760     }
;;;1761     
;;;1762     HAL_UART_TxCpltCallback(huart);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_UART_TxCpltCallback
;;;1763     
;;;1764     return HAL_OK;
00002c  2000              MOVS     r0,#0
;;;1765   }
00002e  bd10              POP      {r4,pc}
;;;1766   
                          ENDP


                          AREA ||i.UART_Receive_IT||, CODE, READONLY, ALIGN=1

                  UART_Receive_IT PROC
;;;1772     */
;;;1773   static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1774   {
000002  4604              MOV      r4,r0
;;;1775     uint16_t* tmp;
;;;1776     uint32_t tmp1 = 0;
000004  2600              MOVS     r6,#0
;;;1777     
;;;1778     tmp1 = huart->State; 
000006  f8946039          LDRB     r6,[r4,#0x39]
;;;1779     if((tmp1 == HAL_UART_STATE_BUSY_RX) || (tmp1 == HAL_UART_STATE_BUSY_TX_RX))
00000a  2e22              CMP      r6,#0x22
00000c  d001              BEQ      |L36.18|
00000e  2e32              CMP      r6,#0x32
000010  d152              BNE      |L36.184|
                  |L36.18|
;;;1780     {
;;;1781       if(huart->Init.WordLength == UART_WORDLENGTH_9B)
000012  68a0              LDR      r0,[r4,#8]
000014  f5b05f80          CMP      r0,#0x1000
000018  d113              BNE      |L36.66|
;;;1782       {
;;;1783         tmp = (uint16_t*) huart->pRxBuffPtr;
00001a  6aa5              LDR      r5,[r4,#0x28]
;;;1784         if(huart->Init.Parity == UART_PARITY_NONE)
00001c  6920              LDR      r0,[r4,#0x10]
00001e  b940              CBNZ     r0,|L36.50|
;;;1785         {
;;;1786           *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
000020  6820              LDR      r0,[r4,#0]
000022  6840              LDR      r0,[r0,#4]
000024  f3c00008          UBFX     r0,r0,#0,#9
000028  8028              STRH     r0,[r5,#0]
;;;1787           huart->pRxBuffPtr += 2;
00002a  6aa0              LDR      r0,[r4,#0x28]
00002c  1c80              ADDS     r0,r0,#2
00002e  62a0              STR      r0,[r4,#0x28]
000030  e019              B        |L36.102|
                  |L36.50|
;;;1788         }
;;;1789         else
;;;1790         {
;;;1791           *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
000032  6820              LDR      r0,[r4,#0]
000034  6840              LDR      r0,[r0,#4]
000036  b2c0              UXTB     r0,r0
000038  8028              STRH     r0,[r5,#0]
;;;1792           huart->pRxBuffPtr += 1;
00003a  6aa0              LDR      r0,[r4,#0x28]
00003c  1c40              ADDS     r0,r0,#1
00003e  62a0              STR      r0,[r4,#0x28]
000040  e011              B        |L36.102|
                  |L36.66|
;;;1793         }
;;;1794       }
;;;1795       else
;;;1796       {
;;;1797         if(huart->Init.Parity == UART_PARITY_NONE)
000042  6920              LDR      r0,[r4,#0x10]
000044  b938              CBNZ     r0,|L36.86|
;;;1798         {
;;;1799           *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
000046  6820              LDR      r0,[r4,#0]
000048  6840              LDR      r0,[r0,#4]
00004a  b2c1              UXTB     r1,r0
00004c  6aa2              LDR      r2,[r4,#0x28]
00004e  1c50              ADDS     r0,r2,#1
000050  62a0              STR      r0,[r4,#0x28]
000052  7011              STRB     r1,[r2,#0]
000054  e007              B        |L36.102|
                  |L36.86|
;;;1800         }
;;;1801         else
;;;1802         {
;;;1803           *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
000056  6820              LDR      r0,[r4,#0]
000058  6840              LDR      r0,[r0,#4]
00005a  f000017f          AND      r1,r0,#0x7f
00005e  6aa2              LDR      r2,[r4,#0x28]
000060  1c50              ADDS     r0,r2,#1
000062  62a0              STR      r0,[r4,#0x28]
000064  7011              STRB     r1,[r2,#0]
                  |L36.102|
;;;1804         }
;;;1805       }
;;;1806   
;;;1807       if(--huart->RxXferCount == 0)
000066  8de0              LDRH     r0,[r4,#0x2e]
000068  1e40              SUBS     r0,r0,#1
00006a  b280              UXTH     r0,r0
00006c  85e0              STRH     r0,[r4,#0x2e]
00006e  bb08              CBNZ     r0,|L36.180|
;;;1808       {
;;;1809         __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
000070  6820              LDR      r0,[r4,#0]
000072  68c0              LDR      r0,[r0,#0xc]
000074  f0200020          BIC      r0,r0,#0x20
000078  6821              LDR      r1,[r4,#0]
00007a  60c8              STR      r0,[r1,#0xc]
;;;1810   
;;;1811         /* Check if a transmit process is ongoing or not */
;;;1812         if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
00007c  f8940039          LDRB     r0,[r4,#0x39]
000080  2832              CMP      r0,#0x32
000082  d103              BNE      |L36.140|
;;;1813         {
;;;1814           huart->State = HAL_UART_STATE_BUSY_TX;
000084  2012              MOVS     r0,#0x12
000086  f8840039          STRB     r0,[r4,#0x39]
00008a  e00e              B        |L36.170|
                  |L36.140|
;;;1815         }
;;;1816         else
;;;1817         {
;;;1818           /* Disable the UART Parity Error Interrupt */
;;;1819           __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
00008c  6820              LDR      r0,[r4,#0]
00008e  68c0              LDR      r0,[r0,#0xc]
000090  f4207080          BIC      r0,r0,#0x100
000094  6821              LDR      r1,[r4,#0]
000096  60c8              STR      r0,[r1,#0xc]
;;;1820   
;;;1821           /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1822           __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
000098  6820              LDR      r0,[r4,#0]
00009a  6940              LDR      r0,[r0,#0x14]
00009c  f0200001          BIC      r0,r0,#1
0000a0  6821              LDR      r1,[r4,#0]
0000a2  6148              STR      r0,[r1,#0x14]
;;;1823   
;;;1824           huart->State = HAL_UART_STATE_READY;
0000a4  2001              MOVS     r0,#1
0000a6  f8840039          STRB     r0,[r4,#0x39]
                  |L36.170|
;;;1825         }
;;;1826         HAL_UART_RxCpltCallback(huart);
0000aa  4620              MOV      r0,r4
0000ac  f7fffffe          BL       HAL_UART_RxCpltCallback
;;;1827   
;;;1828         return HAL_OK;
0000b0  2000              MOVS     r0,#0
                  |L36.178|
;;;1829       }
;;;1830       return HAL_OK;
;;;1831     }
;;;1832     else
;;;1833     {
;;;1834       return HAL_BUSY; 
;;;1835     }
;;;1836   }
0000b2  bd70              POP      {r4-r6,pc}
                  |L36.180|
0000b4  2000              MOVS     r0,#0                 ;1830
0000b6  e7fc              B        |L36.178|
                  |L36.184|
0000b8  2002              MOVS     r0,#2                 ;1834
0000ba  e7fa              B        |L36.178|
;;;1837   
                          ENDP


                          AREA ||i.UART_SetConfig||, CODE, READONLY, ALIGN=2

                  UART_SetConfig PROC
;;;1843     */
;;;1844   static void UART_SetConfig(UART_HandleTypeDef *huart)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1845   {
000004  4604              MOV      r4,r0
;;;1846     uint32_t tmpreg = 0x00;
000006  2500              MOVS     r5,#0
;;;1847     
;;;1848     /* Check the parameters */
;;;1849     assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));  
;;;1850     assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
;;;1851     assert_param(IS_UART_PARITY(huart->Init.Parity));
;;;1852     assert_param(IS_UART_MODE(huart->Init.Mode));
;;;1853   
;;;1854     /*-------------------------- USART CR2 Configuration -----------------------*/
;;;1855     tmpreg = huart->Instance->CR2;
000008  6820              LDR      r0,[r4,#0]
00000a  6905              LDR      r5,[r0,#0x10]
;;;1856   
;;;1857     /* Clear STOP[13:12] bits */
;;;1858     tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
00000c  f4255540          BIC      r5,r5,#0x3000
;;;1859   
;;;1860     /* Configure the UART Stop Bits: Set STOP[13:12] bits according to huart->Init.StopBits value */
;;;1861     tmpreg |= (uint32_t)huart->Init.StopBits;
000010  68e0              LDR      r0,[r4,#0xc]
000012  4305              ORRS     r5,r5,r0
;;;1862     
;;;1863     /* Write to USART CR2 */
;;;1864     huart->Instance->CR2 = (uint32_t)tmpreg;
000014  6820              LDR      r0,[r4,#0]
000016  6105              STR      r5,[r0,#0x10]
;;;1865   
;;;1866     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;1867     tmpreg = huart->Instance->CR1;
000018  6820              LDR      r0,[r4,#0]
00001a  68c5              LDR      r5,[r0,#0xc]
;;;1868   
;;;1869     /* Clear M, PCE, PS, TE and RE bits */
;;;1870     tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | \
00001c  f249600c          MOV      r0,#0x960c
000020  4385              BICS     r5,r5,r0
;;;1871                                      USART_CR1_RE | USART_CR1_OVER8));
;;;1872   
;;;1873     /* Configure the UART Word Length, Parity and mode: 
;;;1874        Set the M bits according to huart->Init.WordLength value 
;;;1875        Set PCE and PS bits according to huart->Init.Parity value
;;;1876        Set TE and RE bits according to huart->Init.Mode value
;;;1877        Set OVER8 bit according to huart->Init.OverSampling value */
;;;1878     tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
000022  6921              LDR      r1,[r4,#0x10]
000024  68a0              LDR      r0,[r4,#8]
000026  4308              ORRS     r0,r0,r1
000028  6961              LDR      r1,[r4,#0x14]
00002a  4308              ORRS     r0,r0,r1
00002c  69e1              LDR      r1,[r4,#0x1c]
00002e  4308              ORRS     r0,r0,r1
000030  4305              ORRS     r5,r5,r0
;;;1879     
;;;1880     /* Write to USART CR1 */
;;;1881     huart->Instance->CR1 = (uint32_t)tmpreg;
000032  6820              LDR      r0,[r4,#0]
000034  60c5              STR      r5,[r0,#0xc]
;;;1882     
;;;1883     /*-------------------------- USART CR3 Configuration -----------------------*/  
;;;1884     tmpreg = huart->Instance->CR3;
000036  6820              LDR      r0,[r4,#0]
000038  6945              LDR      r5,[r0,#0x14]
;;;1885     
;;;1886     /* Clear CTSE and RTSE bits */
;;;1887     tmpreg &= (uint32_t)~((uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE));
00003a  f4257540          BIC      r5,r5,#0x300
;;;1888     
;;;1889     /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
;;;1890     tmpreg |= huart->Init.HwFlowCtl;
00003e  69a0              LDR      r0,[r4,#0x18]
000040  4305              ORRS     r5,r5,r0
;;;1891     
;;;1892     /* Write to USART CR3 */
;;;1893     huart->Instance->CR3 = (uint32_t)tmpreg;
000042  6820              LDR      r0,[r4,#0]
000044  6145              STR      r5,[r0,#0x14]
;;;1894     
;;;1895     /* Check the Over Sampling */
;;;1896     if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
000046  69e0              LDR      r0,[r4,#0x1c]
000048  f5b04f00          CMP      r0,#0x8000
00004c  d172              BNE      |L37.308|
;;;1897     {
;;;1898       /*-------------------------- USART BRR Configuration ---------------------*/
;;;1899       if((huart->Instance == USART1) || (huart->Instance == USART6))
00004e  4973              LDR      r1,|L37.540|
000050  6820              LDR      r0,[r4,#0]
000052  4288              CMP      r0,r1
000054  d003              BEQ      |L37.94|
000056  4972              LDR      r1,|L37.544|
000058  6820              LDR      r0,[r4,#0]
00005a  4288              CMP      r0,r1
00005c  d134              BNE      |L37.200|
                  |L37.94|
;;;1900       {
;;;1901         huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
00005e  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
000062  eb0001c0          ADD      r1,r0,r0,LSL #3
000066  eb011000          ADD      r0,r1,r0,LSL #4
00006a  6861              LDR      r1,[r4,#4]
00006c  0049              LSLS     r1,r1,#1
00006e  fbb0f0f1          UDIV     r0,r0,r1
000072  2164              MOVS     r1,#0x64
000074  fbb0f6f1          UDIV     r6,r0,r1
000078  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
00007c  eb0001c0          ADD      r1,r0,r0,LSL #3
000080  eb011000          ADD      r0,r1,r0,LSL #4
000084  6861              LDR      r1,[r4,#4]
000086  0049              LSLS     r1,r1,#1
000088  fbb0f7f1          UDIV     r7,r0,r1
00008c  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
000090  eb0001c0          ADD      r1,r0,r0,LSL #3
000094  eb011000          ADD      r0,r1,r0,LSL #4
000098  6861              LDR      r1,[r4,#4]
00009a  0049              LSLS     r1,r1,#1
00009c  fbb0f0f1          UDIV     r0,r0,r1
0000a0  2164              MOVS     r1,#0x64
0000a2  fbb0f0f1          UDIV     r0,r0,r1
0000a6  eb0001c0          ADD      r1,r0,r0,LSL #3
0000aa  eb011000          ADD      r0,r1,r0,LSL #4
0000ae  eba70080          SUB      r0,r7,r0,LSL #2
0000b2  2132              MOVS     r1,#0x32
0000b4  eb011000          ADD      r0,r1,r0,LSL #4
0000b8  2164              MOVS     r1,#0x64
0000ba  fbb0f0f1          UDIV     r0,r0,r1
0000be  f366101f          BFI      r0,r6,#4,#28
0000c2  6821              LDR      r1,[r4,#0]
0000c4  6088              STR      r0,[r1,#8]
0000c6  e0a6              B        |L37.534|
                  |L37.200|
;;;1902       }
;;;1903       else
;;;1904       {
;;;1905         huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
0000c8  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0000cc  eb0001c0          ADD      r1,r0,r0,LSL #3
0000d0  eb011000          ADD      r0,r1,r0,LSL #4
0000d4  6861              LDR      r1,[r4,#4]
0000d6  0049              LSLS     r1,r1,#1
0000d8  fbb0f0f1          UDIV     r0,r0,r1
0000dc  2164              MOVS     r1,#0x64
0000de  fbb0f6f1          UDIV     r6,r0,r1
0000e2  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0000e6  eb0001c0          ADD      r1,r0,r0,LSL #3
0000ea  eb011000          ADD      r0,r1,r0,LSL #4
0000ee  6861              LDR      r1,[r4,#4]
0000f0  0049              LSLS     r1,r1,#1
0000f2  fbb0f7f1          UDIV     r7,r0,r1
0000f6  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0000fa  eb0001c0          ADD      r1,r0,r0,LSL #3
0000fe  eb011000          ADD      r0,r1,r0,LSL #4
000102  6861              LDR      r1,[r4,#4]
000104  0049              LSLS     r1,r1,#1
000106  fbb0f0f1          UDIV     r0,r0,r1
00010a  2164              MOVS     r1,#0x64
00010c  fbb0f0f1          UDIV     r0,r0,r1
000110  eb0001c0          ADD      r1,r0,r0,LSL #3
000114  eb011000          ADD      r0,r1,r0,LSL #4
000118  eba70080          SUB      r0,r7,r0,LSL #2
00011c  2132              MOVS     r1,#0x32
00011e  eb011000          ADD      r0,r1,r0,LSL #4
000122  2164              MOVS     r1,#0x64
000124  fbb0f0f1          UDIV     r0,r0,r1
000128  f366101f          BFI      r0,r6,#4,#28
00012c  6821              LDR      r1,[r4,#0]
00012e  6088              STR      r0,[r1,#8]
000130  e071              B        |L37.534|
000132  e7ff              B        |L37.308|
                  |L37.308|
;;;1906       }
;;;1907     }
;;;1908     else
;;;1909     {
;;;1910       /*-------------------------- USART BRR Configuration ---------------------*/
;;;1911       if((huart->Instance == USART1) || (huart->Instance == USART6))
000134  4939              LDR      r1,|L37.540|
000136  6820              LDR      r0,[r4,#0]
000138  4288              CMP      r0,r1
00013a  d003              BEQ      |L37.324|
00013c  4938              LDR      r1,|L37.544|
00013e  6820              LDR      r0,[r4,#0]
000140  4288              CMP      r0,r1
000142  d134              BNE      |L37.430|
                  |L37.324|
;;;1912       {
;;;1913         huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
000144  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
000148  eb0001c0          ADD      r1,r0,r0,LSL #3
00014c  eb011000          ADD      r0,r1,r0,LSL #4
000150  6861              LDR      r1,[r4,#4]
000152  0089              LSLS     r1,r1,#2
000154  fbb0f0f1          UDIV     r0,r0,r1
000158  2164              MOVS     r1,#0x64
00015a  fbb0f6f1          UDIV     r6,r0,r1
00015e  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
000162  eb0001c0          ADD      r1,r0,r0,LSL #3
000166  eb011000          ADD      r0,r1,r0,LSL #4
00016a  6861              LDR      r1,[r4,#4]
00016c  0089              LSLS     r1,r1,#2
00016e  fbb0f7f1          UDIV     r7,r0,r1
000172  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
000176  eb0001c0          ADD      r1,r0,r0,LSL #3
00017a  eb011000          ADD      r0,r1,r0,LSL #4
00017e  6861              LDR      r1,[r4,#4]
000180  0089              LSLS     r1,r1,#2
000182  fbb0f0f1          UDIV     r0,r0,r1
000186  2164              MOVS     r1,#0x64
000188  fbb0f0f1          UDIV     r0,r0,r1
00018c  eb0001c0          ADD      r1,r0,r0,LSL #3
000190  eb011000          ADD      r0,r1,r0,LSL #4
000194  eba70080          SUB      r0,r7,r0,LSL #2
000198  2132              MOVS     r1,#0x32
00019a  eb011000          ADD      r0,r1,r0,LSL #4
00019e  2164              MOVS     r1,#0x64
0001a0  fbb0f0f1          UDIV     r0,r0,r1
0001a4  f366101f          BFI      r0,r6,#4,#28
0001a8  6821              LDR      r1,[r4,#0]
0001aa  6088              STR      r0,[r1,#8]
0001ac  e033              B        |L37.534|
                  |L37.430|
;;;1914       }
;;;1915       else
;;;1916       {
;;;1917         huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
0001ae  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0001b2  eb0001c0          ADD      r1,r0,r0,LSL #3
0001b6  eb011000          ADD      r0,r1,r0,LSL #4
0001ba  6861              LDR      r1,[r4,#4]
0001bc  0089              LSLS     r1,r1,#2
0001be  fbb0f0f1          UDIV     r0,r0,r1
0001c2  2164              MOVS     r1,#0x64
0001c4  fbb0f6f1          UDIV     r6,r0,r1
0001c8  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0001cc  eb0001c0          ADD      r1,r0,r0,LSL #3
0001d0  eb011000          ADD      r0,r1,r0,LSL #4
0001d4  6861              LDR      r1,[r4,#4]
0001d6  0089              LSLS     r1,r1,#2
0001d8  fbb0f7f1          UDIV     r7,r0,r1
0001dc  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0001e0  eb0001c0          ADD      r1,r0,r0,LSL #3
0001e4  eb011000          ADD      r0,r1,r0,LSL #4
0001e8  6861              LDR      r1,[r4,#4]
0001ea  0089              LSLS     r1,r1,#2
0001ec  fbb0f0f1          UDIV     r0,r0,r1
0001f0  2164              MOVS     r1,#0x64
0001f2  fbb0f0f1          UDIV     r0,r0,r1
0001f6  eb0001c0          ADD      r1,r0,r0,LSL #3
0001fa  eb011000          ADD      r0,r1,r0,LSL #4
0001fe  eba70080          SUB      r0,r7,r0,LSL #2
000202  2132              MOVS     r1,#0x32
000204  eb011000          ADD      r0,r1,r0,LSL #4
000208  2164              MOVS     r1,#0x64
00020a  fbb0f0f1          UDIV     r0,r0,r1
00020e  f366101f          BFI      r0,r6,#4,#28
000212  6821              LDR      r1,[r4,#0]
000214  6088              STR      r0,[r1,#8]
                  |L37.534|
;;;1918       }
;;;1919     }
;;;1920   }
000216  e8bd81f0          POP      {r4-r8,pc}
;;;1921   
                          ENDP

00021a  0000              DCW      0x0000
                  |L37.540|
                          DCD      0x40011000
                  |L37.544|
                          DCD      0x40011400

                          AREA ||i.UART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  UART_Transmit_IT PROC
;;;1697     */
;;;1698   static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1699   {
000002  4601              MOV      r1,r0
;;;1700     uint16_t* tmp;
;;;1701     uint32_t tmp1 = 0;
000004  2300              MOVS     r3,#0
;;;1702     
;;;1703     tmp1 = huart->State;
000006  f8913039          LDRB     r3,[r1,#0x39]
;;;1704     if((tmp1 == HAL_UART_STATE_BUSY_TX) || (tmp1 == HAL_UART_STATE_BUSY_TX_RX))
00000a  2b12              CMP      r3,#0x12
00000c  d001              BEQ      |L38.18|
00000e  2b32              CMP      r3,#0x32
000010  d12c              BNE      |L38.108|
                  |L38.18|
;;;1705     {
;;;1706       if(huart->Init.WordLength == UART_WORDLENGTH_9B)
000012  6888              LDR      r0,[r1,#8]
000014  f5b05f80          CMP      r0,#0x1000
000018  d10f              BNE      |L38.58|
;;;1707       {
;;;1708         tmp = (uint16_t*) huart->pTxBuffPtr;
00001a  6a0a              LDR      r2,[r1,#0x20]
;;;1709         huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
00001c  8810              LDRH     r0,[r2,#0]
00001e  f3c00008          UBFX     r0,r0,#0,#9
000022  680c              LDR      r4,[r1,#0]
000024  6060              STR      r0,[r4,#4]
;;;1710         if(huart->Init.Parity == UART_PARITY_NONE)
000026  6908              LDR      r0,[r1,#0x10]
000028  b918              CBNZ     r0,|L38.50|
;;;1711         {
;;;1712           huart->pTxBuffPtr += 2;
00002a  6a08              LDR      r0,[r1,#0x20]
00002c  1c80              ADDS     r0,r0,#2
00002e  6208              STR      r0,[r1,#0x20]
000030  e009              B        |L38.70|
                  |L38.50|
;;;1713         }
;;;1714         else
;;;1715         {
;;;1716           huart->pTxBuffPtr += 1;
000032  6a08              LDR      r0,[r1,#0x20]
000034  1c40              ADDS     r0,r0,#1
000036  6208              STR      r0,[r1,#0x20]
000038  e005              B        |L38.70|
                  |L38.58|
;;;1717         }
;;;1718       } 
;;;1719       else
;;;1720       {
;;;1721         huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FF);
00003a  6a0c              LDR      r4,[r1,#0x20]
00003c  1c60              ADDS     r0,r4,#1
00003e  6208              STR      r0,[r1,#0x20]
000040  7820              LDRB     r0,[r4,#0]
000042  680c              LDR      r4,[r1,#0]
000044  6060              STR      r0,[r4,#4]
                  |L38.70|
;;;1722       }
;;;1723   
;;;1724       if(--huart->TxXferCount == 0)
000046  8cc8              LDRH     r0,[r1,#0x26]
000048  1e40              SUBS     r0,r0,#1
00004a  b280              UXTH     r0,r0
00004c  84c8              STRH     r0,[r1,#0x26]
00004e  b958              CBNZ     r0,|L38.104|
;;;1725       {
;;;1726         /* Disable the UART Transmit Complete Interrupt */
;;;1727         __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
000050  6808              LDR      r0,[r1,#0]
000052  68c0              LDR      r0,[r0,#0xc]
000054  f0200080          BIC      r0,r0,#0x80
000058  680c              LDR      r4,[r1,#0]
00005a  60e0              STR      r0,[r4,#0xc]
;;;1728   
;;;1729         /* Enable the UART Transmit Complete Interrupt */    
;;;1730         __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
00005c  6808              LDR      r0,[r1,#0]
00005e  68c0              LDR      r0,[r0,#0xc]
000060  f0400040          ORR      r0,r0,#0x40
000064  680c              LDR      r4,[r1,#0]
000066  60e0              STR      r0,[r4,#0xc]
                  |L38.104|
;;;1731       }
;;;1732       return HAL_OK;
000068  2000              MOVS     r0,#0
                  |L38.106|
;;;1733     }
;;;1734     else
;;;1735     {
;;;1736       return HAL_BUSY;
;;;1737     }
;;;1738   }
00006a  bd10              POP      {r4,pc}
                  |L38.108|
00006c  2002              MOVS     r0,#2                 ;1736
00006e  e7fc              B        |L38.106|
;;;1739   
                          ENDP


                          AREA ||i.UART_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  UART_WaitOnFlagUntilTimeout PROC
;;;1630     */
;;;1631   static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1632   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;1633     uint32_t tickstart = 0;
00000c  f04f0800          MOV      r8,#0
;;;1634   
;;;1635     /* Get tick */ 
;;;1636     tickstart = HAL_GetTick();
000010  f7fffffe          BL       HAL_GetTick
000014  4680              MOV      r8,r0
;;;1637   
;;;1638     /* Wait until flag is set */
;;;1639     if(Status == RESET)
000016  bb9f              CBNZ     r7,|L39.128|
;;;1640     {
;;;1641       while(__HAL_UART_GET_FLAG(huart, Flag) == RESET)
000018  e02b              B        |L39.114|
                  |L39.26|
;;;1642       {
;;;1643         /* Check for the Timeout */
;;;1644         if(Timeout != HAL_MAX_DELAY)
00001a  1c68              ADDS     r0,r5,#1
00001c  b348              CBZ      r0,|L39.114|
;;;1645         {
;;;1646           if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
00001e  b12d              CBZ      r5,|L39.44|
000020  f7fffffe          BL       HAL_GetTick
000024  eba00008          SUB      r0,r0,r8
000028  42a8              CMP      r0,r5
00002a  d922              BLS      |L39.114|
                  |L39.44|
;;;1647           {
;;;1648             /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
;;;1649             __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
00002c  6820              LDR      r0,[r4,#0]
00002e  68c0              LDR      r0,[r0,#0xc]
000030  f0200080          BIC      r0,r0,#0x80
000034  6821              LDR      r1,[r4,#0]
000036  60c8              STR      r0,[r1,#0xc]
;;;1650             __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
000038  6820              LDR      r0,[r4,#0]
00003a  68c0              LDR      r0,[r0,#0xc]
00003c  f0200020          BIC      r0,r0,#0x20
000040  6821              LDR      r1,[r4,#0]
000042  60c8              STR      r0,[r1,#0xc]
;;;1651             __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
000044  6820              LDR      r0,[r4,#0]
000046  68c0              LDR      r0,[r0,#0xc]
000048  f4207080          BIC      r0,r0,#0x100
00004c  6821              LDR      r1,[r4,#0]
00004e  60c8              STR      r0,[r1,#0xc]
;;;1652             __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
000050  6820              LDR      r0,[r4,#0]
000052  6940              LDR      r0,[r0,#0x14]
000054  f0200001          BIC      r0,r0,#1
000058  6821              LDR      r1,[r4,#0]
00005a  6148              STR      r0,[r1,#0x14]
;;;1653   
;;;1654             huart->State= HAL_UART_STATE_READY;
00005c  2001              MOVS     r0,#1
00005e  f8840039          STRB     r0,[r4,#0x39]
;;;1655   
;;;1656             /* Process Unlocked */
;;;1657             __HAL_UNLOCK(huart);
000062  bf00              NOP      
000064  2000              MOVS     r0,#0
000066  f8840038          STRB     r0,[r4,#0x38]
00006a  bf00              NOP      
;;;1658   
;;;1659             return HAL_TIMEOUT;
00006c  2003              MOVS     r0,#3
                  |L39.110|
;;;1660           }
;;;1661         }
;;;1662       }
;;;1663     }
;;;1664     else
;;;1665     {
;;;1666       while(__HAL_UART_GET_FLAG(huart, Flag) != RESET)
;;;1667       {
;;;1668         /* Check for the Timeout */
;;;1669         if(Timeout != HAL_MAX_DELAY)
;;;1670         {
;;;1671           if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
;;;1672           {
;;;1673             /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
;;;1674             __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
;;;1675             __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
;;;1676             __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
;;;1677             __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
;;;1678   
;;;1679             huart->State= HAL_UART_STATE_READY;
;;;1680   
;;;1681             /* Process Unlocked */
;;;1682             __HAL_UNLOCK(huart);
;;;1683           
;;;1684             return HAL_TIMEOUT;
;;;1685           }
;;;1686         }
;;;1687       }
;;;1688     }
;;;1689     return HAL_OK;
;;;1690   }
00006e  e8bd81f0          POP      {r4-r8,pc}
                  |L39.114|
000072  6820              LDR      r0,[r4,#0]            ;1641
000074  6800              LDR      r0,[r0,#0]            ;1641
000076  4030              ANDS     r0,r0,r6              ;1641
000078  42b0              CMP      r0,r6                 ;1641
00007a  d102              BNE      |L39.130|
00007c  2001              MOVS     r0,#1                 ;1641
00007e  e001              B        |L39.132|
                  |L39.128|
000080  e003              B        |L39.138|
                  |L39.130|
000082  2000              MOVS     r0,#0                 ;1641
                  |L39.132|
000084  2800              CMP      r0,#0                 ;1641
000086  d0c8              BEQ      |L39.26|
000088  e035              B        |L39.246|
                  |L39.138|
00008a  e02a              B        |L39.226|
                  |L39.140|
00008c  1c68              ADDS     r0,r5,#1              ;1669
00008e  b340              CBZ      r0,|L39.226|
000090  b12d              CBZ      r5,|L39.158|
000092  f7fffffe          BL       HAL_GetTick
000096  eba00008          SUB      r0,r0,r8              ;1671
00009a  42a8              CMP      r0,r5                 ;1671
00009c  d921              BLS      |L39.226|
                  |L39.158|
00009e  6820              LDR      r0,[r4,#0]            ;1674
0000a0  68c0              LDR      r0,[r0,#0xc]          ;1674
0000a2  f0200080          BIC      r0,r0,#0x80           ;1674
0000a6  6821              LDR      r1,[r4,#0]            ;1674
0000a8  60c8              STR      r0,[r1,#0xc]          ;1674
0000aa  6820              LDR      r0,[r4,#0]            ;1675
0000ac  68c0              LDR      r0,[r0,#0xc]          ;1675
0000ae  f0200020          BIC      r0,r0,#0x20           ;1675
0000b2  6821              LDR      r1,[r4,#0]            ;1675
0000b4  60c8              STR      r0,[r1,#0xc]          ;1675
0000b6  6820              LDR      r0,[r4,#0]            ;1676
0000b8  68c0              LDR      r0,[r0,#0xc]          ;1676
0000ba  f4207080          BIC      r0,r0,#0x100          ;1676
0000be  6821              LDR      r1,[r4,#0]            ;1676
0000c0  60c8              STR      r0,[r1,#0xc]          ;1676
0000c2  6820              LDR      r0,[r4,#0]            ;1677
0000c4  6940              LDR      r0,[r0,#0x14]         ;1677
0000c6  f0200001          BIC      r0,r0,#1              ;1677
0000ca  6821              LDR      r1,[r4,#0]            ;1677
0000cc  6148              STR      r0,[r1,#0x14]         ;1677
0000ce  2001              MOVS     r0,#1                 ;1679
0000d0  f8840039          STRB     r0,[r4,#0x39]         ;1679
0000d4  bf00              NOP                            ;1682
0000d6  2000              MOVS     r0,#0                 ;1682
0000d8  f8840038          STRB     r0,[r4,#0x38]         ;1682
0000dc  bf00              NOP                            ;1682
0000de  2003              MOVS     r0,#3                 ;1684
0000e0  e7c5              B        |L39.110|
                  |L39.226|
0000e2  6820              LDR      r0,[r4,#0]            ;1666
0000e4  6800              LDR      r0,[r0,#0]            ;1666
0000e6  4030              ANDS     r0,r0,r6              ;1666
0000e8  42b0              CMP      r0,r6                 ;1666
0000ea  d101              BNE      |L39.240|
0000ec  2001              MOVS     r0,#1                 ;1666
0000ee  e000              B        |L39.242|
                  |L39.240|
0000f0  2000              MOVS     r0,#0                 ;1666
                  |L39.242|
0000f2  2800              CMP      r0,#0                 ;1666
0000f4  d1ca              BNE      |L39.140|
                  |L39.246|
0000f6  2000              MOVS     r0,#0                 ;1689
0000f8  e7b9              B        |L39.110|
;;;1691   
                          ENDP


;*** Start embedded assembler ***

#line 1 "HALLIB\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_hal_uart_c_d497114f____REV16|
#line 388 ".\\CORE\\cmsis_armcc.h"
|__asm___20_stm32f4xx_hal_uart_c_d497114f____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_hal_uart_c_d497114f____REVSH|
#line 402
|__asm___20_stm32f4xx_hal_uart_c_d497114f____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_hal_uart_c_d497114f____RRX|
#line 587
|__asm___20_stm32f4xx_hal_uart_c_d497114f____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
