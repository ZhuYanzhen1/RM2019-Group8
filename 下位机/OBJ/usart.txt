; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\usart.o --asm_dir=.\OBJ\ --list_dir=.\OBJ\ --depend=.\obj\usart.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I.\CORE -I.\USER -I.\HALLIB\STM32F4xx_HAL_Driver\Inc -I.\SYSTEM -I.\Hardware -I.\App -I.\DSP_LIB\Include -I.\FreeRTOS -I.\MPU9250\DMP -I.\MPU9250 -I.\RTE\_Project -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=526 -DSTM32F427xx -DSTM32F4 -DUSE_HAL_DRIVER -DSTM32F427xx -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=.\obj\usart.crf Hardware\USART.c]
                          THUMB

                          AREA ||i.HAL_UART_MspDeInit||, CODE, READONLY, ALIGN=2

                  HAL_UART_MspDeInit PROC
;;;144    }
;;;145    void HAL_UART_MspDeInit(UART_HandleTypeDef* uartHandle)
000000  b510              PUSH     {r4,lr}
;;;146    {
000002  4604              MOV      r4,r0
;;;147      if(uartHandle->Instance==USART1)
000004  490a              LDR      r1,|L1.48|
000006  6820              LDR      r0,[r4,#0]
000008  4288              CMP      r0,r1
00000a  d10f              BNE      |L1.44|
;;;148      {
;;;149        __HAL_RCC_USART1_CLK_DISABLE();
00000c  4809              LDR      r0,|L1.52|
00000e  6800              LDR      r0,[r0,#0]
000010  f0200010          BIC      r0,r0,#0x10
000014  4907              LDR      r1,|L1.52|
000016  6008              STR      r0,[r1,#0]
;;;150        HAL_GPIO_DeInit(GPIOB, GPIO_PIN_7|GPIO_PIN_6);
000018  21c0              MOVS     r1,#0xc0
00001a  4807              LDR      r0,|L1.56|
00001c  f7fffffe          BL       HAL_GPIO_DeInit
;;;151        HAL_DMA_DeInit(uartHandle->hdmarx);
000020  6b60              LDR      r0,[r4,#0x34]
000022  f7fffffe          BL       HAL_DMA_DeInit
;;;152        HAL_NVIC_DisableIRQ(USART1_IRQn);
000026  2025              MOVS     r0,#0x25
000028  f7fffffe          BL       HAL_NVIC_DisableIRQ
                  |L1.44|
;;;153      }
;;;154    }
00002c  bd10              POP      {r4,pc}
;;;155    void USART3_Init(unsigned long baud)
                          ENDP

00002e  0000              DCW      0x0000
                  |L1.48|
                          DCD      0x40011000
                  |L1.52|
                          DCD      0x40023844
                  |L1.56|
                          DCD      0x40020400

                          AREA ||i.HAL_UART_RxCpltCallback||, CODE, READONLY, ALIGN=2

                  HAL_UART_RxCpltCallback PROC
;;;62     unsigned char RX_Counter=0x01;
;;;63     void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;64     {
000002  4604              MOV      r4,r0
;;;65     	if(huart->Instance==USART2)//如果是串口2
;;;66     	{
;;;67     		
;;;68     	}
;;;69     	if(huart->Instance==USART3)//如果是串口3
000004  491e              LDR      r1,|L2.128|
000006  6820              LDR      r0,[r4,#0]
000008  4288              CMP      r0,r1
00000a  d137              BNE      |L2.124|
;;;70     	{
;;;71     		if(aRxBuffer3 == 0xff && Rcv_Flg == 1)
00000c  481d              LDR      r0,|L2.132|
00000e  7800              LDRB     r0,[r0,#0]  ; aRxBuffer3
000010  28ff              CMP      r0,#0xff
000012  d110              BNE      |L2.54|
000014  481c              LDR      r0,|L2.136|
000016  7800              LDRB     r0,[r0,#0]  ; Rcv_Flg
000018  2801              CMP      r0,#1
00001a  d10c              BNE      |L2.54|
;;;72     		{
;;;73     			Rcv_Flg = 0;//结束收发
00001c  2000              MOVS     r0,#0
00001e  491a              LDR      r1,|L2.136|
000020  7008              STRB     r0,[r1,#0]
;;;74     			RX_Counter=1;
000022  2001              MOVS     r0,#1
000024  4919              LDR      r1,|L2.140|
000026  7008              STRB     r0,[r1,#0]
;;;75     			USART3_Rcv_Buffer[11]=0xff;
000028  20ff              MOVS     r0,#0xff
00002a  4919              LDR      r1,|L2.144|
00002c  72c8              STRB     r0,[r1,#0xb]
;;;76     			Received_CallBack((unsigned char *)&USART3_Rcv_Buffer);
00002e  4608              MOV      r0,r1
000030  f7fffffe          BL       Received_CallBack
000034  e022              B        |L2.124|
                  |L2.54|
;;;77     		}
;;;78     		else if(aRxBuffer3 == 0xff && Rcv_Flg == 0)
000036  4813              LDR      r0,|L2.132|
000038  7800              LDRB     r0,[r0,#0]  ; aRxBuffer3
00003a  28ff              CMP      r0,#0xff
00003c  d10f              BNE      |L2.94|
00003e  4812              LDR      r0,|L2.136|
000040  7800              LDRB     r0,[r0,#0]  ; Rcv_Flg
000042  b960              CBNZ     r0,|L2.94|
;;;79     		{
;;;80     			Rcv_Flg = 1;
000044  2001              MOVS     r0,#1
000046  4910              LDR      r1,|L2.136|
000048  7008              STRB     r0,[r1,#0]
;;;81     			RX_Counter=1;
00004a  4910              LDR      r1,|L2.140|
00004c  7008              STRB     r0,[r1,#0]
;;;82     			memset(&USART3_Rcv_Buffer,0x00,sizeof(USART3_Rcv_Buffer));
00004e  210f              MOVS     r1,#0xf
000050  480f              LDR      r0,|L2.144|
000052  f7fffffe          BL       __aeabi_memclr4
;;;83     			USART3_Rcv_Buffer[0]=0xff;
000056  20ff              MOVS     r0,#0xff
000058  490d              LDR      r1,|L2.144|
00005a  7008              STRB     r0,[r1,#0]
00005c  e00e              B        |L2.124|
                  |L2.94|
;;;84     		}
;;;85     		else if(Rcv_Flg == 1)
00005e  480a              LDR      r0,|L2.136|
000060  7800              LDRB     r0,[r0,#0]  ; Rcv_Flg
000062  2801              CMP      r0,#1
000064  d10a              BNE      |L2.124|
;;;86     		{
;;;87     			USART3_Rcv_Buffer[RX_Counter] = aRxBuffer3;
000066  4807              LDR      r0,|L2.132|
000068  7800              LDRB     r0,[r0,#0]  ; aRxBuffer3
00006a  4909              LDR      r1,|L2.144|
00006c  4a07              LDR      r2,|L2.140|
00006e  7812              LDRB     r2,[r2,#0]  ; RX_Counter
000070  5488              STRB     r0,[r1,r2]
;;;88     			RX_Counter++;
000072  4806              LDR      r0,|L2.140|
000074  7800              LDRB     r0,[r0,#0]  ; RX_Counter
000076  1c40              ADDS     r0,r0,#1
000078  4904              LDR      r1,|L2.140|
00007a  7008              STRB     r0,[r1,#0]
                  |L2.124|
;;;89     		}
;;;90     	}
;;;91     }
00007c  bd10              POP      {r4,pc}
;;;92     void USART2_IRQHandler(void)                	
                          ENDP

00007e  0000              DCW      0x0000
                  |L2.128|
                          DCD      0x40004800
                  |L2.132|
                          DCD      aRxBuffer3
                  |L2.136|
                          DCD      Rcv_Flg
                  |L2.140|
                          DCD      RX_Counter
                  |L2.144|
                          DCD      USART3_Rcv_Buffer

                          AREA ||i.USART1_Init||, CODE, READONLY, ALIGN=2

                  USART1_Init PROC
;;;109    } 
;;;110    void USART1_Init(void)
000000  b500              PUSH     {lr}
;;;111    {
000002  b087              SUB      sp,sp,#0x1c
;;;112    	GPIO_InitTypeDef GPIO_InitStruct;
;;;113      __HAL_RCC_USART1_CLK_ENABLE();
000004  bf00              NOP      
000006  2000              MOVS     r0,#0
000008  9001              STR      r0,[sp,#4]
00000a  4835              LDR      r0,|L3.224|
00000c  6800              LDR      r0,[r0,#0]
00000e  f0400010          ORR      r0,r0,#0x10
000012  4933              LDR      r1,|L3.224|
000014  6008              STR      r0,[r1,#0]
000016  4608              MOV      r0,r1
000018  6800              LDR      r0,[r0,#0]
00001a  f0000010          AND      r0,r0,#0x10
00001e  9001              STR      r0,[sp,#4]
000020  bf00              NOP      
000022  bf00              NOP      
;;;114    	__HAL_RCC_GPIOB_CLK_ENABLE();
000024  bf00              NOP      
000026  2000              MOVS     r0,#0
000028  9001              STR      r0,[sp,#4]
00002a  482d              LDR      r0,|L3.224|
00002c  3814              SUBS     r0,r0,#0x14
00002e  6800              LDR      r0,[r0,#0]
000030  f0400002          ORR      r0,r0,#2
000034  492a              LDR      r1,|L3.224|
000036  3914              SUBS     r1,r1,#0x14
000038  6008              STR      r0,[r1,#0]
00003a  4608              MOV      r0,r1
00003c  6800              LDR      r0,[r0,#0]
00003e  f0000002          AND      r0,r0,#2
000042  9001              STR      r0,[sp,#4]
000044  bf00              NOP      
000046  bf00              NOP      
;;;115      GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_6;
000048  20c0              MOVS     r0,#0xc0
00004a  9002              STR      r0,[sp,#8]
;;;116      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
00004c  2002              MOVS     r0,#2
00004e  9003              STR      r0,[sp,#0xc]
;;;117       GPIO_InitStruct.Pull = GPIO_PULLUP;
000050  2001              MOVS     r0,#1
000052  9004              STR      r0,[sp,#0x10]
;;;118      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
000054  2003              MOVS     r0,#3
000056  9005              STR      r0,[sp,#0x14]
;;;119      GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
000058  2007              MOVS     r0,#7
00005a  9006              STR      r0,[sp,#0x18]
;;;120      HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
00005c  a902              ADD      r1,sp,#8
00005e  4821              LDR      r0,|L3.228|
000060  f7fffffe          BL       HAL_GPIO_Init
;;;121      hdma_usart1_rx.Instance = DMA2_Stream2;
000064  4820              LDR      r0,|L3.232|
000066  4921              LDR      r1,|L3.236|
000068  6008              STR      r0,[r1,#0]  ; hdma_usart1_rx
;;;122      hdma_usart1_rx.Init.Channel = DMA_CHANNEL_4;
00006a  f04f6000          MOV      r0,#0x8000000
00006e  6048              STR      r0,[r1,#4]  ; hdma_usart1_rx
;;;123      hdma_usart1_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
000070  2100              MOVS     r1,#0
000072  481e              LDR      r0,|L3.236|
000074  6081              STR      r1,[r0,#8]
;;;124      hdma_usart1_rx.Init.PeriphInc = DMA_PINC_DISABLE;
000076  60c1              STR      r1,[r0,#0xc]
;;;125      hdma_usart1_rx.Init.MemInc = DMA_MINC_ENABLE;
000078  f44f6180          MOV      r1,#0x400
00007c  6101              STR      r1,[r0,#0x10]
;;;126      hdma_usart1_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
00007e  2100              MOVS     r1,#0
000080  6141              STR      r1,[r0,#0x14]
;;;127      hdma_usart1_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
000082  6181              STR      r1,[r0,#0x18]
;;;128      hdma_usart1_rx.Init.Mode = DMA_CIRCULAR;
000084  f44f7180          MOV      r1,#0x100
000088  61c1              STR      r1,[r0,#0x1c]
;;;129      hdma_usart1_rx.Init.Priority = DMA_PRIORITY_LOW;
00008a  2100              MOVS     r1,#0
00008c  6201              STR      r1,[r0,#0x20]
;;;130      hdma_usart1_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
00008e  6241              STR      r1,[r0,#0x24]
;;;131      HAL_DMA_Init(&hdma_usart1_rx);
000090  f7fffffe          BL       HAL_DMA_Init
;;;132      __HAL_LINKDMA(&huart1,hdmarx,hdma_usart1_rx);
000094  bf00              NOP      
000096  4815              LDR      r0,|L3.236|
000098  4915              LDR      r1,|L3.240|
00009a  6348              STR      r0,[r1,#0x34]  ; huart1
00009c  4608              MOV      r0,r1
00009e  4913              LDR      r1,|L3.236|
0000a0  6388              STR      r0,[r1,#0x38]  ; hdma_usart1_rx
0000a2  bf00              NOP      
;;;133      HAL_NVIC_SetPriority(USART1_IRQn, 0, 0);
0000a4  2200              MOVS     r2,#0
0000a6  4611              MOV      r1,r2
0000a8  2025              MOVS     r0,#0x25
0000aa  f7fffffe          BL       HAL_NVIC_SetPriority
;;;134      HAL_NVIC_EnableIRQ(USART1_IRQn);
0000ae  2025              MOVS     r0,#0x25
0000b0  f7fffffe          BL       HAL_NVIC_EnableIRQ
;;;135      huart1.Instance = USART1;
0000b4  480f              LDR      r0,|L3.244|
0000b6  490e              LDR      r1,|L3.240|
0000b8  6008              STR      r0,[r1,#0]  ; huart1
;;;136      huart1.Init.BaudRate = 100000;
0000ba  480f              LDR      r0,|L3.248|
0000bc  6048              STR      r0,[r1,#4]  ; huart1
;;;137      huart1.Init.WordLength = UART_WORDLENGTH_8B;
0000be  2100              MOVS     r1,#0
0000c0  480b              LDR      r0,|L3.240|
0000c2  6081              STR      r1,[r0,#8]
;;;138      huart1.Init.StopBits = UART_STOPBITS_1;
0000c4  60c1              STR      r1,[r0,#0xc]
;;;139      huart1.Init.Parity = UART_PARITY_EVEN;
0000c6  f44f6180          MOV      r1,#0x400
0000ca  6101              STR      r1,[r0,#0x10]
;;;140      huart1.Init.Mode = UART_MODE_TX_RX;
0000cc  210c              MOVS     r1,#0xc
0000ce  6141              STR      r1,[r0,#0x14]
;;;141      huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
0000d0  2100              MOVS     r1,#0
0000d2  6181              STR      r1,[r0,#0x18]
;;;142      huart1.Init.OverSampling = UART_OVERSAMPLING_16;
0000d4  61c1              STR      r1,[r0,#0x1c]
;;;143      HAL_UART_Init(&huart1);
0000d6  f7fffffe          BL       HAL_UART_Init
;;;144    }
0000da  b007              ADD      sp,sp,#0x1c
0000dc  bd00              POP      {pc}
;;;145    void HAL_UART_MspDeInit(UART_HandleTypeDef* uartHandle)
                          ENDP

0000de  0000              DCW      0x0000
                  |L3.224|
                          DCD      0x40023844
                  |L3.228|
                          DCD      0x40020400
                  |L3.232|
                          DCD      0x40026440
                  |L3.236|
                          DCD      hdma_usart1_rx
                  |L3.240|
                          DCD      huart1
                  |L3.244|
                          DCD      0x40011000
                  |L3.248|
                          DCD      0x000186a0

                          AREA ||i.USART2_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART2_IRQHandler PROC
;;;91     }
;;;92     void USART2_IRQHandler(void)                	
000000  b570              PUSH     {r4-r6,lr}
;;;93     { 
;;;94     	u32 timeout=0;
000002  2400              MOVS     r4,#0
;;;95     	u32 maxDelay=0x1FFFF;
000004  4d0f              LDR      r5,|L4.68|
;;;96     	HAL_UART_IRQHandler(&USART2_Handler);	//调用HAL库中断处理公用函数
000006  4810              LDR      r0,|L4.72|
000008  f7fffffe          BL       HAL_UART_IRQHandler
;;;97     	timeout=0;
00000c  bf00              NOP      
;;;98         while (HAL_UART_GetState(&USART2_Handler) != HAL_UART_STATE_READY)//等待就绪
00000e  e003              B        |L4.24|
                  |L4.16|
;;;99     	{
;;;100    	 timeout++;////超时处理
000010  1c64              ADDS     r4,r4,#1
;;;101         if(timeout>maxDelay) break;		
000012  42ac              CMP      r4,r5
000014  d900              BLS      |L4.24|
000016  e004              B        |L4.34|
                  |L4.24|
000018  480b              LDR      r0,|L4.72|
00001a  f7fffffe          BL       HAL_UART_GetState
00001e  2801              CMP      r0,#1                 ;98
000020  d1f6              BNE      |L4.16|
                  |L4.34|
000022  bf00              NOP      
;;;102    	}
;;;103    	timeout=0;
000024  2400              MOVS     r4,#0
;;;104    	while(HAL_UART_Receive_IT(&USART2_Handler, &aRxBuffer, 1) != HAL_OK)//一次处理完成之后，重新开启中断并设置RxXferCount为1
000026  e003              B        |L4.48|
                  |L4.40|
;;;105    	{
;;;106    	 timeout++; //超时处理
000028  1c64              ADDS     r4,r4,#1
;;;107    	 if(timeout>maxDelay) break;	
00002a  42ac              CMP      r4,r5
00002c  d900              BLS      |L4.48|
00002e  e006              B        |L4.62|
                  |L4.48|
000030  2201              MOVS     r2,#1                 ;104
000032  4906              LDR      r1,|L4.76|
000034  4804              LDR      r0,|L4.72|
000036  f7fffffe          BL       HAL_UART_Receive_IT
00003a  2800              CMP      r0,#0                 ;104
00003c  d1f4              BNE      |L4.40|
                  |L4.62|
00003e  bf00              NOP      
;;;108    	}
;;;109    } 
000040  bd70              POP      {r4-r6,pc}
;;;110    void USART1_Init(void)
                          ENDP

000042  0000              DCW      0x0000
                  |L4.68|
                          DCD      0x0001ffff
                  |L4.72|
                          DCD      USART2_Handler
                  |L4.76|
                          DCD      aRxBuffer

                          AREA ||i.USART2_init||, CODE, READONLY, ALIGN=2

                  USART2_init PROC
;;;35     extern u8 aRxBuffer3;
;;;36     void USART2_init(u32 bound)
000000  b510              PUSH     {r4,lr}
;;;37     {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;38     	GPIO_InitTypeDef GPIO_Initure;
;;;39     	__HAL_RCC_GPIOD_CLK_ENABLE();			//使能GPIOD时钟
000006  bf00              NOP      
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
00000c  4825              LDR      r0,|L5.164|
00000e  6800              LDR      r0,[r0,#0]
000010  f0400008          ORR      r0,r0,#8
000014  4923              LDR      r1,|L5.164|
000016  6008              STR      r0,[r1,#0]
000018  4608              MOV      r0,r1
00001a  6800              LDR      r0,[r0,#0]
00001c  f0000008          AND      r0,r0,#8
000020  9000              STR      r0,[sp,#0]
000022  bf00              NOP      
000024  bf00              NOP      
;;;40     	__HAL_RCC_USART2_CLK_ENABLE();			//使能USART2时钟
000026  bf00              NOP      
000028  2000              MOVS     r0,#0
00002a  9000              STR      r0,[sp,#0]
00002c  481d              LDR      r0,|L5.164|
00002e  3010              ADDS     r0,r0,#0x10
000030  6800              LDR      r0,[r0,#0]
000032  f4403000          ORR      r0,r0,#0x20000
000036  491b              LDR      r1,|L5.164|
000038  3110              ADDS     r1,r1,#0x10
00003a  6008              STR      r0,[r1,#0]
00003c  4608              MOV      r0,r1
00003e  6800              LDR      r0,[r0,#0]
000040  f4003000          AND      r0,r0,#0x20000
000044  9000              STR      r0,[sp,#0]
000046  bf00              NOP      
000048  bf00              NOP      
;;;41     	GPIO_Initure.Pin=GPIO_PIN_5|GPIO_PIN_6;
00004a  2060              MOVS     r0,#0x60
00004c  9001              STR      r0,[sp,#4]
;;;42     	GPIO_Initure.Mode=GPIO_MODE_AF_PP;		//复用推挽输出
00004e  2002              MOVS     r0,#2
000050  9002              STR      r0,[sp,#8]
;;;43     	GPIO_Initure.Pull=GPIO_PULLUP;			//上拉
000052  2001              MOVS     r0,#1
000054  9003              STR      r0,[sp,#0xc]
;;;44     	GPIO_Initure.Speed=GPIO_SPEED_FREQ_VERY_HIGH;		//高速
000056  2003              MOVS     r0,#3
000058  9004              STR      r0,[sp,#0x10]
;;;45     	GPIO_Initure.Alternate=GPIO_AF7_USART2;	//复用为USART2
00005a  2007              MOVS     r0,#7
00005c  9005              STR      r0,[sp,#0x14]
;;;46     	HAL_GPIO_Init(GPIOD,&GPIO_Initure);	   	//初始化PD5,PD6
00005e  a901              ADD      r1,sp,#4
000060  4811              LDR      r0,|L5.168|
000062  f7fffffe          BL       HAL_GPIO_Init
;;;47     	USART2_Handler.Instance=USART2;					    //USART2
000066  4811              LDR      r0,|L5.172|
000068  4911              LDR      r1,|L5.176|
00006a  6008              STR      r0,[r1,#0]  ; USART2_Handler
;;;48     	USART2_Handler.Init.BaudRate=bound;				    //波特率
00006c  4608              MOV      r0,r1
00006e  6044              STR      r4,[r0,#4]  ; USART2_Handler
;;;49     	USART2_Handler.Init.WordLength=UART_WORDLENGTH_8B;   //字长为8位数据格式
000070  2100              MOVS     r1,#0
000072  6081              STR      r1,[r0,#8]
;;;50     	USART2_Handler.Init.StopBits=UART_STOPBITS_1;	    //一个停止位
000074  60c1              STR      r1,[r0,#0xc]
;;;51     	USART2_Handler.Init.Parity=UART_PARITY_NONE;		    //无奇偶校验位
000076  6101              STR      r1,[r0,#0x10]
;;;52     	USART2_Handler.Init.HwFlowCtl=UART_HWCONTROL_NONE;   //无硬件流控
000078  6181              STR      r1,[r0,#0x18]
;;;53     	USART2_Handler.Init.Mode=UART_MODE_TX_RX;		    //收发模式
00007a  210c              MOVS     r1,#0xc
00007c  6141              STR      r1,[r0,#0x14]
;;;54     	USART2_Handler.Init.OverSampling = UART_OVERSAMPLING_16;
00007e  2100              MOVS     r1,#0
000080  61c1              STR      r1,[r0,#0x1c]
;;;55     	HAL_UART_Init(&USART2_Handler);
000082  f7fffffe          BL       HAL_UART_Init
;;;56     	HAL_NVIC_EnableIRQ(USART2_IRQn);		//使能USART2中断通道
000086  2026              MOVS     r0,#0x26
000088  f7fffffe          BL       HAL_NVIC_EnableIRQ
;;;57     	HAL_NVIC_SetPriority(USART2_IRQn,USART2_Priority,0);	//抢占优先级0，子优先级0
00008c  2200              MOVS     r2,#0
00008e  4611              MOV      r1,r2
000090  2026              MOVS     r0,#0x26
000092  f7fffffe          BL       HAL_NVIC_SetPriority
;;;58     	HAL_UART_Receive_IT(&USART2_Handler,&aRxBuffer, 1);
000096  2201              MOVS     r2,#1
000098  4906              LDR      r1,|L5.180|
00009a  4805              LDR      r0,|L5.176|
00009c  f7fffffe          BL       HAL_UART_Receive_IT
;;;59     }
0000a0  b006              ADD      sp,sp,#0x18
0000a2  bd10              POP      {r4,pc}
;;;60     unsigned char Rcv_Flg=0; //若为1则已经收到过帧头
                          ENDP

                  |L5.164|
                          DCD      0x40023830
                  |L5.168|
                          DCD      0x40020c00
                  |L5.172|
                          DCD      0x40004400
                  |L5.176|
                          DCD      USART2_Handler
                  |L5.180|
                          DCD      aRxBuffer

                          AREA ||i.USART3_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART3_IRQHandler PROC
;;;178    }
;;;179    void USART3_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;180    { 
;;;181    	u32 timeout=0;
000002  2400              MOVS     r4,#0
;;;182    	u32 maxDelay=0x1FFFF;
000004  4d0f              LDR      r5,|L6.68|
;;;183    	HAL_UART_IRQHandler(&USART3_Handler);	//调用HAL库中断处理公用函数
000006  4810              LDR      r0,|L6.72|
000008  f7fffffe          BL       HAL_UART_IRQHandler
;;;184    	timeout=0;
00000c  bf00              NOP      
;;;185        while (HAL_UART_GetState(&USART3_Handler) != HAL_UART_STATE_READY)//等待就绪
00000e  e003              B        |L6.24|
                  |L6.16|
;;;186    	{
;;;187    	 timeout++;////超时处理
000010  1c64              ADDS     r4,r4,#1
;;;188         if(timeout>maxDelay) break;		
000012  42ac              CMP      r4,r5
000014  d900              BLS      |L6.24|
000016  e004              B        |L6.34|
                  |L6.24|
000018  480b              LDR      r0,|L6.72|
00001a  f7fffffe          BL       HAL_UART_GetState
00001e  2801              CMP      r0,#1                 ;185
000020  d1f6              BNE      |L6.16|
                  |L6.34|
000022  bf00              NOP      
;;;189    	}
;;;190    	timeout=0;
000024  2400              MOVS     r4,#0
;;;191    	while(HAL_UART_Receive_IT(&USART3_Handler, &aRxBuffer3, 1) != HAL_OK)//一次处理完成之后，重新开启中断并设置RxXferCount为1
000026  e003              B        |L6.48|
                  |L6.40|
;;;192    	{
;;;193    	 timeout++; //超时处理
000028  1c64              ADDS     r4,r4,#1
;;;194    	 if(timeout>maxDelay) break;	
00002a  42ac              CMP      r4,r5
00002c  d900              BLS      |L6.48|
00002e  e006              B        |L6.62|
                  |L6.48|
000030  2201              MOVS     r2,#1                 ;191
000032  4906              LDR      r1,|L6.76|
000034  4804              LDR      r0,|L6.72|
000036  f7fffffe          BL       HAL_UART_Receive_IT
00003a  2800              CMP      r0,#0                 ;191
00003c  d1f4              BNE      |L6.40|
                  |L6.62|
00003e  bf00              NOP      
;;;195    	}
;;;196    }
000040  bd70              POP      {r4-r6,pc}
;;;197    
                          ENDP

000042  0000              DCW      0x0000
                  |L6.68|
                          DCD      0x0001ffff
                  |L6.72|
                          DCD      USART3_Handler
                  |L6.76|
                          DCD      aRxBuffer3

                          AREA ||i.USART3_Init||, CODE, READONLY, ALIGN=2

                  USART3_Init PROC
;;;154    }
;;;155    void USART3_Init(unsigned long baud)
000000  b510              PUSH     {r4,lr}
;;;156    {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;157    	GPIO_InitTypeDef GPIO_Initure;
;;;158    	__HAL_RCC_GPIOD_CLK_ENABLE();			//使能GPIOD时钟
000006  bf00              NOP      
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
00000c  4826              LDR      r0,|L7.168|
00000e  6800              LDR      r0,[r0,#0]
000010  f0400008          ORR      r0,r0,#8
000014  4924              LDR      r1,|L7.168|
000016  6008              STR      r0,[r1,#0]
000018  4608              MOV      r0,r1
00001a  6800              LDR      r0,[r0,#0]
00001c  f0000008          AND      r0,r0,#8
000020  9000              STR      r0,[sp,#0]
000022  bf00              NOP      
000024  bf00              NOP      
;;;159    	__HAL_RCC_USART3_CLK_ENABLE();			//使能USART3时钟
000026  bf00              NOP      
000028  2000              MOVS     r0,#0
00002a  9000              STR      r0,[sp,#0]
00002c  481e              LDR      r0,|L7.168|
00002e  3010              ADDS     r0,r0,#0x10
000030  6800              LDR      r0,[r0,#0]
000032  f4402080          ORR      r0,r0,#0x40000
000036  491c              LDR      r1,|L7.168|
000038  3110              ADDS     r1,r1,#0x10
00003a  6008              STR      r0,[r1,#0]
00003c  4608              MOV      r0,r1
00003e  6800              LDR      r0,[r0,#0]
000040  f4002080          AND      r0,r0,#0x40000
000044  9000              STR      r0,[sp,#0]
000046  bf00              NOP      
000048  bf00              NOP      
;;;160    	GPIO_Initure.Pin=GPIO_PIN_8|GPIO_PIN_9;
00004a  f44f7040          MOV      r0,#0x300
00004e  9001              STR      r0,[sp,#4]
;;;161    	GPIO_Initure.Mode=GPIO_MODE_AF_PP;		//复用推挽输出
000050  2002              MOVS     r0,#2
000052  9002              STR      r0,[sp,#8]
;;;162    	GPIO_Initure.Pull=GPIO_PULLUP;	 		//上拉
000054  2001              MOVS     r0,#1
000056  9003              STR      r0,[sp,#0xc]
;;;163    	GPIO_Initure.Speed=GPIO_SPEED_FREQ_VERY_HIGH;		//高速
000058  2003              MOVS     r0,#3
00005a  9004              STR      r0,[sp,#0x10]
;;;164    	GPIO_Initure.Alternate=GPIO_AF7_USART3;	//复用为USART3
00005c  2007              MOVS     r0,#7
00005e  9005              STR      r0,[sp,#0x14]
;;;165    	HAL_GPIO_Init(GPIOD,&GPIO_Initure);	   	//初始化PD8,PD9
000060  a901              ADD      r1,sp,#4
000062  4812              LDR      r0,|L7.172|
000064  f7fffffe          BL       HAL_GPIO_Init
;;;166    	USART3_Handler.Instance=USART3;					    //USART2
000068  4811              LDR      r0,|L7.176|
00006a  4912              LDR      r1,|L7.180|
00006c  6008              STR      r0,[r1,#0]  ; USART3_Handler
;;;167    	USART3_Handler.Init.BaudRate=baud;				    //波特率
00006e  4608              MOV      r0,r1
000070  6044              STR      r4,[r0,#4]  ; USART3_Handler
;;;168    	USART3_Handler.Init.WordLength=UART_WORDLENGTH_8B;   //字长为8位数据格式
000072  2100              MOVS     r1,#0
000074  6081              STR      r1,[r0,#8]
;;;169    	USART3_Handler.Init.StopBits=UART_STOPBITS_1;	    //一个停止位
000076  60c1              STR      r1,[r0,#0xc]
;;;170    	USART3_Handler.Init.Parity=UART_PARITY_NONE;		    //无奇偶校验位
000078  6101              STR      r1,[r0,#0x10]
;;;171    	USART3_Handler.Init.HwFlowCtl=UART_HWCONTROL_NONE;   //无硬件流控
00007a  6181              STR      r1,[r0,#0x18]
;;;172    	USART3_Handler.Init.Mode=UART_MODE_TX_RX;		    //收发模式
00007c  210c              MOVS     r1,#0xc
00007e  6141              STR      r1,[r0,#0x14]
;;;173    	USART3_Handler.Init.OverSampling = UART_OVERSAMPLING_16;
000080  2100              MOVS     r1,#0
000082  61c1              STR      r1,[r0,#0x1c]
;;;174    	HAL_UART_Init(&USART3_Handler);
000084  f7fffffe          BL       HAL_UART_Init
;;;175    	HAL_NVIC_EnableIRQ(USART3_IRQn);		//使能USART2中断通道
000088  2027              MOVS     r0,#0x27
00008a  f7fffffe          BL       HAL_NVIC_EnableIRQ
;;;176    	HAL_NVIC_SetPriority(USART3_IRQn,USART3_Priority,0);	//抢占优先级0，子优先级0
00008e  2200              MOVS     r2,#0
000090  2101              MOVS     r1,#1
000092  2027              MOVS     r0,#0x27
000094  f7fffffe          BL       HAL_NVIC_SetPriority
;;;177    	HAL_UART_Receive_IT(&USART3_Handler,&aRxBuffer3, 1);
000098  2201              MOVS     r2,#1
00009a  4907              LDR      r1,|L7.184|
00009c  4805              LDR      r0,|L7.180|
00009e  f7fffffe          BL       HAL_UART_Receive_IT
;;;178    }
0000a2  b006              ADD      sp,sp,#0x18
0000a4  bd10              POP      {r4,pc}
;;;179    void USART3_IRQHandler(void)
                          ENDP

0000a6  0000              DCW      0x0000
                  |L7.168|
                          DCD      0x40023830
                  |L7.172|
                          DCD      0x40020c00
                  |L7.176|
                          DCD      0x40004800
                  |L7.180|
                          DCD      USART3_Handler
                  |L7.184|
                          DCD      aRxBuffer3

                          AREA ||i._sys_exit||, CODE, READONLY, ALIGN=1

                  _sys_exit PROC
;;;21     //定义_sys_exit()以避免使用半主机模式    
;;;22     void _sys_exit(int x) 
000000  bf00              NOP      
;;;23     { 
;;;24     	x = x; 
;;;25     } 
000002  4770              BX       lr
;;;26     //重定义fputc函数 
                          ENDP


                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;26     //重定义fputc函数 
;;;27     int fputc(int ch, FILE *f)
000000  bf00              NOP      
                  |L9.2|
;;;28     { 	
;;;29     	while((USART2->SR&0X40)==0);//循环发送,直到发送完毕   
000002  4a05              LDR      r2,|L9.24|
000004  6812              LDR      r2,[r2,#0]
000006  f0020240          AND      r2,r2,#0x40
00000a  2a00              CMP      r2,#0
00000c  d0f9              BEQ      |L9.2|
;;;30     	USART2->DR = (u8) ch;      
00000e  b2c2              UXTB     r2,r0
000010  4b01              LDR      r3,|L9.24|
000012  1d1b              ADDS     r3,r3,#4
000014  601a              STR      r2,[r3,#0]
;;;31     	return ch;
;;;32     }
000016  4770              BX       lr
;;;33     #endif 
                          ENDP

                  |L9.24|
                          DCD      0x40004400

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  huart1
                          %        64
                  hdma_usart1_rx
                          %        88
                  USART3_Handler
                          %        64
                  USART2_Handler
                          %        64
                  USART3_Rcv_Buffer
                          %        15

                          AREA ||.data||, DATA, ALIGN=1

                  USART2_Receve_Handler
                          %        8
                  USART3_Receve_Handler
                          %        8
                  aRxBuffer3
000010  0000              DCB      0x00,0x00
                  __stdout
000012  0000              DCB      0x00,0x00
000014  0000              DCB      0x00,0x00
                  aRxBuffer
000016  00                DCB      0x00
                  Rcv_Flg
000017  00                DCB      0x00
                  RX_Counter
000018  01                DCB      0x01

;*** Start embedded assembler ***

#line 1 "Hardware\\USART.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_USART_c_9275e5e5____REV16|
#line 388 ".\\CORE\\cmsis_armcc.h"
|__asm___7_USART_c_9275e5e5____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_USART_c_9275e5e5____REVSH|
#line 402
|__asm___7_USART_c_9275e5e5____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___7_USART_c_9275e5e5____RRX|
#line 587
|__asm___7_USART_c_9275e5e5____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
