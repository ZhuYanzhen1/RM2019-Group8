; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\usart.o --asm_dir=.\OBJ\ --list_dir=.\OBJ\ --depend=.\obj\usart.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I.\CORE -I.\USER -I.\HALLIB\STM32F4xx_HAL_Driver\Inc -I.\SYSTEM -I.\Hardware -I.\App -I.\DSP_LIB\Include -I.\FreeRTOS -I.\MPU9250\DMP -I.\MPU9250 -I.\RTE\_Project -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=526 -DSTM32F427xx -DSTM32F4 -DUSE_HAL_DRIVER -DSTM32F427xx -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=.\obj\usart.crf Hardware\USART.c]
                          THUMB

                          AREA ||i.HAL_UART_MspDeInit||, CODE, READONLY, ALIGN=2

                  HAL_UART_MspDeInit PROC
;;;173    }
;;;174    void HAL_UART_MspDeInit(UART_HandleTypeDef* uartHandle)
000000  b510              PUSH     {r4,lr}
;;;175    {
000002  4604              MOV      r4,r0
;;;176      if(uartHandle->Instance==USART1)
000004  490a              LDR      r1,|L1.48|
000006  6820              LDR      r0,[r4,#0]
000008  4288              CMP      r0,r1
00000a  d10f              BNE      |L1.44|
;;;177      {
;;;178        __HAL_RCC_USART1_CLK_DISABLE();
00000c  4809              LDR      r0,|L1.52|
00000e  6800              LDR      r0,[r0,#0]
000010  f0200010          BIC      r0,r0,#0x10
000014  4907              LDR      r1,|L1.52|
000016  6008              STR      r0,[r1,#0]
;;;179        HAL_GPIO_DeInit(GPIOB, GPIO_PIN_7|GPIO_PIN_6);
000018  21c0              MOVS     r1,#0xc0
00001a  4807              LDR      r0,|L1.56|
00001c  f7fffffe          BL       HAL_GPIO_DeInit
;;;180        HAL_DMA_DeInit(uartHandle->hdmarx);
000020  6b60              LDR      r0,[r4,#0x34]
000022  f7fffffe          BL       HAL_DMA_DeInit
;;;181        HAL_NVIC_DisableIRQ(USART1_IRQn);
000026  2025              MOVS     r0,#0x25
000028  f7fffffe          BL       HAL_NVIC_DisableIRQ
                  |L1.44|
;;;182      }
;;;183    }
00002c  bd10              POP      {r4,pc}
;;;184    void USART3_Init(unsigned long baud)
                          ENDP

00002e  0000              DCW      0x0000
                  |L1.48|
                          DCD      0x40011000
                  |L1.52|
                          DCD      0x40023844
                  |L1.56|
                          DCD      0x40020400

                          AREA ||i.HAL_UART_RxCpltCallback||, CODE, READONLY, ALIGN=2

                  HAL_UART_RxCpltCallback PROC
;;;69     
;;;70     void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;71     {
000002  4604              MOV      r4,r0
;;;72     	if(huart->Instance==USART6)//如果是串口6
000004  4940              LDR      r1,|L2.264|
000006  6820              LDR      r0,[r4,#0]
000008  4288              CMP      r0,r1
00000a  d103              BNE      |L2.20|
;;;73     	{
;;;74     		Referee_Decode(aRxBuffer6);	//裁判系统解码
00000c  483f              LDR      r0,|L2.268|
00000e  7800              LDRB     r0,[r0,#0]  ; aRxBuffer6
000010  f7fffffe          BL       Referee_Decode
                  |L2.20|
;;;75     	}
;;;76     	if(huart->Instance==USART2)//如果是串口2
000014  493e              LDR      r1,|L2.272|
000016  6820              LDR      r0,[r4,#0]
000018  4288              CMP      r0,r1
00001a  d137              BNE      |L2.140|
;;;77     	{
;;;78     		if(aRxBuffer == 0xff && Rcv_Flg2 == 1)
00001c  483d              LDR      r0,|L2.276|
00001e  7800              LDRB     r0,[r0,#0]  ; aRxBuffer
000020  28ff              CMP      r0,#0xff
000022  d110              BNE      |L2.70|
000024  483c              LDR      r0,|L2.280|
000026  7800              LDRB     r0,[r0,#0]  ; Rcv_Flg2
000028  2801              CMP      r0,#1
00002a  d10c              BNE      |L2.70|
;;;79     		{
;;;80     			Rcv_Flg2 = 0;//结束收发
00002c  2000              MOVS     r0,#0
00002e  493a              LDR      r1,|L2.280|
000030  7008              STRB     r0,[r1,#0]
;;;81     			RX_Counter2=1;
000032  2001              MOVS     r0,#1
000034  4939              LDR      r1,|L2.284|
000036  7008              STRB     r0,[r1,#0]
;;;82     			USART2_Rcv_Buffer[11]=0xff;
000038  20ff              MOVS     r0,#0xff
00003a  4939              LDR      r1,|L2.288|
00003c  72c8              STRB     r0,[r1,#0xb]
;;;83     			USART2_Received_CallBack((unsigned char *)&USART2_Rcv_Buffer);
00003e  4608              MOV      r0,r1
000040  f7fffffe          BL       USART2_Received_CallBack
000044  e022              B        |L2.140|
                  |L2.70|
;;;84     		}
;;;85     		else if(aRxBuffer == 0xff && Rcv_Flg2 == 0)
000046  4833              LDR      r0,|L2.276|
000048  7800              LDRB     r0,[r0,#0]  ; aRxBuffer
00004a  28ff              CMP      r0,#0xff
00004c  d10f              BNE      |L2.110|
00004e  4832              LDR      r0,|L2.280|
000050  7800              LDRB     r0,[r0,#0]  ; Rcv_Flg2
000052  b960              CBNZ     r0,|L2.110|
;;;86     		{
;;;87     			Rcv_Flg2 = 1;
000054  2001              MOVS     r0,#1
000056  4930              LDR      r1,|L2.280|
000058  7008              STRB     r0,[r1,#0]
;;;88     			RX_Counter2=1;
00005a  4930              LDR      r1,|L2.284|
00005c  7008              STRB     r0,[r1,#0]
;;;89     			memset(&USART2_Rcv_Buffer,0x00,sizeof(USART2_Rcv_Buffer));
00005e  210f              MOVS     r1,#0xf
000060  482f              LDR      r0,|L2.288|
000062  f7fffffe          BL       __aeabi_memclr
;;;90     			USART2_Rcv_Buffer[0]=0xff;
000066  20ff              MOVS     r0,#0xff
000068  492d              LDR      r1,|L2.288|
00006a  7008              STRB     r0,[r1,#0]
00006c  e00e              B        |L2.140|
                  |L2.110|
;;;91     		}
;;;92     		else if(Rcv_Flg2 == 1)
00006e  482a              LDR      r0,|L2.280|
000070  7800              LDRB     r0,[r0,#0]  ; Rcv_Flg2
000072  2801              CMP      r0,#1
000074  d10a              BNE      |L2.140|
;;;93     		{
;;;94     			USART2_Rcv_Buffer[RX_Counter2] = aRxBuffer;
000076  4827              LDR      r0,|L2.276|
000078  7800              LDRB     r0,[r0,#0]  ; aRxBuffer
00007a  4929              LDR      r1,|L2.288|
00007c  4a27              LDR      r2,|L2.284|
00007e  7812              LDRB     r2,[r2,#0]  ; RX_Counter2
000080  5488              STRB     r0,[r1,r2]
;;;95     			RX_Counter2++;
000082  4826              LDR      r0,|L2.284|
000084  7800              LDRB     r0,[r0,#0]  ; RX_Counter2
000086  1c40              ADDS     r0,r0,#1
000088  4924              LDR      r1,|L2.284|
00008a  7008              STRB     r0,[r1,#0]
                  |L2.140|
;;;96     		}
;;;97     	}
;;;98     	if(huart->Instance==USART3)//如果是串口3
00008c  4925              LDR      r1,|L2.292|
00008e  6820              LDR      r0,[r4,#0]
000090  4288              CMP      r0,r1
000092  d137              BNE      |L2.260|
;;;99     	{
;;;100    		if(aRxBuffer3 == 0xff && Rcv_Flg == 1)
000094  4824              LDR      r0,|L2.296|
000096  7800              LDRB     r0,[r0,#0]  ; aRxBuffer3
000098  28ff              CMP      r0,#0xff
00009a  d110              BNE      |L2.190|
00009c  4823              LDR      r0,|L2.300|
00009e  7800              LDRB     r0,[r0,#0]  ; Rcv_Flg
0000a0  2801              CMP      r0,#1
0000a2  d10c              BNE      |L2.190|
;;;101    		{
;;;102    			Rcv_Flg = 0;//结束收发
0000a4  2000              MOVS     r0,#0
0000a6  4921              LDR      r1,|L2.300|
0000a8  7008              STRB     r0,[r1,#0]
;;;103    			RX_Counter=1;
0000aa  2001              MOVS     r0,#1
0000ac  4920              LDR      r1,|L2.304|
0000ae  7008              STRB     r0,[r1,#0]
;;;104    			USART3_Rcv_Buffer[11]=0xff;
0000b0  20ff              MOVS     r0,#0xff
0000b2  4920              LDR      r1,|L2.308|
0000b4  72c8              STRB     r0,[r1,#0xb]
;;;105    			USART3_Received_CallBack((unsigned char *)&USART3_Rcv_Buffer);
0000b6  4608              MOV      r0,r1
0000b8  f7fffffe          BL       USART3_Received_CallBack
0000bc  e022              B        |L2.260|
                  |L2.190|
;;;106    		}
;;;107    		else if(aRxBuffer3 == 0xff && Rcv_Flg == 0)
0000be  481a              LDR      r0,|L2.296|
0000c0  7800              LDRB     r0,[r0,#0]  ; aRxBuffer3
0000c2  28ff              CMP      r0,#0xff
0000c4  d10f              BNE      |L2.230|
0000c6  4819              LDR      r0,|L2.300|
0000c8  7800              LDRB     r0,[r0,#0]  ; Rcv_Flg
0000ca  b960              CBNZ     r0,|L2.230|
;;;108    		{
;;;109    			Rcv_Flg = 1;
0000cc  2001              MOVS     r0,#1
0000ce  4917              LDR      r1,|L2.300|
0000d0  7008              STRB     r0,[r1,#0]
;;;110    			RX_Counter=1;
0000d2  4917              LDR      r1,|L2.304|
0000d4  7008              STRB     r0,[r1,#0]
;;;111    			memset(&USART3_Rcv_Buffer,0x00,sizeof(USART3_Rcv_Buffer));
0000d6  210f              MOVS     r1,#0xf
0000d8  4816              LDR      r0,|L2.308|
0000da  f7fffffe          BL       __aeabi_memclr4
;;;112    			USART3_Rcv_Buffer[0]=0xff;
0000de  20ff              MOVS     r0,#0xff
0000e0  4914              LDR      r1,|L2.308|
0000e2  7008              STRB     r0,[r1,#0]
0000e4  e00e              B        |L2.260|
                  |L2.230|
;;;113    		}
;;;114    		else if(Rcv_Flg == 1)
0000e6  4811              LDR      r0,|L2.300|
0000e8  7800              LDRB     r0,[r0,#0]  ; Rcv_Flg
0000ea  2801              CMP      r0,#1
0000ec  d10a              BNE      |L2.260|
;;;115    		{
;;;116    			USART3_Rcv_Buffer[RX_Counter] = aRxBuffer3;
0000ee  480e              LDR      r0,|L2.296|
0000f0  7800              LDRB     r0,[r0,#0]  ; aRxBuffer3
0000f2  4910              LDR      r1,|L2.308|
0000f4  4a0e              LDR      r2,|L2.304|
0000f6  7812              LDRB     r2,[r2,#0]  ; RX_Counter
0000f8  5488              STRB     r0,[r1,r2]
;;;117    			RX_Counter++;
0000fa  480d              LDR      r0,|L2.304|
0000fc  7800              LDRB     r0,[r0,#0]  ; RX_Counter
0000fe  1c40              ADDS     r0,r0,#1
000100  490b              LDR      r1,|L2.304|
000102  7008              STRB     r0,[r1,#0]
                  |L2.260|
;;;118    		}
;;;119    	}
;;;120    }
000104  bd10              POP      {r4,pc}
;;;121    void USART2_IRQHandler(void)                	
                          ENDP

000106  0000              DCW      0x0000
                  |L2.264|
                          DCD      0x40011400
                  |L2.268|
                          DCD      aRxBuffer6
                  |L2.272|
                          DCD      0x40004400
                  |L2.276|
                          DCD      aRxBuffer
                  |L2.280|
                          DCD      Rcv_Flg2
                  |L2.284|
                          DCD      RX_Counter2
                  |L2.288|
                          DCD      USART2_Rcv_Buffer
                  |L2.292|
                          DCD      0x40004800
                  |L2.296|
                          DCD      aRxBuffer3
                  |L2.300|
                          DCD      Rcv_Flg
                  |L2.304|
                          DCD      RX_Counter
                  |L2.308|
                          DCD      USART3_Rcv_Buffer

                          AREA ||i.USART1_Init||, CODE, READONLY, ALIGN=2

                  USART1_Init PROC
;;;138    } 
;;;139    void USART1_Init(void)
000000  b500              PUSH     {lr}
;;;140    {
000002  b087              SUB      sp,sp,#0x1c
;;;141    	GPIO_InitTypeDef GPIO_InitStruct;
;;;142      __HAL_RCC_USART1_CLK_ENABLE();
000004  bf00              NOP      
000006  2000              MOVS     r0,#0
000008  9001              STR      r0,[sp,#4]
00000a  4835              LDR      r0,|L3.224|
00000c  6800              LDR      r0,[r0,#0]
00000e  f0400010          ORR      r0,r0,#0x10
000012  4933              LDR      r1,|L3.224|
000014  6008              STR      r0,[r1,#0]
000016  4608              MOV      r0,r1
000018  6800              LDR      r0,[r0,#0]
00001a  f0000010          AND      r0,r0,#0x10
00001e  9001              STR      r0,[sp,#4]
000020  bf00              NOP      
000022  bf00              NOP      
;;;143    	__HAL_RCC_GPIOB_CLK_ENABLE();
000024  bf00              NOP      
000026  2000              MOVS     r0,#0
000028  9001              STR      r0,[sp,#4]
00002a  482d              LDR      r0,|L3.224|
00002c  3814              SUBS     r0,r0,#0x14
00002e  6800              LDR      r0,[r0,#0]
000030  f0400002          ORR      r0,r0,#2
000034  492a              LDR      r1,|L3.224|
000036  3914              SUBS     r1,r1,#0x14
000038  6008              STR      r0,[r1,#0]
00003a  4608              MOV      r0,r1
00003c  6800              LDR      r0,[r0,#0]
00003e  f0000002          AND      r0,r0,#2
000042  9001              STR      r0,[sp,#4]
000044  bf00              NOP      
000046  bf00              NOP      
;;;144      GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_6;
000048  20c0              MOVS     r0,#0xc0
00004a  9002              STR      r0,[sp,#8]
;;;145      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
00004c  2002              MOVS     r0,#2
00004e  9003              STR      r0,[sp,#0xc]
;;;146       GPIO_InitStruct.Pull = GPIO_PULLUP;
000050  2001              MOVS     r0,#1
000052  9004              STR      r0,[sp,#0x10]
;;;147      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
000054  2003              MOVS     r0,#3
000056  9005              STR      r0,[sp,#0x14]
;;;148      GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
000058  2007              MOVS     r0,#7
00005a  9006              STR      r0,[sp,#0x18]
;;;149      HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
00005c  a902              ADD      r1,sp,#8
00005e  4821              LDR      r0,|L3.228|
000060  f7fffffe          BL       HAL_GPIO_Init
;;;150      hdma_usart1_rx.Instance = DMA2_Stream2;
000064  4820              LDR      r0,|L3.232|
000066  4921              LDR      r1,|L3.236|
000068  6008              STR      r0,[r1,#0]  ; hdma_usart1_rx
;;;151      hdma_usart1_rx.Init.Channel = DMA_CHANNEL_4;
00006a  f04f6000          MOV      r0,#0x8000000
00006e  6048              STR      r0,[r1,#4]  ; hdma_usart1_rx
;;;152      hdma_usart1_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
000070  2100              MOVS     r1,#0
000072  481e              LDR      r0,|L3.236|
000074  6081              STR      r1,[r0,#8]
;;;153      hdma_usart1_rx.Init.PeriphInc = DMA_PINC_DISABLE;
000076  60c1              STR      r1,[r0,#0xc]
;;;154      hdma_usart1_rx.Init.MemInc = DMA_MINC_ENABLE;
000078  f44f6180          MOV      r1,#0x400
00007c  6101              STR      r1,[r0,#0x10]
;;;155      hdma_usart1_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
00007e  2100              MOVS     r1,#0
000080  6141              STR      r1,[r0,#0x14]
;;;156      hdma_usart1_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
000082  6181              STR      r1,[r0,#0x18]
;;;157      hdma_usart1_rx.Init.Mode = DMA_CIRCULAR;
000084  f44f7180          MOV      r1,#0x100
000088  61c1              STR      r1,[r0,#0x1c]
;;;158      hdma_usart1_rx.Init.Priority = DMA_PRIORITY_LOW;
00008a  2100              MOVS     r1,#0
00008c  6201              STR      r1,[r0,#0x20]
;;;159      hdma_usart1_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
00008e  6241              STR      r1,[r0,#0x24]
;;;160      HAL_DMA_Init(&hdma_usart1_rx);
000090  f7fffffe          BL       HAL_DMA_Init
;;;161      __HAL_LINKDMA(&huart1,hdmarx,hdma_usart1_rx);
000094  bf00              NOP      
000096  4815              LDR      r0,|L3.236|
000098  4915              LDR      r1,|L3.240|
00009a  6348              STR      r0,[r1,#0x34]  ; huart1
00009c  4608              MOV      r0,r1
00009e  4913              LDR      r1,|L3.236|
0000a0  6388              STR      r0,[r1,#0x38]  ; hdma_usart1_rx
0000a2  bf00              NOP      
;;;162      HAL_NVIC_SetPriority(USART1_IRQn, 0, 0);
0000a4  2200              MOVS     r2,#0
0000a6  4611              MOV      r1,r2
0000a8  2025              MOVS     r0,#0x25
0000aa  f7fffffe          BL       HAL_NVIC_SetPriority
;;;163      HAL_NVIC_EnableIRQ(USART1_IRQn);
0000ae  2025              MOVS     r0,#0x25
0000b0  f7fffffe          BL       HAL_NVIC_EnableIRQ
;;;164      huart1.Instance = USART1;
0000b4  480f              LDR      r0,|L3.244|
0000b6  490e              LDR      r1,|L3.240|
0000b8  6008              STR      r0,[r1,#0]  ; huart1
;;;165      huart1.Init.BaudRate = 100000;
0000ba  480f              LDR      r0,|L3.248|
0000bc  6048              STR      r0,[r1,#4]  ; huart1
;;;166      huart1.Init.WordLength = UART_WORDLENGTH_8B;
0000be  2100              MOVS     r1,#0
0000c0  480b              LDR      r0,|L3.240|
0000c2  6081              STR      r1,[r0,#8]
;;;167      huart1.Init.StopBits = UART_STOPBITS_1;
0000c4  60c1              STR      r1,[r0,#0xc]
;;;168      huart1.Init.Parity = UART_PARITY_EVEN;
0000c6  f44f6180          MOV      r1,#0x400
0000ca  6101              STR      r1,[r0,#0x10]
;;;169      huart1.Init.Mode = UART_MODE_TX_RX;
0000cc  210c              MOVS     r1,#0xc
0000ce  6141              STR      r1,[r0,#0x14]
;;;170      huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
0000d0  2100              MOVS     r1,#0
0000d2  6181              STR      r1,[r0,#0x18]
;;;171      huart1.Init.OverSampling = UART_OVERSAMPLING_16;
0000d4  61c1              STR      r1,[r0,#0x1c]
;;;172      HAL_UART_Init(&huart1);
0000d6  f7fffffe          BL       HAL_UART_Init
;;;173    }
0000da  b007              ADD      sp,sp,#0x1c
0000dc  bd00              POP      {pc}
;;;174    void HAL_UART_MspDeInit(UART_HandleTypeDef* uartHandle)
                          ENDP

0000de  0000              DCW      0x0000
                  |L3.224|
                          DCD      0x40023844
                  |L3.228|
                          DCD      0x40020400
                  |L3.232|
                          DCD      0x40026440
                  |L3.236|
                          DCD      hdma_usart1_rx
                  |L3.240|
                          DCD      huart1
                  |L3.244|
                          DCD      0x40011000
                  |L3.248|
                          DCD      0x000186a0

                          AREA ||i.USART2_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART2_IRQHandler PROC
;;;120    }
;;;121    void USART2_IRQHandler(void)                	
000000  b570              PUSH     {r4-r6,lr}
;;;122    { 
;;;123    	u32 timeout=0;
000002  2400              MOVS     r4,#0
;;;124    	u32 maxDelay=0x1FFFF;
000004  4d0f              LDR      r5,|L4.68|
;;;125    	HAL_UART_IRQHandler(&USART2_Handler);	//调用HAL库中断处理公用函数
000006  4810              LDR      r0,|L4.72|
000008  f7fffffe          BL       HAL_UART_IRQHandler
;;;126    	timeout=0;
00000c  bf00              NOP      
;;;127        while (HAL_UART_GetState(&USART2_Handler) != HAL_UART_STATE_READY)//等待就绪
00000e  e003              B        |L4.24|
                  |L4.16|
;;;128    	{
;;;129    	 timeout++;////超时处理
000010  1c64              ADDS     r4,r4,#1
;;;130         if(timeout>maxDelay) break;		
000012  42ac              CMP      r4,r5
000014  d900              BLS      |L4.24|
000016  e004              B        |L4.34|
                  |L4.24|
000018  480b              LDR      r0,|L4.72|
00001a  f7fffffe          BL       HAL_UART_GetState
00001e  2801              CMP      r0,#1                 ;127
000020  d1f6              BNE      |L4.16|
                  |L4.34|
000022  bf00              NOP      
;;;131    	}
;;;132    	timeout=0;
000024  2400              MOVS     r4,#0
;;;133    	while(HAL_UART_Receive_IT(&USART2_Handler, &aRxBuffer, 1) != HAL_OK)//一次处理完成之后，重新开启中断并设置RxXferCount为1
000026  e003              B        |L4.48|
                  |L4.40|
;;;134    	{
;;;135    	 timeout++; //超时处理
000028  1c64              ADDS     r4,r4,#1
;;;136    	 if(timeout>maxDelay) break;	
00002a  42ac              CMP      r4,r5
00002c  d900              BLS      |L4.48|
00002e  e006              B        |L4.62|
                  |L4.48|
000030  2201              MOVS     r2,#1                 ;133
000032  4906              LDR      r1,|L4.76|
000034  4804              LDR      r0,|L4.72|
000036  f7fffffe          BL       HAL_UART_Receive_IT
00003a  2800              CMP      r0,#0                 ;133
00003c  d1f4              BNE      |L4.40|
                  |L4.62|
00003e  bf00              NOP      
;;;137    	}
;;;138    } 
000040  bd70              POP      {r4-r6,pc}
;;;139    void USART1_Init(void)
                          ENDP

000042  0000              DCW      0x0000
                  |L4.68|
                          DCD      0x0001ffff
                  |L4.72|
                          DCD      USART2_Handler
                  |L4.76|
                          DCD      aRxBuffer

                          AREA ||i.USART2_init||, CODE, READONLY, ALIGN=2

                  USART2_init PROC
;;;37     
;;;38     void USART2_init(u32 bound)
000000  b510              PUSH     {r4,lr}
;;;39     {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;40     	GPIO_InitTypeDef GPIO_Initure;
;;;41     	__HAL_RCC_GPIOD_CLK_ENABLE();			//使能GPIOD时钟
000006  bf00              NOP      
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
00000c  4825              LDR      r0,|L5.164|
00000e  6800              LDR      r0,[r0,#0]
000010  f0400008          ORR      r0,r0,#8
000014  4923              LDR      r1,|L5.164|
000016  6008              STR      r0,[r1,#0]
000018  4608              MOV      r0,r1
00001a  6800              LDR      r0,[r0,#0]
00001c  f0000008          AND      r0,r0,#8
000020  9000              STR      r0,[sp,#0]
000022  bf00              NOP      
000024  bf00              NOP      
;;;42     	__HAL_RCC_USART2_CLK_ENABLE();			//使能USART2时钟
000026  bf00              NOP      
000028  2000              MOVS     r0,#0
00002a  9000              STR      r0,[sp,#0]
00002c  481d              LDR      r0,|L5.164|
00002e  3010              ADDS     r0,r0,#0x10
000030  6800              LDR      r0,[r0,#0]
000032  f4403000          ORR      r0,r0,#0x20000
000036  491b              LDR      r1,|L5.164|
000038  3110              ADDS     r1,r1,#0x10
00003a  6008              STR      r0,[r1,#0]
00003c  4608              MOV      r0,r1
00003e  6800              LDR      r0,[r0,#0]
000040  f4003000          AND      r0,r0,#0x20000
000044  9000              STR      r0,[sp,#0]
000046  bf00              NOP      
000048  bf00              NOP      
;;;43     	GPIO_Initure.Pin=GPIO_PIN_5|GPIO_PIN_6;
00004a  2060              MOVS     r0,#0x60
00004c  9001              STR      r0,[sp,#4]
;;;44     	GPIO_Initure.Mode=GPIO_MODE_AF_PP;		//复用推挽输出
00004e  2002              MOVS     r0,#2
000050  9002              STR      r0,[sp,#8]
;;;45     	GPIO_Initure.Pull=GPIO_PULLUP;			//上拉
000052  2001              MOVS     r0,#1
000054  9003              STR      r0,[sp,#0xc]
;;;46     	GPIO_Initure.Speed=GPIO_SPEED_FREQ_VERY_HIGH;		//高速
000056  2003              MOVS     r0,#3
000058  9004              STR      r0,[sp,#0x10]
;;;47     	GPIO_Initure.Alternate=GPIO_AF7_USART2;	//复用为USART2
00005a  2007              MOVS     r0,#7
00005c  9005              STR      r0,[sp,#0x14]
;;;48     	HAL_GPIO_Init(GPIOD,&GPIO_Initure);	   	//初始化PD5,PD6
00005e  a901              ADD      r1,sp,#4
000060  4811              LDR      r0,|L5.168|
000062  f7fffffe          BL       HAL_GPIO_Init
;;;49     	USART2_Handler.Instance=USART2;					    //USART2
000066  4811              LDR      r0,|L5.172|
000068  4911              LDR      r1,|L5.176|
00006a  6008              STR      r0,[r1,#0]  ; USART2_Handler
;;;50     	USART2_Handler.Init.BaudRate=bound;				    //波特率
00006c  4608              MOV      r0,r1
00006e  6044              STR      r4,[r0,#4]  ; USART2_Handler
;;;51     	USART2_Handler.Init.WordLength=UART_WORDLENGTH_8B;   //字长为8位数据格式
000070  2100              MOVS     r1,#0
000072  6081              STR      r1,[r0,#8]
;;;52     	USART2_Handler.Init.StopBits=UART_STOPBITS_1;	    //一个停止位
000074  60c1              STR      r1,[r0,#0xc]
;;;53     	USART2_Handler.Init.Parity=UART_PARITY_NONE;		    //无奇偶校验位
000076  6101              STR      r1,[r0,#0x10]
;;;54     	USART2_Handler.Init.HwFlowCtl=UART_HWCONTROL_NONE;   //无硬件流控
000078  6181              STR      r1,[r0,#0x18]
;;;55     	USART2_Handler.Init.Mode=UART_MODE_TX_RX;		    //收发模式
00007a  210c              MOVS     r1,#0xc
00007c  6141              STR      r1,[r0,#0x14]
;;;56     	USART2_Handler.Init.OverSampling = UART_OVERSAMPLING_16;
00007e  2100              MOVS     r1,#0
000080  61c1              STR      r1,[r0,#0x1c]
;;;57     	HAL_UART_Init(&USART2_Handler);
000082  f7fffffe          BL       HAL_UART_Init
;;;58     	HAL_NVIC_EnableIRQ(USART2_IRQn);		//使能USART2中断通道
000086  2026              MOVS     r0,#0x26
000088  f7fffffe          BL       HAL_NVIC_EnableIRQ
;;;59     	HAL_NVIC_SetPriority(USART2_IRQn,USART2_Priority,0);	//抢占优先级0，子优先级0
00008c  2200              MOVS     r2,#0
00008e  4611              MOV      r1,r2
000090  2026              MOVS     r0,#0x26
000092  f7fffffe          BL       HAL_NVIC_SetPriority
;;;60     	HAL_UART_Receive_IT(&USART2_Handler,&aRxBuffer, 1);
000096  2201              MOVS     r2,#1
000098  4906              LDR      r1,|L5.180|
00009a  4805              LDR      r0,|L5.176|
00009c  f7fffffe          BL       HAL_UART_Receive_IT
;;;61     }
0000a0  b006              ADD      sp,sp,#0x18
0000a2  bd10              POP      {r4,pc}
;;;62     unsigned char Rcv_Flg=0; //若为1则已经收到过帧头
                          ENDP

                  |L5.164|
                          DCD      0x40023830
                  |L5.168|
                          DCD      0x40020c00
                  |L5.172|
                          DCD      0x40004400
                  |L5.176|
                          DCD      USART2_Handler
                  |L5.180|
                          DCD      aRxBuffer

                          AREA ||i.USART3_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART3_IRQHandler PROC
;;;207    }
;;;208    void USART3_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;209    { 
;;;210    	u32 timeout=0;
000002  2400              MOVS     r4,#0
;;;211    	u32 maxDelay=0x1FFFF;
000004  4d0f              LDR      r5,|L6.68|
;;;212    	HAL_UART_IRQHandler(&USART3_Handler);	//调用HAL库中断处理公用函数
000006  4810              LDR      r0,|L6.72|
000008  f7fffffe          BL       HAL_UART_IRQHandler
;;;213    	timeout=0;
00000c  bf00              NOP      
;;;214        while (HAL_UART_GetState(&USART3_Handler) != HAL_UART_STATE_READY)//等待就绪
00000e  e003              B        |L6.24|
                  |L6.16|
;;;215    	{
;;;216    	 timeout++;////超时处理
000010  1c64              ADDS     r4,r4,#1
;;;217         if(timeout>maxDelay) break;		
000012  42ac              CMP      r4,r5
000014  d900              BLS      |L6.24|
000016  e004              B        |L6.34|
                  |L6.24|
000018  480b              LDR      r0,|L6.72|
00001a  f7fffffe          BL       HAL_UART_GetState
00001e  2801              CMP      r0,#1                 ;214
000020  d1f6              BNE      |L6.16|
                  |L6.34|
000022  bf00              NOP      
;;;218    	}
;;;219    	timeout=0;
000024  2400              MOVS     r4,#0
;;;220    	while(HAL_UART_Receive_IT(&USART3_Handler, &aRxBuffer3, 1) != HAL_OK)//一次处理完成之后，重新开启中断并设置RxXferCount为1
000026  e003              B        |L6.48|
                  |L6.40|
;;;221    	{
;;;222    	 timeout++; //超时处理
000028  1c64              ADDS     r4,r4,#1
;;;223    	 if(timeout>maxDelay) break;	
00002a  42ac              CMP      r4,r5
00002c  d900              BLS      |L6.48|
00002e  e006              B        |L6.62|
                  |L6.48|
000030  2201              MOVS     r2,#1                 ;220
000032  4906              LDR      r1,|L6.76|
000034  4804              LDR      r0,|L6.72|
000036  f7fffffe          BL       HAL_UART_Receive_IT
00003a  2800              CMP      r0,#0                 ;220
00003c  d1f4              BNE      |L6.40|
                  |L6.62|
00003e  bf00              NOP      
;;;224    	}
;;;225    }
000040  bd70              POP      {r4-r6,pc}
;;;226    
                          ENDP

000042  0000              DCW      0x0000
                  |L6.68|
                          DCD      0x0001ffff
                  |L6.72|
                          DCD      USART3_Handler
                  |L6.76|
                          DCD      aRxBuffer3

                          AREA ||i.USART3_Init||, CODE, READONLY, ALIGN=2

                  USART3_Init PROC
;;;183    }
;;;184    void USART3_Init(unsigned long baud)
000000  b510              PUSH     {r4,lr}
;;;185    {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;186    	GPIO_InitTypeDef GPIO_Initure;
;;;187    	__HAL_RCC_GPIOD_CLK_ENABLE();			//使能GPIOD时钟
000006  bf00              NOP      
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
00000c  4826              LDR      r0,|L7.168|
00000e  6800              LDR      r0,[r0,#0]
000010  f0400008          ORR      r0,r0,#8
000014  4924              LDR      r1,|L7.168|
000016  6008              STR      r0,[r1,#0]
000018  4608              MOV      r0,r1
00001a  6800              LDR      r0,[r0,#0]
00001c  f0000008          AND      r0,r0,#8
000020  9000              STR      r0,[sp,#0]
000022  bf00              NOP      
000024  bf00              NOP      
;;;188    	__HAL_RCC_USART3_CLK_ENABLE();			//使能USART3时钟
000026  bf00              NOP      
000028  2000              MOVS     r0,#0
00002a  9000              STR      r0,[sp,#0]
00002c  481e              LDR      r0,|L7.168|
00002e  3010              ADDS     r0,r0,#0x10
000030  6800              LDR      r0,[r0,#0]
000032  f4402080          ORR      r0,r0,#0x40000
000036  491c              LDR      r1,|L7.168|
000038  3110              ADDS     r1,r1,#0x10
00003a  6008              STR      r0,[r1,#0]
00003c  4608              MOV      r0,r1
00003e  6800              LDR      r0,[r0,#0]
000040  f4002080          AND      r0,r0,#0x40000
000044  9000              STR      r0,[sp,#0]
000046  bf00              NOP      
000048  bf00              NOP      
;;;189    	GPIO_Initure.Pin=GPIO_PIN_8|GPIO_PIN_9;
00004a  f44f7040          MOV      r0,#0x300
00004e  9001              STR      r0,[sp,#4]
;;;190    	GPIO_Initure.Mode=GPIO_MODE_AF_PP;		//复用推挽输出
000050  2002              MOVS     r0,#2
000052  9002              STR      r0,[sp,#8]
;;;191    	GPIO_Initure.Pull=GPIO_PULLUP;	 		//上拉
000054  2001              MOVS     r0,#1
000056  9003              STR      r0,[sp,#0xc]
;;;192    	GPIO_Initure.Speed=GPIO_SPEED_FREQ_VERY_HIGH;		//高速
000058  2003              MOVS     r0,#3
00005a  9004              STR      r0,[sp,#0x10]
;;;193    	GPIO_Initure.Alternate=GPIO_AF7_USART3;	//复用为USART3
00005c  2007              MOVS     r0,#7
00005e  9005              STR      r0,[sp,#0x14]
;;;194    	HAL_GPIO_Init(GPIOD,&GPIO_Initure);	   	//初始化PD8,PD9
000060  a901              ADD      r1,sp,#4
000062  4812              LDR      r0,|L7.172|
000064  f7fffffe          BL       HAL_GPIO_Init
;;;195    	USART3_Handler.Instance=USART3;					    //USART2
000068  4811              LDR      r0,|L7.176|
00006a  4912              LDR      r1,|L7.180|
00006c  6008              STR      r0,[r1,#0]  ; USART3_Handler
;;;196    	USART3_Handler.Init.BaudRate=baud;				    //波特率
00006e  4608              MOV      r0,r1
000070  6044              STR      r4,[r0,#4]  ; USART3_Handler
;;;197    	USART3_Handler.Init.WordLength=UART_WORDLENGTH_8B;   //字长为8位数据格式
000072  2100              MOVS     r1,#0
000074  6081              STR      r1,[r0,#8]
;;;198    	USART3_Handler.Init.StopBits=UART_STOPBITS_1;	    //一个停止位
000076  60c1              STR      r1,[r0,#0xc]
;;;199    	USART3_Handler.Init.Parity=UART_PARITY_NONE;		    //无奇偶校验位
000078  6101              STR      r1,[r0,#0x10]
;;;200    	USART3_Handler.Init.HwFlowCtl=UART_HWCONTROL_NONE;   //无硬件流控
00007a  6181              STR      r1,[r0,#0x18]
;;;201    	USART3_Handler.Init.Mode=UART_MODE_TX_RX;		    //收发模式
00007c  210c              MOVS     r1,#0xc
00007e  6141              STR      r1,[r0,#0x14]
;;;202    	USART3_Handler.Init.OverSampling = UART_OVERSAMPLING_16;
000080  2100              MOVS     r1,#0
000082  61c1              STR      r1,[r0,#0x1c]
;;;203    	HAL_UART_Init(&USART3_Handler);
000084  f7fffffe          BL       HAL_UART_Init
;;;204    	HAL_NVIC_EnableIRQ(USART3_IRQn);		//使能USART2中断通道
000088  2027              MOVS     r0,#0x27
00008a  f7fffffe          BL       HAL_NVIC_EnableIRQ
;;;205    	HAL_NVIC_SetPriority(USART3_IRQn,USART3_Priority,0);	//抢占优先级0，子优先级0
00008e  2200              MOVS     r2,#0
000090  2102              MOVS     r1,#2
000092  2027              MOVS     r0,#0x27
000094  f7fffffe          BL       HAL_NVIC_SetPriority
;;;206    	HAL_UART_Receive_IT(&USART3_Handler,&aRxBuffer3, 1);
000098  2201              MOVS     r2,#1
00009a  4907              LDR      r1,|L7.184|
00009c  4805              LDR      r0,|L7.180|
00009e  f7fffffe          BL       HAL_UART_Receive_IT
;;;207    }
0000a2  b006              ADD      sp,sp,#0x18
0000a4  bd10              POP      {r4,pc}
;;;208    void USART3_IRQHandler(void)
                          ENDP

0000a6  0000              DCW      0x0000
                  |L7.168|
                          DCD      0x40023830
                  |L7.172|
                          DCD      0x40020c00
                  |L7.176|
                          DCD      0x40004800
                  |L7.180|
                          DCD      USART3_Handler
                  |L7.184|
                          DCD      aRxBuffer3

                          AREA ||i.USART6_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART6_IRQHandler PROC
;;;251    }
;;;252    void USART6_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;253    { 
;;;254    	uint32_t timeout=0;
000002  2400              MOVS     r4,#0
;;;255    	uint32_t maxDelay=0x1FFFF;
000004  4d0f              LDR      r5,|L8.68|
;;;256    	HAL_UART_IRQHandler(&USART6_Handler);	//调用HAL库中断处理公用函数
000006  4810              LDR      r0,|L8.72|
000008  f7fffffe          BL       HAL_UART_IRQHandler
;;;257    	timeout=0;
00000c  bf00              NOP      
;;;258        while (HAL_UART_GetState(&USART6_Handler) != HAL_UART_STATE_READY)//等待就绪
00000e  e003              B        |L8.24|
                  |L8.16|
;;;259    	{
;;;260    	 timeout++;////超时处理
000010  1c64              ADDS     r4,r4,#1
;;;261         if(timeout>maxDelay) break;		
000012  42ac              CMP      r4,r5
000014  d900              BLS      |L8.24|
000016  e004              B        |L8.34|
                  |L8.24|
000018  480b              LDR      r0,|L8.72|
00001a  f7fffffe          BL       HAL_UART_GetState
00001e  2801              CMP      r0,#1                 ;258
000020  d1f6              BNE      |L8.16|
                  |L8.34|
000022  bf00              NOP      
;;;262    	}
;;;263    	timeout=0;
000024  2400              MOVS     r4,#0
;;;264    	while(HAL_UART_Receive_IT(&USART6_Handler, &aRxBuffer6, 1) != HAL_OK)//一次处理完成之后，重新开启中断并设置RxXferCount为1
000026  e003              B        |L8.48|
                  |L8.40|
;;;265    	{
;;;266    	 timeout++; //超时处理
000028  1c64              ADDS     r4,r4,#1
;;;267    	 if(timeout>maxDelay) break;	
00002a  42ac              CMP      r4,r5
00002c  d900              BLS      |L8.48|
00002e  e006              B        |L8.62|
                  |L8.48|
000030  2201              MOVS     r2,#1                 ;264
000032  4906              LDR      r1,|L8.76|
000034  4804              LDR      r0,|L8.72|
000036  f7fffffe          BL       HAL_UART_Receive_IT
00003a  2800              CMP      r0,#0                 ;264
00003c  d1f4              BNE      |L8.40|
                  |L8.62|
00003e  bf00              NOP      
;;;268    	}
;;;269    }
000040  bd70              POP      {r4-r6,pc}
;;;270    
                          ENDP

000042  0000              DCW      0x0000
                  |L8.68|
                          DCD      0x0001ffff
                  |L8.72|
                          DCD      USART6_Handler
                  |L8.76|
                          DCD      aRxBuffer6

                          AREA ||i.USART6_Init||, CODE, READONLY, ALIGN=2

                  USART6_Init PROC
;;;227    
;;;228    void USART6_Init(unsigned long baud)
000000  b510              PUSH     {r4,lr}
;;;229    {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;230    	GPIO_InitTypeDef GPIO_Initure;
;;;231    	__HAL_RCC_GPIOG_CLK_ENABLE();			//使能GPIOD时钟
000006  bf00              NOP      
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
00000c  4827              LDR      r0,|L9.172|
00000e  6800              LDR      r0,[r0,#0]
000010  f0400040          ORR      r0,r0,#0x40
000014  4925              LDR      r1,|L9.172|
000016  6008              STR      r0,[r1,#0]
000018  4608              MOV      r0,r1
00001a  6800              LDR      r0,[r0,#0]
00001c  f0000040          AND      r0,r0,#0x40
000020  9000              STR      r0,[sp,#0]
000022  bf00              NOP      
000024  bf00              NOP      
;;;232    	__HAL_RCC_USART6_CLK_ENABLE();			//使能USART3时钟
000026  bf00              NOP      
000028  2000              MOVS     r0,#0
00002a  9000              STR      r0,[sp,#0]
00002c  481f              LDR      r0,|L9.172|
00002e  3014              ADDS     r0,r0,#0x14
000030  6800              LDR      r0,[r0,#0]
000032  f0400020          ORR      r0,r0,#0x20
000036  491d              LDR      r1,|L9.172|
000038  3114              ADDS     r1,r1,#0x14
00003a  6008              STR      r0,[r1,#0]
00003c  4608              MOV      r0,r1
00003e  6800              LDR      r0,[r0,#0]
000040  f0000020          AND      r0,r0,#0x20
000044  9000              STR      r0,[sp,#0]
000046  bf00              NOP      
000048  bf00              NOP      
;;;233    	GPIO_Initure.Pin=GPIO_PIN_9|GPIO_PIN_14;
00004a  f44f4084          MOV      r0,#0x4200
00004e  9001              STR      r0,[sp,#4]
;;;234    	GPIO_Initure.Mode=GPIO_MODE_AF_PP;		//复用推挽输出
000050  2002              MOVS     r0,#2
000052  9002              STR      r0,[sp,#8]
;;;235    	GPIO_Initure.Pull=GPIO_PULLUP;	 		//上拉
000054  2001              MOVS     r0,#1
000056  9003              STR      r0,[sp,#0xc]
;;;236    	GPIO_Initure.Speed=GPIO_SPEED_FREQ_VERY_HIGH;		//高速
000058  2003              MOVS     r0,#3
00005a  9004              STR      r0,[sp,#0x10]
;;;237    	GPIO_Initure.Alternate=GPIO_AF8_USART6;	//复用为USART3
00005c  2008              MOVS     r0,#8
00005e  9005              STR      r0,[sp,#0x14]
;;;238    	HAL_GPIO_Init(GPIOG,&GPIO_Initure);	   	//初始化PG9,PG14
000060  a901              ADD      r1,sp,#4
000062  4813              LDR      r0,|L9.176|
000064  f7fffffe          BL       HAL_GPIO_Init
;;;239    	USART6_Handler.Instance=USART6;					    //USART6
000068  4812              LDR      r0,|L9.180|
00006a  4913              LDR      r1,|L9.184|
00006c  6008              STR      r0,[r1,#0]  ; USART6_Handler
;;;240    	USART6_Handler.Init.BaudRate=baud;				    //波特率
00006e  4608              MOV      r0,r1
000070  6044              STR      r4,[r0,#4]  ; USART6_Handler
;;;241    	USART6_Handler.Init.WordLength=UART_WORDLENGTH_8B;   //字长为8位数据格式
000072  2100              MOVS     r1,#0
000074  6081              STR      r1,[r0,#8]
;;;242    	USART6_Handler.Init.StopBits=UART_STOPBITS_1;	    //一个停止位
000076  60c1              STR      r1,[r0,#0xc]
;;;243    	USART6_Handler.Init.Parity=UART_PARITY_NONE;		    //无奇偶校验位
000078  6101              STR      r1,[r0,#0x10]
;;;244    	USART6_Handler.Init.HwFlowCtl=UART_HWCONTROL_NONE;   //无硬件流控
00007a  6181              STR      r1,[r0,#0x18]
;;;245    	USART6_Handler.Init.Mode=UART_MODE_TX_RX;		    //收发模式
00007c  210c              MOVS     r1,#0xc
00007e  6141              STR      r1,[r0,#0x14]
;;;246    	USART3_Handler.Init.OverSampling = UART_OVERSAMPLING_16;
000080  2100              MOVS     r1,#0
000082  480e              LDR      r0,|L9.188|
000084  61c1              STR      r1,[r0,#0x1c]
;;;247    	HAL_UART_Init(&USART6_Handler);
000086  480c              LDR      r0,|L9.184|
000088  f7fffffe          BL       HAL_UART_Init
;;;248    	HAL_NVIC_EnableIRQ(USART6_IRQn);		//使能USART6中断通道
00008c  2047              MOVS     r0,#0x47
00008e  f7fffffe          BL       HAL_NVIC_EnableIRQ
;;;249    	HAL_NVIC_SetPriority(USART6_IRQn,USART6_Priority,0);	//抢占优先级0，子优先级0
000092  2200              MOVS     r2,#0
000094  2101              MOVS     r1,#1
000096  2047              MOVS     r0,#0x47
000098  f7fffffe          BL       HAL_NVIC_SetPriority
;;;250    	HAL_UART_Receive_IT(&USART6_Handler,&aRxBuffer6, 1);
00009c  2201              MOVS     r2,#1
00009e  4908              LDR      r1,|L9.192|
0000a0  4805              LDR      r0,|L9.184|
0000a2  f7fffffe          BL       HAL_UART_Receive_IT
;;;251    }
0000a6  b006              ADD      sp,sp,#0x18
0000a8  bd10              POP      {r4,pc}
;;;252    void USART6_IRQHandler(void)
                          ENDP

0000aa  0000              DCW      0x0000
                  |L9.172|
                          DCD      0x40023830
                  |L9.176|
                          DCD      0x40021800
                  |L9.180|
                          DCD      0x40011400
                  |L9.184|
                          DCD      USART6_Handler
                  |L9.188|
                          DCD      USART3_Handler
                  |L9.192|
                          DCD      aRxBuffer6

                          AREA ||i._sys_exit||, CODE, READONLY, ALIGN=1

                  _sys_exit PROC
;;;24     //定义_sys_exit()以避免使用半主机模式    
;;;25     void _sys_exit(int x) 
000000  bf00              NOP      
;;;26     { 
;;;27     	x = x; 
;;;28     } 
000002  4770              BX       lr
;;;29     //重定义fputc函数 
                          ENDP


                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;29     //重定义fputc函数 
;;;30     int fputc(int ch, FILE *f)
000000  bf00              NOP      
                  |L11.2|
;;;31     { 	
;;;32     	while((USART2->SR&0X40)==0);//循环发送,直到发送完毕   
000002  4a05              LDR      r2,|L11.24|
000004  6812              LDR      r2,[r2,#0]
000006  f0020240          AND      r2,r2,#0x40
00000a  2a00              CMP      r2,#0
00000c  d0f9              BEQ      |L11.2|
;;;33     	USART2->DR = (u8) ch;      
00000e  b2c2              UXTB     r2,r0
000010  4b01              LDR      r3,|L11.24|
000012  1d1b              ADDS     r3,r3,#4
000014  601a              STR      r2,[r3,#0]
;;;34     	return ch;
;;;35     }
000016  4770              BX       lr
;;;36     #endif 
                          ENDP

                  |L11.24|
                          DCD      0x40004400

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  huart1
                          %        64
                  hdma_usart1_rx
                          %        88
                  USART3_Handler
                          %        64
                  USART2_Handler
                          %        64
                  USART6_Handler
                          %        64
                  USART3_Rcv_Buffer
                          %        15
                  USART2_Rcv_Buffer
                          %        15

                          AREA ||.data||, DATA, ALIGN=1

                  USART2_Receve_Handler
                          %        8
                  USART3_Receve_Handler
                          %        8
                  aRxBuffer3
000010  00                DCB      0x00
                  aRxBuffer
000011  00                DCB      0x00
                  aRxBuffer6
000012  0000              DCB      0x00,0x00
                  __stdout
                          DCDU     0x00000000
                  Rcv_Flg
000018  00                DCB      0x00
                  RX_Counter
000019  01                DCB      0x01
                  Rcv_Flg2
00001a  00                DCB      0x00
                  RX_Counter2
00001b  01                DCB      0x01

;*** Start embedded assembler ***

#line 1 "Hardware\\USART.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_USART_c_9275e5e5____REV16|
#line 388 ".\\CORE\\cmsis_armcc.h"
|__asm___7_USART_c_9275e5e5____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_USART_c_9275e5e5____REVSH|
#line 402
|__asm___7_USART_c_9275e5e5____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___7_USART_c_9275e5e5____RRX|
#line 587
|__asm___7_USART_c_9275e5e5____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
