; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\stm32f4xx_hal_tim.o --asm_dir=.\OBJ\ --list_dir=.\OBJ\ --depend=.\obj\stm32f4xx_hal_tim.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I.\CORE -I.\USER -I.\HALLIB\STM32F4xx_HAL_Driver\Inc -I.\SYSTEM -I.\Hardware -I.\App -I.\DSP_LIB\Include -I.\FreeRTOS -I.\MPU9250\DMP -I.\MPU9250 -I.\RTE\_Project -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=526 -DSTM32F427xx -DSTM32F4 -DUSE_HAL_DRIVER -DSTM32F427xx -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=.\obj\stm32f4xx_hal_tim.crf HALLIB\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_tim.c]
                          THUMB

                          AREA ||i.HAL_TIM_Base_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_DeInit PROC
;;;246      */
;;;247    HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;248    {  
000002  4604              MOV      r4,r0
;;;249      /* Check the parameters */
;;;250      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;251    
;;;252      htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f8840039          STRB     r0,[r4,#0x39]
;;;253       
;;;254      /* Disable the TIM Peripheral Clock */
;;;255      __HAL_TIM_DISABLE(htim);
00000a  bf00              NOP      
00000c  6820              LDR      r0,[r4,#0]
00000e  6a00              LDR      r0,[r0,#0x20]
000010  f2411111          MOV      r1,#0x1111
000014  4008              ANDS     r0,r0,r1
000016  b950              CBNZ     r0,|L1.46|
000018  6820              LDR      r0,[r4,#0]
00001a  6a00              LDR      r0,[r0,#0x20]
00001c  1089              ASRS     r1,r1,#2
00001e  4008              ANDS     r0,r0,r1
000020  b928              CBNZ     r0,|L1.46|
000022  6820              LDR      r0,[r4,#0]
000024  6800              LDR      r0,[r0,#0]
000026  f0200001          BIC      r0,r0,#1
00002a  6821              LDR      r1,[r4,#0]
00002c  6008              STR      r0,[r1,#0]
                  |L1.46|
00002e  bf00              NOP      
;;;256        
;;;257      /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;258      HAL_TIM_Base_MspDeInit(htim);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       HAL_TIM_Base_MspDeInit
;;;259      
;;;260      /* Change TIM state */  
;;;261      htim->State = HAL_TIM_STATE_RESET; 
000036  2000              MOVS     r0,#0
000038  f8840039          STRB     r0,[r4,#0x39]
;;;262      
;;;263      /* Release Lock */
;;;264      __HAL_UNLOCK(htim);
00003c  bf00              NOP      
00003e  f8840038          STRB     r0,[r4,#0x38]
000042  bf00              NOP      
;;;265    
;;;266      return HAL_OK;
;;;267    }
000044  bd10              POP      {r4,pc}
;;;268    
                          ENDP


                          AREA ||i.HAL_TIM_Base_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_GetState PROC
;;;4401     */
;;;4402   HAL_TIM_StateTypeDef HAL_TIM_Base_GetState(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;4403   {
;;;4404     return htim->State;
000002  f8910039          LDRB     r0,[r1,#0x39]
;;;4405   }
000006  4770              BX       lr
;;;4406   
                          ENDP


                          AREA ||i.HAL_TIM_Base_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Init PROC
;;;207      */
;;;208    HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;209    { 
000002  4604              MOV      r4,r0
;;;210      /* Check the TIM handle allocation */
;;;211      if(htim == NULL)
000004  b90c              CBNZ     r4,|L3.10|
;;;212      {
;;;213        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L3.8|
;;;214      }
;;;215      
;;;216      /* Check the parameters */
;;;217      assert_param(IS_TIM_INSTANCE(htim->Instance)); 
;;;218      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;219      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;220      
;;;221      if(htim->State == HAL_TIM_STATE_RESET)
;;;222      {  
;;;223        /* Allocate lock resource and initialize it */
;;;224        htim->Lock = HAL_UNLOCKED;
;;;225        /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;226        HAL_TIM_Base_MspInit(htim);
;;;227      }
;;;228      
;;;229      /* Set the TIM state */
;;;230      htim->State= HAL_TIM_STATE_BUSY;
;;;231      
;;;232      /* Set the Time Base configuration */
;;;233      TIM_Base_SetConfig(htim->Instance, &htim->Init); 
;;;234      
;;;235      /* Initialize the TIM state*/
;;;236      htim->State= HAL_TIM_STATE_READY;
;;;237      
;;;238      return HAL_OK;
;;;239    }
000008  bd10              POP      {r4,pc}
                  |L3.10|
00000a  f8940039          LDRB     r0,[r4,#0x39]         ;221
00000e  b928              CBNZ     r0,|L3.28|
000010  2000              MOVS     r0,#0                 ;224
000012  f8840038          STRB     r0,[r4,#0x38]         ;224
000016  4620              MOV      r0,r4                 ;226
000018  f7fffffe          BL       HAL_TIM_Base_MspInit
                  |L3.28|
00001c  2002              MOVS     r0,#2                 ;230
00001e  f8840039          STRB     r0,[r4,#0x39]         ;230
000022  1d21              ADDS     r1,r4,#4              ;233
000024  6820              LDR      r0,[r4,#0]            ;233
000026  f7fffffe          BL       TIM_Base_SetConfig
00002a  2001              MOVS     r0,#1                 ;236
00002c  f8840039          STRB     r0,[r4,#0x39]         ;236
000030  2000              MOVS     r0,#0                 ;238
000032  e7e9              B        |L3.8|
;;;240    
                          ENDP


                          AREA ||i.HAL_TIM_Base_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_MspDeInit PROC
;;;289      */
;;;290    __weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;291    {
;;;292      /* Prevent unused argument(s) compilation warning */
;;;293      UNUSED(htim);
;;;294      /* NOTE : This function Should not be modified, when the callback is needed,
;;;295                the HAL_TIM_Base_MspDeInit could be implemented in the user file
;;;296       */
;;;297    }
;;;298    
                          ENDP


                          AREA ||i.HAL_TIM_Base_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_MspInit PROC
;;;274      */
;;;275    __weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;276    {
;;;277      /* Prevent unused argument(s) compilation warning */
;;;278      UNUSED(htim);
;;;279      /* NOTE : This function Should not be modified, when the callback is needed,
;;;280                the HAL_TIM_Base_MspInit could be implemented in the user file
;;;281       */
;;;282    }
;;;283    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Start PROC
;;;304      */
;;;305    HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;306    {
;;;307      /* Check the parameters */
;;;308      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;309      
;;;310      /* Set the TIM state */
;;;311      htim->State= HAL_TIM_STATE_BUSY;
000002  2002              MOVS     r0,#2
000004  f8810039          STRB     r0,[r1,#0x39]
;;;312      
;;;313      /* Enable the Peripheral */
;;;314      __HAL_TIM_ENABLE(htim);
000008  6808              LDR      r0,[r1,#0]
00000a  6800              LDR      r0,[r0,#0]
00000c  f0400001          ORR      r0,r0,#1
000010  680a              LDR      r2,[r1,#0]
000012  6010              STR      r0,[r2,#0]
;;;315      
;;;316      /* Change the TIM state*/
;;;317      htim->State= HAL_TIM_STATE_READY;
000014  2001              MOVS     r0,#1
000016  f8810039          STRB     r0,[r1,#0x39]
;;;318      
;;;319      /* Return function status */
;;;320      return HAL_OK;
00001a  2000              MOVS     r0,#0
;;;321    }
00001c  4770              BX       lr
;;;322    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Base_Start_DMA PROC
;;;395      */
;;;396    HAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;397    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;398      /* Check the parameters */
;;;399      assert_param(IS_TIM_DMA_INSTANCE(htim->Instance)); 
;;;400      
;;;401      if((htim->State == HAL_TIM_STATE_BUSY))
000008  f8940039          LDRB     r0,[r4,#0x39]
00000c  2802              CMP      r0,#2
00000e  d100              BNE      |L7.18|
                  |L7.16|
;;;402      {
;;;403         return HAL_BUSY;
;;;404      }
;;;405      else if((htim->State == HAL_TIM_STATE_READY))
;;;406      {
;;;407        if((pData == 0 ) && (Length > 0)) 
;;;408        {
;;;409          return HAL_ERROR;                                    
;;;410        }
;;;411        else
;;;412        {
;;;413          htim->State = HAL_TIM_STATE_BUSY;
;;;414        }
;;;415      }  
;;;416      /* Set the DMA Period elapsed callback */
;;;417      htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;418         
;;;419      /* Set the DMA error callback */
;;;420      htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
;;;421      
;;;422      /* Enable the DMA Stream */
;;;423      HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR, Length);
;;;424      
;;;425      /* Enable the TIM Update DMA request */
;;;426      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);
;;;427    
;;;428      /* Enable the Peripheral */
;;;429      __HAL_TIM_ENABLE(htim);  
;;;430      
;;;431      /* Return function status */
;;;432      return HAL_OK;
;;;433    }
000010  bd70              POP      {r4-r6,pc}
                  |L7.18|
000012  f8940039          LDRB     r0,[r4,#0x39]         ;405
000016  2801              CMP      r0,#1                 ;405
000018  d106              BNE      |L7.40|
00001a  b916              CBNZ     r6,|L7.34|
00001c  2d00              CMP      r5,#0                 ;407
00001e  dd00              BLE      |L7.34|
000020  e7f6              B        |L7.16|
                  |L7.34|
000022  2002              MOVS     r0,#2                 ;413
000024  f8840039          STRB     r0,[r4,#0x39]         ;413
                  |L7.40|
000028  480d              LDR      r0,|L7.96|
00002a  69e1              LDR      r1,[r4,#0x1c]         ;417
00002c  63c8              STR      r0,[r1,#0x3c]         ;417
00002e  480d              LDR      r0,|L7.100|
000030  69e1              LDR      r1,[r4,#0x1c]         ;420
000032  6488              STR      r0,[r1,#0x48]         ;420
000034  6821              LDR      r1,[r4,#0]            ;423
000036  f101022c          ADD      r2,r1,#0x2c           ;423
00003a  462b              MOV      r3,r5                 ;423
00003c  4631              MOV      r1,r6                 ;423
00003e  69e0              LDR      r0,[r4,#0x1c]         ;423
000040  f7fffffe          BL       HAL_DMA_Start_IT
000044  6820              LDR      r0,[r4,#0]            ;426
000046  68c0              LDR      r0,[r0,#0xc]          ;426
000048  f4407080          ORR      r0,r0,#0x100          ;426
00004c  6821              LDR      r1,[r4,#0]            ;426
00004e  60c8              STR      r0,[r1,#0xc]          ;426
000050  6820              LDR      r0,[r4,#0]            ;429
000052  6800              LDR      r0,[r0,#0]            ;429
000054  f0400001          ORR      r0,r0,#1              ;429
000058  6821              LDR      r1,[r4,#0]            ;429
00005a  6008              STR      r0,[r1,#0]            ;429
00005c  2000              MOVS     r0,#0                 ;432
00005e  e7d7              B        |L7.16|
;;;434    
                          ENDP

                  |L7.96|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L7.100|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_Base_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Start_IT PROC
;;;352      */
;;;353    HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;354    {
;;;355      /* Check the parameters */
;;;356      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;357      
;;;358      /* Enable the TIM Update interrupt */
;;;359      __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
000002  6808              LDR      r0,[r1,#0]
000004  68c0              LDR      r0,[r0,#0xc]
000006  f0400001          ORR      r0,r0,#1
00000a  680a              LDR      r2,[r1,#0]
00000c  60d0              STR      r0,[r2,#0xc]
;;;360          
;;;361      /* Enable the Peripheral */
;;;362      __HAL_TIM_ENABLE(htim);
00000e  6808              LDR      r0,[r1,#0]
000010  6800              LDR      r0,[r0,#0]
000012  f0400001          ORR      r0,r0,#1
000016  680a              LDR      r2,[r1,#0]
000018  6010              STR      r0,[r2,#0]
;;;363          
;;;364      /* Return function status */
;;;365      return HAL_OK;
00001a  2000              MOVS     r0,#0
;;;366    }
00001c  4770              BX       lr
;;;367    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Stop PROC
;;;328      */
;;;329    HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;330    {
;;;331      /* Check the parameters */
;;;332      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;333      
;;;334      /* Set the TIM state */
;;;335      htim->State= HAL_TIM_STATE_BUSY;
000002  2002              MOVS     r0,#2
000004  f8810039          STRB     r0,[r1,#0x39]
;;;336      
;;;337      /* Disable the Peripheral */
;;;338      __HAL_TIM_DISABLE(htim);
000008  bf00              NOP      
00000a  6808              LDR      r0,[r1,#0]
00000c  6a00              LDR      r0,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4010              ANDS     r0,r0,r2
000014  b950              CBNZ     r0,|L9.44|
000016  6808              LDR      r0,[r1,#0]
000018  6a00              LDR      r0,[r0,#0x20]
00001a  1092              ASRS     r2,r2,#2
00001c  4010              ANDS     r0,r0,r2
00001e  b928              CBNZ     r0,|L9.44|
000020  6808              LDR      r0,[r1,#0]
000022  6800              LDR      r0,[r0,#0]
000024  f0200001          BIC      r0,r0,#1
000028  680a              LDR      r2,[r1,#0]
00002a  6010              STR      r0,[r2,#0]
                  |L9.44|
00002c  bf00              NOP      
;;;339      
;;;340      /* Change the TIM state*/
;;;341      htim->State= HAL_TIM_STATE_READY;
00002e  2001              MOVS     r0,#1
000030  f8810039          STRB     r0,[r1,#0x39]
;;;342      
;;;343      /* Return function status */
;;;344      return HAL_OK;
000034  2000              MOVS     r0,#0
;;;345    }
000036  4770              BX       lr
;;;346    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Stop_DMA PROC
;;;440      */
;;;441    HAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;442    {
;;;443      /* Check the parameters */
;;;444      assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
;;;445      
;;;446      /* Disable the TIM Update DMA request */
;;;447      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);
000002  6808              LDR      r0,[r1,#0]
000004  68c0              LDR      r0,[r0,#0xc]
000006  f4207080          BIC      r0,r0,#0x100
00000a  680a              LDR      r2,[r1,#0]
00000c  60d0              STR      r0,[r2,#0xc]
;;;448          
;;;449      /* Disable the Peripheral */
;;;450      __HAL_TIM_DISABLE(htim);
00000e  bf00              NOP      
000010  6808              LDR      r0,[r1,#0]
000012  6a00              LDR      r0,[r0,#0x20]
000014  f2411211          MOV      r2,#0x1111
000018  4010              ANDS     r0,r0,r2
00001a  b950              CBNZ     r0,|L10.50|
00001c  6808              LDR      r0,[r1,#0]
00001e  6a00              LDR      r0,[r0,#0x20]
000020  1092              ASRS     r2,r2,#2
000022  4010              ANDS     r0,r0,r2
000024  b928              CBNZ     r0,|L10.50|
000026  6808              LDR      r0,[r1,#0]
000028  6800              LDR      r0,[r0,#0]
00002a  f0200001          BIC      r0,r0,#1
00002e  680a              LDR      r2,[r1,#0]
000030  6010              STR      r0,[r2,#0]
                  |L10.50|
000032  bf00              NOP      
;;;451        
;;;452      /* Change the htim state */
;;;453      htim->State = HAL_TIM_STATE_READY;
000034  2001              MOVS     r0,#1
000036  f8810039          STRB     r0,[r1,#0x39]
;;;454          
;;;455      /* Return function status */
;;;456      return HAL_OK;
00003a  2000              MOVS     r0,#0
;;;457    }
00003c  4770              BX       lr
;;;458    /**
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Stop_IT PROC
;;;373      */
;;;374    HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;375    {
;;;376      /* Check the parameters */
;;;377      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;378      /* Disable the TIM Update interrupt */
;;;379      __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
000002  6808              LDR      r0,[r1,#0]
000004  68c0              LDR      r0,[r0,#0xc]
000006  f0200001          BIC      r0,r0,#1
00000a  680a              LDR      r2,[r1,#0]
00000c  60d0              STR      r0,[r2,#0xc]
;;;380          
;;;381      /* Disable the Peripheral */
;;;382      __HAL_TIM_DISABLE(htim);
00000e  bf00              NOP      
000010  6808              LDR      r0,[r1,#0]
000012  6a00              LDR      r0,[r0,#0x20]
000014  f2411211          MOV      r2,#0x1111
000018  4010              ANDS     r0,r0,r2
00001a  b950              CBNZ     r0,|L11.50|
00001c  6808              LDR      r0,[r1,#0]
00001e  6a00              LDR      r0,[r0,#0x20]
000020  1092              ASRS     r2,r2,#2
000022  4010              ANDS     r0,r0,r2
000024  b928              CBNZ     r0,|L11.50|
000026  6808              LDR      r0,[r1,#0]
000028  6800              LDR      r0,[r0,#0]
00002a  f0200001          BIC      r0,r0,#1
00002e  680a              LDR      r2,[r1,#0]
000030  6010              STR      r0,[r2,#0]
                  |L11.50|
000032  bf00              NOP      
;;;383        
;;;384      /* Return function status */
;;;385      return HAL_OK;
000034  2000              MOVS     r0,#0
;;;386    }
000036  4770              BX       lr
;;;387    
                          ENDP


                          AREA ||i.HAL_TIM_ConfigClockSource||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigClockSource PROC
;;;3938     */ 
;;;3939   HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef * sClockSourceConfig)    
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3940   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;3941     uint32_t tmpsmcr = 0;
000008  2600              MOVS     r6,#0
;;;3942       
;;;3943     /* Process Locked */
;;;3944     __HAL_LOCK(htim);
00000a  bf00              NOP      
00000c  f8940038          LDRB     r0,[r4,#0x38]
000010  2801              CMP      r0,#1
000012  d102              BNE      |L12.26|
000014  2002              MOVS     r0,#2
                  |L12.22|
;;;3945     
;;;3946     htim->State = HAL_TIM_STATE_BUSY;
;;;3947     
;;;3948     /* Check the parameters */
;;;3949     assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
;;;3950     
;;;3951     /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
;;;3952     tmpsmcr = htim->Instance->SMCR;
;;;3953     tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
;;;3954     tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
;;;3955     htim->Instance->SMCR = tmpsmcr;
;;;3956     
;;;3957     switch (sClockSourceConfig->ClockSource)
;;;3958     {
;;;3959       case TIM_CLOCKSOURCE_INTERNAL:
;;;3960       { 
;;;3961         assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;3962         
;;;3963         /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;3964         htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3965       }
;;;3966       break;
;;;3967       
;;;3968       case TIM_CLOCKSOURCE_ETRMODE1:
;;;3969       {
;;;3970         assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
;;;3971   
;;;3972         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;3973         assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
;;;3974         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;3975   
;;;3976         /* Configure the ETR Clock source */
;;;3977         TIM_ETR_SetConfig(htim->Instance, 
;;;3978                           sClockSourceConfig->ClockPrescaler, 
;;;3979                           sClockSourceConfig->ClockPolarity, 
;;;3980                           sClockSourceConfig->ClockFilter);
;;;3981         /* Get the TIMx SMCR register value */
;;;3982         tmpsmcr = htim->Instance->SMCR;
;;;3983         /* Reset the SMS and TS Bits */
;;;3984         tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
;;;3985         /* Select the External clock mode1 and the ETRF trigger */
;;;3986         tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
;;;3987         /* Write to TIMx SMCR */
;;;3988         htim->Instance->SMCR = tmpsmcr;
;;;3989       }
;;;3990       break;
;;;3991       
;;;3992       case TIM_CLOCKSOURCE_ETRMODE2:
;;;3993       {
;;;3994         assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
;;;3995   
;;;3996         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;3997         assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
;;;3998         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;3999   
;;;4000         /* Configure the ETR Clock source */
;;;4001         TIM_ETR_SetConfig(htim->Instance, 
;;;4002                           sClockSourceConfig->ClockPrescaler, 
;;;4003                           sClockSourceConfig->ClockPolarity,
;;;4004                           sClockSourceConfig->ClockFilter);
;;;4005         /* Enable the External clock mode2 */
;;;4006         htim->Instance->SMCR |= TIM_SMCR_ECE;
;;;4007       }
;;;4008       break;
;;;4009       
;;;4010       case TIM_CLOCKSOURCE_TI1:
;;;4011       {
;;;4012         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4013   
;;;4014         /* Check TI1 input conditioning related parameters */
;;;4015         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4016         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4017   
;;;4018         TIM_TI1_ConfigInputStage(htim->Instance, 
;;;4019                           sClockSourceConfig->ClockPolarity, 
;;;4020                           sClockSourceConfig->ClockFilter);
;;;4021         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
;;;4022       }
;;;4023       break;
;;;4024       case TIM_CLOCKSOURCE_TI2:
;;;4025       {
;;;4026         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4027   
;;;4028         /* Check TI1 input conditioning related parameters */
;;;4029         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4030         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4031   
;;;4032         TIM_TI2_ConfigInputStage(htim->Instance, 
;;;4033                           sClockSourceConfig->ClockPolarity, 
;;;4034                           sClockSourceConfig->ClockFilter);
;;;4035         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
;;;4036       }
;;;4037       break;
;;;4038       case TIM_CLOCKSOURCE_TI1ED:
;;;4039       {
;;;4040         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4041   
;;;4042         /* Check TI1 input conditioning related parameters */
;;;4043         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4044         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4045   
;;;4046         TIM_TI1_ConfigInputStage(htim->Instance, 
;;;4047                           sClockSourceConfig->ClockPolarity,
;;;4048                           sClockSourceConfig->ClockFilter);
;;;4049         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
;;;4050       }
;;;4051       break;
;;;4052       case TIM_CLOCKSOURCE_ITR0:
;;;4053       {
;;;4054         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4055         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR0);
;;;4056       }
;;;4057       break;
;;;4058       case TIM_CLOCKSOURCE_ITR1:
;;;4059       {
;;;4060         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4061         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR1);
;;;4062       }
;;;4063       break;
;;;4064       case TIM_CLOCKSOURCE_ITR2:
;;;4065       {
;;;4066         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4067         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR2);
;;;4068       }
;;;4069       break;
;;;4070       case TIM_CLOCKSOURCE_ITR3:
;;;4071       {
;;;4072         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4073         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR3);
;;;4074       }
;;;4075       break;
;;;4076       
;;;4077       default:
;;;4078       break;    
;;;4079     }
;;;4080     htim->State = HAL_TIM_STATE_READY;
;;;4081     
;;;4082     __HAL_UNLOCK(htim);
;;;4083     
;;;4084     return HAL_OK;
;;;4085   }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L12.26|
00001a  2001              MOVS     r0,#1                 ;3944
00001c  f8840038          STRB     r0,[r4,#0x38]         ;3944
000020  bf00              NOP                            ;3944
000022  2002              MOVS     r0,#2                 ;3946
000024  f8840039          STRB     r0,[r4,#0x39]         ;3946
000028  6820              LDR      r0,[r4,#0]            ;3952
00002a  6886              LDR      r6,[r0,#8]            ;3952
00002c  f0260677          BIC      r6,r6,#0x77           ;3953
000030  f426467f          BIC      r6,r6,#0xff00         ;3954
000034  6820              LDR      r0,[r4,#0]            ;3955
000036  6086              STR      r6,[r0,#8]            ;3955
000038  6828              LDR      r0,[r5,#0]            ;3957
00003a  2850              CMP      r0,#0x50              ;3957
00003c  d03b              BEQ      |L12.182|
00003e  dc0c              BGT      |L12.90|
000040  2820              CMP      r0,#0x20              ;3957
000042  d060              BEQ      |L12.262|
000044  dc04              BGT      |L12.80|
000046  2800              CMP      r0,#0                 ;3957
000048  d053              BEQ      |L12.242|
00004a  2810              CMP      r0,#0x10              ;3957
00004c  d165              BNE      |L12.282|
00004e  e055              B        |L12.252|
                  |L12.80|
000050  2830              CMP      r0,#0x30              ;3957
000052  d05d              BEQ      |L12.272|
000054  2840              CMP      r0,#0x40              ;3957
000056  d160              BNE      |L12.282|
000058  e041              B        |L12.222|
                  |L12.90|
00005a  2860              CMP      r0,#0x60              ;3957
00005c  d035              BEQ      |L12.202|
00005e  2870              CMP      r0,#0x70              ;3957
000060  d00d              BEQ      |L12.126|
000062  f5b05f80          CMP      r0,#0x1000            ;3957
000066  d003              BEQ      |L12.112|
000068  f5b05f00          CMP      r0,#0x2000            ;3957
00006c  d155              BNE      |L12.282|
00006e  e015              B        |L12.156|
                  |L12.112|
000070  6820              LDR      r0,[r4,#0]            ;3964
000072  6880              LDR      r0,[r0,#8]            ;3964
000074  f0200007          BIC      r0,r0,#7              ;3964
000078  6821              LDR      r1,[r4,#0]            ;3964
00007a  6088              STR      r0,[r1,#8]            ;3964
00007c  e04e              B        |L12.284|
                  |L12.126|
00007e  e9d51302          LDRD     r1,r3,[r5,#8]         ;3977
000082  686a              LDR      r2,[r5,#4]            ;3977
000084  6820              LDR      r0,[r4,#0]            ;3977
000086  f7fffffe          BL       TIM_ETR_SetConfig
00008a  6820              LDR      r0,[r4,#0]            ;3982
00008c  6886              LDR      r6,[r0,#8]            ;3982
00008e  f0260677          BIC      r6,r6,#0x77           ;3984
000092  f0460677          ORR      r6,r6,#0x77           ;3986
000096  6820              LDR      r0,[r4,#0]            ;3988
000098  6086              STR      r6,[r0,#8]            ;3988
00009a  e03f              B        |L12.284|
                  |L12.156|
00009c  e9d51302          LDRD     r1,r3,[r5,#8]         ;4001
0000a0  686a              LDR      r2,[r5,#4]            ;4001
0000a2  6820              LDR      r0,[r4,#0]            ;4001
0000a4  f7fffffe          BL       TIM_ETR_SetConfig
0000a8  6820              LDR      r0,[r4,#0]            ;4006
0000aa  6880              LDR      r0,[r0,#8]            ;4006
0000ac  f4404080          ORR      r0,r0,#0x4000         ;4006
0000b0  6821              LDR      r1,[r4,#0]            ;4006
0000b2  6088              STR      r0,[r1,#8]            ;4006
0000b4  e032              B        |L12.284|
                  |L12.182|
0000b6  68ea              LDR      r2,[r5,#0xc]          ;4018
0000b8  6869              LDR      r1,[r5,#4]            ;4018
0000ba  6820              LDR      r0,[r4,#0]            ;4018
0000bc  f7fffffe          BL       TIM_TI1_ConfigInputStage
0000c0  2150              MOVS     r1,#0x50              ;4021
0000c2  6820              LDR      r0,[r4,#0]            ;4021
0000c4  f7fffffe          BL       TIM_ITRx_SetConfig
0000c8  e028              B        |L12.284|
                  |L12.202|
0000ca  68ea              LDR      r2,[r5,#0xc]          ;4032
0000cc  6869              LDR      r1,[r5,#4]            ;4032
0000ce  6820              LDR      r0,[r4,#0]            ;4032
0000d0  f7fffffe          BL       TIM_TI2_ConfigInputStage
0000d4  2160              MOVS     r1,#0x60              ;4035
0000d6  6820              LDR      r0,[r4,#0]            ;4035
0000d8  f7fffffe          BL       TIM_ITRx_SetConfig
0000dc  e01e              B        |L12.284|
                  |L12.222|
0000de  68ea              LDR      r2,[r5,#0xc]          ;4046
0000e0  6869              LDR      r1,[r5,#4]            ;4046
0000e2  6820              LDR      r0,[r4,#0]            ;4046
0000e4  f7fffffe          BL       TIM_TI1_ConfigInputStage
0000e8  2140              MOVS     r1,#0x40              ;4049
0000ea  6820              LDR      r0,[r4,#0]            ;4049
0000ec  f7fffffe          BL       TIM_ITRx_SetConfig
0000f0  e014              B        |L12.284|
                  |L12.242|
0000f2  2100              MOVS     r1,#0                 ;4055
0000f4  6820              LDR      r0,[r4,#0]            ;4055
0000f6  f7fffffe          BL       TIM_ITRx_SetConfig
0000fa  e00f              B        |L12.284|
                  |L12.252|
0000fc  2110              MOVS     r1,#0x10              ;4061
0000fe  6820              LDR      r0,[r4,#0]            ;4061
000100  f7fffffe          BL       TIM_ITRx_SetConfig
000104  e00a              B        |L12.284|
                  |L12.262|
000106  2120              MOVS     r1,#0x20              ;4067
000108  6820              LDR      r0,[r4,#0]            ;4067
00010a  f7fffffe          BL       TIM_ITRx_SetConfig
00010e  e005              B        |L12.284|
                  |L12.272|
000110  2130              MOVS     r1,#0x30              ;4073
000112  6820              LDR      r0,[r4,#0]            ;4073
000114  f7fffffe          BL       TIM_ITRx_SetConfig
000118  e000              B        |L12.284|
                  |L12.282|
00011a  bf00              NOP                            ;4078
                  |L12.284|
00011c  bf00              NOP                            ;3966
00011e  2001              MOVS     r0,#1                 ;4080
000120  f8840039          STRB     r0,[r4,#0x39]         ;4080
000124  bf00              NOP                            ;4082
000126  2000              MOVS     r0,#0                 ;4082
000128  f8840038          STRB     r0,[r4,#0x38]         ;4082
00012c  bf00              NOP                            ;4082
00012e  bf00              NOP                            ;4084
000130  e771              B        |L12.22|
;;;4086   
                          ENDP


                          AREA ||i.HAL_TIM_ConfigOCrefClear||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigOCrefClear PROC
;;;3835     */ 
;;;3836   HAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim, TIM_ClearInputConfigTypeDef * sClearInputConfig, uint32_t Channel)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3837   { 
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;3838     /* Check the parameters */
;;;3839     assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3840     assert_param(IS_TIM_CHANNELS(Channel));
;;;3841     assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));
;;;3842     assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));
;;;3843     assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));
;;;3844     assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));
;;;3845      
;;;3846     /* Process Locked */
;;;3847     __HAL_LOCK(htim);
00000a  bf00              NOP      
00000c  f8940038          LDRB     r0,[r4,#0x38]
000010  2801              CMP      r0,#1
000012  d102              BNE      |L13.26|
000014  2002              MOVS     r0,#2
                  |L13.22|
;;;3848     
;;;3849     htim->State = HAL_TIM_STATE_BUSY;
;;;3850     
;;;3851     if(sClearInputConfig->ClearInputSource == TIM_CLEARINPUTSOURCE_ETR)
;;;3852     {
;;;3853       TIM_ETR_SetConfig(htim->Instance, 
;;;3854                         sClearInputConfig->ClearInputPrescaler,
;;;3855                         sClearInputConfig->ClearInputPolarity,
;;;3856                         sClearInputConfig->ClearInputFilter);
;;;3857     }
;;;3858     
;;;3859     switch (Channel)
;;;3860     {
;;;3861       case TIM_CHANNEL_1:
;;;3862       {        
;;;3863         if(sClearInputConfig->ClearInputState != RESET)  
;;;3864         {
;;;3865           /* Enable the Ocref clear feature for Channel 1 */
;;;3866           htim->Instance->CCMR1 |= TIM_CCMR1_OC1CE;
;;;3867         }
;;;3868         else
;;;3869         {
;;;3870           /* Disable the Ocref clear feature for Channel 1 */
;;;3871           htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1CE;      
;;;3872         }
;;;3873       }    
;;;3874       break;
;;;3875       case TIM_CHANNEL_2:    
;;;3876       { 
;;;3877         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance)); 
;;;3878         if(sClearInputConfig->ClearInputState != RESET)  
;;;3879         {
;;;3880           /* Enable the Ocref clear feature for Channel 2 */
;;;3881           htim->Instance->CCMR1 |= TIM_CCMR1_OC2CE;
;;;3882         }
;;;3883         else
;;;3884         {
;;;3885           /* Disable the Ocref clear feature for Channel 2 */
;;;3886           htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2CE;      
;;;3887         }
;;;3888       } 
;;;3889       break;
;;;3890       case TIM_CHANNEL_3:   
;;;3891       {  
;;;3892         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3893         if(sClearInputConfig->ClearInputState != RESET)  
;;;3894         {
;;;3895           /* Enable the Ocref clear feature for Channel 3 */
;;;3896           htim->Instance->CCMR2 |= TIM_CCMR2_OC3CE;
;;;3897         }
;;;3898         else
;;;3899         {
;;;3900           /* Disable the Ocref clear feature for Channel 3 */
;;;3901           htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3CE;      
;;;3902         }
;;;3903       } 
;;;3904       break;
;;;3905       case TIM_CHANNEL_4:    
;;;3906       {  
;;;3907         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3908         if(sClearInputConfig->ClearInputState != RESET)  
;;;3909         {
;;;3910           /* Enable the Ocref clear feature for Channel 4 */
;;;3911           htim->Instance->CCMR2 |= TIM_CCMR2_OC4CE;
;;;3912         }
;;;3913         else
;;;3914         {
;;;3915           /* Disable the Ocref clear feature for Channel 4 */
;;;3916           htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4CE;      
;;;3917         }
;;;3918       } 
;;;3919       break;
;;;3920       default:  
;;;3921       break;
;;;3922     } 
;;;3923   
;;;3924     htim->State = HAL_TIM_STATE_READY;
;;;3925     
;;;3926     __HAL_UNLOCK(htim);
;;;3927     
;;;3928     return HAL_OK;  
;;;3929   }  
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L13.26|
00001a  2001              MOVS     r0,#1                 ;3847
00001c  f8840038          STRB     r0,[r4,#0x38]         ;3847
000020  bf00              NOP                            ;3847
000022  2002              MOVS     r0,#2                 ;3849
000024  f8840039          STRB     r0,[r4,#0x39]         ;3849
000028  6868              LDR      r0,[r5,#4]            ;3851
00002a  2801              CMP      r0,#1                 ;3851
00002c  d105              BNE      |L13.58|
00002e  e9d51303          LDRD     r1,r3,[r5,#0xc]       ;3853
000032  68aa              LDR      r2,[r5,#8]            ;3853
000034  6820              LDR      r0,[r4,#0]            ;3853
000036  f7fffffe          BL       TIM_ETR_SetConfig
                  |L13.58|
00003a  b136              CBZ      r6,|L13.74|
00003c  2e04              CMP      r6,#4                 ;3859
00003e  d014              BEQ      |L13.106|
000040  2e08              CMP      r6,#8                 ;3859
000042  d022              BEQ      |L13.138|
000044  2e0c              CMP      r6,#0xc               ;3859
000046  d140              BNE      |L13.202|
000048  e02f              B        |L13.170|
                  |L13.74|
00004a  6828              LDR      r0,[r5,#0]            ;3863
00004c  b130              CBZ      r0,|L13.92|
00004e  6820              LDR      r0,[r4,#0]            ;3866
000050  6980              LDR      r0,[r0,#0x18]         ;3866
000052  f0400080          ORR      r0,r0,#0x80           ;3866
000056  6821              LDR      r1,[r4,#0]            ;3866
000058  6188              STR      r0,[r1,#0x18]         ;3866
00005a  e005              B        |L13.104|
                  |L13.92|
00005c  6820              LDR      r0,[r4,#0]            ;3871
00005e  6980              LDR      r0,[r0,#0x18]         ;3871
000060  f0200080          BIC      r0,r0,#0x80           ;3871
000064  6821              LDR      r1,[r4,#0]            ;3871
000066  6188              STR      r0,[r1,#0x18]         ;3871
                  |L13.104|
000068  e030              B        |L13.204|
                  |L13.106|
00006a  6828              LDR      r0,[r5,#0]            ;3878
00006c  b130              CBZ      r0,|L13.124|
00006e  6820              LDR      r0,[r4,#0]            ;3881
000070  6980              LDR      r0,[r0,#0x18]         ;3881
000072  f4404000          ORR      r0,r0,#0x8000         ;3881
000076  6821              LDR      r1,[r4,#0]            ;3881
000078  6188              STR      r0,[r1,#0x18]         ;3881
00007a  e005              B        |L13.136|
                  |L13.124|
00007c  6820              LDR      r0,[r4,#0]            ;3886
00007e  6980              LDR      r0,[r0,#0x18]         ;3886
000080  f4204000          BIC      r0,r0,#0x8000         ;3886
000084  6821              LDR      r1,[r4,#0]            ;3886
000086  6188              STR      r0,[r1,#0x18]         ;3886
                  |L13.136|
000088  e020              B        |L13.204|
                  |L13.138|
00008a  6828              LDR      r0,[r5,#0]            ;3893
00008c  b130              CBZ      r0,|L13.156|
00008e  6820              LDR      r0,[r4,#0]            ;3896
000090  69c0              LDR      r0,[r0,#0x1c]         ;3896
000092  f0400080          ORR      r0,r0,#0x80           ;3896
000096  6821              LDR      r1,[r4,#0]            ;3896
000098  61c8              STR      r0,[r1,#0x1c]         ;3896
00009a  e005              B        |L13.168|
                  |L13.156|
00009c  6820              LDR      r0,[r4,#0]            ;3901
00009e  69c0              LDR      r0,[r0,#0x1c]         ;3901
0000a0  f0200080          BIC      r0,r0,#0x80           ;3901
0000a4  6821              LDR      r1,[r4,#0]            ;3901
0000a6  61c8              STR      r0,[r1,#0x1c]         ;3901
                  |L13.168|
0000a8  e010              B        |L13.204|
                  |L13.170|
0000aa  6828              LDR      r0,[r5,#0]            ;3908
0000ac  b130              CBZ      r0,|L13.188|
0000ae  6820              LDR      r0,[r4,#0]            ;3911
0000b0  69c0              LDR      r0,[r0,#0x1c]         ;3911
0000b2  f4404000          ORR      r0,r0,#0x8000         ;3911
0000b6  6821              LDR      r1,[r4,#0]            ;3911
0000b8  61c8              STR      r0,[r1,#0x1c]         ;3911
0000ba  e005              B        |L13.200|
                  |L13.188|
0000bc  6820              LDR      r0,[r4,#0]            ;3916
0000be  69c0              LDR      r0,[r0,#0x1c]         ;3916
0000c0  f4204000          BIC      r0,r0,#0x8000         ;3916
0000c4  6821              LDR      r1,[r4,#0]            ;3916
0000c6  61c8              STR      r0,[r1,#0x1c]         ;3916
                  |L13.200|
0000c8  e000              B        |L13.204|
                  |L13.202|
0000ca  bf00              NOP                            ;3921
                  |L13.204|
0000cc  bf00              NOP                            ;3874
0000ce  2001              MOVS     r0,#1                 ;3924
0000d0  f8840039          STRB     r0,[r4,#0x39]         ;3924
0000d4  bf00              NOP                            ;3926
0000d6  2000              MOVS     r0,#0                 ;3926
0000d8  f8840038          STRB     r0,[r4,#0x38]         ;3926
0000dc  bf00              NOP                            ;3926
0000de  bf00              NOP                            ;3928
0000e0  e799              B        |L13.22|
;;;3930   
                          ENDP


                          AREA ||i.HAL_TIM_ConfigTI1Input||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigTI1Input PROC
;;;4099     */
;;;4100   HAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)
000000  4602              MOV      r2,r0
;;;4101   {
000002  460b              MOV      r3,r1
;;;4102     uint32_t tmpcr2 = 0;
000004  2100              MOVS     r1,#0
;;;4103     
;;;4104     /* Check the parameters */
;;;4105     assert_param(IS_TIM_XOR_INSTANCE(htim->Instance)); 
;;;4106     assert_param(IS_TIM_TI1SELECTION(TI1_Selection));
;;;4107   
;;;4108     /* Get the TIMx CR2 register value */
;;;4109     tmpcr2 = htim->Instance->CR2;
000006  6810              LDR      r0,[r2,#0]
000008  6841              LDR      r1,[r0,#4]
;;;4110   
;;;4111     /* Reset the TI1 selection */
;;;4112     tmpcr2 &= ~TIM_CR2_TI1S;
00000a  f0210180          BIC      r1,r1,#0x80
;;;4113   
;;;4114     /* Set the TI1 selection */
;;;4115     tmpcr2 |= TI1_Selection;
00000e  4319              ORRS     r1,r1,r3
;;;4116     
;;;4117     /* Write to TIMxCR2 */
;;;4118     htim->Instance->CR2 = tmpcr2;
000010  6810              LDR      r0,[r2,#0]
000012  6041              STR      r1,[r0,#4]
;;;4119   
;;;4120     return HAL_OK;
000014  2000              MOVS     r0,#0
;;;4121   }
000016  4770              BX       lr
;;;4122   
                          ENDP


                          AREA ||i.HAL_TIM_DMABurst_ReadStart||, CODE, READONLY, ALIGN=2

                  HAL_TIM_DMABurst_ReadStart PROC
;;;3591     */
;;;3592   HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3593                                                uint32_t  *BurstBuffer, uint32_t  BurstLength)
;;;3594   {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  9d06              LDR      r5,[sp,#0x18]
;;;3595     /* Check the parameters */
;;;3596     assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
;;;3597     assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
;;;3598     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3599     assert_param(IS_TIM_DMA_LENGTH(BurstLength));
;;;3600     
;;;3601     if((htim->State == HAL_TIM_STATE_BUSY))
00000e  f8940039          LDRB     r0,[r4,#0x39]
000012  2802              CMP      r0,#2
000014  d101              BNE      |L15.26|
                  |L15.22|
;;;3602     {
;;;3603        return HAL_BUSY;
;;;3604     }
;;;3605     else if((htim->State == HAL_TIM_STATE_READY))
;;;3606     {
;;;3607       if((BurstBuffer == 0 ) && (BurstLength > 0)) 
;;;3608       {
;;;3609         return HAL_ERROR;                                    
;;;3610       }
;;;3611       else
;;;3612       {
;;;3613         htim->State = HAL_TIM_STATE_BUSY;
;;;3614       }
;;;3615     }  
;;;3616     switch(BurstRequestSrc)
;;;3617     {
;;;3618       case TIM_DMA_UPDATE:
;;;3619       {  
;;;3620         /* Set the DMA Period elapsed callback */
;;;3621         htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;3622        
;;;3623         /* Set the DMA error callback */
;;;3624         htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
;;;3625     
;;;3626         /* Enable the DMA Stream */
;;;3627          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);     
;;;3628       }
;;;3629       break;
;;;3630       case TIM_DMA_CC1:
;;;3631       {  
;;;3632         /* Set the DMA Period elapsed callback */
;;;3633         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;3634        
;;;3635         /* Set the DMA error callback */
;;;3636         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;3637     
;;;3638         /* Enable the DMA Stream */
;;;3639         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
;;;3640       }
;;;3641       break;
;;;3642       case TIM_DMA_CC2:
;;;3643       {  
;;;3644         /* Set the DMA Period elapsed callback */
;;;3645         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;3646        
;;;3647         /* Set the DMA error callback */
;;;3648         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;3649     
;;;3650         /* Enable the DMA Stream */
;;;3651         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);     
;;;3652       }
;;;3653       break;
;;;3654       case TIM_DMA_CC3:
;;;3655       {  
;;;3656         /* Set the DMA Period elapsed callback */
;;;3657         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
;;;3658        
;;;3659         /* Set the DMA error callback */
;;;3660         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;3661     
;;;3662         /* Enable the DMA Stream */
;;;3663         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
;;;3664       }
;;;3665       break;
;;;3666       case TIM_DMA_CC4:
;;;3667       {  
;;;3668         /* Set the DMA Period elapsed callback */
;;;3669         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
;;;3670        
;;;3671         /* Set the DMA error callback */
;;;3672         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;3673     
;;;3674         /* Enable the DMA Stream */
;;;3675         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
;;;3676       }
;;;3677       break;
;;;3678       case TIM_DMA_COM:
;;;3679       {  
;;;3680         /* Set the DMA Period elapsed callback */
;;;3681         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = TIMEx_DMACommutationCplt;
;;;3682        
;;;3683         /* Set the DMA error callback */
;;;3684         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
;;;3685     
;;;3686         /* Enable the DMA Stream */
;;;3687         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
;;;3688       }
;;;3689       break;
;;;3690       case TIM_DMA_TRIGGER:
;;;3691       {  
;;;3692         /* Set the DMA Period elapsed callback */
;;;3693         htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
;;;3694        
;;;3695         /* Set the DMA error callback */
;;;3696         htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
;;;3697     
;;;3698         /* Enable the DMA Stream */
;;;3699         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
;;;3700       }
;;;3701       break;
;;;3702       default:
;;;3703       break;  
;;;3704     }
;;;3705   
;;;3706     /* configure the DMA Burst Mode */
;;;3707     htim->Instance->DCR = BurstBaseAddress | BurstLength;  
;;;3708     
;;;3709     /* Enable the TIM DMA Request */
;;;3710     __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
;;;3711     
;;;3712     htim->State = HAL_TIM_STATE_READY;
;;;3713     
;;;3714     /* Return function status */
;;;3715     return HAL_OK;
;;;3716   }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L15.26|
00001a  f8940039          LDRB     r0,[r4,#0x39]         ;3605
00001e  2801              CMP      r0,#1                 ;3605
000020  d105              BNE      |L15.46|
000022  b90f              CBNZ     r7,|L15.40|
000024  b105              CBZ      r5,|L15.40|
000026  e7f6              B        |L15.22|
                  |L15.40|
000028  2002              MOVS     r0,#2                 ;3613
00002a  f8840039          STRB     r0,[r4,#0x39]         ;3613
                  |L15.46|
00002e  f5b66f00          CMP      r6,#0x800             ;3616
000032  d047              BEQ      |L15.196|
000034  dc09              BGT      |L15.74|
000036  f5b67f80          CMP      r6,#0x100             ;3616
00003a  d010              BEQ      |L15.94|
00003c  f5b67f00          CMP      r6,#0x200             ;3616
000040  d01e              BEQ      |L15.128|
000042  f5b66f80          CMP      r6,#0x400             ;3616
000046  d170              BNE      |L15.298|
000048  e02b              B        |L15.162|
                  |L15.74|
00004a  f5b65f80          CMP      r6,#0x1000            ;3616
00004e  d04a              BEQ      |L15.230|
000050  f5b65f00          CMP      r6,#0x2000            ;3616
000054  d058              BEQ      |L15.264|
000056  f5b64f80          CMP      r6,#0x4000            ;3616
00005a  d178              BNE      |L15.334|
00005c  e066              B        |L15.300|
                  |L15.94|
00005e  4844              LDR      r0,|L15.368|
000060  69e1              LDR      r1,[r4,#0x1c]         ;3621
000062  63c8              STR      r0,[r1,#0x3c]         ;3621
000064  4843              LDR      r0,|L15.372|
000066  69e1              LDR      r1,[r4,#0x1c]         ;3624
000068  6488              STR      r0,[r1,#0x48]         ;3624
00006a  2201              MOVS     r2,#1                 ;3627
00006c  eb022315          ADD      r3,r2,r5,LSR #8       ;3627
000070  6822              LDR      r2,[r4,#0]            ;3627
000072  f102014c          ADD      r1,r2,#0x4c           ;3627
000076  463a              MOV      r2,r7                 ;3627
000078  69e0              LDR      r0,[r4,#0x1c]         ;3627
00007a  f7fffffe          BL       HAL_DMA_Start_IT
00007e  e067              B        |L15.336|
                  |L15.128|
000080  493d              LDR      r1,|L15.376|
000082  6a20              LDR      r0,[r4,#0x20]         ;3633
000084  63c1              STR      r1,[r0,#0x3c]         ;3633
000086  493b              LDR      r1,|L15.372|
000088  6a20              LDR      r0,[r4,#0x20]         ;3636
00008a  6481              STR      r1,[r0,#0x48]         ;3636
00008c  2201              MOVS     r2,#1                 ;3639
00008e  eb022315          ADD      r3,r2,r5,LSR #8       ;3639
000092  6822              LDR      r2,[r4,#0]            ;3639
000094  f102014c          ADD      r1,r2,#0x4c           ;3639
000098  463a              MOV      r2,r7                 ;3639
00009a  6a20              LDR      r0,[r4,#0x20]         ;3639
00009c  f7fffffe          BL       HAL_DMA_Start_IT
0000a0  e056              B        |L15.336|
                  |L15.162|
0000a2  4935              LDR      r1,|L15.376|
0000a4  6a60              LDR      r0,[r4,#0x24]         ;3645
0000a6  63c1              STR      r1,[r0,#0x3c]         ;3645
0000a8  4932              LDR      r1,|L15.372|
0000aa  6a60              LDR      r0,[r4,#0x24]         ;3648
0000ac  6481              STR      r1,[r0,#0x48]         ;3648
0000ae  2201              MOVS     r2,#1                 ;3651
0000b0  eb022315          ADD      r3,r2,r5,LSR #8       ;3651
0000b4  6822              LDR      r2,[r4,#0]            ;3651
0000b6  f102014c          ADD      r1,r2,#0x4c           ;3651
0000ba  463a              MOV      r2,r7                 ;3651
0000bc  6a60              LDR      r0,[r4,#0x24]         ;3651
0000be  f7fffffe          BL       HAL_DMA_Start_IT
0000c2  e045              B        |L15.336|
                  |L15.196|
0000c4  492c              LDR      r1,|L15.376|
0000c6  6aa0              LDR      r0,[r4,#0x28]         ;3657
0000c8  63c1              STR      r1,[r0,#0x3c]         ;3657
0000ca  492a              LDR      r1,|L15.372|
0000cc  6aa0              LDR      r0,[r4,#0x28]         ;3660
0000ce  6481              STR      r1,[r0,#0x48]         ;3660
0000d0  2201              MOVS     r2,#1                 ;3663
0000d2  eb022315          ADD      r3,r2,r5,LSR #8       ;3663
0000d6  6822              LDR      r2,[r4,#0]            ;3663
0000d8  f102014c          ADD      r1,r2,#0x4c           ;3663
0000dc  463a              MOV      r2,r7                 ;3663
0000de  6aa0              LDR      r0,[r4,#0x28]         ;3663
0000e0  f7fffffe          BL       HAL_DMA_Start_IT
0000e4  e034              B        |L15.336|
                  |L15.230|
0000e6  4924              LDR      r1,|L15.376|
0000e8  6ae0              LDR      r0,[r4,#0x2c]         ;3669
0000ea  63c1              STR      r1,[r0,#0x3c]         ;3669
0000ec  4921              LDR      r1,|L15.372|
0000ee  6ae0              LDR      r0,[r4,#0x2c]         ;3672
0000f0  6481              STR      r1,[r0,#0x48]         ;3672
0000f2  2201              MOVS     r2,#1                 ;3675
0000f4  eb022315          ADD      r3,r2,r5,LSR #8       ;3675
0000f8  6822              LDR      r2,[r4,#0]            ;3675
0000fa  f102014c          ADD      r1,r2,#0x4c           ;3675
0000fe  463a              MOV      r2,r7                 ;3675
000100  6ae0              LDR      r0,[r4,#0x2c]         ;3675
000102  f7fffffe          BL       HAL_DMA_Start_IT
000106  e023              B        |L15.336|
                  |L15.264|
000108  491c              LDR      r1,|L15.380|
00010a  6b20              LDR      r0,[r4,#0x30]         ;3681
00010c  63c1              STR      r1,[r0,#0x3c]         ;3681
00010e  4919              LDR      r1,|L15.372|
000110  6b20              LDR      r0,[r4,#0x30]         ;3684
000112  6481              STR      r1,[r0,#0x48]         ;3684
000114  2201              MOVS     r2,#1                 ;3687
000116  eb022315          ADD      r3,r2,r5,LSR #8       ;3687
00011a  6822              LDR      r2,[r4,#0]            ;3687
00011c  f102014c          ADD      r1,r2,#0x4c           ;3687
000120  463a              MOV      r2,r7                 ;3687
000122  6b20              LDR      r0,[r4,#0x30]         ;3687
000124  f7fffffe          BL       HAL_DMA_Start_IT
000128  e012              B        |L15.336|
                  |L15.298|
00012a  e010              B        |L15.334|
                  |L15.300|
00012c  4914              LDR      r1,|L15.384|
00012e  6b60              LDR      r0,[r4,#0x34]         ;3693
000130  63c1              STR      r1,[r0,#0x3c]         ;3693
000132  4910              LDR      r1,|L15.372|
000134  6b60              LDR      r0,[r4,#0x34]         ;3696
000136  6481              STR      r1,[r0,#0x48]         ;3696
000138  2201              MOVS     r2,#1                 ;3699
00013a  eb022315          ADD      r3,r2,r5,LSR #8       ;3699
00013e  6822              LDR      r2,[r4,#0]            ;3699
000140  f102014c          ADD      r1,r2,#0x4c           ;3699
000144  463a              MOV      r2,r7                 ;3699
000146  6b60              LDR      r0,[r4,#0x34]         ;3699
000148  f7fffffe          BL       HAL_DMA_Start_IT
00014c  e000              B        |L15.336|
                  |L15.334|
00014e  bf00              NOP                            ;3703
                  |L15.336|
000150  bf00              NOP                            ;3629
000152  ea480005          ORR      r0,r8,r5              ;3707
000156  6821              LDR      r1,[r4,#0]            ;3707
000158  6488              STR      r0,[r1,#0x48]         ;3707
00015a  6820              LDR      r0,[r4,#0]            ;3710
00015c  68c0              LDR      r0,[r0,#0xc]          ;3710
00015e  4330              ORRS     r0,r0,r6              ;3710
000160  6821              LDR      r1,[r4,#0]            ;3710
000162  60c8              STR      r0,[r1,#0xc]          ;3710
000164  2001              MOVS     r0,#1                 ;3712
000166  f8840039          STRB     r0,[r4,#0x39]         ;3712
00016a  2000              MOVS     r0,#0                 ;3715
00016c  e753              B        |L15.22|
;;;3717   
                          ENDP

00016e  0000              DCW      0x0000
                  |L15.368|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L15.372|
                          DCD      TIM_DMAError
                  |L15.376|
                          DCD      TIM_DMACaptureCplt
                  |L15.380|
                          DCD      TIMEx_DMACommutationCplt
                  |L15.384|
                          DCD      TIM_DMATriggerCplt

                          AREA ||i.HAL_TIM_DMABurst_ReadStop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMABurst_ReadStop PROC
;;;3724     */
;;;3725   HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
000000  b570              PUSH     {r4-r6,lr}
;;;3726   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;3727     /* Check the parameters */
;;;3728     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3729     
;;;3730     /* Abort the DMA transfer (at least disable the DMA channel) */
;;;3731     switch(BurstRequestSrc)
000006  f5b56f00          CMP      r5,#0x800
00000a  d020              BEQ      |L16.78|
00000c  dc09              BGT      |L16.34|
00000e  f5b57f80          CMP      r5,#0x100
000012  d010              BEQ      |L16.54|
000014  f5b57f00          CMP      r5,#0x200
000018  d011              BEQ      |L16.62|
00001a  f5b56f80          CMP      r5,#0x400
00001e  d126              BNE      |L16.110|
000020  e011              B        |L16.70|
                  |L16.34|
000022  f5b55f80          CMP      r5,#0x1000
000026  d016              BEQ      |L16.86|
000028  f5b55f00          CMP      r5,#0x2000
00002c  d017              BEQ      |L16.94|
00002e  f5b54f80          CMP      r5,#0x4000
000032  d11c              BNE      |L16.110|
000034  e017              B        |L16.102|
                  |L16.54|
;;;3732     {
;;;3733       case TIM_DMA_UPDATE:
;;;3734       {  
;;;3735         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
000036  69e0              LDR      r0,[r4,#0x1c]
000038  f7fffffe          BL       HAL_DMA_Abort
;;;3736       }
;;;3737       break;
00003c  e018              B        |L16.112|
                  |L16.62|
;;;3738       case TIM_DMA_CC1:
;;;3739       {  
;;;3740         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
00003e  6a20              LDR      r0,[r4,#0x20]
000040  f7fffffe          BL       HAL_DMA_Abort
;;;3741       }
;;;3742       break;
000044  e014              B        |L16.112|
                  |L16.70|
;;;3743       case TIM_DMA_CC2:
;;;3744       {  
;;;3745         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
000046  6a60              LDR      r0,[r4,#0x24]
000048  f7fffffe          BL       HAL_DMA_Abort
;;;3746       }
;;;3747       break;
00004c  e010              B        |L16.112|
                  |L16.78|
;;;3748       case TIM_DMA_CC3:
;;;3749       {  
;;;3750         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
00004e  6aa0              LDR      r0,[r4,#0x28]
000050  f7fffffe          BL       HAL_DMA_Abort
;;;3751       }
;;;3752       break;
000054  e00c              B        |L16.112|
                  |L16.86|
;;;3753       case TIM_DMA_CC4:
;;;3754       {  
;;;3755         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
000056  6ae0              LDR      r0,[r4,#0x2c]
000058  f7fffffe          BL       HAL_DMA_Abort
;;;3756       }
;;;3757       break;
00005c  e008              B        |L16.112|
                  |L16.94|
;;;3758       case TIM_DMA_COM:
;;;3759       {  
;;;3760         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
00005e  6b20              LDR      r0,[r4,#0x30]
000060  f7fffffe          BL       HAL_DMA_Abort
;;;3761       }
;;;3762       break;
000064  e004              B        |L16.112|
                  |L16.102|
;;;3763       case TIM_DMA_TRIGGER:
;;;3764       {  
;;;3765         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
000066  6b60              LDR      r0,[r4,#0x34]
000068  f7fffffe          BL       HAL_DMA_Abort
;;;3766       }
;;;3767       break;
00006c  e000              B        |L16.112|
                  |L16.110|
;;;3768       default:
;;;3769       break;  
00006e  bf00              NOP      
                  |L16.112|
000070  bf00              NOP                            ;3737
;;;3770     }
;;;3771     
;;;3772     /* Disable the TIM Update DMA request */
;;;3773     __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
000072  6820              LDR      r0,[r4,#0]
000074  68c0              LDR      r0,[r0,#0xc]
000076  43a8              BICS     r0,r0,r5
000078  6821              LDR      r1,[r4,#0]
00007a  60c8              STR      r0,[r1,#0xc]
;;;3774         
;;;3775     /* Return function status */
;;;3776     return HAL_OK;  
00007c  2000              MOVS     r0,#0
;;;3777   }
00007e  bd70              POP      {r4-r6,pc}
;;;3778   
                          ENDP


                          AREA ||i.HAL_TIM_DMABurst_WriteStart||, CODE, READONLY, ALIGN=2

                  HAL_TIM_DMABurst_WriteStart PROC
;;;3366     */
;;;3367   HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3368                                                 uint32_t* BurstBuffer, uint32_t  BurstLength)
;;;3369   {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  9d06              LDR      r5,[sp,#0x18]
;;;3370     /* Check the parameters */
;;;3371     assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
;;;3372     assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
;;;3373     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3374     assert_param(IS_TIM_DMA_LENGTH(BurstLength));
;;;3375     
;;;3376     if((htim->State == HAL_TIM_STATE_BUSY))
00000e  f8940039          LDRB     r0,[r4,#0x39]
000012  2802              CMP      r0,#2
000014  d101              BNE      |L17.26|
                  |L17.22|
;;;3377     {
;;;3378        return HAL_BUSY;
;;;3379     }
;;;3380     else if((htim->State == HAL_TIM_STATE_READY))
;;;3381     {
;;;3382       if((BurstBuffer == 0 ) && (BurstLength > 0)) 
;;;3383       {
;;;3384         return HAL_ERROR;                                    
;;;3385       }
;;;3386       else
;;;3387       {
;;;3388         htim->State = HAL_TIM_STATE_BUSY;
;;;3389       }
;;;3390     }
;;;3391     switch(BurstRequestSrc)
;;;3392     {
;;;3393       case TIM_DMA_UPDATE:
;;;3394       {  
;;;3395         /* Set the DMA Period elapsed callback */
;;;3396         htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;3397        
;;;3398         /* Set the DMA error callback */
;;;3399         htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
;;;3400     
;;;3401         /* Enable the DMA Stream */
;;;3402         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1); 
;;;3403       }
;;;3404       break;
;;;3405       case TIM_DMA_CC1:
;;;3406       {  
;;;3407         /* Set the DMA Period elapsed callback */
;;;3408         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;3409        
;;;3410         /* Set the DMA error callback */
;;;3411         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;3412     
;;;3413         /* Enable the DMA Stream */
;;;3414         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3415       }
;;;3416       break;
;;;3417       case TIM_DMA_CC2:
;;;3418       {  
;;;3419         /* Set the DMA Period elapsed callback */
;;;3420         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;3421        
;;;3422         /* Set the DMA error callback */
;;;3423         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;3424     
;;;3425         /* Enable the DMA Stream */
;;;3426         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3427       }
;;;3428       break;
;;;3429       case TIM_DMA_CC3:
;;;3430       {  
;;;3431         /* Set the DMA Period elapsed callback */
;;;3432         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;3433        
;;;3434         /* Set the DMA error callback */
;;;3435         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;3436     
;;;3437         /* Enable the DMA Stream */
;;;3438         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3439       }
;;;3440       break;
;;;3441       case TIM_DMA_CC4:
;;;3442       {  
;;;3443         /* Set the DMA Period elapsed callback */
;;;3444         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;3445        
;;;3446         /* Set the DMA error callback */
;;;3447         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;3448     
;;;3449         /* Enable the DMA Stream */
;;;3450         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3451       }
;;;3452       break;
;;;3453       case TIM_DMA_COM:
;;;3454       {  
;;;3455         /* Set the DMA Period elapsed callback */
;;;3456         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = TIMEx_DMACommutationCplt;
;;;3457        
;;;3458         /* Set the DMA error callback */
;;;3459         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
;;;3460     
;;;3461         /* Enable the DMA Stream */
;;;3462         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3463       }
;;;3464       break;
;;;3465       case TIM_DMA_TRIGGER:
;;;3466       {  
;;;3467         /* Set the DMA Period elapsed callback */
;;;3468         htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
;;;3469        
;;;3470         /* Set the DMA error callback */
;;;3471         htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
;;;3472     
;;;3473         /* Enable the DMA Stream */
;;;3474         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3475       }
;;;3476       break;
;;;3477       default:
;;;3478       break;  
;;;3479     }
;;;3480      /* configure the DMA Burst Mode */
;;;3481      htim->Instance->DCR = BurstBaseAddress | BurstLength;  
;;;3482      
;;;3483      /* Enable the TIM DMA Request */
;;;3484      __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);  
;;;3485      
;;;3486      htim->State = HAL_TIM_STATE_READY;
;;;3487     
;;;3488     /* Return function status */
;;;3489     return HAL_OK;
;;;3490   }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L17.26|
00001a  f8940039          LDRB     r0,[r4,#0x39]         ;3380
00001e  2801              CMP      r0,#1                 ;3380
000020  d105              BNE      |L17.46|
000022  b90f              CBNZ     r7,|L17.40|
000024  b105              CBZ      r5,|L17.40|
000026  e7f6              B        |L17.22|
                  |L17.40|
000028  2002              MOVS     r0,#2                 ;3388
00002a  f8840039          STRB     r0,[r4,#0x39]         ;3388
                  |L17.46|
00002e  f5b66f00          CMP      r6,#0x800             ;3391
000032  d047              BEQ      |L17.196|
000034  dc09              BGT      |L17.74|
000036  f5b67f80          CMP      r6,#0x100             ;3391
00003a  d010              BEQ      |L17.94|
00003c  f5b67f00          CMP      r6,#0x200             ;3391
000040  d01e              BEQ      |L17.128|
000042  f5b66f80          CMP      r6,#0x400             ;3391
000046  d170              BNE      |L17.298|
000048  e02b              B        |L17.162|
                  |L17.74|
00004a  f5b65f80          CMP      r6,#0x1000            ;3391
00004e  d04a              BEQ      |L17.230|
000050  f5b65f00          CMP      r6,#0x2000            ;3391
000054  d058              BEQ      |L17.264|
000056  f5b64f80          CMP      r6,#0x4000            ;3391
00005a  d178              BNE      |L17.334|
00005c  e066              B        |L17.300|
                  |L17.94|
00005e  4844              LDR      r0,|L17.368|
000060  69e1              LDR      r1,[r4,#0x1c]         ;3396
000062  63c8              STR      r0,[r1,#0x3c]         ;3396
000064  4843              LDR      r0,|L17.372|
000066  69e1              LDR      r1,[r4,#0x1c]         ;3399
000068  6488              STR      r0,[r1,#0x48]         ;3399
00006a  2101              MOVS     r1,#1                 ;3402
00006c  eb012315          ADD      r3,r1,r5,LSR #8       ;3402
000070  6821              LDR      r1,[r4,#0]            ;3402
000072  f101024c          ADD      r2,r1,#0x4c           ;3402
000076  4639              MOV      r1,r7                 ;3402
000078  69e0              LDR      r0,[r4,#0x1c]         ;3402
00007a  f7fffffe          BL       HAL_DMA_Start_IT
00007e  e067              B        |L17.336|
                  |L17.128|
000080  493d              LDR      r1,|L17.376|
000082  6a20              LDR      r0,[r4,#0x20]         ;3408
000084  63c1              STR      r1,[r0,#0x3c]         ;3408
000086  493b              LDR      r1,|L17.372|
000088  6a20              LDR      r0,[r4,#0x20]         ;3411
00008a  6481              STR      r1,[r0,#0x48]         ;3411
00008c  2101              MOVS     r1,#1                 ;3414
00008e  eb012315          ADD      r3,r1,r5,LSR #8       ;3414
000092  6821              LDR      r1,[r4,#0]            ;3414
000094  f101024c          ADD      r2,r1,#0x4c           ;3414
000098  4639              MOV      r1,r7                 ;3414
00009a  6a20              LDR      r0,[r4,#0x20]         ;3414
00009c  f7fffffe          BL       HAL_DMA_Start_IT
0000a0  e056              B        |L17.336|
                  |L17.162|
0000a2  4935              LDR      r1,|L17.376|
0000a4  6a60              LDR      r0,[r4,#0x24]         ;3420
0000a6  63c1              STR      r1,[r0,#0x3c]         ;3420
0000a8  4932              LDR      r1,|L17.372|
0000aa  6a60              LDR      r0,[r4,#0x24]         ;3423
0000ac  6481              STR      r1,[r0,#0x48]         ;3423
0000ae  2101              MOVS     r1,#1                 ;3426
0000b0  eb012315          ADD      r3,r1,r5,LSR #8       ;3426
0000b4  6821              LDR      r1,[r4,#0]            ;3426
0000b6  f101024c          ADD      r2,r1,#0x4c           ;3426
0000ba  4639              MOV      r1,r7                 ;3426
0000bc  6a60              LDR      r0,[r4,#0x24]         ;3426
0000be  f7fffffe          BL       HAL_DMA_Start_IT
0000c2  e045              B        |L17.336|
                  |L17.196|
0000c4  492c              LDR      r1,|L17.376|
0000c6  6aa0              LDR      r0,[r4,#0x28]         ;3432
0000c8  63c1              STR      r1,[r0,#0x3c]         ;3432
0000ca  492a              LDR      r1,|L17.372|
0000cc  6aa0              LDR      r0,[r4,#0x28]         ;3435
0000ce  6481              STR      r1,[r0,#0x48]         ;3435
0000d0  2101              MOVS     r1,#1                 ;3438
0000d2  eb012315          ADD      r3,r1,r5,LSR #8       ;3438
0000d6  6821              LDR      r1,[r4,#0]            ;3438
0000d8  f101024c          ADD      r2,r1,#0x4c           ;3438
0000dc  4639              MOV      r1,r7                 ;3438
0000de  6aa0              LDR      r0,[r4,#0x28]         ;3438
0000e0  f7fffffe          BL       HAL_DMA_Start_IT
0000e4  e034              B        |L17.336|
                  |L17.230|
0000e6  4924              LDR      r1,|L17.376|
0000e8  6ae0              LDR      r0,[r4,#0x2c]         ;3444
0000ea  63c1              STR      r1,[r0,#0x3c]         ;3444
0000ec  4921              LDR      r1,|L17.372|
0000ee  6ae0              LDR      r0,[r4,#0x2c]         ;3447
0000f0  6481              STR      r1,[r0,#0x48]         ;3447
0000f2  2101              MOVS     r1,#1                 ;3450
0000f4  eb012315          ADD      r3,r1,r5,LSR #8       ;3450
0000f8  6821              LDR      r1,[r4,#0]            ;3450
0000fa  f101024c          ADD      r2,r1,#0x4c           ;3450
0000fe  4639              MOV      r1,r7                 ;3450
000100  6ae0              LDR      r0,[r4,#0x2c]         ;3450
000102  f7fffffe          BL       HAL_DMA_Start_IT
000106  e023              B        |L17.336|
                  |L17.264|
000108  491c              LDR      r1,|L17.380|
00010a  6b20              LDR      r0,[r4,#0x30]         ;3456
00010c  63c1              STR      r1,[r0,#0x3c]         ;3456
00010e  4919              LDR      r1,|L17.372|
000110  6b20              LDR      r0,[r4,#0x30]         ;3459
000112  6481              STR      r1,[r0,#0x48]         ;3459
000114  2101              MOVS     r1,#1                 ;3462
000116  eb012315          ADD      r3,r1,r5,LSR #8       ;3462
00011a  6821              LDR      r1,[r4,#0]            ;3462
00011c  f101024c          ADD      r2,r1,#0x4c           ;3462
000120  4639              MOV      r1,r7                 ;3462
000122  6b20              LDR      r0,[r4,#0x30]         ;3462
000124  f7fffffe          BL       HAL_DMA_Start_IT
000128  e012              B        |L17.336|
                  |L17.298|
00012a  e010              B        |L17.334|
                  |L17.300|
00012c  4914              LDR      r1,|L17.384|
00012e  6b60              LDR      r0,[r4,#0x34]         ;3468
000130  63c1              STR      r1,[r0,#0x3c]         ;3468
000132  4910              LDR      r1,|L17.372|
000134  6b60              LDR      r0,[r4,#0x34]         ;3471
000136  6481              STR      r1,[r0,#0x48]         ;3471
000138  2101              MOVS     r1,#1                 ;3474
00013a  eb012315          ADD      r3,r1,r5,LSR #8       ;3474
00013e  6821              LDR      r1,[r4,#0]            ;3474
000140  f101024c          ADD      r2,r1,#0x4c           ;3474
000144  4639              MOV      r1,r7                 ;3474
000146  6b60              LDR      r0,[r4,#0x34]         ;3474
000148  f7fffffe          BL       HAL_DMA_Start_IT
00014c  e000              B        |L17.336|
                  |L17.334|
00014e  bf00              NOP                            ;3478
                  |L17.336|
000150  bf00              NOP                            ;3404
000152  ea480005          ORR      r0,r8,r5              ;3481
000156  6821              LDR      r1,[r4,#0]            ;3481
000158  6488              STR      r0,[r1,#0x48]         ;3481
00015a  6820              LDR      r0,[r4,#0]            ;3484
00015c  68c0              LDR      r0,[r0,#0xc]          ;3484
00015e  4330              ORRS     r0,r0,r6              ;3484
000160  6821              LDR      r1,[r4,#0]            ;3484
000162  60c8              STR      r0,[r1,#0xc]          ;3484
000164  2001              MOVS     r0,#1                 ;3486
000166  f8840039          STRB     r0,[r4,#0x39]         ;3486
00016a  2000              MOVS     r0,#0                 ;3489
00016c  e753              B        |L17.22|
;;;3491   
                          ENDP

00016e  0000              DCW      0x0000
                  |L17.368|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L17.372|
                          DCD      TIM_DMAError
                  |L17.376|
                          DCD      TIM_DMADelayPulseCplt
                  |L17.380|
                          DCD      TIMEx_DMACommutationCplt
                  |L17.384|
                          DCD      TIM_DMATriggerCplt

                          AREA ||i.HAL_TIM_DMABurst_WriteStop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMABurst_WriteStop PROC
;;;3498     */
;;;3499   HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
000000  b570              PUSH     {r4-r6,lr}
;;;3500   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;3501     /* Check the parameters */
;;;3502     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3503     
;;;3504     /* Abort the DMA transfer (at least disable the DMA channel) */
;;;3505     switch(BurstRequestSrc)
000006  f5b56f00          CMP      r5,#0x800
00000a  d020              BEQ      |L18.78|
00000c  dc09              BGT      |L18.34|
00000e  f5b57f80          CMP      r5,#0x100
000012  d010              BEQ      |L18.54|
000014  f5b57f00          CMP      r5,#0x200
000018  d011              BEQ      |L18.62|
00001a  f5b56f80          CMP      r5,#0x400
00001e  d126              BNE      |L18.110|
000020  e011              B        |L18.70|
                  |L18.34|
000022  f5b55f80          CMP      r5,#0x1000
000026  d016              BEQ      |L18.86|
000028  f5b55f00          CMP      r5,#0x2000
00002c  d017              BEQ      |L18.94|
00002e  f5b54f80          CMP      r5,#0x4000
000032  d11c              BNE      |L18.110|
000034  e017              B        |L18.102|
                  |L18.54|
;;;3506     {
;;;3507       case TIM_DMA_UPDATE:
;;;3508       {  
;;;3509         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
000036  69e0              LDR      r0,[r4,#0x1c]
000038  f7fffffe          BL       HAL_DMA_Abort
;;;3510       }
;;;3511       break;
00003c  e018              B        |L18.112|
                  |L18.62|
;;;3512       case TIM_DMA_CC1:
;;;3513       {  
;;;3514         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
00003e  6a20              LDR      r0,[r4,#0x20]
000040  f7fffffe          BL       HAL_DMA_Abort
;;;3515       }
;;;3516       break;
000044  e014              B        |L18.112|
                  |L18.70|
;;;3517       case TIM_DMA_CC2:
;;;3518       {  
;;;3519         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
000046  6a60              LDR      r0,[r4,#0x24]
000048  f7fffffe          BL       HAL_DMA_Abort
;;;3520       }
;;;3521       break;
00004c  e010              B        |L18.112|
                  |L18.78|
;;;3522       case TIM_DMA_CC3:
;;;3523       {  
;;;3524         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
00004e  6aa0              LDR      r0,[r4,#0x28]
000050  f7fffffe          BL       HAL_DMA_Abort
;;;3525       }
;;;3526       break;
000054  e00c              B        |L18.112|
                  |L18.86|
;;;3527       case TIM_DMA_CC4:
;;;3528       {  
;;;3529         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
000056  6ae0              LDR      r0,[r4,#0x2c]
000058  f7fffffe          BL       HAL_DMA_Abort
;;;3530       }
;;;3531       break;
00005c  e008              B        |L18.112|
                  |L18.94|
;;;3532       case TIM_DMA_COM:
;;;3533       {  
;;;3534         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
00005e  6b20              LDR      r0,[r4,#0x30]
000060  f7fffffe          BL       HAL_DMA_Abort
;;;3535       }
;;;3536       break;
000064  e004              B        |L18.112|
                  |L18.102|
;;;3537       case TIM_DMA_TRIGGER:
;;;3538       {  
;;;3539         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
000066  6b60              LDR      r0,[r4,#0x34]
000068  f7fffffe          BL       HAL_DMA_Abort
;;;3540       }
;;;3541       break;
00006c  e000              B        |L18.112|
                  |L18.110|
;;;3542       default:
;;;3543       break;
00006e  bf00              NOP      
                  |L18.112|
000070  bf00              NOP                            ;3511
;;;3544     }
;;;3545   
;;;3546     /* Disable the TIM Update DMA request */
;;;3547     __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
000072  6820              LDR      r0,[r4,#0]
000074  68c0              LDR      r0,[r0,#0xc]
000076  43a8              BICS     r0,r0,r5
000078  6821              LDR      r1,[r4,#0]
00007a  60c8              STR      r0,[r1,#0xc]
;;;3548         
;;;3549     /* Return function status */
;;;3550     return HAL_OK;  
00007c  2000              MOVS     r0,#0
;;;3551   }
00007e  bd70              POP      {r4-r6,pc}
;;;3552   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_DeInit PROC
;;;2363     */
;;;2364   HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;2365   {
000002  4604              MOV      r4,r0
;;;2366     /* Check the parameters */
;;;2367     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2368     
;;;2369     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f8840039          STRB     r0,[r4,#0x39]
;;;2370     
;;;2371     /* Disable the TIM Peripheral Clock */
;;;2372     __HAL_TIM_DISABLE(htim);
00000a  bf00              NOP      
00000c  6820              LDR      r0,[r4,#0]
00000e  6a00              LDR      r0,[r0,#0x20]
000010  f2411111          MOV      r1,#0x1111
000014  4008              ANDS     r0,r0,r1
000016  b950              CBNZ     r0,|L19.46|
000018  6820              LDR      r0,[r4,#0]
00001a  6a00              LDR      r0,[r0,#0x20]
00001c  1089              ASRS     r1,r1,#2
00001e  4008              ANDS     r0,r0,r1
000020  b928              CBNZ     r0,|L19.46|
000022  6820              LDR      r0,[r4,#0]
000024  6800              LDR      r0,[r0,#0]
000026  f0200001          BIC      r0,r0,#1
00002a  6821              LDR      r1,[r4,#0]
00002c  6008              STR      r0,[r1,#0]
                  |L19.46|
00002e  bf00              NOP      
;;;2373     
;;;2374     /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;2375     HAL_TIM_Encoder_MspDeInit(htim);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       HAL_TIM_Encoder_MspDeInit
;;;2376       
;;;2377     /* Change TIM state */  
;;;2378     htim->State = HAL_TIM_STATE_RESET;
000036  2000              MOVS     r0,#0
000038  f8840039          STRB     r0,[r4,#0x39]
;;;2379    
;;;2380     /* Release Lock */
;;;2381     __HAL_UNLOCK(htim);
00003c  bf00              NOP      
00003e  f8840038          STRB     r0,[r4,#0x38]
000042  bf00              NOP      
;;;2382   
;;;2383     return HAL_OK;
;;;2384   }
000044  bd10              POP      {r4,pc}
;;;2385   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_GetState PROC
;;;4456     */
;;;4457   HAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;4458   {
;;;4459     return htim->State;
000002  f8910039          LDRB     r0,[r1,#0x39]
;;;4460   }
000006  4770              BX       lr
;;;4461   /**
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Init PROC
;;;2274     */
;;;2275   HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef* sConfig)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2276   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;2277     uint32_t tmpsmcr = 0;
000008  f04f0800          MOV      r8,#0
;;;2278     uint32_t tmpccmr1 = 0;
00000c  2600              MOVS     r6,#0
;;;2279     uint32_t tmpccer = 0;
00000e  2700              MOVS     r7,#0
;;;2280     
;;;2281     /* Check the TIM handle allocation */
;;;2282     if(htim == NULL)
000010  b914              CBNZ     r4,|L21.24|
;;;2283     {
;;;2284       return HAL_ERROR;
000012  2001              MOVS     r0,#1
                  |L21.20|
;;;2285     }
;;;2286      
;;;2287     /* Check the parameters */
;;;2288     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2289     assert_param(IS_TIM_ENCODER_MODE(sConfig->EncoderMode));
;;;2290     assert_param(IS_TIM_IC_SELECTION(sConfig->IC1Selection));
;;;2291     assert_param(IS_TIM_IC_SELECTION(sConfig->IC2Selection));
;;;2292     assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
;;;2293     assert_param(IS_TIM_IC_POLARITY(sConfig->IC2Polarity));
;;;2294     assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
;;;2295     assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));
;;;2296     assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
;;;2297     assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));
;;;2298   
;;;2299     if(htim->State == HAL_TIM_STATE_RESET)
;;;2300     { 
;;;2301       /* Allocate lock resource and initialize it */
;;;2302       htim->Lock = HAL_UNLOCKED;
;;;2303       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;2304       HAL_TIM_Encoder_MspInit(htim);
;;;2305     }
;;;2306     
;;;2307     /* Set the TIM state */
;;;2308     htim->State= HAL_TIM_STATE_BUSY;   
;;;2309       
;;;2310     /* Reset the SMS bits */
;;;2311     htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;2312     
;;;2313     /* Configure the Time base in the Encoder Mode */
;;;2314     TIM_Base_SetConfig(htim->Instance, &htim->Init);  
;;;2315     
;;;2316     /* Get the TIMx SMCR register value */
;;;2317     tmpsmcr = htim->Instance->SMCR;
;;;2318   
;;;2319     /* Get the TIMx CCMR1 register value */
;;;2320     tmpccmr1 = htim->Instance->CCMR1;
;;;2321   
;;;2322     /* Get the TIMx CCER register value */
;;;2323     tmpccer = htim->Instance->CCER;
;;;2324   
;;;2325     /* Set the encoder Mode */
;;;2326     tmpsmcr |= sConfig->EncoderMode;
;;;2327   
;;;2328     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;2329     tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
;;;2330     tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8));
;;;2331     
;;;2332     /* Set the Capture Compare 1 and the Capture Compare 2 prescalers and filters */
;;;2333     tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);
;;;2334     tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
;;;2335     tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8);
;;;2336     tmpccmr1 |= (sConfig->IC1Filter << 4) | (sConfig->IC2Filter << 12);
;;;2337   
;;;2338     /* Set the TI1 and the TI2 Polarities */
;;;2339     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
;;;2340     tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
;;;2341     tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4);
;;;2342     
;;;2343     /* Write to TIMx SMCR */
;;;2344     htim->Instance->SMCR = tmpsmcr;
;;;2345   
;;;2346     /* Write to TIMx CCMR1 */
;;;2347     htim->Instance->CCMR1 = tmpccmr1;
;;;2348   
;;;2349     /* Write to TIMx CCER */
;;;2350     htim->Instance->CCER = tmpccer;
;;;2351     
;;;2352     /* Initialize the TIM state*/
;;;2353     htim->State= HAL_TIM_STATE_READY;
;;;2354     
;;;2355     return HAL_OK;
;;;2356   }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L21.24|
000018  f8940039          LDRB     r0,[r4,#0x39]         ;2299
00001c  b928              CBNZ     r0,|L21.42|
00001e  2000              MOVS     r0,#0                 ;2302
000020  f8840038          STRB     r0,[r4,#0x38]         ;2302
000024  4620              MOV      r0,r4                 ;2304
000026  f7fffffe          BL       HAL_TIM_Encoder_MspInit
                  |L21.42|
00002a  2002              MOVS     r0,#2                 ;2308
00002c  f8840039          STRB     r0,[r4,#0x39]         ;2308
000030  6820              LDR      r0,[r4,#0]            ;2311
000032  6880              LDR      r0,[r0,#8]            ;2311
000034  f0200007          BIC      r0,r0,#7              ;2311
000038  6821              LDR      r1,[r4,#0]            ;2311
00003a  6088              STR      r0,[r1,#8]            ;2311
00003c  1d21              ADDS     r1,r4,#4              ;2314
00003e  6820              LDR      r0,[r4,#0]            ;2314
000040  f7fffffe          BL       TIM_Base_SetConfig
000044  6820              LDR      r0,[r4,#0]            ;2317
000046  f8d08008          LDR      r8,[r0,#8]            ;2317
00004a  6820              LDR      r0,[r4,#0]            ;2320
00004c  6986              LDR      r6,[r0,#0x18]         ;2320
00004e  6820              LDR      r0,[r4,#0]            ;2323
000050  6a07              LDR      r7,[r0,#0x20]         ;2323
000052  6828              LDR      r0,[r5,#0]            ;2326
000054  ea400808          ORR      r8,r0,r8              ;2326
000058  f2403003          MOV      r0,#0x303             ;2329
00005c  4386              BICS     r6,r6,r0              ;2329
00005e  69a9              LDR      r1,[r5,#0x18]         ;2330
000060  68a8              LDR      r0,[r5,#8]            ;2330
000062  ea402001          ORR      r0,r0,r1,LSL #8       ;2330
000066  4306              ORRS     r6,r6,r0              ;2330
000068  f640400c          MOV      r0,#0xc0c             ;2333
00006c  4386              BICS     r6,r6,r0              ;2333
00006e  f24f00f0          MOV      r0,#0xf0f0            ;2334
000072  4386              BICS     r6,r6,r0              ;2334
000074  69e9              LDR      r1,[r5,#0x1c]         ;2335
000076  68e8              LDR      r0,[r5,#0xc]          ;2335
000078  ea402001          ORR      r0,r0,r1,LSL #8       ;2335
00007c  4306              ORRS     r6,r6,r0              ;2335
00007e  6928              LDR      r0,[r5,#0x10]         ;2336
000080  0100              LSLS     r0,r0,#4              ;2336
000082  6a29              LDR      r1,[r5,#0x20]         ;2336
000084  ea403001          ORR      r0,r0,r1,LSL #12      ;2336
000088  4306              ORRS     r6,r6,r0              ;2336
00008a  f0270722          BIC      r7,r7,#0x22           ;2339
00008e  f0270788          BIC      r7,r7,#0x88           ;2340
000092  6969              LDR      r1,[r5,#0x14]         ;2341
000094  6868              LDR      r0,[r5,#4]            ;2341
000096  ea401001          ORR      r0,r0,r1,LSL #4       ;2341
00009a  4307              ORRS     r7,r7,r0              ;2341
00009c  6820              LDR      r0,[r4,#0]            ;2344
00009e  f8c08008          STR      r8,[r0,#8]            ;2344
0000a2  6820              LDR      r0,[r4,#0]            ;2347
0000a4  6186              STR      r6,[r0,#0x18]         ;2347
0000a6  6820              LDR      r0,[r4,#0]            ;2350
0000a8  6207              STR      r7,[r0,#0x20]         ;2350
0000aa  2001              MOVS     r0,#1                 ;2353
0000ac  f8840039          STRB     r0,[r4,#0x39]         ;2353
0000b0  2000              MOVS     r0,#0                 ;2355
0000b2  e7af              B        |L21.20|
;;;2357   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_MspDeInit PROC
;;;2406     */
;;;2407   __weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2408   {
;;;2409     /* Prevent unused argument(s) compilation warning */
;;;2410     UNUSED(htim);
;;;2411     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2412               the HAL_TIM_Encoder_MspDeInit could be implemented in the user file
;;;2413      */
;;;2414   }
;;;2415   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_MspInit PROC
;;;2391     */
;;;2392   __weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2393   {
;;;2394     /* Prevent unused argument(s) compilation warning */
;;;2395     UNUSED(htim);
;;;2396     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2397               the HAL_TIM_Encoder_MspInit could be implemented in the user file
;;;2398      */
;;;2399   }
;;;2400   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Start PROC
;;;2426     */
;;;2427   HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;2428   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2429     /* Check the parameters */
;;;2430     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2431     
;;;2432     /* Enable the encoder interface channels */
;;;2433     switch (Channel)
000006  b115              CBZ      r5,|L24.14|
000008  2d04              CMP      r5,#4
00000a  d10c              BNE      |L24.38|
00000c  e005              B        |L24.26|
                  |L24.14|
;;;2434     {
;;;2435       case TIM_CHANNEL_1:
;;;2436       {
;;;2437         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
00000e  2201              MOVS     r2,#1
000010  2100              MOVS     r1,#0
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       TIM_CCxChannelCmd
;;;2438         break; 
000018  e010              B        |L24.60|
                  |L24.26|
;;;2439       }
;;;2440       case TIM_CHANNEL_2:
;;;2441       { 
;;;2442         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
00001a  2201              MOVS     r2,#1
00001c  2104              MOVS     r1,#4
00001e  6820              LDR      r0,[r4,#0]
000020  f7fffffe          BL       TIM_CCxChannelCmd
;;;2443         break;
000024  e00a              B        |L24.60|
                  |L24.38|
;;;2444       }  
;;;2445       default :
;;;2446       {
;;;2447        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000026  2201              MOVS     r2,#1
000028  2100              MOVS     r1,#0
00002a  6820              LDR      r0,[r4,#0]
00002c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2448        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
000030  2201              MOVS     r2,#1
000032  2104              MOVS     r1,#4
000034  6820              LDR      r0,[r4,#0]
000036  f7fffffe          BL       TIM_CCxChannelCmd
;;;2449        break; 
00003a  bf00              NOP      
                  |L24.60|
00003c  bf00              NOP                            ;2438
;;;2450       }
;;;2451     }  
;;;2452     /* Enable the Peripheral */
;;;2453     __HAL_TIM_ENABLE(htim);
00003e  6820              LDR      r0,[r4,#0]
000040  6800              LDR      r0,[r0,#0]
000042  f0400001          ORR      r0,r0,#1
000046  6821              LDR      r1,[r4,#0]
000048  6008              STR      r0,[r1,#0]
;;;2454     
;;;2455     /* Return function status */
;;;2456     return HAL_OK;
00004a  2000              MOVS     r0,#0
;;;2457   }
00004c  bd30              POP      {r4,r5,pc}
;;;2458   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Encoder_Start_DMA PROC
;;;2617     */
;;;2618   HAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1, uint32_t *pData2, uint16_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2619   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
00000c  f8dd8018          LDR      r8,[sp,#0x18]
;;;2620     /* Check the parameters */
;;;2621     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;2622     
;;;2623     if((htim->State == HAL_TIM_STATE_BUSY))
000010  f8940039          LDRB     r0,[r4,#0x39]
000014  2802              CMP      r0,#2
000016  d101              BNE      |L25.28|
                  |L25.24|
;;;2624     {
;;;2625        return HAL_BUSY;
;;;2626     }
;;;2627     else if((htim->State == HAL_TIM_STATE_READY))
;;;2628     {
;;;2629       if((((pData1 == 0) || (pData2 == 0) )) && (Length > 0)) 
;;;2630       {
;;;2631         return HAL_ERROR;                                    
;;;2632       }
;;;2633       else
;;;2634       {
;;;2635         htim->State = HAL_TIM_STATE_BUSY;
;;;2636       }
;;;2637     }  
;;;2638      
;;;2639     switch (Channel)
;;;2640     {
;;;2641       case TIM_CHANNEL_1:
;;;2642       {
;;;2643         /* Set the DMA Period elapsed callback */
;;;2644         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2645        
;;;2646         /* Set the DMA error callback */
;;;2647         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;2648         
;;;2649         /* Enable the DMA Stream */
;;;2650         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t )pData1, Length); 
;;;2651         
;;;2652         /* Enable the TIM Input Capture DMA request */      
;;;2653         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;2654               
;;;2655         /* Enable the Peripheral */
;;;2656         __HAL_TIM_ENABLE(htim);
;;;2657         
;;;2658         /* Enable the Capture compare channel */
;;;2659         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2660       }
;;;2661       break;
;;;2662       
;;;2663       case TIM_CHANNEL_2:
;;;2664       {
;;;2665         /* Set the DMA Period elapsed callback */
;;;2666         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2667        
;;;2668         /* Set the DMA error callback */
;;;2669         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError;
;;;2670         /* Enable the DMA Stream */
;;;2671         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
;;;2672         
;;;2673         /* Enable the TIM Input Capture  DMA request */
;;;2674         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;2675        
;;;2676         /* Enable the Peripheral */
;;;2677         __HAL_TIM_ENABLE(htim);
;;;2678         
;;;2679         /* Enable the Capture compare channel */
;;;2680         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2681       }
;;;2682       break;
;;;2683       
;;;2684       case TIM_CHANNEL_ALL:
;;;2685       {
;;;2686         /* Set the DMA Period elapsed callback */
;;;2687         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2688        
;;;2689         /* Set the DMA error callback */
;;;2690         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;2691         
;;;2692         /* Enable the DMA Stream */
;;;2693         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length);
;;;2694         
;;;2695         /* Set the DMA Period elapsed callback */
;;;2696         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2697        
;;;2698         /* Set the DMA error callback */
;;;2699         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;2700         
;;;2701         /* Enable the DMA Stream */
;;;2702         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
;;;2703             
;;;2704        /* Enable the Peripheral */
;;;2705         __HAL_TIM_ENABLE(htim);
;;;2706         
;;;2707         /* Enable the Capture compare channel */
;;;2708         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2709         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2710         
;;;2711         /* Enable the TIM Input Capture  DMA request */
;;;2712         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;2713         /* Enable the TIM Input Capture  DMA request */
;;;2714         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;2715       }
;;;2716       break;
;;;2717       
;;;2718       default:
;;;2719       break;
;;;2720     }  
;;;2721     /* Return function status */
;;;2722     return HAL_OK;
;;;2723   }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L25.28|
00001c  f8940039          LDRB     r0,[r4,#0x39]         ;2627
000020  2801              CMP      r0,#1                 ;2627
000022  d109              BNE      |L25.56|
000024  b107              CBZ      r7,|L25.40|
000026  b925              CBNZ     r5,|L25.50|
                  |L25.40|
000028  f1b80f00          CMP      r8,#0                 ;2629
00002c  dd01              BLE      |L25.50|
00002e  2001              MOVS     r0,#1                 ;2631
000030  e7f2              B        |L25.24|
                  |L25.50|
000032  2002              MOVS     r0,#2                 ;2635
000034  f8840039          STRB     r0,[r4,#0x39]         ;2635
                  |L25.56|
000038  b126              CBZ      r6,|L25.68|
00003a  2e04              CMP      r6,#4                 ;2639
00003c  d022              BEQ      |L25.132|
00003e  2e18              CMP      r6,#0x18              ;2639
000040  d17a              BNE      |L25.312|
000042  e03f              B        |L25.196|
                  |L25.68|
000044  493e              LDR      r1,|L25.320|
000046  6a20              LDR      r0,[r4,#0x20]         ;2644
000048  63c1              STR      r1,[r0,#0x3c]         ;2644
00004a  493e              LDR      r1,|L25.324|
00004c  6a20              LDR      r0,[r4,#0x20]         ;2647
00004e  6481              STR      r1,[r0,#0x48]         ;2647
000050  6822              LDR      r2,[r4,#0]            ;2650
000052  f1020134          ADD      r1,r2,#0x34           ;2650
000056  4643              MOV      r3,r8                 ;2650
000058  463a              MOV      r2,r7                 ;2650
00005a  6a20              LDR      r0,[r4,#0x20]         ;2650
00005c  f7fffffe          BL       HAL_DMA_Start_IT
000060  6820              LDR      r0,[r4,#0]            ;2653
000062  68c0              LDR      r0,[r0,#0xc]          ;2653
000064  f4407000          ORR      r0,r0,#0x200          ;2653
000068  6821              LDR      r1,[r4,#0]            ;2653
00006a  60c8              STR      r0,[r1,#0xc]          ;2653
00006c  6820              LDR      r0,[r4,#0]            ;2656
00006e  6800              LDR      r0,[r0,#0]            ;2656
000070  f0400001          ORR      r0,r0,#1              ;2656
000074  6821              LDR      r1,[r4,#0]            ;2656
000076  6008              STR      r0,[r1,#0]            ;2656
000078  2201              MOVS     r2,#1                 ;2659
00007a  2100              MOVS     r1,#0                 ;2659
00007c  6820              LDR      r0,[r4,#0]            ;2659
00007e  f7fffffe          BL       TIM_CCxChannelCmd
000082  e05a              B        |L25.314|
                  |L25.132|
000084  492e              LDR      r1,|L25.320|
000086  6a60              LDR      r0,[r4,#0x24]         ;2666
000088  63c1              STR      r1,[r0,#0x3c]         ;2666
00008a  492e              LDR      r1,|L25.324|
00008c  6a60              LDR      r0,[r4,#0x24]         ;2669
00008e  6481              STR      r1,[r0,#0x48]         ;2669
000090  6822              LDR      r2,[r4,#0]            ;2671
000092  f1020138          ADD      r1,r2,#0x38           ;2671
000096  4643              MOV      r3,r8                 ;2671
000098  462a              MOV      r2,r5                 ;2671
00009a  6a60              LDR      r0,[r4,#0x24]         ;2671
00009c  f7fffffe          BL       HAL_DMA_Start_IT
0000a0  6820              LDR      r0,[r4,#0]            ;2674
0000a2  68c0              LDR      r0,[r0,#0xc]          ;2674
0000a4  f4406080          ORR      r0,r0,#0x400          ;2674
0000a8  6821              LDR      r1,[r4,#0]            ;2674
0000aa  60c8              STR      r0,[r1,#0xc]          ;2674
0000ac  6820              LDR      r0,[r4,#0]            ;2677
0000ae  6800              LDR      r0,[r0,#0]            ;2677
0000b0  f0400001          ORR      r0,r0,#1              ;2677
0000b4  6821              LDR      r1,[r4,#0]            ;2677
0000b6  6008              STR      r0,[r1,#0]            ;2677
0000b8  2201              MOVS     r2,#1                 ;2680
0000ba  2104              MOVS     r1,#4                 ;2680
0000bc  6820              LDR      r0,[r4,#0]            ;2680
0000be  f7fffffe          BL       TIM_CCxChannelCmd
0000c2  e03a              B        |L25.314|
                  |L25.196|
0000c4  491e              LDR      r1,|L25.320|
0000c6  6a20              LDR      r0,[r4,#0x20]         ;2687
0000c8  63c1              STR      r1,[r0,#0x3c]         ;2687
0000ca  491e              LDR      r1,|L25.324|
0000cc  6a20              LDR      r0,[r4,#0x20]         ;2690
0000ce  6481              STR      r1,[r0,#0x48]         ;2690
0000d0  6822              LDR      r2,[r4,#0]            ;2693
0000d2  f1020134          ADD      r1,r2,#0x34           ;2693
0000d6  4643              MOV      r3,r8                 ;2693
0000d8  463a              MOV      r2,r7                 ;2693
0000da  6a20              LDR      r0,[r4,#0x20]         ;2693
0000dc  f7fffffe          BL       HAL_DMA_Start_IT
0000e0  4917              LDR      r1,|L25.320|
0000e2  6a60              LDR      r0,[r4,#0x24]         ;2696
0000e4  63c1              STR      r1,[r0,#0x3c]         ;2696
0000e6  4917              LDR      r1,|L25.324|
0000e8  6a60              LDR      r0,[r4,#0x24]         ;2699
0000ea  6481              STR      r1,[r0,#0x48]         ;2699
0000ec  6822              LDR      r2,[r4,#0]            ;2702
0000ee  f1020138          ADD      r1,r2,#0x38           ;2702
0000f2  4643              MOV      r3,r8                 ;2702
0000f4  462a              MOV      r2,r5                 ;2702
0000f6  6a60              LDR      r0,[r4,#0x24]         ;2702
0000f8  f7fffffe          BL       HAL_DMA_Start_IT
0000fc  6820              LDR      r0,[r4,#0]            ;2705
0000fe  6800              LDR      r0,[r0,#0]            ;2705
000100  f0400001          ORR      r0,r0,#1              ;2705
000104  6821              LDR      r1,[r4,#0]            ;2705
000106  6008              STR      r0,[r1,#0]            ;2705
000108  2201              MOVS     r2,#1                 ;2708
00010a  2100              MOVS     r1,#0                 ;2708
00010c  6820              LDR      r0,[r4,#0]            ;2708
00010e  f7fffffe          BL       TIM_CCxChannelCmd
000112  2201              MOVS     r2,#1                 ;2709
000114  2104              MOVS     r1,#4                 ;2709
000116  6820              LDR      r0,[r4,#0]            ;2709
000118  f7fffffe          BL       TIM_CCxChannelCmd
00011c  6820              LDR      r0,[r4,#0]            ;2712
00011e  68c0              LDR      r0,[r0,#0xc]          ;2712
000120  f4407000          ORR      r0,r0,#0x200          ;2712
000124  6821              LDR      r1,[r4,#0]            ;2712
000126  60c8              STR      r0,[r1,#0xc]          ;2712
000128  6820              LDR      r0,[r4,#0]            ;2714
00012a  68c0              LDR      r0,[r0,#0xc]          ;2714
00012c  f4406080          ORR      r0,r0,#0x400          ;2714
000130  6821              LDR      r1,[r4,#0]            ;2714
000132  60c8              STR      r0,[r1,#0xc]          ;2714
000134  e001              B        |L25.314|
000136  e7ff              B        |L25.312|
                  |L25.312|
000138  bf00              NOP                            ;2719
                  |L25.314|
00013a  bf00              NOP                            ;2661
00013c  2000              MOVS     r0,#0                 ;2722
00013e  e76b              B        |L25.24|
;;;2724   
                          ENDP

                  |L25.320|
                          DCD      TIM_DMACaptureCplt
                  |L25.324|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_Encoder_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Start_IT PROC
;;;2513     */
;;;2514   HAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;2515   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2516     /* Check the parameters */
;;;2517     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2518     
;;;2519     /* Enable the encoder interface channels */
;;;2520     /* Enable the capture compare Interrupts 1 and/or 2 */
;;;2521     switch (Channel)
000006  b115              CBZ      r5,|L26.14|
000008  2d04              CMP      r5,#4
00000a  d118              BNE      |L26.62|
00000c  e00b              B        |L26.38|
                  |L26.14|
;;;2522     {
;;;2523       case TIM_CHANNEL_1:
;;;2524       {
;;;2525         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
00000e  2201              MOVS     r2,#1
000010  2100              MOVS     r1,#0
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       TIM_CCxChannelCmd
;;;2526         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000018  6820              LDR      r0,[r4,#0]
00001a  68c0              LDR      r0,[r0,#0xc]
00001c  f0400002          ORR      r0,r0,#2
000020  6821              LDR      r1,[r4,#0]
000022  60c8              STR      r0,[r1,#0xc]
;;;2527         break; 
000024  e022              B        |L26.108|
                  |L26.38|
;;;2528       }
;;;2529       case TIM_CHANNEL_2:
;;;2530       { 
;;;2531         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
000026  2201              MOVS     r2,#1
000028  2104              MOVS     r1,#4
00002a  6820              LDR      r0,[r4,#0]
00002c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2532         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2); 
000030  6820              LDR      r0,[r4,#0]
000032  68c0              LDR      r0,[r0,#0xc]
000034  f0400004          ORR      r0,r0,#4
000038  6821              LDR      r1,[r4,#0]
00003a  60c8              STR      r0,[r1,#0xc]
;;;2533         break;
00003c  e016              B        |L26.108|
                  |L26.62|
;;;2534       }  
;;;2535       default :
;;;2536       {
;;;2537        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
00003e  2201              MOVS     r2,#1
000040  2100              MOVS     r1,#0
000042  6820              LDR      r0,[r4,#0]
000044  f7fffffe          BL       TIM_CCxChannelCmd
;;;2538        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
000048  2201              MOVS     r2,#1
00004a  2104              MOVS     r1,#4
00004c  6820              LDR      r0,[r4,#0]
00004e  f7fffffe          BL       TIM_CCxChannelCmd
;;;2539        __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000052  6820              LDR      r0,[r4,#0]
000054  68c0              LDR      r0,[r0,#0xc]
000056  f0400002          ORR      r0,r0,#2
00005a  6821              LDR      r1,[r4,#0]
00005c  60c8              STR      r0,[r1,#0xc]
;;;2540        __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00005e  6820              LDR      r0,[r4,#0]
000060  68c0              LDR      r0,[r0,#0xc]
000062  f0400004          ORR      r0,r0,#4
000066  6821              LDR      r1,[r4,#0]
000068  60c8              STR      r0,[r1,#0xc]
;;;2541        break; 
00006a  bf00              NOP      
                  |L26.108|
00006c  bf00              NOP                            ;2527
;;;2542       }
;;;2543     }
;;;2544     
;;;2545     /* Enable the Peripheral */
;;;2546     __HAL_TIM_ENABLE(htim);
00006e  6820              LDR      r0,[r4,#0]
000070  6800              LDR      r0,[r0,#0]
000072  f0400001          ORR      r0,r0,#1
000076  6821              LDR      r1,[r4,#0]
000078  6008              STR      r0,[r1,#0]
;;;2547     
;;;2548     /* Return function status */
;;;2549     return HAL_OK;
00007a  2000              MOVS     r0,#0
;;;2550   }
00007c  bd30              POP      {r4,r5,pc}
;;;2551   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Stop PROC
;;;2469     */
;;;2470   HAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;2471   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2472     /* Check the parameters */
;;;2473       assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2474       
;;;2475      /* Disable the Input Capture channels 1 and 2
;;;2476       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
;;;2477     switch (Channel)
000006  b115              CBZ      r5,|L27.14|
000008  2d04              CMP      r5,#4
00000a  d10c              BNE      |L27.38|
00000c  e005              B        |L27.26|
                  |L27.14|
;;;2478     {
;;;2479       case TIM_CHANNEL_1:
;;;2480       {
;;;2481         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
00000e  2200              MOVS     r2,#0
000010  4611              MOV      r1,r2
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       TIM_CCxChannelCmd
;;;2482         break; 
000018  e010              B        |L27.60|
                  |L27.26|
;;;2483       }
;;;2484       case TIM_CHANNEL_2:
;;;2485       { 
;;;2486         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
00001a  2200              MOVS     r2,#0
00001c  2104              MOVS     r1,#4
00001e  6820              LDR      r0,[r4,#0]
000020  f7fffffe          BL       TIM_CCxChannelCmd
;;;2487         break;
000024  e00a              B        |L27.60|
                  |L27.38|
;;;2488       }  
;;;2489       default :
;;;2490       {
;;;2491        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000026  2200              MOVS     r2,#0
000028  4611              MOV      r1,r2
00002a  6820              LDR      r0,[r4,#0]
00002c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2492        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
000030  2200              MOVS     r2,#0
000032  2104              MOVS     r1,#4
000034  6820              LDR      r0,[r4,#0]
000036  f7fffffe          BL       TIM_CCxChannelCmd
;;;2493        break; 
00003a  bf00              NOP      
                  |L27.60|
00003c  bf00              NOP                            ;2482
;;;2494       }
;;;2495     }  
;;;2496     /* Disable the Peripheral */
;;;2497     __HAL_TIM_DISABLE(htim);
00003e  bf00              NOP      
000040  6820              LDR      r0,[r4,#0]
000042  6a00              LDR      r0,[r0,#0x20]
000044  f2411111          MOV      r1,#0x1111
000048  4008              ANDS     r0,r0,r1
00004a  b950              CBNZ     r0,|L27.98|
00004c  6820              LDR      r0,[r4,#0]
00004e  6a00              LDR      r0,[r0,#0x20]
000050  1089              ASRS     r1,r1,#2
000052  4008              ANDS     r0,r0,r1
000054  b928              CBNZ     r0,|L27.98|
000056  6820              LDR      r0,[r4,#0]
000058  6800              LDR      r0,[r0,#0]
00005a  f0200001          BIC      r0,r0,#1
00005e  6821              LDR      r1,[r4,#0]
000060  6008              STR      r0,[r1,#0]
                  |L27.98|
000062  bf00              NOP      
;;;2498     
;;;2499     /* Return function status */
;;;2500     return HAL_OK;
000064  2000              MOVS     r0,#0
;;;2501   }
000066  bd30              POP      {r4,r5,pc}
;;;2502   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Stop_DMA PROC
;;;2735     */
;;;2736   HAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;2737   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2738     /* Check the parameters */
;;;2739     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;2740     
;;;2741     /* Disable the Input Capture channels 1 and 2
;;;2742       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
;;;2743     if(Channel == TIM_CHANNEL_1)
000006  b95d              CBNZ     r5,|L28.32|
;;;2744     {
;;;2745       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
000008  2200              MOVS     r2,#0
00000a  4611              MOV      r1,r2
00000c  6820              LDR      r0,[r4,#0]
00000e  f7fffffe          BL       TIM_CCxChannelCmd
;;;2746       
;;;2747       /* Disable the capture compare DMA Request 1 */
;;;2748       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000012  6820              LDR      r0,[r4,#0]
000014  68c0              LDR      r0,[r0,#0xc]
000016  f4207000          BIC      r0,r0,#0x200
00001a  6821              LDR      r1,[r4,#0]
00001c  60c8              STR      r0,[r1,#0xc]
00001e  e023              B        |L28.104|
                  |L28.32|
;;;2749     }  
;;;2750     else if(Channel == TIM_CHANNEL_2)
000020  2d04              CMP      r5,#4
000022  d10b              BNE      |L28.60|
;;;2751     {  
;;;2752       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
000024  2200              MOVS     r2,#0
000026  2104              MOVS     r1,#4
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;2753       
;;;2754       /* Disable the capture compare DMA Request 2 */
;;;2755       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
00002e  6820              LDR      r0,[r4,#0]
000030  68c0              LDR      r0,[r0,#0xc]
000032  f4206080          BIC      r0,r0,#0x400
000036  6821              LDR      r1,[r4,#0]
000038  60c8              STR      r0,[r1,#0xc]
00003a  e015              B        |L28.104|
                  |L28.60|
;;;2756     }  
;;;2757     else
;;;2758     {
;;;2759       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
00003c  2200              MOVS     r2,#0
00003e  4611              MOV      r1,r2
000040  6820              LDR      r0,[r4,#0]
000042  f7fffffe          BL       TIM_CCxChannelCmd
;;;2760       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
000046  2200              MOVS     r2,#0
000048  2104              MOVS     r1,#4
00004a  6820              LDR      r0,[r4,#0]
00004c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2761       
;;;2762       /* Disable the capture compare DMA Request 1 and 2 */
;;;2763       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000050  6820              LDR      r0,[r4,#0]
000052  68c0              LDR      r0,[r0,#0xc]
000054  f4207000          BIC      r0,r0,#0x200
000058  6821              LDR      r1,[r4,#0]
00005a  60c8              STR      r0,[r1,#0xc]
;;;2764       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
00005c  6820              LDR      r0,[r4,#0]
00005e  68c0              LDR      r0,[r0,#0xc]
000060  f4206080          BIC      r0,r0,#0x400
000064  6821              LDR      r1,[r4,#0]
000066  60c8              STR      r0,[r1,#0xc]
                  |L28.104|
;;;2765     }
;;;2766     
;;;2767     /* Disable the Peripheral */
;;;2768     __HAL_TIM_DISABLE(htim);
000068  bf00              NOP      
00006a  6820              LDR      r0,[r4,#0]
00006c  6a00              LDR      r0,[r0,#0x20]
00006e  f2411111          MOV      r1,#0x1111
000072  4008              ANDS     r0,r0,r1
000074  b950              CBNZ     r0,|L28.140|
000076  6820              LDR      r0,[r4,#0]
000078  6a00              LDR      r0,[r0,#0x20]
00007a  1089              ASRS     r1,r1,#2
00007c  4008              ANDS     r0,r0,r1
00007e  b928              CBNZ     r0,|L28.140|
000080  6820              LDR      r0,[r4,#0]
000082  6800              LDR      r0,[r0,#0]
000084  f0200001          BIC      r0,r0,#1
000088  6821              LDR      r1,[r4,#0]
00008a  6008              STR      r0,[r1,#0]
                  |L28.140|
00008c  bf00              NOP      
;;;2769     
;;;2770     /* Change the htim state */
;;;2771     htim->State = HAL_TIM_STATE_READY;
00008e  2001              MOVS     r0,#1
000090  f8840039          STRB     r0,[r4,#0x39]
;;;2772     
;;;2773     /* Return function status */
;;;2774     return HAL_OK;
000094  2000              MOVS     r0,#0
;;;2775   }
000096  bd30              POP      {r4,r5,pc}
;;;2776   /**
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Stop_IT PROC
;;;2562     */
;;;2563   HAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;2564   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2565     /* Check the parameters */
;;;2566     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2567       
;;;2568     /* Disable the Input Capture channels 1 and 2
;;;2569       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
;;;2570     if(Channel == TIM_CHANNEL_1)
000006  b95d              CBNZ     r5,|L29.32|
;;;2571     {
;;;2572       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
000008  2200              MOVS     r2,#0
00000a  4611              MOV      r1,r2
00000c  6820              LDR      r0,[r4,#0]
00000e  f7fffffe          BL       TIM_CCxChannelCmd
;;;2573       
;;;2574       /* Disable the capture compare Interrupts 1 */
;;;2575     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000012  6820              LDR      r0,[r4,#0]
000014  68c0              LDR      r0,[r0,#0xc]
000016  f0200002          BIC      r0,r0,#2
00001a  6821              LDR      r1,[r4,#0]
00001c  60c8              STR      r0,[r1,#0xc]
00001e  e023              B        |L29.104|
                  |L29.32|
;;;2576     }  
;;;2577     else if(Channel == TIM_CHANNEL_2)
000020  2d04              CMP      r5,#4
000022  d10b              BNE      |L29.60|
;;;2578     {  
;;;2579       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
000024  2200              MOVS     r2,#0
000026  2104              MOVS     r1,#4
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;2580       
;;;2581       /* Disable the capture compare Interrupts 2 */
;;;2582     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00002e  6820              LDR      r0,[r4,#0]
000030  68c0              LDR      r0,[r0,#0xc]
000032  f0200004          BIC      r0,r0,#4
000036  6821              LDR      r1,[r4,#0]
000038  60c8              STR      r0,[r1,#0xc]
00003a  e015              B        |L29.104|
                  |L29.60|
;;;2583     }  
;;;2584     else
;;;2585     {
;;;2586       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
00003c  2200              MOVS     r2,#0
00003e  4611              MOV      r1,r2
000040  6820              LDR      r0,[r4,#0]
000042  f7fffffe          BL       TIM_CCxChannelCmd
;;;2587       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
000046  2200              MOVS     r2,#0
000048  2104              MOVS     r1,#4
00004a  6820              LDR      r0,[r4,#0]
00004c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2588       
;;;2589       /* Disable the capture compare Interrupts 1 and 2 */
;;;2590       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000050  6820              LDR      r0,[r4,#0]
000052  68c0              LDR      r0,[r0,#0xc]
000054  f0200002          BIC      r0,r0,#2
000058  6821              LDR      r1,[r4,#0]
00005a  60c8              STR      r0,[r1,#0xc]
;;;2591       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00005c  6820              LDR      r0,[r4,#0]
00005e  68c0              LDR      r0,[r0,#0xc]
000060  f0200004          BIC      r0,r0,#4
000064  6821              LDR      r1,[r4,#0]
000066  60c8              STR      r0,[r1,#0xc]
                  |L29.104|
;;;2592     }
;;;2593       
;;;2594     /* Disable the Peripheral */
;;;2595     __HAL_TIM_DISABLE(htim);
000068  bf00              NOP      
00006a  6820              LDR      r0,[r4,#0]
00006c  6a00              LDR      r0,[r0,#0x20]
00006e  f2411111          MOV      r1,#0x1111
000072  4008              ANDS     r0,r0,r1
000074  b950              CBNZ     r0,|L29.140|
000076  6820              LDR      r0,[r4,#0]
000078  6a00              LDR      r0,[r0,#0x20]
00007a  1089              ASRS     r1,r1,#2
00007c  4008              ANDS     r0,r0,r1
00007e  b928              CBNZ     r0,|L29.140|
000080  6820              LDR      r0,[r4,#0]
000082  6800              LDR      r0,[r0,#0]
000084  f0200001          BIC      r0,r0,#1
000088  6821              LDR      r1,[r4,#0]
00008a  6008              STR      r0,[r1,#0]
                  |L29.140|
00008c  bf00              NOP      
;;;2596     
;;;2597     /* Change the htim state */
;;;2598     htim->State = HAL_TIM_STATE_READY;
00008e  2001              MOVS     r0,#1
000090  f8840039          STRB     r0,[r4,#0x39]
;;;2599     
;;;2600     /* Return function status */
;;;2601     return HAL_OK;
000094  2000              MOVS     r0,#0
;;;2602   }
000096  bd30              POP      {r4,r5,pc}
;;;2603   
                          ENDP


                          AREA ||i.HAL_TIM_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ErrorCallback PROC
;;;4368     */
;;;4369   __weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4370   {
;;;4371     /* Prevent unused argument(s) compilation warning */
;;;4372     UNUSED(htim);
;;;4373     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4374               the HAL_TIM_ErrorCallback could be implemented in the user file
;;;4375      */
;;;4376   }
;;;4377   /**
                          ENDP


                          AREA ||i.HAL_TIM_GenerateEvent||, CODE, READONLY, ALIGN=1

                  HAL_TIM_GenerateEvent PROC
;;;3797   
;;;3798   HAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource)
000000  4602              MOV      r2,r0
;;;3799   {
;;;3800     /* Check the parameters */
;;;3801     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;3802     assert_param(IS_TIM_EVENT_SOURCE(EventSource));
;;;3803     
;;;3804     /* Process Locked */
;;;3805     __HAL_LOCK(htim);
000002  bf00              NOP      
000004  f8920038          LDRB     r0,[r2,#0x38]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L31.16|
00000c  2002              MOVS     r0,#2
                  |L31.14|
;;;3806     
;;;3807     /* Change the TIM state */
;;;3808     htim->State = HAL_TIM_STATE_BUSY;
;;;3809     
;;;3810     /* Set the event sources */
;;;3811     htim->Instance->EGR = EventSource;
;;;3812     
;;;3813     /* Change the TIM state */
;;;3814     htim->State = HAL_TIM_STATE_READY;
;;;3815     
;;;3816     __HAL_UNLOCK(htim);
;;;3817     
;;;3818     /* Return function status */
;;;3819     return HAL_OK;  
;;;3820   }
00000e  4770              BX       lr
                  |L31.16|
000010  2001              MOVS     r0,#1                 ;3805
000012  f8820038          STRB     r0,[r2,#0x38]         ;3805
000016  bf00              NOP                            ;3805
000018  2002              MOVS     r0,#2                 ;3808
00001a  f8820039          STRB     r0,[r2,#0x39]         ;3808
00001e  6810              LDR      r0,[r2,#0]            ;3811
000020  6141              STR      r1,[r0,#0x14]         ;3811
000022  2001              MOVS     r0,#1                 ;3814
000024  f8820039          STRB     r0,[r2,#0x39]         ;3814
000028  bf00              NOP                            ;3816
00002a  2000              MOVS     r0,#0                 ;3816
00002c  f8820038          STRB     r0,[r2,#0x38]         ;3816
000030  bf00              NOP                            ;3816
000032  bf00              NOP                            ;3819
000034  e7eb              B        |L31.14|
;;;3821   
                          ENDP


                          AREA ||i.HAL_TIM_IC_CaptureCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_CaptureCallback PROC
;;;4323     */
;;;4324   __weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4325   {
;;;4326     /* Prevent unused argument(s) compilation warning */
;;;4327     UNUSED(htim);
;;;4328     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4329               the __HAL_TIM_IC_CaptureCallback could be implemented in the user file
;;;4330      */
;;;4331   }
;;;4332   
                          ENDP


                          AREA ||i.HAL_TIM_IC_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_ConfigChannel PROC
;;;3031     */
;;;3032   HAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef* sConfig, uint32_t Channel)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3033   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;3034     /* Check the parameters */
;;;3035     assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3036     assert_param(IS_TIM_IC_POLARITY(sConfig->ICPolarity));
;;;3037     assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));
;;;3038     assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));
;;;3039     assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));
;;;3040     
;;;3041     __HAL_LOCK(htim);
00000a  bf00              NOP      
00000c  f8940038          LDRB     r0,[r4,#0x38]
000010  2801              CMP      r0,#1
000012  d102              BNE      |L33.26|
000014  2002              MOVS     r0,#2
                  |L33.22|
;;;3042     
;;;3043     htim->State = HAL_TIM_STATE_BUSY;
;;;3044     
;;;3045     if (Channel == TIM_CHANNEL_1)
;;;3046     {
;;;3047       /* TI1 Configuration */
;;;3048       TIM_TI1_SetConfig(htim->Instance,
;;;3049                  sConfig->ICPolarity,
;;;3050                  sConfig->ICSelection,
;;;3051                  sConfig->ICFilter);
;;;3052                  
;;;3053       /* Reset the IC1PSC Bits */
;;;3054       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;3055   
;;;3056       /* Set the IC1PSC value */
;;;3057       htim->Instance->CCMR1 |= sConfig->ICPrescaler;
;;;3058     }
;;;3059     else if (Channel == TIM_CHANNEL_2)
;;;3060     {
;;;3061       /* TI2 Configuration */
;;;3062       assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3063       
;;;3064       TIM_TI2_SetConfig(htim->Instance, 
;;;3065                         sConfig->ICPolarity,
;;;3066                         sConfig->ICSelection,
;;;3067                         sConfig->ICFilter);
;;;3068                  
;;;3069       /* Reset the IC2PSC Bits */
;;;3070       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
;;;3071   
;;;3072       /* Set the IC2PSC value */
;;;3073       htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8);
;;;3074     }
;;;3075     else if (Channel == TIM_CHANNEL_3)
;;;3076     {
;;;3077       /* TI3 Configuration */
;;;3078       assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3079       
;;;3080       TIM_TI3_SetConfig(htim->Instance,  
;;;3081                  sConfig->ICPolarity,
;;;3082                  sConfig->ICSelection,
;;;3083                  sConfig->ICFilter);
;;;3084                  
;;;3085       /* Reset the IC3PSC Bits */
;;;3086       htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
;;;3087   
;;;3088       /* Set the IC3PSC value */
;;;3089       htim->Instance->CCMR2 |= sConfig->ICPrescaler;
;;;3090     }
;;;3091     else
;;;3092     {
;;;3093       /* TI4 Configuration */
;;;3094       assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3095       
;;;3096       TIM_TI4_SetConfig(htim->Instance, 
;;;3097                  sConfig->ICPolarity,
;;;3098                  sConfig->ICSelection,
;;;3099                  sConfig->ICFilter);
;;;3100                  
;;;3101       /* Reset the IC4PSC Bits */
;;;3102       htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
;;;3103   
;;;3104       /* Set the IC4PSC value */
;;;3105       htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8);
;;;3106     }
;;;3107     
;;;3108     htim->State = HAL_TIM_STATE_READY;
;;;3109       
;;;3110     __HAL_UNLOCK(htim);
;;;3111     
;;;3112     return HAL_OK; 
;;;3113   }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L33.26|
00001a  2001              MOVS     r0,#1                 ;3041
00001c  f8840038          STRB     r0,[r4,#0x38]         ;3041
000020  bf00              NOP                            ;3041
000022  2002              MOVS     r0,#2                 ;3043
000024  f8840039          STRB     r0,[r4,#0x39]         ;3043
000028  b996              CBNZ     r6,|L33.80|
00002a  68eb              LDR      r3,[r5,#0xc]          ;3048
00002c  e9d51200          LDRD     r1,r2,[r5,#0]         ;3048
000030  6820              LDR      r0,[r4,#0]            ;3048
000032  f7fffffe          BL       TIM_TI1_SetConfig
000036  6820              LDR      r0,[r4,#0]            ;3054
000038  6980              LDR      r0,[r0,#0x18]         ;3054
00003a  f020000c          BIC      r0,r0,#0xc            ;3054
00003e  6821              LDR      r1,[r4,#0]            ;3054
000040  6188              STR      r0,[r1,#0x18]         ;3054
000042  6820              LDR      r0,[r4,#0]            ;3057
000044  6980              LDR      r0,[r0,#0x18]         ;3057
000046  68a9              LDR      r1,[r5,#8]            ;3057
000048  4308              ORRS     r0,r0,r1              ;3057
00004a  6821              LDR      r1,[r4,#0]            ;3057
00004c  6188              STR      r0,[r1,#0x18]         ;3057
00004e  e03d              B        |L33.204|
                  |L33.80|
000050  2e04              CMP      r6,#4                 ;3059
000052  d113              BNE      |L33.124|
000054  68eb              LDR      r3,[r5,#0xc]          ;3064
000056  e9d51200          LDRD     r1,r2,[r5,#0]         ;3064
00005a  6820              LDR      r0,[r4,#0]            ;3064
00005c  f7fffffe          BL       TIM_TI2_SetConfig
000060  6820              LDR      r0,[r4,#0]            ;3070
000062  6980              LDR      r0,[r0,#0x18]         ;3070
000064  f4206040          BIC      r0,r0,#0xc00          ;3070
000068  6821              LDR      r1,[r4,#0]            ;3070
00006a  6188              STR      r0,[r1,#0x18]         ;3070
00006c  6820              LDR      r0,[r4,#0]            ;3073
00006e  6980              LDR      r0,[r0,#0x18]         ;3073
000070  68a9              LDR      r1,[r5,#8]            ;3073
000072  ea402001          ORR      r0,r0,r1,LSL #8       ;3073
000076  6821              LDR      r1,[r4,#0]            ;3073
000078  6188              STR      r0,[r1,#0x18]         ;3073
00007a  e027              B        |L33.204|
                  |L33.124|
00007c  2e08              CMP      r6,#8                 ;3075
00007e  d112              BNE      |L33.166|
000080  68eb              LDR      r3,[r5,#0xc]          ;3080
000082  e9d51200          LDRD     r1,r2,[r5,#0]         ;3080
000086  6820              LDR      r0,[r4,#0]            ;3080
000088  f7fffffe          BL       TIM_TI3_SetConfig
00008c  6820              LDR      r0,[r4,#0]            ;3086
00008e  69c0              LDR      r0,[r0,#0x1c]         ;3086
000090  f020000c          BIC      r0,r0,#0xc            ;3086
000094  6821              LDR      r1,[r4,#0]            ;3086
000096  61c8              STR      r0,[r1,#0x1c]         ;3086
000098  6820              LDR      r0,[r4,#0]            ;3089
00009a  69c0              LDR      r0,[r0,#0x1c]         ;3089
00009c  68a9              LDR      r1,[r5,#8]            ;3089
00009e  4308              ORRS     r0,r0,r1              ;3089
0000a0  6821              LDR      r1,[r4,#0]            ;3089
0000a2  61c8              STR      r0,[r1,#0x1c]         ;3089
0000a4  e012              B        |L33.204|
                  |L33.166|
0000a6  68eb              LDR      r3,[r5,#0xc]          ;3096
0000a8  e9d51200          LDRD     r1,r2,[r5,#0]         ;3096
0000ac  6820              LDR      r0,[r4,#0]            ;3096
0000ae  f7fffffe          BL       TIM_TI4_SetConfig
0000b2  6820              LDR      r0,[r4,#0]            ;3102
0000b4  69c0              LDR      r0,[r0,#0x1c]         ;3102
0000b6  f4206040          BIC      r0,r0,#0xc00          ;3102
0000ba  6821              LDR      r1,[r4,#0]            ;3102
0000bc  61c8              STR      r0,[r1,#0x1c]         ;3102
0000be  6820              LDR      r0,[r4,#0]            ;3105
0000c0  69c0              LDR      r0,[r0,#0x1c]         ;3105
0000c2  68a9              LDR      r1,[r5,#8]            ;3105
0000c4  ea402001          ORR      r0,r0,r1,LSL #8       ;3105
0000c8  6821              LDR      r1,[r4,#0]            ;3105
0000ca  61c8              STR      r0,[r1,#0x1c]         ;3105
                  |L33.204|
0000cc  2001              MOVS     r0,#1                 ;3108
0000ce  f8840039          STRB     r0,[r4,#0x39]         ;3108
0000d2  bf00              NOP                            ;3110
0000d4  2000              MOVS     r0,#0                 ;3110
0000d6  f8840038          STRB     r0,[r4,#0x38]         ;3110
0000da  bf00              NOP                            ;3110
0000dc  bf00              NOP                            ;3112
0000de  e79a              B        |L33.22|
;;;3114   
                          ENDP


                          AREA ||i.HAL_TIM_IC_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_DeInit PROC
;;;1555     */
;;;1556   HAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1557   {
000002  4604              MOV      r4,r0
;;;1558     /* Check the parameters */
;;;1559     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1560   
;;;1561     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f8840039          STRB     r0,[r4,#0x39]
;;;1562     
;;;1563     /* Disable the TIM Peripheral Clock */
;;;1564     __HAL_TIM_DISABLE(htim);
00000a  bf00              NOP      
00000c  6820              LDR      r0,[r4,#0]
00000e  6a00              LDR      r0,[r0,#0x20]
000010  f2411111          MOV      r1,#0x1111
000014  4008              ANDS     r0,r0,r1
000016  b950              CBNZ     r0,|L34.46|
000018  6820              LDR      r0,[r4,#0]
00001a  6a00              LDR      r0,[r0,#0x20]
00001c  1089              ASRS     r1,r1,#2
00001e  4008              ANDS     r0,r0,r1
000020  b928              CBNZ     r0,|L34.46|
000022  6820              LDR      r0,[r4,#0]
000024  6800              LDR      r0,[r0,#0]
000026  f0200001          BIC      r0,r0,#1
00002a  6821              LDR      r1,[r4,#0]
00002c  6008              STR      r0,[r1,#0]
                  |L34.46|
00002e  bf00              NOP      
;;;1565       
;;;1566     /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;1567     HAL_TIM_IC_MspDeInit(htim);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       HAL_TIM_IC_MspDeInit
;;;1568       
;;;1569     /* Change TIM state */  
;;;1570     htim->State = HAL_TIM_STATE_RESET;
000036  2000              MOVS     r0,#0
000038  f8840039          STRB     r0,[r4,#0x39]
;;;1571   
;;;1572     /* Release Lock */
;;;1573     __HAL_UNLOCK(htim);
00003c  bf00              NOP      
00003e  f8840038          STRB     r0,[r4,#0x38]
000042  bf00              NOP      
;;;1574   
;;;1575     return HAL_OK;
;;;1576   }
000044  bd10              POP      {r4,pc}
;;;1577   
                          ENDP


                          AREA ||i.HAL_TIM_IC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_GetState PROC
;;;4434     */
;;;4435   HAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;4436   {
;;;4437     return htim->State;
000002  f8910039          LDRB     r0,[r1,#0x39]
;;;4438   }
000006  4770              BX       lr
;;;4439   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Init PROC
;;;1516     */
;;;1517   HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1518   {
000002  4604              MOV      r4,r0
;;;1519     /* Check the TIM handle allocation */
;;;1520     if(htim == NULL)
000004  b90c              CBNZ     r4,|L36.10|
;;;1521     {
;;;1522       return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L36.8|
;;;1523     }
;;;1524   
;;;1525     /* Check the parameters */
;;;1526     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1527     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;1528     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision)); 
;;;1529   
;;;1530     if(htim->State == HAL_TIM_STATE_RESET)
;;;1531     { 
;;;1532       /* Allocate lock resource and initialize it */
;;;1533       htim->Lock = HAL_UNLOCKED;
;;;1534       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1535       HAL_TIM_IC_MspInit(htim);
;;;1536     }
;;;1537     
;;;1538     /* Set the TIM state */
;;;1539     htim->State= HAL_TIM_STATE_BUSY;   
;;;1540     
;;;1541     /* Init the base time for the input capture */  
;;;1542     TIM_Base_SetConfig(htim->Instance, &htim->Init); 
;;;1543      
;;;1544     /* Initialize the TIM state*/
;;;1545     htim->State= HAL_TIM_STATE_READY;
;;;1546     
;;;1547     return HAL_OK;
;;;1548   }
000008  bd10              POP      {r4,pc}
                  |L36.10|
00000a  f8940039          LDRB     r0,[r4,#0x39]         ;1530
00000e  b928              CBNZ     r0,|L36.28|
000010  2000              MOVS     r0,#0                 ;1533
000012  f8840038          STRB     r0,[r4,#0x38]         ;1533
000016  4620              MOV      r0,r4                 ;1535
000018  f7fffffe          BL       HAL_TIM_IC_MspInit
                  |L36.28|
00001c  2002              MOVS     r0,#2                 ;1539
00001e  f8840039          STRB     r0,[r4,#0x39]         ;1539
000022  1d21              ADDS     r1,r4,#4              ;1542
000024  6820              LDR      r0,[r4,#0]            ;1542
000026  f7fffffe          BL       TIM_Base_SetConfig
00002a  2001              MOVS     r0,#1                 ;1545
00002c  f8840039          STRB     r0,[r4,#0x39]         ;1545
000030  2000              MOVS     r0,#0                 ;1547
000032  e7e9              B        |L36.8|
;;;1549   
                          ENDP


                          AREA ||i.HAL_TIM_IC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_MspDeInit PROC
;;;1598     */
;;;1599   __weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1600   {
;;;1601     /* Prevent unused argument(s) compilation warning */
;;;1602     UNUSED(htim);
;;;1603     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1604               the HAL_TIM_IC_MspDeInit could be implemented in the user file
;;;1605      */
;;;1606   }
;;;1607   
                          ENDP


                          AREA ||i.HAL_TIM_IC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_MspInit PROC
;;;1583     */
;;;1584   __weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1585   {
;;;1586     /* Prevent unused argument(s) compilation warning */
;;;1587     UNUSED(htim);
;;;1588     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1589               the HAL_TIM_IC_MspInit could be implemented in the user file
;;;1590      */
;;;1591   }
;;;1592   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Start PROC
;;;1619     */
;;;1620   HAL_StatusTypeDef HAL_TIM_IC_Start (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1621   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1622     /* Check the parameters */
;;;1623     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1624     
;;;1625     /* Enable the Input Capture channel */
;;;1626     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000006  2201              MOVS     r2,#1
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;1627       
;;;1628     /* Enable the Peripheral */
;;;1629     __HAL_TIM_ENABLE(htim);  
000010  6820              LDR      r0,[r4,#0]
000012  6800              LDR      r0,[r0,#0]
000014  f0400001          ORR      r0,r0,#1
000018  6821              LDR      r1,[r4,#0]
00001a  6008              STR      r0,[r1,#0]
;;;1630   
;;;1631     /* Return function status */
;;;1632     return HAL_OK;  
00001c  2000              MOVS     r0,#0
;;;1633   } 
00001e  bd30              POP      {r4,r5,pc}
;;;1634   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_IC_Start_DMA PROC
;;;1796     */
;;;1797   HAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1798   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1799     /* Check the parameters */
;;;1800     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1801     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;1802     
;;;1803     if((htim->State == HAL_TIM_STATE_BUSY))
00000c  f8940039          LDRB     r0,[r4,#0x39]
000010  2802              CMP      r0,#2
000012  d101              BNE      |L40.24|
                  |L40.20|
;;;1804     {
;;;1805        return HAL_BUSY;
;;;1806     }
;;;1807     else if((htim->State == HAL_TIM_STATE_READY))
;;;1808     {
;;;1809       if((pData == 0 ) && (Length > 0)) 
;;;1810       {
;;;1811         return HAL_ERROR;                                    
;;;1812       }
;;;1813       else
;;;1814       {
;;;1815         htim->State = HAL_TIM_STATE_BUSY;
;;;1816       }
;;;1817     }  
;;;1818      
;;;1819     switch (Channel)
;;;1820     {
;;;1821       case TIM_CHANNEL_1:
;;;1822       {
;;;1823         /* Set the DMA Period elapsed callback */
;;;1824         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1825        
;;;1826         /* Set the DMA error callback */
;;;1827         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;1828         
;;;1829         /* Enable the DMA Stream */
;;;1830         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length); 
;;;1831         
;;;1832         /* Enable the TIM Capture/Compare 1 DMA request */      
;;;1833         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1834       }
;;;1835       break;
;;;1836       
;;;1837       case TIM_CHANNEL_2:
;;;1838       {
;;;1839         /* Set the DMA Period elapsed callback */
;;;1840         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1841        
;;;1842         /* Set the DMA error callback */
;;;1843         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;1844         
;;;1845         /* Enable the DMA Stream */
;;;1846         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData, Length);
;;;1847         
;;;1848         /* Enable the TIM Capture/Compare 2  DMA request */
;;;1849         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1850       }
;;;1851       break;
;;;1852       
;;;1853       case TIM_CHANNEL_3:
;;;1854       {
;;;1855         /* Set the DMA Period elapsed callback */
;;;1856         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1857        
;;;1858         /* Set the DMA error callback */
;;;1859         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;1860         
;;;1861         /* Enable the DMA Stream */
;;;1862         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData, Length);
;;;1863         
;;;1864         /* Enable the TIM Capture/Compare 3  DMA request */
;;;1865         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;1866       }
;;;1867       break;
;;;1868       
;;;1869       case TIM_CHANNEL_4:
;;;1870       {
;;;1871         /* Set the DMA Period elapsed callback */
;;;1872         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1873        
;;;1874         /* Set the DMA error callback */
;;;1875         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;1876         
;;;1877         /* Enable the DMA Stream */
;;;1878         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData, Length);
;;;1879         
;;;1880         /* Enable the TIM Capture/Compare 4  DMA request */
;;;1881         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;1882       }
;;;1883       break;
;;;1884       
;;;1885       default:
;;;1886       break;
;;;1887     }
;;;1888   
;;;1889     /* Enable the Input Capture channel */
;;;1890     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1891      
;;;1892     /* Enable the Peripheral */
;;;1893     __HAL_TIM_ENABLE(htim); 
;;;1894     
;;;1895     /* Return function status */
;;;1896     return HAL_OK;
;;;1897   }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L40.24|
000018  f8940039          LDRB     r0,[r4,#0x39]         ;1807
00001c  2801              CMP      r0,#1                 ;1807
00001e  d106              BNE      |L40.46|
000020  b916              CBNZ     r6,|L40.40|
000022  2f00              CMP      r7,#0                 ;1809
000024  dd00              BLE      |L40.40|
000026  e7f5              B        |L40.20|
                  |L40.40|
000028  2002              MOVS     r0,#2                 ;1815
00002a  f8840039          STRB     r0,[r4,#0x39]         ;1815
                  |L40.46|
00002e  b135              CBZ      r5,|L40.62|
000030  2d04              CMP      r5,#4                 ;1819
000032  d019              BEQ      |L40.104|
000034  2d08              CMP      r5,#8                 ;1819
000036  d02c              BEQ      |L40.146|
000038  2d0c              CMP      r5,#0xc               ;1819
00003a  d154              BNE      |L40.230|
00003c  e03e              B        |L40.188|
                  |L40.62|
00003e  4931              LDR      r1,|L40.260|
000040  6a20              LDR      r0,[r4,#0x20]         ;1824
000042  63c1              STR      r1,[r0,#0x3c]         ;1824
000044  4930              LDR      r1,|L40.264|
000046  6a20              LDR      r0,[r4,#0x20]         ;1827
000048  6481              STR      r1,[r0,#0x48]         ;1827
00004a  6822              LDR      r2,[r4,#0]            ;1830
00004c  f1020134          ADD      r1,r2,#0x34           ;1830
000050  463b              MOV      r3,r7                 ;1830
000052  4632              MOV      r2,r6                 ;1830
000054  6a20              LDR      r0,[r4,#0x20]         ;1830
000056  f7fffffe          BL       HAL_DMA_Start_IT
00005a  6820              LDR      r0,[r4,#0]            ;1833
00005c  68c0              LDR      r0,[r0,#0xc]          ;1833
00005e  f4407000          ORR      r0,r0,#0x200          ;1833
000062  6821              LDR      r1,[r4,#0]            ;1833
000064  60c8              STR      r0,[r1,#0xc]          ;1833
000066  e03f              B        |L40.232|
                  |L40.104|
000068  4926              LDR      r1,|L40.260|
00006a  6a60              LDR      r0,[r4,#0x24]         ;1840
00006c  63c1              STR      r1,[r0,#0x3c]         ;1840
00006e  4926              LDR      r1,|L40.264|
000070  6a60              LDR      r0,[r4,#0x24]         ;1843
000072  6481              STR      r1,[r0,#0x48]         ;1843
000074  6822              LDR      r2,[r4,#0]            ;1846
000076  f1020138          ADD      r1,r2,#0x38           ;1846
00007a  463b              MOV      r3,r7                 ;1846
00007c  4632              MOV      r2,r6                 ;1846
00007e  6a60              LDR      r0,[r4,#0x24]         ;1846
000080  f7fffffe          BL       HAL_DMA_Start_IT
000084  6820              LDR      r0,[r4,#0]            ;1849
000086  68c0              LDR      r0,[r0,#0xc]          ;1849
000088  f4406080          ORR      r0,r0,#0x400          ;1849
00008c  6821              LDR      r1,[r4,#0]            ;1849
00008e  60c8              STR      r0,[r1,#0xc]          ;1849
000090  e02a              B        |L40.232|
                  |L40.146|
000092  491c              LDR      r1,|L40.260|
000094  6aa0              LDR      r0,[r4,#0x28]         ;1856
000096  63c1              STR      r1,[r0,#0x3c]         ;1856
000098  491b              LDR      r1,|L40.264|
00009a  6aa0              LDR      r0,[r4,#0x28]         ;1859
00009c  6481              STR      r1,[r0,#0x48]         ;1859
00009e  6822              LDR      r2,[r4,#0]            ;1862
0000a0  f102013c          ADD      r1,r2,#0x3c           ;1862
0000a4  463b              MOV      r3,r7                 ;1862
0000a6  4632              MOV      r2,r6                 ;1862
0000a8  6aa0              LDR      r0,[r4,#0x28]         ;1862
0000aa  f7fffffe          BL       HAL_DMA_Start_IT
0000ae  6820              LDR      r0,[r4,#0]            ;1865
0000b0  68c0              LDR      r0,[r0,#0xc]          ;1865
0000b2  f4406000          ORR      r0,r0,#0x800          ;1865
0000b6  6821              LDR      r1,[r4,#0]            ;1865
0000b8  60c8              STR      r0,[r1,#0xc]          ;1865
0000ba  e015              B        |L40.232|
                  |L40.188|
0000bc  4911              LDR      r1,|L40.260|
0000be  6ae0              LDR      r0,[r4,#0x2c]         ;1872
0000c0  63c1              STR      r1,[r0,#0x3c]         ;1872
0000c2  4911              LDR      r1,|L40.264|
0000c4  6ae0              LDR      r0,[r4,#0x2c]         ;1875
0000c6  6481              STR      r1,[r0,#0x48]         ;1875
0000c8  6822              LDR      r2,[r4,#0]            ;1878
0000ca  f1020140          ADD      r1,r2,#0x40           ;1878
0000ce  463b              MOV      r3,r7                 ;1878
0000d0  4632              MOV      r2,r6                 ;1878
0000d2  6ae0              LDR      r0,[r4,#0x2c]         ;1878
0000d4  f7fffffe          BL       HAL_DMA_Start_IT
0000d8  6820              LDR      r0,[r4,#0]            ;1881
0000da  68c0              LDR      r0,[r0,#0xc]          ;1881
0000dc  f4405080          ORR      r0,r0,#0x1000         ;1881
0000e0  6821              LDR      r1,[r4,#0]            ;1881
0000e2  60c8              STR      r0,[r1,#0xc]          ;1881
0000e4  e000              B        |L40.232|
                  |L40.230|
0000e6  bf00              NOP                            ;1886
                  |L40.232|
0000e8  bf00              NOP                            ;1835
0000ea  2201              MOVS     r2,#1                 ;1890
0000ec  4629              MOV      r1,r5                 ;1890
0000ee  6820              LDR      r0,[r4,#0]            ;1890
0000f0  f7fffffe          BL       TIM_CCxChannelCmd
0000f4  6820              LDR      r0,[r4,#0]            ;1893
0000f6  6800              LDR      r0,[r0,#0]            ;1893
0000f8  f0400001          ORR      r0,r0,#1              ;1893
0000fc  6821              LDR      r1,[r4,#0]            ;1893
0000fe  6008              STR      r0,[r1,#0]            ;1893
000100  2000              MOVS     r0,#0                 ;1896
000102  e787              B        |L40.20|
;;;1898   
                          ENDP

                  |L40.260|
                          DCD      TIM_DMACaptureCplt
                  |L40.264|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_IC_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Start_IT PROC
;;;1673     */
;;;1674   HAL_StatusTypeDef HAL_TIM_IC_Start_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1675   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1676     /* Check the parameters */
;;;1677     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1678     
;;;1679     switch (Channel)
000006  b135              CBZ      r5,|L41.22|
000008  2d04              CMP      r5,#4
00000a  d00b              BEQ      |L41.36|
00000c  2d08              CMP      r5,#8
00000e  d010              BEQ      |L41.50|
000010  2d0c              CMP      r5,#0xc
000012  d11c              BNE      |L41.78|
000014  e014              B        |L41.64|
                  |L41.22|
;;;1680     {
;;;1681       case TIM_CHANNEL_1:
;;;1682       {       
;;;1683         /* Enable the TIM Capture/Compare 1 interrupt */
;;;1684         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000016  6820              LDR      r0,[r4,#0]
000018  68c0              LDR      r0,[r0,#0xc]
00001a  f0400002          ORR      r0,r0,#2
00001e  6821              LDR      r1,[r4,#0]
000020  60c8              STR      r0,[r1,#0xc]
;;;1685       }
;;;1686       break;
000022  e015              B        |L41.80|
                  |L41.36|
;;;1687       
;;;1688       case TIM_CHANNEL_2:
;;;1689       {
;;;1690         /* Enable the TIM Capture/Compare 2 interrupt */
;;;1691         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000024  6820              LDR      r0,[r4,#0]
000026  68c0              LDR      r0,[r0,#0xc]
000028  f0400004          ORR      r0,r0,#4
00002c  6821              LDR      r1,[r4,#0]
00002e  60c8              STR      r0,[r1,#0xc]
;;;1692       }
;;;1693       break;
000030  e00e              B        |L41.80|
                  |L41.50|
;;;1694       
;;;1695       case TIM_CHANNEL_3:
;;;1696       {
;;;1697         /* Enable the TIM Capture/Compare 3 interrupt */
;;;1698         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
000032  6820              LDR      r0,[r4,#0]
000034  68c0              LDR      r0,[r0,#0xc]
000036  f0400008          ORR      r0,r0,#8
00003a  6821              LDR      r1,[r4,#0]
00003c  60c8              STR      r0,[r1,#0xc]
;;;1699       }
;;;1700       break;
00003e  e007              B        |L41.80|
                  |L41.64|
;;;1701       
;;;1702       case TIM_CHANNEL_4:
;;;1703       {
;;;1704         /* Enable the TIM Capture/Compare 4 interrupt */
;;;1705         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000040  6820              LDR      r0,[r4,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  f0400010          ORR      r0,r0,#0x10
000048  6821              LDR      r1,[r4,#0]
00004a  60c8              STR      r0,[r1,#0xc]
;;;1706       }
;;;1707       break;
00004c  e000              B        |L41.80|
                  |L41.78|
;;;1708       
;;;1709       default:
;;;1710       break;
00004e  bf00              NOP      
                  |L41.80|
000050  bf00              NOP                            ;1686
;;;1711     }  
;;;1712     /* Enable the Input Capture channel */
;;;1713     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000052  2201              MOVS     r2,#1
000054  4629              MOV      r1,r5
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       TIM_CCxChannelCmd
;;;1714       
;;;1715     /* Enable the Peripheral */
;;;1716     __HAL_TIM_ENABLE(htim);  
00005c  6820              LDR      r0,[r4,#0]
00005e  6800              LDR      r0,[r0,#0]
000060  f0400001          ORR      r0,r0,#1
000064  6821              LDR      r1,[r4,#0]
000066  6008              STR      r0,[r1,#0]
;;;1717   
;;;1718     /* Return function status */
;;;1719     return HAL_OK;  
000068  2000              MOVS     r0,#0
;;;1720   } 
00006a  bd30              POP      {r4,r5,pc}
;;;1721   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Stop PROC
;;;1646     */
;;;1647   HAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1648   { 
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1649     /* Check the parameters */
;;;1650     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1651     
;;;1652     /* Disable the Input Capture channel */
;;;1653     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000006  2200              MOVS     r2,#0
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;1654     
;;;1655     /* Disable the Peripheral */
;;;1656     __HAL_TIM_DISABLE(htim); 
000010  bf00              NOP      
000012  6820              LDR      r0,[r4,#0]
000014  6a00              LDR      r0,[r0,#0x20]
000016  f2411111          MOV      r1,#0x1111
00001a  4008              ANDS     r0,r0,r1
00001c  b950              CBNZ     r0,|L42.52|
00001e  6820              LDR      r0,[r4,#0]
000020  6a00              LDR      r0,[r0,#0x20]
000022  1089              ASRS     r1,r1,#2
000024  4008              ANDS     r0,r0,r1
000026  b928              CBNZ     r0,|L42.52|
000028  6820              LDR      r0,[r4,#0]
00002a  6800              LDR      r0,[r0,#0]
00002c  f0200001          BIC      r0,r0,#1
000030  6821              LDR      r1,[r4,#0]
000032  6008              STR      r0,[r1,#0]
                  |L42.52|
000034  bf00              NOP      
;;;1657     
;;;1658     /* Return function status */
;;;1659     return HAL_OK;
000036  2000              MOVS     r0,#0
;;;1660   }
000038  bd30              POP      {r4,r5,pc}
;;;1661   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Stop_DMA PROC
;;;1910     */
;;;1911   HAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1912   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1913     /* Check the parameters */
;;;1914     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1915     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;1916     
;;;1917     switch (Channel)
000006  b135              CBZ      r5,|L43.22|
000008  2d04              CMP      r5,#4
00000a  d00b              BEQ      |L43.36|
00000c  2d08              CMP      r5,#8
00000e  d010              BEQ      |L43.50|
000010  2d0c              CMP      r5,#0xc
000012  d11c              BNE      |L43.78|
000014  e014              B        |L43.64|
                  |L43.22|
;;;1918     {
;;;1919       case TIM_CHANNEL_1:
;;;1920       {       
;;;1921         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1922         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000016  6820              LDR      r0,[r4,#0]
000018  68c0              LDR      r0,[r0,#0xc]
00001a  f4207000          BIC      r0,r0,#0x200
00001e  6821              LDR      r1,[r4,#0]
000020  60c8              STR      r0,[r1,#0xc]
;;;1923       }
;;;1924       break;
000022  e015              B        |L43.80|
                  |L43.36|
;;;1925       
;;;1926       case TIM_CHANNEL_2:
;;;1927       {
;;;1928         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1929         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000024  6820              LDR      r0,[r4,#0]
000026  68c0              LDR      r0,[r0,#0xc]
000028  f4206080          BIC      r0,r0,#0x400
00002c  6821              LDR      r1,[r4,#0]
00002e  60c8              STR      r0,[r1,#0xc]
;;;1930       }
;;;1931       break;
000030  e00e              B        |L43.80|
                  |L43.50|
;;;1932       
;;;1933       case TIM_CHANNEL_3:
;;;1934       {
;;;1935         /* Disable the TIM Capture/Compare 3  DMA request */
;;;1936         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
000032  6820              LDR      r0,[r4,#0]
000034  68c0              LDR      r0,[r0,#0xc]
000036  f4206000          BIC      r0,r0,#0x800
00003a  6821              LDR      r1,[r4,#0]
00003c  60c8              STR      r0,[r1,#0xc]
;;;1937       }
;;;1938       break;
00003e  e007              B        |L43.80|
                  |L43.64|
;;;1939       
;;;1940       case TIM_CHANNEL_4:
;;;1941       {
;;;1942         /* Disable the TIM Capture/Compare 4  DMA request */
;;;1943         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
000040  6820              LDR      r0,[r4,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  f4205080          BIC      r0,r0,#0x1000
000048  6821              LDR      r1,[r4,#0]
00004a  60c8              STR      r0,[r1,#0xc]
;;;1944       }
;;;1945       break;
00004c  e000              B        |L43.80|
                  |L43.78|
;;;1946       
;;;1947       default:
;;;1948       break;
00004e  bf00              NOP      
                  |L43.80|
000050  bf00              NOP                            ;1924
;;;1949     }
;;;1950   
;;;1951     /* Disable the Input Capture channel */
;;;1952     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000052  2200              MOVS     r2,#0
000054  4629              MOV      r1,r5
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       TIM_CCxChannelCmd
;;;1953     
;;;1954     /* Disable the Peripheral */
;;;1955     __HAL_TIM_DISABLE(htim); 
00005c  bf00              NOP      
00005e  6820              LDR      r0,[r4,#0]
000060  6a00              LDR      r0,[r0,#0x20]
000062  f2411111          MOV      r1,#0x1111
000066  4008              ANDS     r0,r0,r1
000068  b950              CBNZ     r0,|L43.128|
00006a  6820              LDR      r0,[r4,#0]
00006c  6a00              LDR      r0,[r0,#0x20]
00006e  1089              ASRS     r1,r1,#2
000070  4008              ANDS     r0,r0,r1
000072  b928              CBNZ     r0,|L43.128|
000074  6820              LDR      r0,[r4,#0]
000076  6800              LDR      r0,[r0,#0]
000078  f0200001          BIC      r0,r0,#1
00007c  6821              LDR      r1,[r4,#0]
00007e  6008              STR      r0,[r1,#0]
                  |L43.128|
000080  bf00              NOP      
;;;1956     
;;;1957     /* Change the htim state */
;;;1958     htim->State = HAL_TIM_STATE_READY;
000082  2001              MOVS     r0,#1
000084  f8840039          STRB     r0,[r4,#0x39]
;;;1959     
;;;1960     /* Return function status */
;;;1961     return HAL_OK;
000088  2000              MOVS     r0,#0
;;;1962   }  
00008a  bd30              POP      {r4,r5,pc}
;;;1963   /**
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Stop_IT PROC
;;;1733     */
;;;1734   HAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1735   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1736     /* Check the parameters */
;;;1737     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1738     
;;;1739     switch (Channel)
000006  b135              CBZ      r5,|L44.22|
000008  2d04              CMP      r5,#4
00000a  d00b              BEQ      |L44.36|
00000c  2d08              CMP      r5,#8
00000e  d010              BEQ      |L44.50|
000010  2d0c              CMP      r5,#0xc
000012  d11c              BNE      |L44.78|
000014  e014              B        |L44.64|
                  |L44.22|
;;;1740     {
;;;1741       case TIM_CHANNEL_1:
;;;1742       {       
;;;1743         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1744         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000016  6820              LDR      r0,[r4,#0]
000018  68c0              LDR      r0,[r0,#0xc]
00001a  f0200002          BIC      r0,r0,#2
00001e  6821              LDR      r1,[r4,#0]
000020  60c8              STR      r0,[r1,#0xc]
;;;1745       }
;;;1746       break;
000022  e015              B        |L44.80|
                  |L44.36|
;;;1747       
;;;1748       case TIM_CHANNEL_2:
;;;1749       {
;;;1750         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1751         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000024  6820              LDR      r0,[r4,#0]
000026  68c0              LDR      r0,[r0,#0xc]
000028  f0200004          BIC      r0,r0,#4
00002c  6821              LDR      r1,[r4,#0]
00002e  60c8              STR      r0,[r1,#0xc]
;;;1752       }
;;;1753       break;
000030  e00e              B        |L44.80|
                  |L44.50|
;;;1754       
;;;1755       case TIM_CHANNEL_3:
;;;1756       {
;;;1757         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1758         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
000032  6820              LDR      r0,[r4,#0]
000034  68c0              LDR      r0,[r0,#0xc]
000036  f0200008          BIC      r0,r0,#8
00003a  6821              LDR      r1,[r4,#0]
00003c  60c8              STR      r0,[r1,#0xc]
;;;1759       }
;;;1760       break;
00003e  e007              B        |L44.80|
                  |L44.64|
;;;1761       
;;;1762       case TIM_CHANNEL_4:
;;;1763       {
;;;1764         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1765         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
000040  6820              LDR      r0,[r4,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  f0200010          BIC      r0,r0,#0x10
000048  6821              LDR      r1,[r4,#0]
00004a  60c8              STR      r0,[r1,#0xc]
;;;1766       }
;;;1767       break;
00004c  e000              B        |L44.80|
                  |L44.78|
;;;1768       
;;;1769       default:
;;;1770       break; 
00004e  bf00              NOP      
                  |L44.80|
000050  bf00              NOP                            ;1746
;;;1771     } 
;;;1772     
;;;1773     /* Disable the Input Capture channel */
;;;1774     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE); 
000052  2200              MOVS     r2,#0
000054  4629              MOV      r1,r5
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       TIM_CCxChannelCmd
;;;1775     
;;;1776     /* Disable the Peripheral */
;;;1777     __HAL_TIM_DISABLE(htim); 
00005c  bf00              NOP      
00005e  6820              LDR      r0,[r4,#0]
000060  6a00              LDR      r0,[r0,#0x20]
000062  f2411111          MOV      r1,#0x1111
000066  4008              ANDS     r0,r0,r1
000068  b950              CBNZ     r0,|L44.128|
00006a  6820              LDR      r0,[r4,#0]
00006c  6a00              LDR      r0,[r0,#0x20]
00006e  1089              ASRS     r1,r1,#2
000070  4008              ANDS     r0,r0,r1
000072  b928              CBNZ     r0,|L44.128|
000074  6820              LDR      r0,[r4,#0]
000076  6800              LDR      r0,[r0,#0]
000078  f0200001          BIC      r0,r0,#1
00007c  6821              LDR      r1,[r4,#0]
00007e  6008              STR      r0,[r1,#0]
                  |L44.128|
000080  bf00              NOP      
;;;1778     
;;;1779     /* Return function status */
;;;1780     return HAL_OK;
000082  2000              MOVS     r0,#0
;;;1781   }
000084  bd30              POP      {r4,r5,pc}
;;;1782   
                          ENDP


                          AREA ||i.HAL_TIM_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IRQHandler PROC
;;;2798     */
;;;2799   void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;2800   {
000002  4604              MOV      r4,r0
;;;2801     /* Capture compare 1 event */
;;;2802     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
000004  6820              LDR      r0,[r4,#0]
000006  6900              LDR      r0,[r0,#0x10]
000008  f3c00040          UBFX     r0,r0,#1,#1
00000c  b1d8              CBZ      r0,|L45.70|
;;;2803     {
;;;2804       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
00000e  6820              LDR      r0,[r4,#0]
000010  68c0              LDR      r0,[r0,#0xc]
000012  f3c00040          UBFX     r0,r0,#1,#1
000016  b1b0              CBZ      r0,|L45.70|
;;;2805       {
;;;2806         {
;;;2807           __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
000018  f06f0002          MVN      r0,#2
00001c  6821              LDR      r1,[r4,#0]
00001e  6108              STR      r0,[r1,#0x10]
;;;2808           htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
000020  2001              MOVS     r0,#1
000022  7620              STRB     r0,[r4,#0x18]
;;;2809           
;;;2810           /* Input capture event */
;;;2811           if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00)
000024  6820              LDR      r0,[r4,#0]
000026  6980              LDR      r0,[r0,#0x18]
000028  f0000003          AND      r0,r0,#3
00002c  b118              CBZ      r0,|L45.54|
;;;2812           {
;;;2813             HAL_TIM_IC_CaptureCallback(htim);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
000034  e005              B        |L45.66|
                  |L45.54|
;;;2814           }
;;;2815           /* Output compare event */
;;;2816           else
;;;2817           {
;;;2818             HAL_TIM_OC_DelayElapsedCallback(htim);
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2819             HAL_TIM_PWM_PulseFinishedCallback(htim);
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.66|
;;;2820           }
;;;2821           htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000042  2000              MOVS     r0,#0
000044  7620              STRB     r0,[r4,#0x18]
                  |L45.70|
;;;2822         }
;;;2823       }
;;;2824     }
;;;2825     /* Capture compare 2 event */
;;;2826     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
000046  6820              LDR      r0,[r4,#0]
000048  6900              LDR      r0,[r0,#0x10]
00004a  f3c00080          UBFX     r0,r0,#2,#1
00004e  b1d8              CBZ      r0,|L45.136|
;;;2827     {
;;;2828       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
000050  6820              LDR      r0,[r4,#0]
000052  68c0              LDR      r0,[r0,#0xc]
000054  f3c00080          UBFX     r0,r0,#2,#1
000058  b1b0              CBZ      r0,|L45.136|
;;;2829       {
;;;2830         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
00005a  f06f0004          MVN      r0,#4
00005e  6821              LDR      r1,[r4,#0]
000060  6108              STR      r0,[r1,#0x10]
;;;2831         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
000062  2002              MOVS     r0,#2
000064  7620              STRB     r0,[r4,#0x18]
;;;2832         /* Input capture event */
;;;2833         if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00)
000066  6820              LDR      r0,[r4,#0]
000068  6980              LDR      r0,[r0,#0x18]
00006a  f4007040          AND      r0,r0,#0x300
00006e  b118              CBZ      r0,|L45.120|
;;;2834         {          
;;;2835           HAL_TIM_IC_CaptureCallback(htim);
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
000076  e005              B        |L45.132|
                  |L45.120|
;;;2836         }
;;;2837         /* Output compare event */
;;;2838         else
;;;2839         {
;;;2840           HAL_TIM_OC_DelayElapsedCallback(htim);
000078  4620              MOV      r0,r4
00007a  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2841           HAL_TIM_PWM_PulseFinishedCallback(htim);
00007e  4620              MOV      r0,r4
000080  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.132|
;;;2842         }
;;;2843         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000084  2000              MOVS     r0,#0
000086  7620              STRB     r0,[r4,#0x18]
                  |L45.136|
;;;2844       }
;;;2845     }
;;;2846     /* Capture compare 3 event */
;;;2847     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
000088  6820              LDR      r0,[r4,#0]
00008a  6900              LDR      r0,[r0,#0x10]
00008c  f3c000c0          UBFX     r0,r0,#3,#1
000090  b1d8              CBZ      r0,|L45.202|
;;;2848     {
;;;2849       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
000092  6820              LDR      r0,[r4,#0]
000094  68c0              LDR      r0,[r0,#0xc]
000096  f3c000c0          UBFX     r0,r0,#3,#1
00009a  b1b0              CBZ      r0,|L45.202|
;;;2850       {
;;;2851         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
00009c  f06f0008          MVN      r0,#8
0000a0  6821              LDR      r1,[r4,#0]
0000a2  6108              STR      r0,[r1,#0x10]
;;;2852         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
0000a4  2004              MOVS     r0,#4
0000a6  7620              STRB     r0,[r4,#0x18]
;;;2853         /* Input capture event */
;;;2854         if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00)
0000a8  6820              LDR      r0,[r4,#0]
0000aa  69c0              LDR      r0,[r0,#0x1c]
0000ac  f0000003          AND      r0,r0,#3
0000b0  b118              CBZ      r0,|L45.186|
;;;2855         {          
;;;2856           HAL_TIM_IC_CaptureCallback(htim);
0000b2  4620              MOV      r0,r4
0000b4  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
0000b8  e005              B        |L45.198|
                  |L45.186|
;;;2857         }
;;;2858         /* Output compare event */
;;;2859         else
;;;2860         {
;;;2861           HAL_TIM_OC_DelayElapsedCallback(htim);
0000ba  4620              MOV      r0,r4
0000bc  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2862           HAL_TIM_PWM_PulseFinishedCallback(htim); 
0000c0  4620              MOV      r0,r4
0000c2  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.198|
;;;2863         }
;;;2864         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
0000c6  2000              MOVS     r0,#0
0000c8  7620              STRB     r0,[r4,#0x18]
                  |L45.202|
;;;2865       }
;;;2866     }
;;;2867     /* Capture compare 4 event */
;;;2868     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
0000ca  6820              LDR      r0,[r4,#0]
0000cc  6900              LDR      r0,[r0,#0x10]
0000ce  f3c01000          UBFX     r0,r0,#4,#1
0000d2  b1d8              CBZ      r0,|L45.268|
;;;2869     {
;;;2870       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
0000d4  6820              LDR      r0,[r4,#0]
0000d6  68c0              LDR      r0,[r0,#0xc]
0000d8  f3c01000          UBFX     r0,r0,#4,#1
0000dc  b1b0              CBZ      r0,|L45.268|
;;;2871       {
;;;2872         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
0000de  f06f0010          MVN      r0,#0x10
0000e2  6821              LDR      r1,[r4,#0]
0000e4  6108              STR      r0,[r1,#0x10]
;;;2873         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
0000e6  2008              MOVS     r0,#8
0000e8  7620              STRB     r0,[r4,#0x18]
;;;2874         /* Input capture event */
;;;2875         if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00)
0000ea  6820              LDR      r0,[r4,#0]
0000ec  69c0              LDR      r0,[r0,#0x1c]
0000ee  f4007040          AND      r0,r0,#0x300
0000f2  b118              CBZ      r0,|L45.252|
;;;2876         {          
;;;2877           HAL_TIM_IC_CaptureCallback(htim);
0000f4  4620              MOV      r0,r4
0000f6  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
0000fa  e005              B        |L45.264|
                  |L45.252|
;;;2878         }
;;;2879         /* Output compare event */
;;;2880         else
;;;2881         {
;;;2882           HAL_TIM_OC_DelayElapsedCallback(htim);
0000fc  4620              MOV      r0,r4
0000fe  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2883           HAL_TIM_PWM_PulseFinishedCallback(htim);
000102  4620              MOV      r0,r4
000104  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.264|
;;;2884         }
;;;2885         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000108  2000              MOVS     r0,#0
00010a  7620              STRB     r0,[r4,#0x18]
                  |L45.268|
;;;2886       }
;;;2887     }
;;;2888     /* TIM Update event */
;;;2889     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
00010c  6820              LDR      r0,[r4,#0]
00010e  6900              LDR      r0,[r0,#0x10]
000110  f0000001          AND      r0,r0,#1
000114  b158              CBZ      r0,|L45.302|
;;;2890     {
;;;2891       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) !=RESET)
000116  6820              LDR      r0,[r4,#0]
000118  68c0              LDR      r0,[r0,#0xc]
00011a  f0000001          AND      r0,r0,#1
00011e  b130              CBZ      r0,|L45.302|
;;;2892       {
;;;2893         __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
000120  f06f0001          MVN      r0,#1
000124  6821              LDR      r1,[r4,#0]
000126  6108              STR      r0,[r1,#0x10]
;;;2894         HAL_TIM_PeriodElapsedCallback(htim);
000128  4620              MOV      r0,r4
00012a  f7fffffe          BL       HAL_TIM_PeriodElapsedCallback
                  |L45.302|
;;;2895       }
;;;2896     }
;;;2897     /* TIM Break input event */
;;;2898     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
00012e  6820              LDR      r0,[r4,#0]
000130  6900              LDR      r0,[r0,#0x10]
000132  f3c010c0          UBFX     r0,r0,#7,#1
000136  b158              CBZ      r0,|L45.336|
;;;2899     {
;;;2900       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
000138  6820              LDR      r0,[r4,#0]
00013a  68c0              LDR      r0,[r0,#0xc]
00013c  f3c010c0          UBFX     r0,r0,#7,#1
000140  b130              CBZ      r0,|L45.336|
;;;2901       {
;;;2902         __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
000142  f06f0080          MVN      r0,#0x80
000146  6821              LDR      r1,[r4,#0]
000148  6108              STR      r0,[r1,#0x10]
;;;2903         HAL_TIMEx_BreakCallback(htim);
00014a  4620              MOV      r0,r4
00014c  f7fffffe          BL       HAL_TIMEx_BreakCallback
                  |L45.336|
;;;2904       }
;;;2905     }
;;;2906     /* TIM Trigger detection event */
;;;2907     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
000150  6820              LDR      r0,[r4,#0]
000152  6900              LDR      r0,[r0,#0x10]
000154  f3c01080          UBFX     r0,r0,#6,#1
000158  b158              CBZ      r0,|L45.370|
;;;2908     {
;;;2909       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) !=RESET)
00015a  6820              LDR      r0,[r4,#0]
00015c  68c0              LDR      r0,[r0,#0xc]
00015e  f3c01080          UBFX     r0,r0,#6,#1
000162  b130              CBZ      r0,|L45.370|
;;;2910       {
;;;2911         __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
000164  f06f0040          MVN      r0,#0x40
000168  6821              LDR      r1,[r4,#0]
00016a  6108              STR      r0,[r1,#0x10]
;;;2912         HAL_TIM_TriggerCallback(htim);
00016c  4620              MOV      r0,r4
00016e  f7fffffe          BL       HAL_TIM_TriggerCallback
                  |L45.370|
;;;2913       }
;;;2914     }
;;;2915     /* TIM commutation event */
;;;2916     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
000172  6820              LDR      r0,[r4,#0]
000174  6900              LDR      r0,[r0,#0x10]
000176  f3c01040          UBFX     r0,r0,#5,#1
00017a  b158              CBZ      r0,|L45.404|
;;;2917     {
;;;2918       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) !=RESET)
00017c  6820              LDR      r0,[r4,#0]
00017e  68c0              LDR      r0,[r0,#0xc]
000180  f3c01040          UBFX     r0,r0,#5,#1
000184  b130              CBZ      r0,|L45.404|
;;;2919       {
;;;2920         __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
000186  f06f0020          MVN      r0,#0x20
00018a  6821              LDR      r1,[r4,#0]
00018c  6108              STR      r0,[r1,#0x10]
;;;2921         HAL_TIMEx_CommutationCallback(htim);
00018e  4620              MOV      r0,r4
000190  f7fffffe          BL       HAL_TIMEx_CommutationCallback
                  |L45.404|
;;;2922       }
;;;2923     }
;;;2924   }
000194  bd10              POP      {r4,pc}
;;;2925   /**
                          ENDP


                          AREA ||i.HAL_TIM_OC_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_ConfigChannel PROC
;;;2961     */
;;;2962   HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;2963   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;2964     /* Check the parameters */ 
;;;2965     assert_param(IS_TIM_CHANNELS(Channel)); 
;;;2966     assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
;;;2967     assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
;;;2968     
;;;2969     /* Check input state */
;;;2970     __HAL_LOCK(htim); 
000008  bf00              NOP      
00000a  f8940038          LDRB     r0,[r4,#0x38]
00000e  2801              CMP      r0,#1
000010  d101              BNE      |L46.22|
000012  2002              MOVS     r0,#2
                  |L46.20|
;;;2971     
;;;2972     htim->State = HAL_TIM_STATE_BUSY;
;;;2973     
;;;2974     switch (Channel)
;;;2975     {
;;;2976       case TIM_CHANNEL_1:
;;;2977       {
;;;2978         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;2979         /* Configure the TIM Channel 1 in Output Compare */
;;;2980         TIM_OC1_SetConfig(htim->Instance, sConfig);
;;;2981       }
;;;2982       break;
;;;2983       
;;;2984       case TIM_CHANNEL_2:
;;;2985       {
;;;2986         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2987         /* Configure the TIM Channel 2 in Output Compare */
;;;2988         TIM_OC2_SetConfig(htim->Instance, sConfig);
;;;2989       }
;;;2990       break;
;;;2991       
;;;2992       case TIM_CHANNEL_3:
;;;2993       {
;;;2994          assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;2995         /* Configure the TIM Channel 3 in Output Compare */
;;;2996         TIM_OC3_SetConfig(htim->Instance, sConfig);
;;;2997       }
;;;2998       break;
;;;2999       
;;;3000       case TIM_CHANNEL_4:
;;;3001       {
;;;3002         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3003         /* Configure the TIM Channel 4 in Output Compare */
;;;3004         TIM_OC4_SetConfig(htim->Instance, sConfig);
;;;3005       }
;;;3006       break;
;;;3007       
;;;3008       default:
;;;3009       break;    
;;;3010     }
;;;3011     htim->State = HAL_TIM_STATE_READY;
;;;3012     
;;;3013     __HAL_UNLOCK(htim); 
;;;3014     
;;;3015     return HAL_OK;
;;;3016   }
000014  bd70              POP      {r4-r6,pc}
                  |L46.22|
000016  2001              MOVS     r0,#1                 ;2970
000018  f8840038          STRB     r0,[r4,#0x38]         ;2970
00001c  bf00              NOP                            ;2970
00001e  2002              MOVS     r0,#2                 ;2972
000020  f8840039          STRB     r0,[r4,#0x39]         ;2972
000024  b135              CBZ      r5,|L46.52|
000026  2d04              CMP      r5,#4                 ;2974
000028  d009              BEQ      |L46.62|
00002a  2d08              CMP      r5,#8                 ;2974
00002c  d00c              BEQ      |L46.72|
00002e  2d0c              CMP      r5,#0xc               ;2974
000030  d114              BNE      |L46.92|
000032  e00e              B        |L46.82|
                  |L46.52|
000034  4631              MOV      r1,r6                 ;2980
000036  6820              LDR      r0,[r4,#0]            ;2980
000038  f7fffffe          BL       TIM_OC1_SetConfig
00003c  e00f              B        |L46.94|
                  |L46.62|
00003e  4631              MOV      r1,r6                 ;2988
000040  6820              LDR      r0,[r4,#0]            ;2988
000042  f7fffffe          BL       TIM_OC2_SetConfig
000046  e00a              B        |L46.94|
                  |L46.72|
000048  4631              MOV      r1,r6                 ;2996
00004a  6820              LDR      r0,[r4,#0]            ;2996
00004c  f7fffffe          BL       TIM_OC3_SetConfig
000050  e005              B        |L46.94|
                  |L46.82|
000052  4631              MOV      r1,r6                 ;3004
000054  6820              LDR      r0,[r4,#0]            ;3004
000056  f7fffffe          BL       TIM_OC4_SetConfig
00005a  e000              B        |L46.94|
                  |L46.92|
00005c  bf00              NOP                            ;3009
                  |L46.94|
00005e  bf00              NOP                            ;2982
000060  2001              MOVS     r0,#1                 ;3011
000062  f8840039          STRB     r0,[r4,#0x39]         ;3011
000066  bf00              NOP                            ;3013
000068  2000              MOVS     r0,#0                 ;3013
00006a  f8840038          STRB     r0,[r4,#0x38]         ;3013
00006e  bf00              NOP                            ;3013
000070  bf00              NOP                            ;3015
000072  e7cf              B        |L46.20|
;;;3017   
                          ENDP


                          AREA ||i.HAL_TIM_OC_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_DeInit PROC
;;;528      */
;;;529    HAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;530    {
000002  4604              MOV      r4,r0
;;;531      /* Check the parameters */
;;;532      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;533      
;;;534       htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f8840039          STRB     r0,[r4,#0x39]
;;;535       
;;;536      /* Disable the TIM Peripheral Clock */
;;;537      __HAL_TIM_DISABLE(htim);
00000a  bf00              NOP      
00000c  6820              LDR      r0,[r4,#0]
00000e  6a00              LDR      r0,[r0,#0x20]
000010  f2411111          MOV      r1,#0x1111
000014  4008              ANDS     r0,r0,r1
000016  b950              CBNZ     r0,|L47.46|
000018  6820              LDR      r0,[r4,#0]
00001a  6a00              LDR      r0,[r0,#0x20]
00001c  1089              ASRS     r1,r1,#2
00001e  4008              ANDS     r0,r0,r1
000020  b928              CBNZ     r0,|L47.46|
000022  6820              LDR      r0,[r4,#0]
000024  6800              LDR      r0,[r0,#0]
000026  f0200001          BIC      r0,r0,#1
00002a  6821              LDR      r1,[r4,#0]
00002c  6008              STR      r0,[r1,#0]
                  |L47.46|
00002e  bf00              NOP      
;;;538      
;;;539      /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;540      HAL_TIM_OC_MspDeInit(htim);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       HAL_TIM_OC_MspDeInit
;;;541        
;;;542      /* Change TIM state */  
;;;543      htim->State = HAL_TIM_STATE_RESET; 
000036  2000              MOVS     r0,#0
000038  f8840039          STRB     r0,[r4,#0x39]
;;;544    
;;;545      /* Release Lock */
;;;546      __HAL_UNLOCK(htim);
00003c  bf00              NOP      
00003e  f8840038          STRB     r0,[r4,#0x38]
000042  bf00              NOP      
;;;547    
;;;548      return HAL_OK;
;;;549    }
000044  bd10              POP      {r4,pc}
;;;550    
                          ENDP


                          AREA ||i.HAL_TIM_OC_DelayElapsedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_DelayElapsedCallback PROC
;;;4308     */
;;;4309   __weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4310   {
;;;4311     /* Prevent unused argument(s) compilation warning */
;;;4312     UNUSED(htim);
;;;4313     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4314               the __HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
;;;4315      */
;;;4316   }
;;;4317   
                          ENDP


                          AREA ||i.HAL_TIM_OC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_GetState PROC
;;;4412     */
;;;4413   HAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;4414   {
;;;4415     return htim->State;
000002  f8910039          LDRB     r0,[r1,#0x39]
;;;4416   }
000006  4770              BX       lr
;;;4417   
                          ENDP


                          AREA ||i.HAL_TIM_OC_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_Init PROC
;;;489      */
;;;490    HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef* htim)
000000  b510              PUSH     {r4,lr}
;;;491    {
000002  4604              MOV      r4,r0
;;;492      /* Check the TIM handle allocation */
;;;493      if(htim == NULL)
000004  b90c              CBNZ     r4,|L50.10|
;;;494      {
;;;495        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L50.8|
;;;496      }
;;;497    
;;;498      /* Check the parameters */
;;;499      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;500      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;501      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;502     
;;;503      if(htim->State == HAL_TIM_STATE_RESET)
;;;504      { 
;;;505        /* Allocate lock resource and initialize it */
;;;506        htim->Lock = HAL_UNLOCKED;
;;;507        /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;508        HAL_TIM_OC_MspInit(htim);
;;;509      }
;;;510      
;;;511      /* Set the TIM state */
;;;512      htim->State= HAL_TIM_STATE_BUSY;
;;;513      
;;;514      /* Init the base time for the Output Compare */  
;;;515      TIM_Base_SetConfig(htim->Instance,  &htim->Init); 
;;;516      
;;;517      /* Initialize the TIM state*/
;;;518      htim->State= HAL_TIM_STATE_READY;
;;;519      
;;;520      return HAL_OK;
;;;521    }
000008  bd10              POP      {r4,pc}
                  |L50.10|
00000a  f8940039          LDRB     r0,[r4,#0x39]         ;503
00000e  b928              CBNZ     r0,|L50.28|
000010  2000              MOVS     r0,#0                 ;506
000012  f8840038          STRB     r0,[r4,#0x38]         ;506
000016  4620              MOV      r0,r4                 ;508
000018  f7fffffe          BL       HAL_TIM_OC_MspInit
                  |L50.28|
00001c  2002              MOVS     r0,#2                 ;512
00001e  f8840039          STRB     r0,[r4,#0x39]         ;512
000022  1d21              ADDS     r1,r4,#4              ;515
000024  6820              LDR      r0,[r4,#0]            ;515
000026  f7fffffe          BL       TIM_Base_SetConfig
00002a  2001              MOVS     r0,#1                 ;518
00002c  f8840039          STRB     r0,[r4,#0x39]         ;518
000030  2000              MOVS     r0,#0                 ;520
000032  e7e9              B        |L50.8|
;;;522    
                          ENDP


                          AREA ||i.HAL_TIM_OC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_MspDeInit PROC
;;;571      */
;;;572    __weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;573    {
;;;574      /* Prevent unused argument(s) compilation warning */
;;;575      UNUSED(htim);
;;;576      /* NOTE : This function Should not be modified, when the callback is needed,
;;;577                the HAL_TIM_OC_MspDeInit could be implemented in the user file
;;;578       */
;;;579    }
;;;580    
                          ENDP


                          AREA ||i.HAL_TIM_OC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_MspInit PROC
;;;556      */
;;;557    __weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;558    {
;;;559      /* Prevent unused argument(s) compilation warning */
;;;560      UNUSED(htim);
;;;561      /* NOTE : This function Should not be modified, when the callback is needed,
;;;562                the HAL_TIM_OC_MspInit could be implemented in the user file
;;;563       */
;;;564    }
;;;565    
                          ENDP


                          AREA ||i.HAL_TIM_OC_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Start PROC
;;;592      */
;;;593    HAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;594    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;595      /* Check the parameters */
;;;596      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;597      
;;;598      /* Enable the Output compare channel */
;;;599      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000006  2201              MOVS     r2,#1
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;600      
;;;601      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000010  490c              LDR      r1,|L53.68|
000012  6820              LDR      r0,[r4,#0]
000014  4288              CMP      r0,r1
000016  d003              BEQ      |L53.32|
000018  490b              LDR      r1,|L53.72|
00001a  6820              LDR      r0,[r4,#0]
00001c  4288              CMP      r0,r1
00001e  d101              BNE      |L53.36|
                  |L53.32|
000020  2001              MOVS     r0,#1
000022  e000              B        |L53.38|
                  |L53.36|
000024  2000              MOVS     r0,#0
                  |L53.38|
000026  b128              CBZ      r0,|L53.52|
;;;602      {
;;;603        /* Enable the main output */
;;;604        __HAL_TIM_MOE_ENABLE(htim);
000028  6820              LDR      r0,[r4,#0]
00002a  6c40              LDR      r0,[r0,#0x44]
00002c  f4404000          ORR      r0,r0,#0x8000
000030  6821              LDR      r1,[r4,#0]
000032  6448              STR      r0,[r1,#0x44]
                  |L53.52|
;;;605      }
;;;606      
;;;607      /* Enable the Peripheral */
;;;608      __HAL_TIM_ENABLE(htim); 
000034  6820              LDR      r0,[r4,#0]
000036  6800              LDR      r0,[r0,#0]
000038  f0400001          ORR      r0,r0,#1
00003c  6821              LDR      r1,[r4,#0]
00003e  6008              STR      r0,[r1,#0]
;;;609      
;;;610      /* Return function status */
;;;611      return HAL_OK;
000040  2000              MOVS     r0,#0
;;;612    }
000042  bd30              POP      {r4,r5,pc}
;;;613    
                          ENDP

                  |L53.68|
                          DCD      0x40010000
                  |L53.72|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Start_DMA PROC
;;;794      */
;;;795    HAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;796    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
00000a  461f              MOV      r7,r3
;;;797      /* Check the parameters */
;;;798      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;799      
;;;800      if((htim->State == HAL_TIM_STATE_BUSY))
00000c  f8940039          LDRB     r0,[r4,#0x39]
000010  2802              CMP      r0,#2
000012  d101              BNE      |L54.24|
                  |L54.20|
;;;801      {
;;;802         return HAL_BUSY;
;;;803      }
;;;804      else if((htim->State == HAL_TIM_STATE_READY))
;;;805      {
;;;806        if(((uint32_t)pData == 0 ) && (Length > 0)) 
;;;807        {
;;;808          return HAL_ERROR;                                    
;;;809        }
;;;810        else
;;;811        {
;;;812          htim->State = HAL_TIM_STATE_BUSY;
;;;813        }
;;;814      }    
;;;815      switch (Channel)
;;;816      {
;;;817        case TIM_CHANNEL_1:
;;;818        {      
;;;819          /* Set the DMA Period elapsed callback */
;;;820          htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;821         
;;;822          /* Set the DMA error callback */
;;;823          htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;824          
;;;825          /* Enable the DMA Stream */
;;;826          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;827          
;;;828          /* Enable the TIM Capture/Compare 1 DMA request */
;;;829          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;830        }
;;;831        break;
;;;832        
;;;833        case TIM_CHANNEL_2:
;;;834        {
;;;835          /* Set the DMA Period elapsed callback */
;;;836          htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;837         
;;;838          /* Set the DMA error callback */
;;;839          htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;840          
;;;841          /* Enable the DMA Stream */
;;;842          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;843          
;;;844          /* Enable the TIM Capture/Compare 2 DMA request */
;;;845          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;846        }
;;;847        break;
;;;848        
;;;849        case TIM_CHANNEL_3:
;;;850        {
;;;851          /* Set the DMA Period elapsed callback */
;;;852          htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;853         
;;;854          /* Set the DMA error callback */
;;;855          htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;856          
;;;857          /* Enable the DMA Stream */
;;;858          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;859          
;;;860          /* Enable the TIM Capture/Compare 3 DMA request */
;;;861          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;862        }
;;;863        break;
;;;864        
;;;865        case TIM_CHANNEL_4:
;;;866        {
;;;867         /* Set the DMA Period elapsed callback */
;;;868          htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;869         
;;;870          /* Set the DMA error callback */
;;;871          htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;872          
;;;873          /* Enable the DMA Stream */
;;;874          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;875          
;;;876          /* Enable the TIM Capture/Compare 4 DMA request */
;;;877          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;878        }
;;;879        break;
;;;880        
;;;881        default:
;;;882        break;
;;;883      }
;;;884    
;;;885      /* Enable the Output compare channel */
;;;886      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;887      
;;;888      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
;;;889      {
;;;890        /* Enable the main output */
;;;891        __HAL_TIM_MOE_ENABLE(htim);
;;;892      }  
;;;893      
;;;894      /* Enable the Peripheral */
;;;895      __HAL_TIM_ENABLE(htim); 
;;;896      
;;;897      /* Return function status */
;;;898      return HAL_OK;
;;;899    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L54.24|
000018  f8940039          LDRB     r0,[r4,#0x39]         ;804
00001c  2801              CMP      r0,#1                 ;804
00001e  d106              BNE      |L54.46|
000020  b915              CBNZ     r5,|L54.40|
000022  2f00              CMP      r7,#0                 ;806
000024  dd00              BLE      |L54.40|
000026  e7f5              B        |L54.20|
                  |L54.40|
000028  2002              MOVS     r0,#2                 ;812
00002a  f8840039          STRB     r0,[r4,#0x39]         ;812
                  |L54.46|
00002e  b136              CBZ      r6,|L54.62|
000030  2e04              CMP      r6,#4                 ;815
000032  d019              BEQ      |L54.104|
000034  2e08              CMP      r6,#8                 ;815
000036  d02c              BEQ      |L54.146|
000038  2e0c              CMP      r6,#0xc               ;815
00003a  d154              BNE      |L54.230|
00003c  e03e              B        |L54.188|
                  |L54.62|
00003e  493a              LDR      r1,|L54.296|
000040  6a20              LDR      r0,[r4,#0x20]         ;820
000042  63c1              STR      r1,[r0,#0x3c]         ;820
000044  4939              LDR      r1,|L54.300|
000046  6a20              LDR      r0,[r4,#0x20]         ;823
000048  6481              STR      r1,[r0,#0x48]         ;823
00004a  6821              LDR      r1,[r4,#0]            ;826
00004c  f1010234          ADD      r2,r1,#0x34           ;826
000050  463b              MOV      r3,r7                 ;826
000052  4629              MOV      r1,r5                 ;826
000054  6a20              LDR      r0,[r4,#0x20]         ;826
000056  f7fffffe          BL       HAL_DMA_Start_IT
00005a  6820              LDR      r0,[r4,#0]            ;829
00005c  68c0              LDR      r0,[r0,#0xc]          ;829
00005e  f4407000          ORR      r0,r0,#0x200          ;829
000062  6821              LDR      r1,[r4,#0]            ;829
000064  60c8              STR      r0,[r1,#0xc]          ;829
000066  e03f              B        |L54.232|
                  |L54.104|
000068  492f              LDR      r1,|L54.296|
00006a  6a60              LDR      r0,[r4,#0x24]         ;836
00006c  63c1              STR      r1,[r0,#0x3c]         ;836
00006e  492f              LDR      r1,|L54.300|
000070  6a60              LDR      r0,[r4,#0x24]         ;839
000072  6481              STR      r1,[r0,#0x48]         ;839
000074  6821              LDR      r1,[r4,#0]            ;842
000076  f1010238          ADD      r2,r1,#0x38           ;842
00007a  463b              MOV      r3,r7                 ;842
00007c  4629              MOV      r1,r5                 ;842
00007e  6a60              LDR      r0,[r4,#0x24]         ;842
000080  f7fffffe          BL       HAL_DMA_Start_IT
000084  6820              LDR      r0,[r4,#0]            ;845
000086  68c0              LDR      r0,[r0,#0xc]          ;845
000088  f4406080          ORR      r0,r0,#0x400          ;845
00008c  6821              LDR      r1,[r4,#0]            ;845
00008e  60c8              STR      r0,[r1,#0xc]          ;845
000090  e02a              B        |L54.232|
                  |L54.146|
000092  4925              LDR      r1,|L54.296|
000094  6aa0              LDR      r0,[r4,#0x28]         ;852
000096  63c1              STR      r1,[r0,#0x3c]         ;852
000098  4924              LDR      r1,|L54.300|
00009a  6aa0              LDR      r0,[r4,#0x28]         ;855
00009c  6481              STR      r1,[r0,#0x48]         ;855
00009e  6821              LDR      r1,[r4,#0]            ;858
0000a0  f101023c          ADD      r2,r1,#0x3c           ;858
0000a4  463b              MOV      r3,r7                 ;858
0000a6  4629              MOV      r1,r5                 ;858
0000a8  6aa0              LDR      r0,[r4,#0x28]         ;858
0000aa  f7fffffe          BL       HAL_DMA_Start_IT
0000ae  6820              LDR      r0,[r4,#0]            ;861
0000b0  68c0              LDR      r0,[r0,#0xc]          ;861
0000b2  f4406000          ORR      r0,r0,#0x800          ;861
0000b6  6821              LDR      r1,[r4,#0]            ;861
0000b8  60c8              STR      r0,[r1,#0xc]          ;861
0000ba  e015              B        |L54.232|
                  |L54.188|
0000bc  491a              LDR      r1,|L54.296|
0000be  6ae0              LDR      r0,[r4,#0x2c]         ;868
0000c0  63c1              STR      r1,[r0,#0x3c]         ;868
0000c2  491a              LDR      r1,|L54.300|
0000c4  6ae0              LDR      r0,[r4,#0x2c]         ;871
0000c6  6481              STR      r1,[r0,#0x48]         ;871
0000c8  6821              LDR      r1,[r4,#0]            ;874
0000ca  f1010240          ADD      r2,r1,#0x40           ;874
0000ce  463b              MOV      r3,r7                 ;874
0000d0  4629              MOV      r1,r5                 ;874
0000d2  6ae0              LDR      r0,[r4,#0x2c]         ;874
0000d4  f7fffffe          BL       HAL_DMA_Start_IT
0000d8  6820              LDR      r0,[r4,#0]            ;877
0000da  68c0              LDR      r0,[r0,#0xc]          ;877
0000dc  f4405080          ORR      r0,r0,#0x1000         ;877
0000e0  6821              LDR      r1,[r4,#0]            ;877
0000e2  60c8              STR      r0,[r1,#0xc]          ;877
0000e4  e000              B        |L54.232|
                  |L54.230|
0000e6  bf00              NOP                            ;882
                  |L54.232|
0000e8  bf00              NOP                            ;831
0000ea  2201              MOVS     r2,#1                 ;886
0000ec  4631              MOV      r1,r6                 ;886
0000ee  6820              LDR      r0,[r4,#0]            ;886
0000f0  f7fffffe          BL       TIM_CCxChannelCmd
0000f4  490e              LDR      r1,|L54.304|
0000f6  6820              LDR      r0,[r4,#0]            ;888
0000f8  4288              CMP      r0,r1                 ;888
0000fa  d003              BEQ      |L54.260|
0000fc  490d              LDR      r1,|L54.308|
0000fe  6820              LDR      r0,[r4,#0]            ;888
000100  4288              CMP      r0,r1                 ;888
000102  d101              BNE      |L54.264|
                  |L54.260|
000104  2001              MOVS     r0,#1                 ;888
000106  e000              B        |L54.266|
                  |L54.264|
000108  2000              MOVS     r0,#0                 ;888
                  |L54.266|
00010a  b128              CBZ      r0,|L54.280|
00010c  6820              LDR      r0,[r4,#0]            ;891
00010e  6c40              LDR      r0,[r0,#0x44]         ;891
000110  f4404000          ORR      r0,r0,#0x8000         ;891
000114  6821              LDR      r1,[r4,#0]            ;891
000116  6448              STR      r0,[r1,#0x44]         ;891
                  |L54.280|
000118  6820              LDR      r0,[r4,#0]            ;895
00011a  6800              LDR      r0,[r0,#0]            ;895
00011c  f0400001          ORR      r0,r0,#1              ;895
000120  6821              LDR      r1,[r4,#0]            ;895
000122  6008              STR      r0,[r1,#0]            ;895
000124  2000              MOVS     r0,#0                 ;898
000126  e775              B        |L54.20|
;;;900    
                          ENDP

                  |L54.296|
                          DCD      TIM_DMADelayPulseCplt
                  |L54.300|
                          DCD      TIM_DMAError
                  |L54.304|
                          DCD      0x40010000
                  |L54.308|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OC_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Start_IT PROC
;;;658      */
;;;659    HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;660    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;661      /* Check the parameters */
;;;662      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;663      
;;;664      switch (Channel)
000006  b135              CBZ      r5,|L55.22|
000008  2d04              CMP      r5,#4
00000a  d00b              BEQ      |L55.36|
00000c  2d08              CMP      r5,#8
00000e  d010              BEQ      |L55.50|
000010  2d0c              CMP      r5,#0xc
000012  d11c              BNE      |L55.78|
000014  e014              B        |L55.64|
                  |L55.22|
;;;665      {
;;;666        case TIM_CHANNEL_1:
;;;667        {       
;;;668          /* Enable the TIM Capture/Compare 1 interrupt */
;;;669          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000016  6820              LDR      r0,[r4,#0]
000018  68c0              LDR      r0,[r0,#0xc]
00001a  f0400002          ORR      r0,r0,#2
00001e  6821              LDR      r1,[r4,#0]
000020  60c8              STR      r0,[r1,#0xc]
;;;670        }
;;;671        break;
000022  e015              B        |L55.80|
                  |L55.36|
;;;672        
;;;673        case TIM_CHANNEL_2:
;;;674        {
;;;675          /* Enable the TIM Capture/Compare 2 interrupt */
;;;676          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000024  6820              LDR      r0,[r4,#0]
000026  68c0              LDR      r0,[r0,#0xc]
000028  f0400004          ORR      r0,r0,#4
00002c  6821              LDR      r1,[r4,#0]
00002e  60c8              STR      r0,[r1,#0xc]
;;;677        }
;;;678        break;
000030  e00e              B        |L55.80|
                  |L55.50|
;;;679        
;;;680        case TIM_CHANNEL_3:
;;;681        {
;;;682          /* Enable the TIM Capture/Compare 3 interrupt */
;;;683          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
000032  6820              LDR      r0,[r4,#0]
000034  68c0              LDR      r0,[r0,#0xc]
000036  f0400008          ORR      r0,r0,#8
00003a  6821              LDR      r1,[r4,#0]
00003c  60c8              STR      r0,[r1,#0xc]
;;;684        }
;;;685        break;
00003e  e007              B        |L55.80|
                  |L55.64|
;;;686        
;;;687        case TIM_CHANNEL_4:
;;;688        {
;;;689          /* Enable the TIM Capture/Compare 4 interrupt */
;;;690          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000040  6820              LDR      r0,[r4,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  f0400010          ORR      r0,r0,#0x10
000048  6821              LDR      r1,[r4,#0]
00004a  60c8              STR      r0,[r1,#0xc]
;;;691        }
;;;692        break;
00004c  e000              B        |L55.80|
                  |L55.78|
;;;693        
;;;694        default:
;;;695        break;
00004e  bf00              NOP      
                  |L55.80|
000050  bf00              NOP                            ;671
;;;696      } 
;;;697    
;;;698      /* Enable the Output compare channel */
;;;699      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000052  2201              MOVS     r2,#1
000054  4629              MOV      r1,r5
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       TIM_CCxChannelCmd
;;;700      
;;;701      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00005c  490c              LDR      r1,|L55.144|
00005e  6820              LDR      r0,[r4,#0]
000060  4288              CMP      r0,r1
000062  d003              BEQ      |L55.108|
000064  490b              LDR      r1,|L55.148|
000066  6820              LDR      r0,[r4,#0]
000068  4288              CMP      r0,r1
00006a  d101              BNE      |L55.112|
                  |L55.108|
00006c  2001              MOVS     r0,#1
00006e  e000              B        |L55.114|
                  |L55.112|
000070  2000              MOVS     r0,#0
                  |L55.114|
000072  b128              CBZ      r0,|L55.128|
;;;702      {
;;;703        /* Enable the main output */
;;;704        __HAL_TIM_MOE_ENABLE(htim);
000074  6820              LDR      r0,[r4,#0]
000076  6c40              LDR      r0,[r0,#0x44]
000078  f4404000          ORR      r0,r0,#0x8000
00007c  6821              LDR      r1,[r4,#0]
00007e  6448              STR      r0,[r1,#0x44]
                  |L55.128|
;;;705      }
;;;706    
;;;707      /* Enable the Peripheral */
;;;708      __HAL_TIM_ENABLE(htim);
000080  6820              LDR      r0,[r4,#0]
000082  6800              LDR      r0,[r0,#0]
000084  f0400001          ORR      r0,r0,#1
000088  6821              LDR      r1,[r4,#0]
00008a  6008              STR      r0,[r1,#0]
;;;709      
;;;710      /* Return function status */
;;;711      return HAL_OK;
00008c  2000              MOVS     r0,#0
;;;712    }
00008e  bd30              POP      {r4,r5,pc}
;;;713    
                          ENDP

                  |L55.144|
                          DCD      0x40010000
                  |L55.148|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OC_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Stop PROC
;;;625      */
;;;626    HAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;627    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;628      /* Check the parameters */
;;;629      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;630      
;;;631      /* Disable the Output compare channel */
;;;632      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000006  2200              MOVS     r2,#0
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;633      
;;;634      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000010  4919              LDR      r1,|L56.120|
000012  6820              LDR      r0,[r4,#0]
000014  4288              CMP      r0,r1
000016  d003              BEQ      |L56.32|
000018  4918              LDR      r1,|L56.124|
00001a  6820              LDR      r0,[r4,#0]
00001c  4288              CMP      r0,r1
00001e  d101              BNE      |L56.36|
                  |L56.32|
000020  2001              MOVS     r0,#1
000022  e000              B        |L56.38|
                  |L56.36|
000024  2000              MOVS     r0,#0
                  |L56.38|
000026  b190              CBZ      r0,|L56.78|
;;;635      {
;;;636        /* Disable the Main Output */
;;;637        __HAL_TIM_MOE_DISABLE(htim);
000028  bf00              NOP      
00002a  6820              LDR      r0,[r4,#0]
00002c  6a00              LDR      r0,[r0,#0x20]
00002e  f2411111          MOV      r1,#0x1111
000032  4008              ANDS     r0,r0,r1
000034  b950              CBNZ     r0,|L56.76|
000036  6820              LDR      r0,[r4,#0]
000038  6a00              LDR      r0,[r0,#0x20]
00003a  1089              ASRS     r1,r1,#2
00003c  4008              ANDS     r0,r0,r1
00003e  b928              CBNZ     r0,|L56.76|
000040  6820              LDR      r0,[r4,#0]
000042  6c40              LDR      r0,[r0,#0x44]
000044  f4204000          BIC      r0,r0,#0x8000
000048  6821              LDR      r1,[r4,#0]
00004a  6448              STR      r0,[r1,#0x44]
                  |L56.76|
00004c  bf00              NOP      
                  |L56.78|
;;;638      }  
;;;639      
;;;640      /* Disable the Peripheral */
;;;641      __HAL_TIM_DISABLE(htim);  
00004e  bf00              NOP      
000050  6820              LDR      r0,[r4,#0]
000052  6a00              LDR      r0,[r0,#0x20]
000054  f2411111          MOV      r1,#0x1111
000058  4008              ANDS     r0,r0,r1
00005a  b950              CBNZ     r0,|L56.114|
00005c  6820              LDR      r0,[r4,#0]
00005e  6a00              LDR      r0,[r0,#0x20]
000060  1089              ASRS     r1,r1,#2
000062  4008              ANDS     r0,r0,r1
000064  b928              CBNZ     r0,|L56.114|
000066  6820              LDR      r0,[r4,#0]
000068  6800              LDR      r0,[r0,#0]
00006a  f0200001          BIC      r0,r0,#1
00006e  6821              LDR      r1,[r4,#0]
000070  6008              STR      r0,[r1,#0]
                  |L56.114|
000072  bf00              NOP      
;;;642      
;;;643      /* Return function status */
;;;644      return HAL_OK;
000074  2000              MOVS     r0,#0
;;;645    }  
000076  bd30              POP      {r4,r5,pc}
;;;646    
                          ENDP

                  |L56.120|
                          DCD      0x40010000
                  |L56.124|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OC_Stop_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Stop_DMA PROC
;;;912      */
;;;913    HAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;914    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;915      /* Check the parameters */
;;;916      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;917      
;;;918      switch (Channel)
000006  b135              CBZ      r5,|L57.22|
000008  2d04              CMP      r5,#4
00000a  d00b              BEQ      |L57.36|
00000c  2d08              CMP      r5,#8
00000e  d010              BEQ      |L57.50|
000010  2d0c              CMP      r5,#0xc
000012  d11c              BNE      |L57.78|
000014  e014              B        |L57.64|
                  |L57.22|
;;;919      {
;;;920        case TIM_CHANNEL_1:
;;;921        {       
;;;922          /* Disable the TIM Capture/Compare 1 DMA request */
;;;923          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000016  6820              LDR      r0,[r4,#0]
000018  68c0              LDR      r0,[r0,#0xc]
00001a  f4207000          BIC      r0,r0,#0x200
00001e  6821              LDR      r1,[r4,#0]
000020  60c8              STR      r0,[r1,#0xc]
;;;924        }
;;;925        break;
000022  e015              B        |L57.80|
                  |L57.36|
;;;926        
;;;927        case TIM_CHANNEL_2:
;;;928        {
;;;929          /* Disable the TIM Capture/Compare 2 DMA request */
;;;930          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000024  6820              LDR      r0,[r4,#0]
000026  68c0              LDR      r0,[r0,#0xc]
000028  f4206080          BIC      r0,r0,#0x400
00002c  6821              LDR      r1,[r4,#0]
00002e  60c8              STR      r0,[r1,#0xc]
;;;931        }
;;;932        break;
000030  e00e              B        |L57.80|
                  |L57.50|
;;;933        
;;;934        case TIM_CHANNEL_3:
;;;935        {
;;;936          /* Disable the TIM Capture/Compare 3 DMA request */
;;;937          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
000032  6820              LDR      r0,[r4,#0]
000034  68c0              LDR      r0,[r0,#0xc]
000036  f4206000          BIC      r0,r0,#0x800
00003a  6821              LDR      r1,[r4,#0]
00003c  60c8              STR      r0,[r1,#0xc]
;;;938        }
;;;939        break;
00003e  e007              B        |L57.80|
                  |L57.64|
;;;940        
;;;941        case TIM_CHANNEL_4:
;;;942        {
;;;943          /* Disable the TIM Capture/Compare 4 interrupt */
;;;944          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
000040  6820              LDR      r0,[r4,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  f4205080          BIC      r0,r0,#0x1000
000048  6821              LDR      r1,[r4,#0]
00004a  60c8              STR      r0,[r1,#0xc]
;;;945        }
;;;946        break;
00004c  e000              B        |L57.80|
                  |L57.78|
;;;947        
;;;948        default:
;;;949        break;
00004e  bf00              NOP      
                  |L57.80|
000050  bf00              NOP                            ;925
;;;950      } 
;;;951      
;;;952      /* Disable the Output compare channel */
;;;953      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000052  2200              MOVS     r2,#0
000054  4629              MOV      r1,r5
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       TIM_CCxChannelCmd
;;;954      
;;;955      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00005c  491b              LDR      r1,|L57.204|
00005e  6820              LDR      r0,[r4,#0]
000060  4288              CMP      r0,r1
000062  d003              BEQ      |L57.108|
000064  491a              LDR      r1,|L57.208|
000066  6820              LDR      r0,[r4,#0]
000068  4288              CMP      r0,r1
00006a  d101              BNE      |L57.112|
                  |L57.108|
00006c  2001              MOVS     r0,#1
00006e  e000              B        |L57.114|
                  |L57.112|
000070  2000              MOVS     r0,#0
                  |L57.114|
000072  b190              CBZ      r0,|L57.154|
;;;956      {
;;;957        /* Disable the Main Output */
;;;958        __HAL_TIM_MOE_DISABLE(htim);
000074  bf00              NOP      
000076  6820              LDR      r0,[r4,#0]
000078  6a00              LDR      r0,[r0,#0x20]
00007a  f2411111          MOV      r1,#0x1111
00007e  4008              ANDS     r0,r0,r1
000080  b950              CBNZ     r0,|L57.152|
000082  6820              LDR      r0,[r4,#0]
000084  6a00              LDR      r0,[r0,#0x20]
000086  1089              ASRS     r1,r1,#2
000088  4008              ANDS     r0,r0,r1
00008a  b928              CBNZ     r0,|L57.152|
00008c  6820              LDR      r0,[r4,#0]
00008e  6c40              LDR      r0,[r0,#0x44]
000090  f4204000          BIC      r0,r0,#0x8000
000094  6821              LDR      r1,[r4,#0]
000096  6448              STR      r0,[r1,#0x44]
                  |L57.152|
000098  bf00              NOP      
                  |L57.154|
;;;959      }
;;;960      
;;;961      /* Disable the Peripheral */
;;;962      __HAL_TIM_DISABLE(htim);
00009a  bf00              NOP      
00009c  6820              LDR      r0,[r4,#0]
00009e  6a00              LDR      r0,[r0,#0x20]
0000a0  f2411111          MOV      r1,#0x1111
0000a4  4008              ANDS     r0,r0,r1
0000a6  b950              CBNZ     r0,|L57.190|
0000a8  6820              LDR      r0,[r4,#0]
0000aa  6a00              LDR      r0,[r0,#0x20]
0000ac  1089              ASRS     r1,r1,#2
0000ae  4008              ANDS     r0,r0,r1
0000b0  b928              CBNZ     r0,|L57.190|
0000b2  6820              LDR      r0,[r4,#0]
0000b4  6800              LDR      r0,[r0,#0]
0000b6  f0200001          BIC      r0,r0,#1
0000ba  6821              LDR      r1,[r4,#0]
0000bc  6008              STR      r0,[r1,#0]
                  |L57.190|
0000be  bf00              NOP      
;;;963      
;;;964      /* Change the htim state */
;;;965      htim->State = HAL_TIM_STATE_READY;
0000c0  2001              MOVS     r0,#1
0000c2  f8840039          STRB     r0,[r4,#0x39]
;;;966      
;;;967      /* Return function status */
;;;968      return HAL_OK;
0000c6  2000              MOVS     r0,#0
;;;969    }
0000c8  bd30              POP      {r4,r5,pc}
;;;970    /**
                          ENDP

0000ca  0000              DCW      0x0000
                  |L57.204|
                          DCD      0x40010000
                  |L57.208|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OC_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Stop_IT PROC
;;;725      */
;;;726    HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;727    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;728      /* Check the parameters */
;;;729      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;730      
;;;731      switch (Channel)
000006  b135              CBZ      r5,|L58.22|
000008  2d04              CMP      r5,#4
00000a  d00b              BEQ      |L58.36|
00000c  2d08              CMP      r5,#8
00000e  d010              BEQ      |L58.50|
000010  2d0c              CMP      r5,#0xc
000012  d11c              BNE      |L58.78|
000014  e014              B        |L58.64|
                  |L58.22|
;;;732      {
;;;733        case TIM_CHANNEL_1:
;;;734        {       
;;;735          /* Disable the TIM Capture/Compare 1 interrupt */
;;;736          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000016  6820              LDR      r0,[r4,#0]
000018  68c0              LDR      r0,[r0,#0xc]
00001a  f0200002          BIC      r0,r0,#2
00001e  6821              LDR      r1,[r4,#0]
000020  60c8              STR      r0,[r1,#0xc]
;;;737        }
;;;738        break;
000022  e015              B        |L58.80|
                  |L58.36|
;;;739        
;;;740        case TIM_CHANNEL_2:
;;;741        {
;;;742          /* Disable the TIM Capture/Compare 2 interrupt */
;;;743          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000024  6820              LDR      r0,[r4,#0]
000026  68c0              LDR      r0,[r0,#0xc]
000028  f0200004          BIC      r0,r0,#4
00002c  6821              LDR      r1,[r4,#0]
00002e  60c8              STR      r0,[r1,#0xc]
;;;744        }
;;;745        break;
000030  e00e              B        |L58.80|
                  |L58.50|
;;;746        
;;;747        case TIM_CHANNEL_3:
;;;748        {
;;;749          /* Disable the TIM Capture/Compare 3 interrupt */
;;;750          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
000032  6820              LDR      r0,[r4,#0]
000034  68c0              LDR      r0,[r0,#0xc]
000036  f0200008          BIC      r0,r0,#8
00003a  6821              LDR      r1,[r4,#0]
00003c  60c8              STR      r0,[r1,#0xc]
;;;751        }
;;;752        break;
00003e  e007              B        |L58.80|
                  |L58.64|
;;;753        
;;;754        case TIM_CHANNEL_4:
;;;755        {
;;;756          /* Disable the TIM Capture/Compare 4 interrupt */
;;;757          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
000040  6820              LDR      r0,[r4,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  f0200010          BIC      r0,r0,#0x10
000048  6821              LDR      r1,[r4,#0]
00004a  60c8              STR      r0,[r1,#0xc]
;;;758        }
;;;759        break;
00004c  e000              B        |L58.80|
                  |L58.78|
;;;760        
;;;761        default:
;;;762        break; 
00004e  bf00              NOP      
                  |L58.80|
000050  bf00              NOP                            ;738
;;;763      } 
;;;764      
;;;765      /* Disable the Output compare channel */
;;;766      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE); 
000052  2200              MOVS     r2,#0
000054  4629              MOV      r1,r5
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       TIM_CCxChannelCmd
;;;767      
;;;768      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00005c  4919              LDR      r1,|L58.196|
00005e  6820              LDR      r0,[r4,#0]
000060  4288              CMP      r0,r1
000062  d003              BEQ      |L58.108|
000064  4918              LDR      r1,|L58.200|
000066  6820              LDR      r0,[r4,#0]
000068  4288              CMP      r0,r1
00006a  d101              BNE      |L58.112|
                  |L58.108|
00006c  2001              MOVS     r0,#1
00006e  e000              B        |L58.114|
                  |L58.112|
000070  2000              MOVS     r0,#0
                  |L58.114|
000072  b190              CBZ      r0,|L58.154|
;;;769      {
;;;770        /* Disable the Main Output */
;;;771        __HAL_TIM_MOE_DISABLE(htim);
000074  bf00              NOP      
000076  6820              LDR      r0,[r4,#0]
000078  6a00              LDR      r0,[r0,#0x20]
00007a  f2411111          MOV      r1,#0x1111
00007e  4008              ANDS     r0,r0,r1
000080  b950              CBNZ     r0,|L58.152|
000082  6820              LDR      r0,[r4,#0]
000084  6a00              LDR      r0,[r0,#0x20]
000086  1089              ASRS     r1,r1,#2
000088  4008              ANDS     r0,r0,r1
00008a  b928              CBNZ     r0,|L58.152|
00008c  6820              LDR      r0,[r4,#0]
00008e  6c40              LDR      r0,[r0,#0x44]
000090  f4204000          BIC      r0,r0,#0x8000
000094  6821              LDR      r1,[r4,#0]
000096  6448              STR      r0,[r1,#0x44]
                  |L58.152|
000098  bf00              NOP      
                  |L58.154|
;;;772      }
;;;773      
;;;774      /* Disable the Peripheral */
;;;775      __HAL_TIM_DISABLE(htim);  
00009a  bf00              NOP      
00009c  6820              LDR      r0,[r4,#0]
00009e  6a00              LDR      r0,[r0,#0x20]
0000a0  f2411111          MOV      r1,#0x1111
0000a4  4008              ANDS     r0,r0,r1
0000a6  b950              CBNZ     r0,|L58.190|
0000a8  6820              LDR      r0,[r4,#0]
0000aa  6a00              LDR      r0,[r0,#0x20]
0000ac  1089              ASRS     r1,r1,#2
0000ae  4008              ANDS     r0,r0,r1
0000b0  b928              CBNZ     r0,|L58.190|
0000b2  6820              LDR      r0,[r4,#0]
0000b4  6800              LDR      r0,[r0,#0]
0000b6  f0200001          BIC      r0,r0,#1
0000ba  6821              LDR      r1,[r4,#0]
0000bc  6008              STR      r0,[r1,#0]
                  |L58.190|
0000be  bf00              NOP      
;;;776      
;;;777      /* Return function status */
;;;778      return HAL_OK;
0000c0  2000              MOVS     r0,#0
;;;779    }
0000c2  bd30              POP      {r4,r5,pc}
;;;780    
                          ENDP

                  |L58.196|
                          DCD      0x40010000
                  |L58.200|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OnePulse_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_ConfigChannel PROC
;;;3229     */
;;;3230   HAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim,  TIM_OnePulse_InitTypeDef* sConfig, uint32_t OutputChannel,  uint32_t InputChannel)
000000  b5f0              PUSH     {r4-r7,lr}
;;;3231   {
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;3232     TIM_OC_InitTypeDef temp1;
;;;3233     
;;;3234     /* Check the parameters */
;;;3235     assert_param(IS_TIM_OPM_CHANNELS(OutputChannel));
;;;3236     assert_param(IS_TIM_OPM_CHANNELS(InputChannel));
;;;3237   
;;;3238     if(OutputChannel != InputChannel)  
00000c  42be              CMP      r6,r7
00000e  d078              BEQ      |L59.258|
;;;3239     {
;;;3240       __HAL_LOCK(htim);
000010  bf00              NOP      
000012  f8940038          LDRB     r0,[r4,#0x38]
000016  2801              CMP      r0,#1
000018  d102              BNE      |L59.32|
00001a  2002              MOVS     r0,#2
                  |L59.28|
;;;3241     
;;;3242       htim->State = HAL_TIM_STATE_BUSY;
;;;3243   
;;;3244       /* Extract the Output compare configuration from sConfig structure */  
;;;3245       temp1.OCMode = sConfig->OCMode;
;;;3246       temp1.Pulse = sConfig->Pulse;
;;;3247       temp1.OCPolarity = sConfig->OCPolarity;
;;;3248       temp1.OCNPolarity = sConfig->OCNPolarity;
;;;3249       temp1.OCIdleState = sConfig->OCIdleState;
;;;3250       temp1.OCNIdleState = sConfig->OCNIdleState; 
;;;3251       
;;;3252       switch (OutputChannel)
;;;3253       {
;;;3254         case TIM_CHANNEL_1:
;;;3255         {
;;;3256           assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3257         
;;;3258           TIM_OC1_SetConfig(htim->Instance, &temp1); 
;;;3259         }
;;;3260         break;
;;;3261         case TIM_CHANNEL_2:
;;;3262         {
;;;3263           assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3264         
;;;3265           TIM_OC2_SetConfig(htim->Instance, &temp1);
;;;3266         }
;;;3267         break;
;;;3268         default:
;;;3269         break;  
;;;3270       } 
;;;3271       switch (InputChannel)
;;;3272       {
;;;3273         case TIM_CHANNEL_1:
;;;3274         {
;;;3275           assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3276         
;;;3277           TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,
;;;3278                           sConfig->ICSelection, sConfig->ICFilter);
;;;3279                  
;;;3280           /* Reset the IC1PSC Bits */
;;;3281           htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;3282   
;;;3283           /* Select the Trigger source */
;;;3284           htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;3285           htim->Instance->SMCR |= TIM_TS_TI1FP1;
;;;3286         
;;;3287           /* Select the Slave Mode */      
;;;3288           htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3289           htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
;;;3290         }
;;;3291         break;
;;;3292         case TIM_CHANNEL_2:
;;;3293         {
;;;3294           assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3295         
;;;3296           TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,
;;;3297                    sConfig->ICSelection, sConfig->ICFilter);
;;;3298                  
;;;3299           /* Reset the IC2PSC Bits */
;;;3300           htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
;;;3301   
;;;3302           /* Select the Trigger source */
;;;3303           htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;3304           htim->Instance->SMCR |= TIM_TS_TI2FP2;
;;;3305         
;;;3306           /* Select the Slave Mode */      
;;;3307           htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3308           htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
;;;3309         }
;;;3310         break;
;;;3311       
;;;3312         default:
;;;3313         break;  
;;;3314       }
;;;3315     
;;;3316       htim->State = HAL_TIM_STATE_READY;
;;;3317       
;;;3318       __HAL_UNLOCK(htim);
;;;3319     
;;;3320       return HAL_OK;
;;;3321     }
;;;3322     else
;;;3323     {
;;;3324       return HAL_ERROR;
;;;3325     }
;;;3326   } 
00001c  b007              ADD      sp,sp,#0x1c
00001e  bdf0              POP      {r4-r7,pc}
                  |L59.32|
000020  2001              MOVS     r0,#1                 ;3240
000022  f8840038          STRB     r0,[r4,#0x38]         ;3240
000026  bf00              NOP                            ;3240
000028  2002              MOVS     r0,#2                 ;3242
00002a  f8840039          STRB     r0,[r4,#0x39]         ;3242
00002e  6828              LDR      r0,[r5,#0]            ;3245
000030  9000              STR      r0,[sp,#0]            ;3245
000032  6868              LDR      r0,[r5,#4]            ;3246
000034  9001              STR      r0,[sp,#4]            ;3246
000036  68a8              LDR      r0,[r5,#8]            ;3247
000038  9002              STR      r0,[sp,#8]            ;3247
00003a  68e8              LDR      r0,[r5,#0xc]          ;3248
00003c  9003              STR      r0,[sp,#0xc]          ;3248
00003e  6928              LDR      r0,[r5,#0x10]         ;3249
000040  9005              STR      r0,[sp,#0x14]         ;3249
000042  6968              LDR      r0,[r5,#0x14]         ;3250
000044  9006              STR      r0,[sp,#0x18]         ;3250
000046  b116              CBZ      r6,|L59.78|
000048  2e04              CMP      r6,#4                 ;3252
00004a  d10a              BNE      |L59.98|
00004c  e004              B        |L59.88|
                  |L59.78|
00004e  4669              MOV      r1,sp                 ;3258
000050  6820              LDR      r0,[r4,#0]            ;3258
000052  f7fffffe          BL       TIM_OC1_SetConfig
000056  e005              B        |L59.100|
                  |L59.88|
000058  4669              MOV      r1,sp                 ;3265
00005a  6820              LDR      r0,[r4,#0]            ;3265
00005c  f7fffffe          BL       TIM_OC2_SetConfig
000060  e000              B        |L59.100|
                  |L59.98|
000062  bf00              NOP                            ;3269
                  |L59.100|
000064  bf00              NOP                            ;3260
000066  b117              CBZ      r7,|L59.110|
000068  2f04              CMP      r7,#4                 ;3271
00006a  d14b              BNE      |L59.260|
00006c  e024              B        |L59.184|
                  |L59.110|
00006e  e9d52307          LDRD     r2,r3,[r5,#0x1c]      ;3277
000072  69a9              LDR      r1,[r5,#0x18]         ;3277
000074  6820              LDR      r0,[r4,#0]            ;3277
000076  f7fffffe          BL       TIM_TI1_SetConfig
00007a  6820              LDR      r0,[r4,#0]            ;3281
00007c  6980              LDR      r0,[r0,#0x18]         ;3281
00007e  f020000c          BIC      r0,r0,#0xc            ;3281
000082  6821              LDR      r1,[r4,#0]            ;3281
000084  6188              STR      r0,[r1,#0x18]         ;3281
000086  6820              LDR      r0,[r4,#0]            ;3284
000088  6880              LDR      r0,[r0,#8]            ;3284
00008a  f0200070          BIC      r0,r0,#0x70           ;3284
00008e  6821              LDR      r1,[r4,#0]            ;3284
000090  6088              STR      r0,[r1,#8]            ;3284
000092  6820              LDR      r0,[r4,#0]            ;3285
000094  6880              LDR      r0,[r0,#8]            ;3285
000096  f0400050          ORR      r0,r0,#0x50           ;3285
00009a  6821              LDR      r1,[r4,#0]            ;3285
00009c  6088              STR      r0,[r1,#8]            ;3285
00009e  6820              LDR      r0,[r4,#0]            ;3288
0000a0  6880              LDR      r0,[r0,#8]            ;3288
0000a2  f0200007          BIC      r0,r0,#7              ;3288
0000a6  6821              LDR      r1,[r4,#0]            ;3288
0000a8  6088              STR      r0,[r1,#8]            ;3288
0000aa  6820              LDR      r0,[r4,#0]            ;3289
0000ac  6880              LDR      r0,[r0,#8]            ;3289
0000ae  f0400006          ORR      r0,r0,#6              ;3289
0000b2  6821              LDR      r1,[r4,#0]            ;3289
0000b4  6088              STR      r0,[r1,#8]            ;3289
0000b6  e026              B        |L59.262|
                  |L59.184|
0000b8  e9d52307          LDRD     r2,r3,[r5,#0x1c]      ;3296
0000bc  69a9              LDR      r1,[r5,#0x18]         ;3296
0000be  6820              LDR      r0,[r4,#0]            ;3296
0000c0  f7fffffe          BL       TIM_TI2_SetConfig
0000c4  6820              LDR      r0,[r4,#0]            ;3300
0000c6  6980              LDR      r0,[r0,#0x18]         ;3300
0000c8  f4206040          BIC      r0,r0,#0xc00          ;3300
0000cc  6821              LDR      r1,[r4,#0]            ;3300
0000ce  6188              STR      r0,[r1,#0x18]         ;3300
0000d0  6820              LDR      r0,[r4,#0]            ;3303
0000d2  6880              LDR      r0,[r0,#8]            ;3303
0000d4  f0200070          BIC      r0,r0,#0x70           ;3303
0000d8  6821              LDR      r1,[r4,#0]            ;3303
0000da  6088              STR      r0,[r1,#8]            ;3303
0000dc  6820              LDR      r0,[r4,#0]            ;3304
0000de  6880              LDR      r0,[r0,#8]            ;3304
0000e0  f0400060          ORR      r0,r0,#0x60           ;3304
0000e4  6821              LDR      r1,[r4,#0]            ;3304
0000e6  6088              STR      r0,[r1,#8]            ;3304
0000e8  6820              LDR      r0,[r4,#0]            ;3307
0000ea  6880              LDR      r0,[r0,#8]            ;3307
0000ec  f0200007          BIC      r0,r0,#7              ;3307
0000f0  6821              LDR      r1,[r4,#0]            ;3307
0000f2  6088              STR      r0,[r1,#8]            ;3307
0000f4  6820              LDR      r0,[r4,#0]            ;3308
0000f6  6880              LDR      r0,[r0,#8]            ;3308
0000f8  f0400006          ORR      r0,r0,#6              ;3308
0000fc  6821              LDR      r1,[r4,#0]            ;3308
0000fe  6088              STR      r0,[r1,#8]            ;3308
000100  e001              B        |L59.262|
                  |L59.258|
000102  e00a              B        |L59.282|
                  |L59.260|
000104  bf00              NOP                            ;3313
                  |L59.262|
000106  bf00              NOP                            ;3291
000108  2001              MOVS     r0,#1                 ;3316
00010a  f8840039          STRB     r0,[r4,#0x39]         ;3316
00010e  bf00              NOP                            ;3318
000110  2000              MOVS     r0,#0                 ;3318
000112  f8840038          STRB     r0,[r4,#0x38]         ;3318
000116  bf00              NOP                            ;3318
000118  e780              B        |L59.28|
                  |L59.282|
00011a  2001              MOVS     r0,#1                 ;3324
00011c  e77e              B        |L59.28|
;;;3327   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_DeInit PROC
;;;2044     */
;;;2045   HAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;2046   {
000002  4604              MOV      r4,r0
;;;2047     /* Check the parameters */
;;;2048     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2049     
;;;2050     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f8840039          STRB     r0,[r4,#0x39]
;;;2051     
;;;2052     /* Disable the TIM Peripheral Clock */
;;;2053     __HAL_TIM_DISABLE(htim);
00000a  bf00              NOP      
00000c  6820              LDR      r0,[r4,#0]
00000e  6a00              LDR      r0,[r0,#0x20]
000010  f2411111          MOV      r1,#0x1111
000014  4008              ANDS     r0,r0,r1
000016  b950              CBNZ     r0,|L60.46|
000018  6820              LDR      r0,[r4,#0]
00001a  6a00              LDR      r0,[r0,#0x20]
00001c  1089              ASRS     r1,r1,#2
00001e  4008              ANDS     r0,r0,r1
000020  b928              CBNZ     r0,|L60.46|
000022  6820              LDR      r0,[r4,#0]
000024  6800              LDR      r0,[r0,#0]
000026  f0200001          BIC      r0,r0,#1
00002a  6821              LDR      r1,[r4,#0]
00002c  6008              STR      r0,[r1,#0]
                  |L60.46|
00002e  bf00              NOP      
;;;2054     
;;;2055     /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;2056     HAL_TIM_OnePulse_MspDeInit(htim);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       HAL_TIM_OnePulse_MspDeInit
;;;2057       
;;;2058     /* Change TIM state */  
;;;2059     htim->State = HAL_TIM_STATE_RESET;
000036  2000              MOVS     r0,#0
000038  f8840039          STRB     r0,[r4,#0x39]
;;;2060   
;;;2061     /* Release Lock */
;;;2062     __HAL_UNLOCK(htim);
00003c  bf00              NOP      
00003e  f8840038          STRB     r0,[r4,#0x38]
000042  bf00              NOP      
;;;2063   
;;;2064     return HAL_OK;
;;;2065   }
000044  bd10              POP      {r4,pc}
;;;2066   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_GetState PROC
;;;4445     */
;;;4446   HAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;4447   {
;;;4448     return htim->State;
000002  f8910039          LDRB     r0,[r1,#0x39]
;;;4449   }
000006  4770              BX       lr
;;;4450   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_Init PROC
;;;1998     */
;;;1999   HAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode)
000000  b570              PUSH     {r4-r6,lr}
;;;2000   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2001     /* Check the TIM handle allocation */
;;;2002     if(htim == NULL)
000006  b90c              CBNZ     r4,|L62.12|
;;;2003     {
;;;2004       return HAL_ERROR;
000008  2001              MOVS     r0,#1
                  |L62.10|
;;;2005     }
;;;2006   
;;;2007     /* Check the parameters */
;;;2008     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2009     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;2010     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;2011     assert_param(IS_TIM_OPM_MODE(OnePulseMode));
;;;2012     
;;;2013     if(htim->State == HAL_TIM_STATE_RESET)
;;;2014     { 
;;;2015       /* Allocate lock resource and initialize it */
;;;2016       htim->Lock = HAL_UNLOCKED;
;;;2017       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;2018       HAL_TIM_OnePulse_MspInit(htim);
;;;2019     }
;;;2020     
;;;2021     /* Set the TIM state */
;;;2022     htim->State= HAL_TIM_STATE_BUSY;  
;;;2023     
;;;2024     /* Configure the Time base in the One Pulse Mode */
;;;2025     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;2026     
;;;2027     /* Reset the OPM Bit */
;;;2028     htim->Instance->CR1 &= ~TIM_CR1_OPM;
;;;2029   
;;;2030     /* Configure the OPM Mode */
;;;2031     htim->Instance->CR1 |= OnePulseMode;
;;;2032      
;;;2033     /* Initialize the TIM state*/
;;;2034     htim->State= HAL_TIM_STATE_READY;
;;;2035     
;;;2036     return HAL_OK;
;;;2037   }
00000a  bd70              POP      {r4-r6,pc}
                  |L62.12|
00000c  f8940039          LDRB     r0,[r4,#0x39]         ;2013
000010  b928              CBNZ     r0,|L62.30|
000012  2000              MOVS     r0,#0                 ;2016
000014  f8840038          STRB     r0,[r4,#0x38]         ;2016
000018  4620              MOV      r0,r4                 ;2018
00001a  f7fffffe          BL       HAL_TIM_OnePulse_MspInit
                  |L62.30|
00001e  2002              MOVS     r0,#2                 ;2022
000020  f8840039          STRB     r0,[r4,#0x39]         ;2022
000024  1d21              ADDS     r1,r4,#4              ;2025
000026  6820              LDR      r0,[r4,#0]            ;2025
000028  f7fffffe          BL       TIM_Base_SetConfig
00002c  6820              LDR      r0,[r4,#0]            ;2028
00002e  6800              LDR      r0,[r0,#0]            ;2028
000030  f0200008          BIC      r0,r0,#8              ;2028
000034  6821              LDR      r1,[r4,#0]            ;2028
000036  6008              STR      r0,[r1,#0]            ;2028
000038  6820              LDR      r0,[r4,#0]            ;2031
00003a  6800              LDR      r0,[r0,#0]            ;2031
00003c  4328              ORRS     r0,r0,r5              ;2031
00003e  6821              LDR      r1,[r4,#0]            ;2031
000040  6008              STR      r0,[r1,#0]            ;2031
000042  2001              MOVS     r0,#1                 ;2034
000044  f8840039          STRB     r0,[r4,#0x39]         ;2034
000048  2000              MOVS     r0,#0                 ;2036
00004a  e7de              B        |L62.10|
;;;2038   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_MspDeInit PROC
;;;2087     */
;;;2088   __weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2089   {
;;;2090     /* Prevent unused argument(s) compilation warning */
;;;2091     UNUSED(htim);
;;;2092     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2093               the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file
;;;2094      */
;;;2095   }
;;;2096   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_MspInit PROC
;;;2072     */
;;;2073   __weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2074   {
;;;2075     /* Prevent unused argument(s) compilation warning */
;;;2076     UNUSED(htim);
;;;2077     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2078               the HAL_TIM_OnePulse_MspInit could be implemented in the user file
;;;2079      */
;;;2080   }
;;;2081   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Start PROC
;;;2106     */
;;;2107   HAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b530              PUSH     {r4,r5,lr}
;;;2108   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2109     /* Enable the Capture compare and the Input Capture channels 
;;;2110       (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2111       if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2112       if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2113       in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
;;;2114       
;;;2115       No need to enable the counter, it's enabled automatically by hardware 
;;;2116       (the counter starts in response to a stimulus and generate a pulse */
;;;2117     
;;;2118     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
000006  2201              MOVS     r2,#1
000008  2100              MOVS     r1,#0
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2119     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
000010  2201              MOVS     r2,#1
000012  2104              MOVS     r1,#4
000014  6820              LDR      r0,[r4,#0]
000016  f7fffffe          BL       TIM_CCxChannelCmd
;;;2120     
;;;2121     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00001a  490a              LDR      r1,|L65.68|
00001c  6820              LDR      r0,[r4,#0]
00001e  4288              CMP      r0,r1
000020  d003              BEQ      |L65.42|
000022  4909              LDR      r1,|L65.72|
000024  6820              LDR      r0,[r4,#0]
000026  4288              CMP      r0,r1
000028  d101              BNE      |L65.46|
                  |L65.42|
00002a  2001              MOVS     r0,#1
00002c  e000              B        |L65.48|
                  |L65.46|
00002e  2000              MOVS     r0,#0
                  |L65.48|
000030  b128              CBZ      r0,|L65.62|
;;;2122     {
;;;2123       /* Enable the main output */
;;;2124       __HAL_TIM_MOE_ENABLE(htim);
000032  6820              LDR      r0,[r4,#0]
000034  6c40              LDR      r0,[r0,#0x44]
000036  f4404000          ORR      r0,r0,#0x8000
00003a  6821              LDR      r1,[r4,#0]
00003c  6448              STR      r0,[r1,#0x44]
                  |L65.62|
;;;2125     }
;;;2126     
;;;2127     /* Return function status */
;;;2128     return HAL_OK;
00003e  2000              MOVS     r0,#0
;;;2129   }
000040  bd30              POP      {r4,r5,pc}
;;;2130   
                          ENDP

000042  0000              DCW      0x0000
                  |L65.68|
                          DCD      0x40010000
                  |L65.72|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OnePulse_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Start_IT PROC
;;;2174     */
;;;2175   HAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b530              PUSH     {r4,r5,lr}
;;;2176   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2177     /* Enable the Capture compare and the Input Capture channels 
;;;2178       (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2179       if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2180       if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2181       in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
;;;2182       
;;;2183       No need to enable the counter, it's enabled automatically by hardware 
;;;2184       (the counter starts in response to a stimulus and generate a pulse */
;;;2185    
;;;2186     /* Enable the TIM Capture/Compare 1 interrupt */
;;;2187     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000006  6820              LDR      r0,[r4,#0]
000008  68c0              LDR      r0,[r0,#0xc]
00000a  f0400002          ORR      r0,r0,#2
00000e  6821              LDR      r1,[r4,#0]
000010  60c8              STR      r0,[r1,#0xc]
;;;2188     
;;;2189     /* Enable the TIM Capture/Compare 2 interrupt */
;;;2190     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000012  6820              LDR      r0,[r4,#0]
000014  68c0              LDR      r0,[r0,#0xc]
000016  f0400004          ORR      r0,r0,#4
00001a  6821              LDR      r1,[r4,#0]
00001c  60c8              STR      r0,[r1,#0xc]
;;;2191     
;;;2192     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
00001e  2201              MOVS     r2,#1
000020  2100              MOVS     r1,#0
000022  6820              LDR      r0,[r4,#0]
000024  f7fffffe          BL       TIM_CCxChannelCmd
;;;2193     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
000028  2201              MOVS     r2,#1
00002a  2104              MOVS     r1,#4
00002c  6820              LDR      r0,[r4,#0]
00002e  f7fffffe          BL       TIM_CCxChannelCmd
;;;2194     
;;;2195     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000032  490a              LDR      r1,|L66.92|
000034  6820              LDR      r0,[r4,#0]
000036  4288              CMP      r0,r1
000038  d003              BEQ      |L66.66|
00003a  4909              LDR      r1,|L66.96|
00003c  6820              LDR      r0,[r4,#0]
00003e  4288              CMP      r0,r1
000040  d101              BNE      |L66.70|
                  |L66.66|
000042  2001              MOVS     r0,#1
000044  e000              B        |L66.72|
                  |L66.70|
000046  2000              MOVS     r0,#0
                  |L66.72|
000048  b128              CBZ      r0,|L66.86|
;;;2196     {
;;;2197       /* Enable the main output */
;;;2198       __HAL_TIM_MOE_ENABLE(htim);
00004a  6820              LDR      r0,[r4,#0]
00004c  6c40              LDR      r0,[r0,#0x44]
00004e  f4404000          ORR      r0,r0,#0x8000
000052  6821              LDR      r1,[r4,#0]
000054  6448              STR      r0,[r1,#0x44]
                  |L66.86|
;;;2199     }
;;;2200     
;;;2201     /* Return function status */
;;;2202     return HAL_OK;
000056  2000              MOVS     r0,#0
;;;2203   }
000058  bd30              POP      {r4,r5,pc}
;;;2204   
                          ENDP

00005a  0000              DCW      0x0000
                  |L66.92|
                          DCD      0x40010000
                  |L66.96|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OnePulse_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Stop PROC
;;;2140     */
;;;2141   HAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b530              PUSH     {r4,r5,lr}
;;;2142   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2143     /* Disable the Capture compare and the Input Capture channels 
;;;2144     (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2145     if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2146     if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2147     in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
;;;2148     
;;;2149     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
000006  2200              MOVS     r2,#0
000008  4611              MOV      r1,r2
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2150     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
000010  2200              MOVS     r2,#0
000012  2104              MOVS     r1,#4
000014  6820              LDR      r0,[r4,#0]
000016  f7fffffe          BL       TIM_CCxChannelCmd
;;;2151       
;;;2152     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00001a  491a              LDR      r1,|L67.132|
00001c  6820              LDR      r0,[r4,#0]
00001e  4288              CMP      r0,r1
000020  d003              BEQ      |L67.42|
000022  4919              LDR      r1,|L67.136|
000024  6820              LDR      r0,[r4,#0]
000026  4288              CMP      r0,r1
000028  d101              BNE      |L67.46|
                  |L67.42|
00002a  2001              MOVS     r0,#1
00002c  e000              B        |L67.48|
                  |L67.46|
00002e  2000              MOVS     r0,#0
                  |L67.48|
000030  b190              CBZ      r0,|L67.88|
;;;2153     {
;;;2154       /* Disable the Main Output */
;;;2155       __HAL_TIM_MOE_DISABLE(htim);
000032  bf00              NOP      
000034  6820              LDR      r0,[r4,#0]
000036  6a00              LDR      r0,[r0,#0x20]
000038  f2411111          MOV      r1,#0x1111
00003c  4008              ANDS     r0,r0,r1
00003e  b950              CBNZ     r0,|L67.86|
000040  6820              LDR      r0,[r4,#0]
000042  6a00              LDR      r0,[r0,#0x20]
000044  1089              ASRS     r1,r1,#2
000046  4008              ANDS     r0,r0,r1
000048  b928              CBNZ     r0,|L67.86|
00004a  6820              LDR      r0,[r4,#0]
00004c  6c40              LDR      r0,[r0,#0x44]
00004e  f4204000          BIC      r0,r0,#0x8000
000052  6821              LDR      r1,[r4,#0]
000054  6448              STR      r0,[r1,#0x44]
                  |L67.86|
000056  bf00              NOP      
                  |L67.88|
;;;2156     }
;;;2157       
;;;2158     /* Disable the Peripheral */
;;;2159     __HAL_TIM_DISABLE(htim); 
000058  bf00              NOP      
00005a  6820              LDR      r0,[r4,#0]
00005c  6a00              LDR      r0,[r0,#0x20]
00005e  f2411111          MOV      r1,#0x1111
000062  4008              ANDS     r0,r0,r1
000064  b950              CBNZ     r0,|L67.124|
000066  6820              LDR      r0,[r4,#0]
000068  6a00              LDR      r0,[r0,#0x20]
00006a  1089              ASRS     r1,r1,#2
00006c  4008              ANDS     r0,r0,r1
00006e  b928              CBNZ     r0,|L67.124|
000070  6820              LDR      r0,[r4,#0]
000072  6800              LDR      r0,[r0,#0]
000074  f0200001          BIC      r0,r0,#1
000078  6821              LDR      r1,[r4,#0]
00007a  6008              STR      r0,[r1,#0]
                  |L67.124|
00007c  bf00              NOP      
;;;2160     
;;;2161     /* Return function status */
;;;2162     return HAL_OK;
00007e  2000              MOVS     r0,#0
;;;2163   }
000080  bd30              POP      {r4,r5,pc}
;;;2164   
                          ENDP

000082  0000              DCW      0x0000
                  |L67.132|
                          DCD      0x40010000
                  |L67.136|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OnePulse_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Stop_IT PROC
;;;2214     */
;;;2215   HAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b530              PUSH     {r4,r5,lr}
;;;2216   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2217     /* Disable the TIM Capture/Compare 1 interrupt */
;;;2218     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);  
000006  6820              LDR      r0,[r4,#0]
000008  68c0              LDR      r0,[r0,#0xc]
00000a  f0200002          BIC      r0,r0,#2
00000e  6821              LDR      r1,[r4,#0]
000010  60c8              STR      r0,[r1,#0xc]
;;;2219     
;;;2220     /* Disable the TIM Capture/Compare 2 interrupt */
;;;2221     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000012  6820              LDR      r0,[r4,#0]
000014  68c0              LDR      r0,[r0,#0xc]
000016  f0200004          BIC      r0,r0,#4
00001a  6821              LDR      r1,[r4,#0]
00001c  60c8              STR      r0,[r1,#0xc]
;;;2222     
;;;2223     /* Disable the Capture compare and the Input Capture channels 
;;;2224     (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2225     if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2226     if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2227     in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */  
;;;2228     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
00001e  2200              MOVS     r2,#0
000020  4611              MOV      r1,r2
000022  6820              LDR      r0,[r4,#0]
000024  f7fffffe          BL       TIM_CCxChannelCmd
;;;2229     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
000028  2200              MOVS     r2,#0
00002a  2104              MOVS     r1,#4
00002c  6820              LDR      r0,[r4,#0]
00002e  f7fffffe          BL       TIM_CCxChannelCmd
;;;2230       
;;;2231     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000032  491a              LDR      r1,|L68.156|
000034  6820              LDR      r0,[r4,#0]
000036  4288              CMP      r0,r1
000038  d003              BEQ      |L68.66|
00003a  4919              LDR      r1,|L68.160|
00003c  6820              LDR      r0,[r4,#0]
00003e  4288              CMP      r0,r1
000040  d101              BNE      |L68.70|
                  |L68.66|
000042  2001              MOVS     r0,#1
000044  e000              B        |L68.72|
                  |L68.70|
000046  2000              MOVS     r0,#0
                  |L68.72|
000048  b190              CBZ      r0,|L68.112|
;;;2232     {
;;;2233       /* Disable the Main Output */
;;;2234       __HAL_TIM_MOE_DISABLE(htim);
00004a  bf00              NOP      
00004c  6820              LDR      r0,[r4,#0]
00004e  6a00              LDR      r0,[r0,#0x20]
000050  f2411111          MOV      r1,#0x1111
000054  4008              ANDS     r0,r0,r1
000056  b950              CBNZ     r0,|L68.110|
000058  6820              LDR      r0,[r4,#0]
00005a  6a00              LDR      r0,[r0,#0x20]
00005c  1089              ASRS     r1,r1,#2
00005e  4008              ANDS     r0,r0,r1
000060  b928              CBNZ     r0,|L68.110|
000062  6820              LDR      r0,[r4,#0]
000064  6c40              LDR      r0,[r0,#0x44]
000066  f4204000          BIC      r0,r0,#0x8000
00006a  6821              LDR      r1,[r4,#0]
00006c  6448              STR      r0,[r1,#0x44]
                  |L68.110|
00006e  bf00              NOP      
                  |L68.112|
;;;2235     }
;;;2236       
;;;2237     /* Disable the Peripheral */
;;;2238      __HAL_TIM_DISABLE(htim);  
000070  bf00              NOP      
000072  6820              LDR      r0,[r4,#0]
000074  6a00              LDR      r0,[r0,#0x20]
000076  f2411111          MOV      r1,#0x1111
00007a  4008              ANDS     r0,r0,r1
00007c  b950              CBNZ     r0,|L68.148|
00007e  6820              LDR      r0,[r4,#0]
000080  6a00              LDR      r0,[r0,#0x20]
000082  1089              ASRS     r1,r1,#2
000084  4008              ANDS     r0,r0,r1
000086  b928              CBNZ     r0,|L68.148|
000088  6820              LDR      r0,[r4,#0]
00008a  6800              LDR      r0,[r0,#0]
00008c  f0200001          BIC      r0,r0,#1
000090  6821              LDR      r1,[r4,#0]
000092  6008              STR      r0,[r1,#0]
                  |L68.148|
000094  bf00              NOP      
;;;2239     
;;;2240     /* Return function status */
;;;2241     return HAL_OK;
000096  2000              MOVS     r0,#0
;;;2242   }
000098  bd30              POP      {r4,r5,pc}
;;;2243   /**
                          ENDP

00009a  0000              DCW      0x0000
                  |L68.156|
                          DCD      0x40010000
                  |L68.160|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_PWM_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_ConfigChannel PROC
;;;3128     */
;;;3129   HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;3130   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;3131     __HAL_LOCK(htim);
000008  bf00              NOP      
00000a  f8940038          LDRB     r0,[r4,#0x38]
00000e  2801              CMP      r0,#1
000010  d101              BNE      |L69.22|
000012  2002              MOVS     r0,#2
                  |L69.20|
;;;3132     
;;;3133     /* Check the parameters */ 
;;;3134     assert_param(IS_TIM_CHANNELS(Channel)); 
;;;3135     assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
;;;3136     assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
;;;3137     assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
;;;3138   
;;;3139     htim->State = HAL_TIM_STATE_BUSY;
;;;3140       
;;;3141     switch (Channel)
;;;3142     {
;;;3143       case TIM_CHANNEL_1:
;;;3144       {
;;;3145         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3146         /* Configure the Channel 1 in PWM mode */
;;;3147         TIM_OC1_SetConfig(htim->Instance, sConfig);
;;;3148         
;;;3149         /* Set the Preload enable bit for channel1 */
;;;3150         htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
;;;3151         
;;;3152         /* Configure the Output Fast mode */
;;;3153         htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
;;;3154         htim->Instance->CCMR1 |= sConfig->OCFastMode;
;;;3155       }
;;;3156       break;
;;;3157       
;;;3158       case TIM_CHANNEL_2:
;;;3159       {
;;;3160         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3161         /* Configure the Channel 2 in PWM mode */
;;;3162         TIM_OC2_SetConfig(htim->Instance, sConfig);
;;;3163         
;;;3164         /* Set the Preload enable bit for channel2 */
;;;3165         htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
;;;3166         
;;;3167         /* Configure the Output Fast mode */
;;;3168         htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
;;;3169         htim->Instance->CCMR1 |= sConfig->OCFastMode << 8;
;;;3170       }
;;;3171       break;
;;;3172       
;;;3173       case TIM_CHANNEL_3:
;;;3174       {
;;;3175         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3176         /* Configure the Channel 3 in PWM mode */
;;;3177         TIM_OC3_SetConfig(htim->Instance, sConfig);
;;;3178         
;;;3179         /* Set the Preload enable bit for channel3 */
;;;3180         htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
;;;3181         
;;;3182        /* Configure the Output Fast mode */
;;;3183         htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
;;;3184         htim->Instance->CCMR2 |= sConfig->OCFastMode;  
;;;3185       }
;;;3186       break;
;;;3187       
;;;3188       case TIM_CHANNEL_4:
;;;3189       {
;;;3190         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3191         /* Configure the Channel 4 in PWM mode */
;;;3192         TIM_OC4_SetConfig(htim->Instance, sConfig);
;;;3193         
;;;3194         /* Set the Preload enable bit for channel4 */
;;;3195         htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
;;;3196         
;;;3197        /* Configure the Output Fast mode */
;;;3198         htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
;;;3199         htim->Instance->CCMR2 |= sConfig->OCFastMode << 8;  
;;;3200       }
;;;3201       break;
;;;3202       
;;;3203       default:
;;;3204       break;    
;;;3205     }
;;;3206     
;;;3207     htim->State = HAL_TIM_STATE_READY;
;;;3208       
;;;3209     __HAL_UNLOCK(htim);
;;;3210     
;;;3211     return HAL_OK;
;;;3212   }
000014  bd70              POP      {r4-r6,pc}
                  |L69.22|
000016  2001              MOVS     r0,#1                 ;3131
000018  f8840038          STRB     r0,[r4,#0x38]         ;3131
00001c  bf00              NOP                            ;3131
00001e  2002              MOVS     r0,#2                 ;3139
000020  f8840039          STRB     r0,[r4,#0x39]         ;3139
000024  b136              CBZ      r6,|L69.52|
000026  2e04              CMP      r6,#4                 ;3141
000028  d01b              BEQ      |L69.98|
00002a  2e08              CMP      r6,#8                 ;3141
00002c  d031              BEQ      |L69.146|
00002e  2e0c              CMP      r6,#0xc               ;3141
000030  d15e              BNE      |L69.240|
000032  e045              B        |L69.192|
                  |L69.52|
000034  4629              MOV      r1,r5                 ;3147
000036  6820              LDR      r0,[r4,#0]            ;3147
000038  f7fffffe          BL       TIM_OC1_SetConfig
00003c  6820              LDR      r0,[r4,#0]            ;3150
00003e  6980              LDR      r0,[r0,#0x18]         ;3150
000040  f0400008          ORR      r0,r0,#8              ;3150
000044  6821              LDR      r1,[r4,#0]            ;3150
000046  6188              STR      r0,[r1,#0x18]         ;3150
000048  6820              LDR      r0,[r4,#0]            ;3153
00004a  6980              LDR      r0,[r0,#0x18]         ;3153
00004c  f0200004          BIC      r0,r0,#4              ;3153
000050  6821              LDR      r1,[r4,#0]            ;3153
000052  6188              STR      r0,[r1,#0x18]         ;3153
000054  6820              LDR      r0,[r4,#0]            ;3154
000056  6980              LDR      r0,[r0,#0x18]         ;3154
000058  6929              LDR      r1,[r5,#0x10]         ;3154
00005a  4308              ORRS     r0,r0,r1              ;3154
00005c  6821              LDR      r1,[r4,#0]            ;3154
00005e  6188              STR      r0,[r1,#0x18]         ;3154
000060  e047              B        |L69.242|
                  |L69.98|
000062  4629              MOV      r1,r5                 ;3162
000064  6820              LDR      r0,[r4,#0]            ;3162
000066  f7fffffe          BL       TIM_OC2_SetConfig
00006a  6820              LDR      r0,[r4,#0]            ;3165
00006c  6980              LDR      r0,[r0,#0x18]         ;3165
00006e  f4406000          ORR      r0,r0,#0x800          ;3165
000072  6821              LDR      r1,[r4,#0]            ;3165
000074  6188              STR      r0,[r1,#0x18]         ;3165
000076  6820              LDR      r0,[r4,#0]            ;3168
000078  6980              LDR      r0,[r0,#0x18]         ;3168
00007a  f4206080          BIC      r0,r0,#0x400          ;3168
00007e  6821              LDR      r1,[r4,#0]            ;3168
000080  6188              STR      r0,[r1,#0x18]         ;3168
000082  6820              LDR      r0,[r4,#0]            ;3169
000084  6980              LDR      r0,[r0,#0x18]         ;3169
000086  6929              LDR      r1,[r5,#0x10]         ;3169
000088  ea402001          ORR      r0,r0,r1,LSL #8       ;3169
00008c  6821              LDR      r1,[r4,#0]            ;3169
00008e  6188              STR      r0,[r1,#0x18]         ;3169
000090  e02f              B        |L69.242|
                  |L69.146|
000092  4629              MOV      r1,r5                 ;3177
000094  6820              LDR      r0,[r4,#0]            ;3177
000096  f7fffffe          BL       TIM_OC3_SetConfig
00009a  6820              LDR      r0,[r4,#0]            ;3180
00009c  69c0              LDR      r0,[r0,#0x1c]         ;3180
00009e  f0400008          ORR      r0,r0,#8              ;3180
0000a2  6821              LDR      r1,[r4,#0]            ;3180
0000a4  61c8              STR      r0,[r1,#0x1c]         ;3180
0000a6  6820              LDR      r0,[r4,#0]            ;3183
0000a8  69c0              LDR      r0,[r0,#0x1c]         ;3183
0000aa  f0200004          BIC      r0,r0,#4              ;3183
0000ae  6821              LDR      r1,[r4,#0]            ;3183
0000b0  61c8              STR      r0,[r1,#0x1c]         ;3183
0000b2  6820              LDR      r0,[r4,#0]            ;3184
0000b4  69c0              LDR      r0,[r0,#0x1c]         ;3184
0000b6  6929              LDR      r1,[r5,#0x10]         ;3184
0000b8  4308              ORRS     r0,r0,r1              ;3184
0000ba  6821              LDR      r1,[r4,#0]            ;3184
0000bc  61c8              STR      r0,[r1,#0x1c]         ;3184
0000be  e018              B        |L69.242|
                  |L69.192|
0000c0  4629              MOV      r1,r5                 ;3192
0000c2  6820              LDR      r0,[r4,#0]            ;3192
0000c4  f7fffffe          BL       TIM_OC4_SetConfig
0000c8  6820              LDR      r0,[r4,#0]            ;3195
0000ca  69c0              LDR      r0,[r0,#0x1c]         ;3195
0000cc  f4406000          ORR      r0,r0,#0x800          ;3195
0000d0  6821              LDR      r1,[r4,#0]            ;3195
0000d2  61c8              STR      r0,[r1,#0x1c]         ;3195
0000d4  6820              LDR      r0,[r4,#0]            ;3198
0000d6  69c0              LDR      r0,[r0,#0x1c]         ;3198
0000d8  f4206080          BIC      r0,r0,#0x400          ;3198
0000dc  6821              LDR      r1,[r4,#0]            ;3198
0000de  61c8              STR      r0,[r1,#0x1c]         ;3198
0000e0  6820              LDR      r0,[r4,#0]            ;3199
0000e2  69c0              LDR      r0,[r0,#0x1c]         ;3199
0000e4  6929              LDR      r1,[r5,#0x10]         ;3199
0000e6  ea402001          ORR      r0,r0,r1,LSL #8       ;3199
0000ea  6821              LDR      r1,[r4,#0]            ;3199
0000ec  61c8              STR      r0,[r1,#0x1c]         ;3199
0000ee  e000              B        |L69.242|
                  |L69.240|
0000f0  bf00              NOP                            ;3204
                  |L69.242|
0000f2  bf00              NOP                            ;3156
0000f4  2001              MOVS     r0,#1                 ;3207
0000f6  f8840039          STRB     r0,[r4,#0x39]         ;3207
0000fa  bf00              NOP                            ;3209
0000fc  2000              MOVS     r0,#0                 ;3209
0000fe  f8840038          STRB     r0,[r4,#0x38]         ;3209
000102  bf00              NOP                            ;3209
000104  bf00              NOP                            ;3211
000106  e785              B        |L69.20|
;;;3213   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_DeInit PROC
;;;1040     */
;;;1041   HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1042   {
000002  4604              MOV      r4,r0
;;;1043     /* Check the parameters */
;;;1044     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1045     
;;;1046     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f8840039          STRB     r0,[r4,#0x39]
;;;1047     
;;;1048     /* Disable the TIM Peripheral Clock */
;;;1049     __HAL_TIM_DISABLE(htim);
00000a  bf00              NOP      
00000c  6820              LDR      r0,[r4,#0]
00000e  6a00              LDR      r0,[r0,#0x20]
000010  f2411111          MOV      r1,#0x1111
000014  4008              ANDS     r0,r0,r1
000016  b950              CBNZ     r0,|L70.46|
000018  6820              LDR      r0,[r4,#0]
00001a  6a00              LDR      r0,[r0,#0x20]
00001c  1089              ASRS     r1,r1,#2
00001e  4008              ANDS     r0,r0,r1
000020  b928              CBNZ     r0,|L70.46|
000022  6820              LDR      r0,[r4,#0]
000024  6800              LDR      r0,[r0,#0]
000026  f0200001          BIC      r0,r0,#1
00002a  6821              LDR      r1,[r4,#0]
00002c  6008              STR      r0,[r1,#0]
                  |L70.46|
00002e  bf00              NOP      
;;;1050       
;;;1051     /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;1052     HAL_TIM_PWM_MspDeInit(htim);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       HAL_TIM_PWM_MspDeInit
;;;1053       
;;;1054     /* Change TIM state */  
;;;1055     htim->State = HAL_TIM_STATE_RESET; 
000036  2000              MOVS     r0,#0
000038  f8840039          STRB     r0,[r4,#0x39]
;;;1056   
;;;1057     /* Release Lock */
;;;1058     __HAL_UNLOCK(htim);
00003c  bf00              NOP      
00003e  f8840038          STRB     r0,[r4,#0x38]
000042  bf00              NOP      
;;;1059   
;;;1060     return HAL_OK;
;;;1061   }
000044  bd10              POP      {r4,pc}
;;;1062   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_GetState PROC
;;;4423     */
;;;4424   HAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;4425   {
;;;4426     return htim->State;
000002  f8910039          LDRB     r0,[r1,#0x39]
;;;4427   }
000006  4770              BX       lr
;;;4428   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_Init PROC
;;;1001     */
;;;1002   HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1003   {
000002  4604              MOV      r4,r0
;;;1004     /* Check the TIM handle allocation */
;;;1005     if(htim == NULL)
000004  b90c              CBNZ     r4,|L72.10|
;;;1006     {
;;;1007       return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L72.8|
;;;1008     }
;;;1009   
;;;1010     /* Check the parameters */
;;;1011     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1012     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;1013     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;1014   
;;;1015     if(htim->State == HAL_TIM_STATE_RESET)
;;;1016     {
;;;1017       /* Allocate lock resource and initialize it */
;;;1018       htim->Lock = HAL_UNLOCKED;
;;;1019       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1020       HAL_TIM_PWM_MspInit(htim);
;;;1021     }
;;;1022   
;;;1023     /* Set the TIM state */
;;;1024     htim->State= HAL_TIM_STATE_BUSY;  
;;;1025     
;;;1026     /* Init the base time for the PWM */  
;;;1027     TIM_Base_SetConfig(htim->Instance, &htim->Init); 
;;;1028      
;;;1029     /* Initialize the TIM state*/
;;;1030     htim->State= HAL_TIM_STATE_READY;
;;;1031     
;;;1032     return HAL_OK;
;;;1033   }  
000008  bd10              POP      {r4,pc}
                  |L72.10|
00000a  f8940039          LDRB     r0,[r4,#0x39]         ;1015
00000e  b928              CBNZ     r0,|L72.28|
000010  2000              MOVS     r0,#0                 ;1018
000012  f8840038          STRB     r0,[r4,#0x38]         ;1018
000016  4620              MOV      r0,r4                 ;1020
000018  f7fffffe          BL       HAL_TIM_PWM_MspInit
                  |L72.28|
00001c  2002              MOVS     r0,#2                 ;1024
00001e  f8840039          STRB     r0,[r4,#0x39]         ;1024
000022  1d21              ADDS     r1,r4,#4              ;1027
000024  6820              LDR      r0,[r4,#0]            ;1027
000026  f7fffffe          BL       TIM_Base_SetConfig
00002a  2001              MOVS     r0,#1                 ;1030
00002c  f8840039          STRB     r0,[r4,#0x39]         ;1030
000030  2000              MOVS     r0,#0                 ;1032
000032  e7e9              B        |L72.8|
;;;1034   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_MspDeInit PROC
;;;1083     */
;;;1084   __weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1085   {
;;;1086     /* Prevent unused argument(s) compilation warning */
;;;1087     UNUSED(htim);
;;;1088     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1089               the HAL_TIM_PWM_MspDeInit could be implemented in the user file
;;;1090      */
;;;1091   }
;;;1092   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_MspInit PROC
;;;1068     */
;;;1069   __weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1070   {
;;;1071     /* Prevent unused argument(s) compilation warning */
;;;1072     UNUSED(htim);
;;;1073     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1074               the HAL_TIM_PWM_MspInit could be implemented in the user file
;;;1075      */
;;;1076   }
;;;1077   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_PulseFinishedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_PulseFinishedCallback PROC
;;;4338     */
;;;4339   __weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4340   {
;;;4341     /* Prevent unused argument(s) compilation warning */
;;;4342     UNUSED(htim);
;;;4343     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4344               the __HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
;;;4345      */
;;;4346   }
;;;4347   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Start PROC
;;;1104     */
;;;1105   HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1106   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1107     /* Check the parameters */
;;;1108     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1109   
;;;1110     /* Enable the Capture compare channel */
;;;1111     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000006  2201              MOVS     r2,#1
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;1112     
;;;1113     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000010  490c              LDR      r1,|L76.68|
000012  6820              LDR      r0,[r4,#0]
000014  4288              CMP      r0,r1
000016  d003              BEQ      |L76.32|
000018  490b              LDR      r1,|L76.72|
00001a  6820              LDR      r0,[r4,#0]
00001c  4288              CMP      r0,r1
00001e  d101              BNE      |L76.36|
                  |L76.32|
000020  2001              MOVS     r0,#1
000022  e000              B        |L76.38|
                  |L76.36|
000024  2000              MOVS     r0,#0
                  |L76.38|
000026  b128              CBZ      r0,|L76.52|
;;;1114     {
;;;1115       /* Enable the main output */
;;;1116       __HAL_TIM_MOE_ENABLE(htim);
000028  6820              LDR      r0,[r4,#0]
00002a  6c40              LDR      r0,[r0,#0x44]
00002c  f4404000          ORR      r0,r0,#0x8000
000030  6821              LDR      r1,[r4,#0]
000032  6448              STR      r0,[r1,#0x44]
                  |L76.52|
;;;1117     }
;;;1118       
;;;1119     /* Enable the Peripheral */
;;;1120     __HAL_TIM_ENABLE(htim);
000034  6820              LDR      r0,[r4,#0]
000036  6800              LDR      r0,[r0,#0]
000038  f0400001          ORR      r0,r0,#1
00003c  6821              LDR      r1,[r4,#0]
00003e  6008              STR      r0,[r1,#0]
;;;1121     
;;;1122     /* Return function status */
;;;1123     return HAL_OK;
000040  2000              MOVS     r0,#0
;;;1124   } 
000042  bd30              POP      {r4,r5,pc}
;;;1125   
                          ENDP

                  |L76.68|
                          DCD      0x40010000
                  |L76.72|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_PWM_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Start_DMA PROC
;;;1309     */
;;;1310   HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1311   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
00000a  461f              MOV      r7,r3
;;;1312     /* Check the parameters */
;;;1313     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1314     
;;;1315     if((htim->State == HAL_TIM_STATE_BUSY))
00000c  f8940039          LDRB     r0,[r4,#0x39]
000010  2802              CMP      r0,#2
000012  d101              BNE      |L77.24|
                  |L77.20|
;;;1316     {
;;;1317        return HAL_BUSY;
;;;1318     }
;;;1319     else if((htim->State == HAL_TIM_STATE_READY))
;;;1320     {
;;;1321       if(((uint32_t)pData == 0 ) && (Length > 0)) 
;;;1322       {
;;;1323         return HAL_ERROR;                                    
;;;1324       }
;;;1325       else
;;;1326       {
;;;1327         htim->State = HAL_TIM_STATE_BUSY;
;;;1328       }
;;;1329     }    
;;;1330     switch (Channel)
;;;1331     {
;;;1332       case TIM_CHANNEL_1:
;;;1333       {      
;;;1334         /* Set the DMA Period elapsed callback */
;;;1335         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1336        
;;;1337         /* Set the DMA error callback */
;;;1338         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;1339         
;;;1340         /* Enable the DMA Stream */
;;;1341         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;1342         
;;;1343         /* Enable the TIM Capture/Compare 1 DMA request */
;;;1344         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1345       }
;;;1346       break;
;;;1347       
;;;1348       case TIM_CHANNEL_2:
;;;1349       {
;;;1350         /* Set the DMA Period elapsed callback */
;;;1351         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1352        
;;;1353         /* Set the DMA error callback */
;;;1354         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;1355         
;;;1356         /* Enable the DMA Stream */
;;;1357         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;1358         
;;;1359         /* Enable the TIM Capture/Compare 2 DMA request */
;;;1360         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1361       }
;;;1362       break;
;;;1363       
;;;1364       case TIM_CHANNEL_3:
;;;1365       {
;;;1366         /* Set the DMA Period elapsed callback */
;;;1367         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1368        
;;;1369         /* Set the DMA error callback */
;;;1370         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;1371         
;;;1372         /* Enable the DMA Stream */
;;;1373         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;1374         
;;;1375         /* Enable the TIM Output Capture/Compare 3 request */
;;;1376         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;1377       }
;;;1378       break;
;;;1379       
;;;1380       case TIM_CHANNEL_4:
;;;1381       {
;;;1382        /* Set the DMA Period elapsed callback */
;;;1383         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1384        
;;;1385         /* Set the DMA error callback */
;;;1386         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;1387         
;;;1388         /* Enable the DMA Stream */
;;;1389         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;1390         
;;;1391         /* Enable the TIM Capture/Compare 4 DMA request */
;;;1392         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;1393       }
;;;1394       break;
;;;1395       
;;;1396       default:
;;;1397       break;
;;;1398     }
;;;1399   
;;;1400     /* Enable the Capture compare channel */
;;;1401     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1402       
;;;1403     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
;;;1404     {
;;;1405       /* Enable the main output */
;;;1406       __HAL_TIM_MOE_ENABLE(htim);
;;;1407     }
;;;1408     
;;;1409     /* Enable the Peripheral */
;;;1410     __HAL_TIM_ENABLE(htim); 
;;;1411     
;;;1412     /* Return function status */
;;;1413     return HAL_OK;
;;;1414   }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L77.24|
000018  f8940039          LDRB     r0,[r4,#0x39]         ;1319
00001c  2801              CMP      r0,#1                 ;1319
00001e  d106              BNE      |L77.46|
000020  b915              CBNZ     r5,|L77.40|
000022  2f00              CMP      r7,#0                 ;1321
000024  dd00              BLE      |L77.40|
000026  e7f5              B        |L77.20|
                  |L77.40|
000028  2002              MOVS     r0,#2                 ;1327
00002a  f8840039          STRB     r0,[r4,#0x39]         ;1327
                  |L77.46|
00002e  b136              CBZ      r6,|L77.62|
000030  2e04              CMP      r6,#4                 ;1330
000032  d019              BEQ      |L77.104|
000034  2e08              CMP      r6,#8                 ;1330
000036  d02c              BEQ      |L77.146|
000038  2e0c              CMP      r6,#0xc               ;1330
00003a  d154              BNE      |L77.230|
00003c  e03e              B        |L77.188|
                  |L77.62|
00003e  493a              LDR      r1,|L77.296|
000040  6a20              LDR      r0,[r4,#0x20]         ;1335
000042  63c1              STR      r1,[r0,#0x3c]         ;1335
000044  4939              LDR      r1,|L77.300|
000046  6a20              LDR      r0,[r4,#0x20]         ;1338
000048  6481              STR      r1,[r0,#0x48]         ;1338
00004a  6821              LDR      r1,[r4,#0]            ;1341
00004c  f1010234          ADD      r2,r1,#0x34           ;1341
000050  463b              MOV      r3,r7                 ;1341
000052  4629              MOV      r1,r5                 ;1341
000054  6a20              LDR      r0,[r4,#0x20]         ;1341
000056  f7fffffe          BL       HAL_DMA_Start_IT
00005a  6820              LDR      r0,[r4,#0]            ;1344
00005c  68c0              LDR      r0,[r0,#0xc]          ;1344
00005e  f4407000          ORR      r0,r0,#0x200          ;1344
000062  6821              LDR      r1,[r4,#0]            ;1344
000064  60c8              STR      r0,[r1,#0xc]          ;1344
000066  e03f              B        |L77.232|
                  |L77.104|
000068  492f              LDR      r1,|L77.296|
00006a  6a60              LDR      r0,[r4,#0x24]         ;1351
00006c  63c1              STR      r1,[r0,#0x3c]         ;1351
00006e  492f              LDR      r1,|L77.300|
000070  6a60              LDR      r0,[r4,#0x24]         ;1354
000072  6481              STR      r1,[r0,#0x48]         ;1354
000074  6821              LDR      r1,[r4,#0]            ;1357
000076  f1010238          ADD      r2,r1,#0x38           ;1357
00007a  463b              MOV      r3,r7                 ;1357
00007c  4629              MOV      r1,r5                 ;1357
00007e  6a60              LDR      r0,[r4,#0x24]         ;1357
000080  f7fffffe          BL       HAL_DMA_Start_IT
000084  6820              LDR      r0,[r4,#0]            ;1360
000086  68c0              LDR      r0,[r0,#0xc]          ;1360
000088  f4406080          ORR      r0,r0,#0x400          ;1360
00008c  6821              LDR      r1,[r4,#0]            ;1360
00008e  60c8              STR      r0,[r1,#0xc]          ;1360
000090  e02a              B        |L77.232|
                  |L77.146|
000092  4925              LDR      r1,|L77.296|
000094  6aa0              LDR      r0,[r4,#0x28]         ;1367
000096  63c1              STR      r1,[r0,#0x3c]         ;1367
000098  4924              LDR      r1,|L77.300|
00009a  6aa0              LDR      r0,[r4,#0x28]         ;1370
00009c  6481              STR      r1,[r0,#0x48]         ;1370
00009e  6821              LDR      r1,[r4,#0]            ;1373
0000a0  f101023c          ADD      r2,r1,#0x3c           ;1373
0000a4  463b              MOV      r3,r7                 ;1373
0000a6  4629              MOV      r1,r5                 ;1373
0000a8  6aa0              LDR      r0,[r4,#0x28]         ;1373
0000aa  f7fffffe          BL       HAL_DMA_Start_IT
0000ae  6820              LDR      r0,[r4,#0]            ;1376
0000b0  68c0              LDR      r0,[r0,#0xc]          ;1376
0000b2  f4406000          ORR      r0,r0,#0x800          ;1376
0000b6  6821              LDR      r1,[r4,#0]            ;1376
0000b8  60c8              STR      r0,[r1,#0xc]          ;1376
0000ba  e015              B        |L77.232|
                  |L77.188|
0000bc  491a              LDR      r1,|L77.296|
0000be  6ae0              LDR      r0,[r4,#0x2c]         ;1383
0000c0  63c1              STR      r1,[r0,#0x3c]         ;1383
0000c2  491a              LDR      r1,|L77.300|
0000c4  6ae0              LDR      r0,[r4,#0x2c]         ;1386
0000c6  6481              STR      r1,[r0,#0x48]         ;1386
0000c8  6821              LDR      r1,[r4,#0]            ;1389
0000ca  f1010240          ADD      r2,r1,#0x40           ;1389
0000ce  463b              MOV      r3,r7                 ;1389
0000d0  4629              MOV      r1,r5                 ;1389
0000d2  6ae0              LDR      r0,[r4,#0x2c]         ;1389
0000d4  f7fffffe          BL       HAL_DMA_Start_IT
0000d8  6820              LDR      r0,[r4,#0]            ;1392
0000da  68c0              LDR      r0,[r0,#0xc]          ;1392
0000dc  f4405080          ORR      r0,r0,#0x1000         ;1392
0000e0  6821              LDR      r1,[r4,#0]            ;1392
0000e2  60c8              STR      r0,[r1,#0xc]          ;1392
0000e4  e000              B        |L77.232|
                  |L77.230|
0000e6  bf00              NOP                            ;1397
                  |L77.232|
0000e8  bf00              NOP                            ;1346
0000ea  2201              MOVS     r2,#1                 ;1401
0000ec  4631              MOV      r1,r6                 ;1401
0000ee  6820              LDR      r0,[r4,#0]            ;1401
0000f0  f7fffffe          BL       TIM_CCxChannelCmd
0000f4  490e              LDR      r1,|L77.304|
0000f6  6820              LDR      r0,[r4,#0]            ;1403
0000f8  4288              CMP      r0,r1                 ;1403
0000fa  d003              BEQ      |L77.260|
0000fc  490d              LDR      r1,|L77.308|
0000fe  6820              LDR      r0,[r4,#0]            ;1403
000100  4288              CMP      r0,r1                 ;1403
000102  d101              BNE      |L77.264|
                  |L77.260|
000104  2001              MOVS     r0,#1                 ;1403
000106  e000              B        |L77.266|
                  |L77.264|
000108  2000              MOVS     r0,#0                 ;1403
                  |L77.266|
00010a  b128              CBZ      r0,|L77.280|
00010c  6820              LDR      r0,[r4,#0]            ;1406
00010e  6c40              LDR      r0,[r0,#0x44]         ;1406
000110  f4404000          ORR      r0,r0,#0x8000         ;1406
000114  6821              LDR      r1,[r4,#0]            ;1406
000116  6448              STR      r0,[r1,#0x44]         ;1406
                  |L77.280|
000118  6820              LDR      r0,[r4,#0]            ;1410
00011a  6800              LDR      r0,[r0,#0]            ;1410
00011c  f0400001          ORR      r0,r0,#1              ;1410
000120  6821              LDR      r1,[r4,#0]            ;1410
000122  6008              STR      r0,[r1,#0]            ;1410
000124  2000              MOVS     r0,#0                 ;1413
000126  e775              B        |L77.20|
;;;1415   
                          ENDP

                  |L77.296|
                          DCD      TIM_DMADelayPulseCplt
                  |L77.300|
                          DCD      TIM_DMAError
                  |L77.304|
                          DCD      0x40010000
                  |L77.308|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_PWM_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Start_IT PROC
;;;1173     */
;;;1174   HAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1175   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1176     /* Check the parameters */
;;;1177     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1178     
;;;1179     switch (Channel)
000006  b135              CBZ      r5,|L78.22|
000008  2d04              CMP      r5,#4
00000a  d00b              BEQ      |L78.36|
00000c  2d08              CMP      r5,#8
00000e  d010              BEQ      |L78.50|
000010  2d0c              CMP      r5,#0xc
000012  d11c              BNE      |L78.78|
000014  e014              B        |L78.64|
                  |L78.22|
;;;1180     {
;;;1181       case TIM_CHANNEL_1:
;;;1182       {       
;;;1183         /* Enable the TIM Capture/Compare 1 interrupt */
;;;1184         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000016  6820              LDR      r0,[r4,#0]
000018  68c0              LDR      r0,[r0,#0xc]
00001a  f0400002          ORR      r0,r0,#2
00001e  6821              LDR      r1,[r4,#0]
000020  60c8              STR      r0,[r1,#0xc]
;;;1185       }
;;;1186       break;
000022  e015              B        |L78.80|
                  |L78.36|
;;;1187       
;;;1188       case TIM_CHANNEL_2:
;;;1189       {
;;;1190         /* Enable the TIM Capture/Compare 2 interrupt */
;;;1191         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000024  6820              LDR      r0,[r4,#0]
000026  68c0              LDR      r0,[r0,#0xc]
000028  f0400004          ORR      r0,r0,#4
00002c  6821              LDR      r1,[r4,#0]
00002e  60c8              STR      r0,[r1,#0xc]
;;;1192       }
;;;1193       break;
000030  e00e              B        |L78.80|
                  |L78.50|
;;;1194       
;;;1195       case TIM_CHANNEL_3:
;;;1196       {
;;;1197         /* Enable the TIM Capture/Compare 3 interrupt */
;;;1198         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
000032  6820              LDR      r0,[r4,#0]
000034  68c0              LDR      r0,[r0,#0xc]
000036  f0400008          ORR      r0,r0,#8
00003a  6821              LDR      r1,[r4,#0]
00003c  60c8              STR      r0,[r1,#0xc]
;;;1199       }
;;;1200       break;
00003e  e007              B        |L78.80|
                  |L78.64|
;;;1201       
;;;1202       case TIM_CHANNEL_4:
;;;1203       {
;;;1204         /* Enable the TIM Capture/Compare 4 interrupt */
;;;1205         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000040  6820              LDR      r0,[r4,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  f0400010          ORR      r0,r0,#0x10
000048  6821              LDR      r1,[r4,#0]
00004a  60c8              STR      r0,[r1,#0xc]
;;;1206       }
;;;1207       break;
00004c  e000              B        |L78.80|
                  |L78.78|
;;;1208       
;;;1209       default:
;;;1210       break;
00004e  bf00              NOP      
                  |L78.80|
000050  bf00              NOP                            ;1186
;;;1211     } 
;;;1212     
;;;1213     /* Enable the Capture compare channel */
;;;1214     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000052  2201              MOVS     r2,#1
000054  4629              MOV      r1,r5
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       TIM_CCxChannelCmd
;;;1215     
;;;1216     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00005c  490c              LDR      r1,|L78.144|
00005e  6820              LDR      r0,[r4,#0]
000060  4288              CMP      r0,r1
000062  d003              BEQ      |L78.108|
000064  490b              LDR      r1,|L78.148|
000066  6820              LDR      r0,[r4,#0]
000068  4288              CMP      r0,r1
00006a  d101              BNE      |L78.112|
                  |L78.108|
00006c  2001              MOVS     r0,#1
00006e  e000              B        |L78.114|
                  |L78.112|
000070  2000              MOVS     r0,#0
                  |L78.114|
000072  b128              CBZ      r0,|L78.128|
;;;1217     {
;;;1218       /* Enable the main output */
;;;1219       __HAL_TIM_MOE_ENABLE(htim);
000074  6820              LDR      r0,[r4,#0]
000076  6c40              LDR      r0,[r0,#0x44]
000078  f4404000          ORR      r0,r0,#0x8000
00007c  6821              LDR      r1,[r4,#0]
00007e  6448              STR      r0,[r1,#0x44]
                  |L78.128|
;;;1220     }
;;;1221   
;;;1222     /* Enable the Peripheral */
;;;1223     __HAL_TIM_ENABLE(htim);
000080  6820              LDR      r0,[r4,#0]
000082  6800              LDR      r0,[r0,#0]
000084  f0400001          ORR      r0,r0,#1
000088  6821              LDR      r1,[r4,#0]
00008a  6008              STR      r0,[r1,#0]
;;;1224     
;;;1225     /* Return function status */
;;;1226     return HAL_OK;
00008c  2000              MOVS     r0,#0
;;;1227   } 
00008e  bd30              POP      {r4,r5,pc}
;;;1228   
                          ENDP

                  |L78.144|
                          DCD      0x40010000
                  |L78.148|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_PWM_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Stop PROC
;;;1137     */
;;;1138   HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1139   { 
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1140     /* Check the parameters */
;;;1141     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1142       
;;;1143     /* Disable the Capture compare channel */
;;;1144     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000006  2200              MOVS     r2,#0
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;1145     
;;;1146     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000010  491b              LDR      r1,|L79.128|
000012  6820              LDR      r0,[r4,#0]
000014  4288              CMP      r0,r1
000016  d003              BEQ      |L79.32|
000018  491a              LDR      r1,|L79.132|
00001a  6820              LDR      r0,[r4,#0]
00001c  4288              CMP      r0,r1
00001e  d101              BNE      |L79.36|
                  |L79.32|
000020  2001              MOVS     r0,#1
000022  e000              B        |L79.38|
                  |L79.36|
000024  2000              MOVS     r0,#0
                  |L79.38|
000026  b190              CBZ      r0,|L79.78|
;;;1147     {
;;;1148       /* Disable the Main Output */
;;;1149       __HAL_TIM_MOE_DISABLE(htim);
000028  bf00              NOP      
00002a  6820              LDR      r0,[r4,#0]
00002c  6a00              LDR      r0,[r0,#0x20]
00002e  f2411111          MOV      r1,#0x1111
000032  4008              ANDS     r0,r0,r1
000034  b950              CBNZ     r0,|L79.76|
000036  6820              LDR      r0,[r4,#0]
000038  6a00              LDR      r0,[r0,#0x20]
00003a  1089              ASRS     r1,r1,#2
00003c  4008              ANDS     r0,r0,r1
00003e  b928              CBNZ     r0,|L79.76|
000040  6820              LDR      r0,[r4,#0]
000042  6c40              LDR      r0,[r0,#0x44]
000044  f4204000          BIC      r0,r0,#0x8000
000048  6821              LDR      r1,[r4,#0]
00004a  6448              STR      r0,[r1,#0x44]
                  |L79.76|
00004c  bf00              NOP      
                  |L79.78|
;;;1150     }
;;;1151     
;;;1152     /* Disable the Peripheral */
;;;1153     __HAL_TIM_DISABLE(htim);
00004e  bf00              NOP      
000050  6820              LDR      r0,[r4,#0]
000052  6a00              LDR      r0,[r0,#0x20]
000054  f2411111          MOV      r1,#0x1111
000058  4008              ANDS     r0,r0,r1
00005a  b950              CBNZ     r0,|L79.114|
00005c  6820              LDR      r0,[r4,#0]
00005e  6a00              LDR      r0,[r0,#0x20]
000060  1089              ASRS     r1,r1,#2
000062  4008              ANDS     r0,r0,r1
000064  b928              CBNZ     r0,|L79.114|
000066  6820              LDR      r0,[r4,#0]
000068  6800              LDR      r0,[r0,#0]
00006a  f0200001          BIC      r0,r0,#1
00006e  6821              LDR      r1,[r4,#0]
000070  6008              STR      r0,[r1,#0]
                  |L79.114|
000072  bf00              NOP      
;;;1154     
;;;1155     /* Change the htim state */
;;;1156     htim->State = HAL_TIM_STATE_READY;
000074  2001              MOVS     r0,#1
000076  f8840039          STRB     r0,[r4,#0x39]
;;;1157     
;;;1158     /* Return function status */
;;;1159     return HAL_OK;
00007a  2000              MOVS     r0,#0
;;;1160   } 
00007c  bd30              POP      {r4,r5,pc}
;;;1161   
                          ENDP

00007e  0000              DCW      0x0000
                  |L79.128|
                          DCD      0x40010000
                  |L79.132|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_PWM_Stop_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Stop_DMA PROC
;;;1427     */
;;;1428   HAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1429   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1430     /* Check the parameters */
;;;1431     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1432     
;;;1433     switch (Channel)
000006  b135              CBZ      r5,|L80.22|
000008  2d04              CMP      r5,#4
00000a  d00b              BEQ      |L80.36|
00000c  2d08              CMP      r5,#8
00000e  d010              BEQ      |L80.50|
000010  2d0c              CMP      r5,#0xc
000012  d11c              BNE      |L80.78|
000014  e014              B        |L80.64|
                  |L80.22|
;;;1434     {
;;;1435       case TIM_CHANNEL_1:
;;;1436       {       
;;;1437         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1438         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000016  6820              LDR      r0,[r4,#0]
000018  68c0              LDR      r0,[r0,#0xc]
00001a  f4207000          BIC      r0,r0,#0x200
00001e  6821              LDR      r1,[r4,#0]
000020  60c8              STR      r0,[r1,#0xc]
;;;1439       }
;;;1440       break;
000022  e015              B        |L80.80|
                  |L80.36|
;;;1441       
;;;1442       case TIM_CHANNEL_2:
;;;1443       {
;;;1444         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1445         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000024  6820              LDR      r0,[r4,#0]
000026  68c0              LDR      r0,[r0,#0xc]
000028  f4206080          BIC      r0,r0,#0x400
00002c  6821              LDR      r1,[r4,#0]
00002e  60c8              STR      r0,[r1,#0xc]
;;;1446       }
;;;1447       break;
000030  e00e              B        |L80.80|
                  |L80.50|
;;;1448       
;;;1449       case TIM_CHANNEL_3:
;;;1450       {
;;;1451         /* Disable the TIM Capture/Compare 3 DMA request */
;;;1452         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
000032  6820              LDR      r0,[r4,#0]
000034  68c0              LDR      r0,[r0,#0xc]
000036  f4206000          BIC      r0,r0,#0x800
00003a  6821              LDR      r1,[r4,#0]
00003c  60c8              STR      r0,[r1,#0xc]
;;;1453       }
;;;1454       break;
00003e  e007              B        |L80.80|
                  |L80.64|
;;;1455       
;;;1456       case TIM_CHANNEL_4:
;;;1457       {
;;;1458         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1459         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
000040  6820              LDR      r0,[r4,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  f4205080          BIC      r0,r0,#0x1000
000048  6821              LDR      r1,[r4,#0]
00004a  60c8              STR      r0,[r1,#0xc]
;;;1460       }
;;;1461       break;
00004c  e000              B        |L80.80|
                  |L80.78|
;;;1462       
;;;1463       default:
;;;1464       break;
00004e  bf00              NOP      
                  |L80.80|
000050  bf00              NOP                            ;1440
;;;1465     } 
;;;1466     
;;;1467     /* Disable the Capture compare channel */
;;;1468     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000052  2200              MOVS     r2,#0
000054  4629              MOV      r1,r5
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       TIM_CCxChannelCmd
;;;1469     
;;;1470     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00005c  491b              LDR      r1,|L80.204|
00005e  6820              LDR      r0,[r4,#0]
000060  4288              CMP      r0,r1
000062  d003              BEQ      |L80.108|
000064  491a              LDR      r1,|L80.208|
000066  6820              LDR      r0,[r4,#0]
000068  4288              CMP      r0,r1
00006a  d101              BNE      |L80.112|
                  |L80.108|
00006c  2001              MOVS     r0,#1
00006e  e000              B        |L80.114|
                  |L80.112|
000070  2000              MOVS     r0,#0
                  |L80.114|
000072  b190              CBZ      r0,|L80.154|
;;;1471     {
;;;1472       /* Disable the Main Output */
;;;1473       __HAL_TIM_MOE_DISABLE(htim);
000074  bf00              NOP      
000076  6820              LDR      r0,[r4,#0]
000078  6a00              LDR      r0,[r0,#0x20]
00007a  f2411111          MOV      r1,#0x1111
00007e  4008              ANDS     r0,r0,r1
000080  b950              CBNZ     r0,|L80.152|
000082  6820              LDR      r0,[r4,#0]
000084  6a00              LDR      r0,[r0,#0x20]
000086  1089              ASRS     r1,r1,#2
000088  4008              ANDS     r0,r0,r1
00008a  b928              CBNZ     r0,|L80.152|
00008c  6820              LDR      r0,[r4,#0]
00008e  6c40              LDR      r0,[r0,#0x44]
000090  f4204000          BIC      r0,r0,#0x8000
000094  6821              LDR      r1,[r4,#0]
000096  6448              STR      r0,[r1,#0x44]
                  |L80.152|
000098  bf00              NOP      
                  |L80.154|
;;;1474     }
;;;1475     
;;;1476     /* Disable the Peripheral */
;;;1477     __HAL_TIM_DISABLE(htim);
00009a  bf00              NOP      
00009c  6820              LDR      r0,[r4,#0]
00009e  6a00              LDR      r0,[r0,#0x20]
0000a0  f2411111          MOV      r1,#0x1111
0000a4  4008              ANDS     r0,r0,r1
0000a6  b950              CBNZ     r0,|L80.190|
0000a8  6820              LDR      r0,[r4,#0]
0000aa  6a00              LDR      r0,[r0,#0x20]
0000ac  1089              ASRS     r1,r1,#2
0000ae  4008              ANDS     r0,r0,r1
0000b0  b928              CBNZ     r0,|L80.190|
0000b2  6820              LDR      r0,[r4,#0]
0000b4  6800              LDR      r0,[r0,#0]
0000b6  f0200001          BIC      r0,r0,#1
0000ba  6821              LDR      r1,[r4,#0]
0000bc  6008              STR      r0,[r1,#0]
                  |L80.190|
0000be  bf00              NOP      
;;;1478     
;;;1479     /* Change the htim state */
;;;1480     htim->State = HAL_TIM_STATE_READY;
0000c0  2001              MOVS     r0,#1
0000c2  f8840039          STRB     r0,[r4,#0x39]
;;;1481     
;;;1482     /* Return function status */
;;;1483     return HAL_OK;
0000c6  2000              MOVS     r0,#0
;;;1484   }
0000c8  bd30              POP      {r4,r5,pc}
;;;1485   /**
                          ENDP

0000ca  0000              DCW      0x0000
                  |L80.204|
                          DCD      0x40010000
                  |L80.208|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_PWM_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Stop_IT PROC
;;;1240     */
;;;1241   HAL_StatusTypeDef HAL_TIM_PWM_Stop_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1242   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1243     /* Check the parameters */
;;;1244     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1245     
;;;1246     switch (Channel)
000006  b135              CBZ      r5,|L81.22|
000008  2d04              CMP      r5,#4
00000a  d00b              BEQ      |L81.36|
00000c  2d08              CMP      r5,#8
00000e  d010              BEQ      |L81.50|
000010  2d0c              CMP      r5,#0xc
000012  d11c              BNE      |L81.78|
000014  e014              B        |L81.64|
                  |L81.22|
;;;1247     {
;;;1248       case TIM_CHANNEL_1:
;;;1249       {       
;;;1250         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1251         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000016  6820              LDR      r0,[r4,#0]
000018  68c0              LDR      r0,[r0,#0xc]
00001a  f0200002          BIC      r0,r0,#2
00001e  6821              LDR      r1,[r4,#0]
000020  60c8              STR      r0,[r1,#0xc]
;;;1252       }
;;;1253       break;
000022  e015              B        |L81.80|
                  |L81.36|
;;;1254       
;;;1255       case TIM_CHANNEL_2:
;;;1256       {
;;;1257         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1258         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000024  6820              LDR      r0,[r4,#0]
000026  68c0              LDR      r0,[r0,#0xc]
000028  f0200004          BIC      r0,r0,#4
00002c  6821              LDR      r1,[r4,#0]
00002e  60c8              STR      r0,[r1,#0xc]
;;;1259       }
;;;1260       break;
000030  e00e              B        |L81.80|
                  |L81.50|
;;;1261       
;;;1262       case TIM_CHANNEL_3:
;;;1263       {
;;;1264         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1265         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
000032  6820              LDR      r0,[r4,#0]
000034  68c0              LDR      r0,[r0,#0xc]
000036  f0200008          BIC      r0,r0,#8
00003a  6821              LDR      r1,[r4,#0]
00003c  60c8              STR      r0,[r1,#0xc]
;;;1266       }
;;;1267       break;
00003e  e007              B        |L81.80|
                  |L81.64|
;;;1268       
;;;1269       case TIM_CHANNEL_4:
;;;1270       {
;;;1271         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1272         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
000040  6820              LDR      r0,[r4,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  f0200010          BIC      r0,r0,#0x10
000048  6821              LDR      r1,[r4,#0]
00004a  60c8              STR      r0,[r1,#0xc]
;;;1273       }
;;;1274       break;
00004c  e000              B        |L81.80|
                  |L81.78|
;;;1275       
;;;1276       default:
;;;1277       break; 
00004e  bf00              NOP      
                  |L81.80|
000050  bf00              NOP                            ;1253
;;;1278     }
;;;1279     
;;;1280     /* Disable the Capture compare channel */
;;;1281     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000052  2200              MOVS     r2,#0
000054  4629              MOV      r1,r5
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       TIM_CCxChannelCmd
;;;1282     
;;;1283     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00005c  4919              LDR      r1,|L81.196|
00005e  6820              LDR      r0,[r4,#0]
000060  4288              CMP      r0,r1
000062  d003              BEQ      |L81.108|
000064  4918              LDR      r1,|L81.200|
000066  6820              LDR      r0,[r4,#0]
000068  4288              CMP      r0,r1
00006a  d101              BNE      |L81.112|
                  |L81.108|
00006c  2001              MOVS     r0,#1
00006e  e000              B        |L81.114|
                  |L81.112|
000070  2000              MOVS     r0,#0
                  |L81.114|
000072  b190              CBZ      r0,|L81.154|
;;;1284     {
;;;1285       /* Disable the Main Output */
;;;1286       __HAL_TIM_MOE_DISABLE(htim);
000074  bf00              NOP      
000076  6820              LDR      r0,[r4,#0]
000078  6a00              LDR      r0,[r0,#0x20]
00007a  f2411111          MOV      r1,#0x1111
00007e  4008              ANDS     r0,r0,r1
000080  b950              CBNZ     r0,|L81.152|
000082  6820              LDR      r0,[r4,#0]
000084  6a00              LDR      r0,[r0,#0x20]
000086  1089              ASRS     r1,r1,#2
000088  4008              ANDS     r0,r0,r1
00008a  b928              CBNZ     r0,|L81.152|
00008c  6820              LDR      r0,[r4,#0]
00008e  6c40              LDR      r0,[r0,#0x44]
000090  f4204000          BIC      r0,r0,#0x8000
000094  6821              LDR      r1,[r4,#0]
000096  6448              STR      r0,[r1,#0x44]
                  |L81.152|
000098  bf00              NOP      
                  |L81.154|
;;;1287     }
;;;1288     
;;;1289     /* Disable the Peripheral */
;;;1290     __HAL_TIM_DISABLE(htim);
00009a  bf00              NOP      
00009c  6820              LDR      r0,[r4,#0]
00009e  6a00              LDR      r0,[r0,#0x20]
0000a0  f2411111          MOV      r1,#0x1111
0000a4  4008              ANDS     r0,r0,r1
0000a6  b950              CBNZ     r0,|L81.190|
0000a8  6820              LDR      r0,[r4,#0]
0000aa  6a00              LDR      r0,[r0,#0x20]
0000ac  1089              ASRS     r1,r1,#2
0000ae  4008              ANDS     r0,r0,r1
0000b0  b928              CBNZ     r0,|L81.190|
0000b2  6820              LDR      r0,[r4,#0]
0000b4  6800              LDR      r0,[r0,#0]
0000b6  f0200001          BIC      r0,r0,#1
0000ba  6821              LDR      r1,[r4,#0]
0000bc  6008              STR      r0,[r1,#0]
                  |L81.190|
0000be  bf00              NOP      
;;;1291     
;;;1292     /* Return function status */
;;;1293     return HAL_OK;
0000c0  2000              MOVS     r0,#0
;;;1294   } 
0000c2  bd30              POP      {r4,r5,pc}
;;;1295   
                          ENDP

                  |L81.196|
                          DCD      0x40010000
                  |L81.200|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_PeriodElapsedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PeriodElapsedCallback PROC
;;;4293     */
;;;4294   __weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4295   {
;;;4296     /* Prevent unused argument(s) compilation warning */
;;;4297     UNUSED(htim);
;;;4298     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4299               the __HAL_TIM_PeriodElapsedCallback could be implemented in the user file
;;;4300      */
;;;4301   }
;;;4302   
                          ENDP


                          AREA ||i.HAL_TIM_ReadCapturedValue||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ReadCapturedValue PROC
;;;4206     */
;;;4207   uint32_t HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  4602              MOV      r2,r0
;;;4208   {
;;;4209     uint32_t tmpreg = 0;
000002  2300              MOVS     r3,#0
;;;4210     
;;;4211     __HAL_LOCK(htim);
000004  bf00              NOP      
000006  f8920038          LDRB     r0,[r2,#0x38]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L83.18|
00000e  2002              MOVS     r0,#2
                  |L83.16|
;;;4212     
;;;4213     switch (Channel)
;;;4214     {
;;;4215       case TIM_CHANNEL_1:
;;;4216       {
;;;4217         /* Check the parameters */
;;;4218         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4219         
;;;4220         /* Return the capture 1 value */
;;;4221         tmpreg = htim->Instance->CCR1;
;;;4222         
;;;4223         break;
;;;4224       }
;;;4225       case TIM_CHANNEL_2:
;;;4226       {
;;;4227         /* Check the parameters */
;;;4228         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4229         
;;;4230         /* Return the capture 2 value */
;;;4231         tmpreg = htim->Instance->CCR2;
;;;4232         
;;;4233         break;
;;;4234       }
;;;4235       
;;;4236       case TIM_CHANNEL_3:
;;;4237       {
;;;4238         /* Check the parameters */
;;;4239         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;4240         
;;;4241         /* Return the capture 3 value */
;;;4242         tmpreg = htim->Instance->CCR3;
;;;4243         
;;;4244         break;
;;;4245       }
;;;4246       
;;;4247       case TIM_CHANNEL_4:
;;;4248       {
;;;4249         /* Check the parameters */
;;;4250         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;4251         
;;;4252         /* Return the capture 4 value */
;;;4253         tmpreg = htim->Instance->CCR4;
;;;4254         
;;;4255         break;
;;;4256       }
;;;4257       
;;;4258       default:
;;;4259       break;  
;;;4260     }
;;;4261        
;;;4262     __HAL_UNLOCK(htim);  
;;;4263     return tmpreg;
;;;4264   }
000010  4770              BX       lr
                  |L83.18|
000012  2001              MOVS     r0,#1                 ;4211
000014  f8820038          STRB     r0,[r2,#0x38]         ;4211
000018  bf00              NOP                            ;4211
00001a  b131              CBZ      r1,|L83.42|
00001c  2904              CMP      r1,#4                 ;4213
00001e  d007              BEQ      |L83.48|
000020  2908              CMP      r1,#8                 ;4213
000022  d008              BEQ      |L83.54|
000024  290c              CMP      r1,#0xc               ;4213
000026  d10c              BNE      |L83.66|
000028  e008              B        |L83.60|
                  |L83.42|
00002a  6810              LDR      r0,[r2,#0]            ;4221
00002c  6b43              LDR      r3,[r0,#0x34]         ;4221
00002e  e009              B        |L83.68|
                  |L83.48|
000030  6810              LDR      r0,[r2,#0]            ;4231
000032  6b83              LDR      r3,[r0,#0x38]         ;4231
000034  e006              B        |L83.68|
                  |L83.54|
000036  6810              LDR      r0,[r2,#0]            ;4242
000038  6bc3              LDR      r3,[r0,#0x3c]         ;4242
00003a  e003              B        |L83.68|
                  |L83.60|
00003c  6810              LDR      r0,[r2,#0]            ;4253
00003e  6c03              LDR      r3,[r0,#0x40]         ;4253
000040  e000              B        |L83.68|
                  |L83.66|
000042  bf00              NOP                            ;4259
                  |L83.68|
000044  bf00              NOP                            ;4223
000046  bf00              NOP                            ;4262
000048  2000              MOVS     r0,#0                 ;4262
00004a  f8820038          STRB     r0,[r2,#0x38]         ;4262
00004e  bf00              NOP                            ;4262
000050  4618              MOV      r0,r3                 ;4263
000052  e7dd              B        |L83.16|
;;;4265   /**
                          ENDP


                          AREA ||i.HAL_TIM_SlaveConfigSynchronization||, CODE, READONLY, ALIGN=1

                  HAL_TIM_SlaveConfigSynchronization PROC
;;;4132     */
;;;4133   HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef * sSlaveConfig)
000000  b570              PUSH     {r4-r6,lr}
;;;4134   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;4135     /* Check the parameters */
;;;4136     assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
;;;4137     assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
;;;4138     assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
;;;4139      
;;;4140     __HAL_LOCK(htim);
000006  bf00              NOP      
000008  f8940038          LDRB     r0,[r4,#0x38]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L84.20|
000010  2002              MOVS     r0,#2
                  |L84.18|
;;;4141     
;;;4142     htim->State = HAL_TIM_STATE_BUSY;
;;;4143   
;;;4144     TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
;;;4145     
;;;4146     /* Disable Trigger Interrupt */
;;;4147     __HAL_TIM_DISABLE_IT(htim, TIM_IT_TRIGGER);
;;;4148     
;;;4149     /* Disable Trigger DMA request */
;;;4150     __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
;;;4151     
;;;4152     htim->State = HAL_TIM_STATE_READY;
;;;4153        
;;;4154     __HAL_UNLOCK(htim);  
;;;4155     
;;;4156     return HAL_OK;
;;;4157   } 
000012  bd70              POP      {r4-r6,pc}
                  |L84.20|
000014  2001              MOVS     r0,#1                 ;4140
000016  f8840038          STRB     r0,[r4,#0x38]         ;4140
00001a  bf00              NOP                            ;4140
00001c  2002              MOVS     r0,#2                 ;4142
00001e  f8840039          STRB     r0,[r4,#0x39]         ;4142
000022  4629              MOV      r1,r5                 ;4144
000024  4620              MOV      r0,r4                 ;4144
000026  f7fffffe          BL       TIM_SlaveTimer_SetConfig
00002a  6820              LDR      r0,[r4,#0]            ;4147
00002c  68c0              LDR      r0,[r0,#0xc]          ;4147
00002e  f0200040          BIC      r0,r0,#0x40           ;4147
000032  6821              LDR      r1,[r4,#0]            ;4147
000034  60c8              STR      r0,[r1,#0xc]          ;4147
000036  6820              LDR      r0,[r4,#0]            ;4150
000038  68c0              LDR      r0,[r0,#0xc]          ;4150
00003a  f4204080          BIC      r0,r0,#0x4000         ;4150
00003e  6821              LDR      r1,[r4,#0]            ;4150
000040  60c8              STR      r0,[r1,#0xc]          ;4150
000042  2001              MOVS     r0,#1                 ;4152
000044  f8840039          STRB     r0,[r4,#0x39]         ;4152
000048  bf00              NOP                            ;4154
00004a  2000              MOVS     r0,#0                 ;4154
00004c  f8840038          STRB     r0,[r4,#0x38]         ;4154
000050  bf00              NOP                            ;4154
000052  bf00              NOP                            ;4156
000054  e7dd              B        |L84.18|
;;;4158   
                          ENDP


                          AREA ||i.HAL_TIM_SlaveConfigSynchronization_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_SlaveConfigSynchronization_IT PROC
;;;4167     */
;;;4168   HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization_IT(TIM_HandleTypeDef *htim, 
000000  b570              PUSH     {r4-r6,lr}
;;;4169                                                           TIM_SlaveConfigTypeDef * sSlaveConfig)
;;;4170   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;4171     /* Check the parameters */
;;;4172     assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
;;;4173     assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
;;;4174     assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
;;;4175     
;;;4176     __HAL_LOCK(htim);
000006  bf00              NOP      
000008  f8940038          LDRB     r0,[r4,#0x38]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L85.20|
000010  2002              MOVS     r0,#2
                  |L85.18|
;;;4177   
;;;4178     htim->State = HAL_TIM_STATE_BUSY;
;;;4179     
;;;4180     TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
;;;4181     
;;;4182     /* Enable Trigger Interrupt */
;;;4183     __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);
;;;4184     
;;;4185     /* Disable Trigger DMA request */
;;;4186     __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
;;;4187     
;;;4188     htim->State = HAL_TIM_STATE_READY;
;;;4189        
;;;4190     __HAL_UNLOCK(htim);  
;;;4191     
;;;4192     return HAL_OK;
;;;4193   }
000012  bd70              POP      {r4-r6,pc}
                  |L85.20|
000014  2001              MOVS     r0,#1                 ;4176
000016  f8840038          STRB     r0,[r4,#0x38]         ;4176
00001a  bf00              NOP                            ;4176
00001c  2002              MOVS     r0,#2                 ;4178
00001e  f8840039          STRB     r0,[r4,#0x39]         ;4178
000022  4629              MOV      r1,r5                 ;4180
000024  4620              MOV      r0,r4                 ;4180
000026  f7fffffe          BL       TIM_SlaveTimer_SetConfig
00002a  6820              LDR      r0,[r4,#0]            ;4183
00002c  68c0              LDR      r0,[r0,#0xc]          ;4183
00002e  f0400040          ORR      r0,r0,#0x40           ;4183
000032  6821              LDR      r1,[r4,#0]            ;4183
000034  60c8              STR      r0,[r1,#0xc]          ;4183
000036  6820              LDR      r0,[r4,#0]            ;4186
000038  68c0              LDR      r0,[r0,#0xc]          ;4186
00003a  f4204080          BIC      r0,r0,#0x4000         ;4186
00003e  6821              LDR      r1,[r4,#0]            ;4186
000040  60c8              STR      r0,[r1,#0xc]          ;4186
000042  2001              MOVS     r0,#1                 ;4188
000044  f8840039          STRB     r0,[r4,#0x39]         ;4188
000048  bf00              NOP                            ;4190
00004a  2000              MOVS     r0,#0                 ;4190
00004c  f8840038          STRB     r0,[r4,#0x38]         ;4190
000050  bf00              NOP                            ;4190
000052  bf00              NOP                            ;4192
000054  e7dd              B        |L85.18|
;;;4194   
                          ENDP


                          AREA ||i.HAL_TIM_TriggerCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_TriggerCallback PROC
;;;4353     */
;;;4354   __weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4355   {
;;;4356     /* Prevent unused argument(s) compilation warning */
;;;4357     UNUSED(htim);
;;;4358     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4359               the HAL_TIM_TriggerCallback could be implemented in the user file
;;;4360      */
;;;4361   }
;;;4362   
                          ENDP


                          AREA ||i.TIM_Base_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_Base_SetConfig PROC
;;;4470     */
;;;4471   void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
000000  2200              MOVS     r2,#0
;;;4472   {
;;;4473     uint32_t tmpcr1 = 0;
;;;4474     tmpcr1 = TIMx->CR1;
000002  6802              LDR      r2,[r0,#0]
;;;4475     
;;;4476     /* Set TIM Time Base Unit parameters ---------------------------------------*/
;;;4477     if(IS_TIM_CC3_INSTANCE(TIMx) != RESET)   
000004  4b2c              LDR      r3,|L87.184|
000006  4298              CMP      r0,r3
000008  d00e              BEQ      |L87.40|
00000a  f1b04f80          CMP      r0,#0x40000000
00000e  d00b              BEQ      |L87.40|
000010  4b2a              LDR      r3,|L87.188|
000012  4298              CMP      r0,r3
000014  d008              BEQ      |L87.40|
000016  4b2a              LDR      r3,|L87.192|
000018  4298              CMP      r0,r3
00001a  d005              BEQ      |L87.40|
00001c  4b29              LDR      r3,|L87.196|
00001e  4298              CMP      r0,r3
000020  d002              BEQ      |L87.40|
000022  4b29              LDR      r3,|L87.200|
000024  4298              CMP      r0,r3
000026  d101              BNE      |L87.44|
                  |L87.40|
000028  2301              MOVS     r3,#1
00002a  e000              B        |L87.46|
                  |L87.44|
00002c  2300              MOVS     r3,#0
                  |L87.46|
00002e  b11b              CBZ      r3,|L87.56|
;;;4478     {
;;;4479       /* Select the Counter Mode */
;;;4480       tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
000030  f0220270          BIC      r2,r2,#0x70
;;;4481       tmpcr1 |= Structure->CounterMode;
000034  684b              LDR      r3,[r1,#4]
000036  431a              ORRS     r2,r2,r3
                  |L87.56|
;;;4482     }
;;;4483    
;;;4484     if(IS_TIM_CC1_INSTANCE(TIMx) != RESET)  
000038  4b1f              LDR      r3,|L87.184|
00003a  4298              CMP      r0,r3
00003c  d020              BEQ      |L87.128|
00003e  f1b04f80          CMP      r0,#0x40000000
000042  d01d              BEQ      |L87.128|
000044  4b1d              LDR      r3,|L87.188|
000046  4298              CMP      r0,r3
000048  d01a              BEQ      |L87.128|
00004a  4b1d              LDR      r3,|L87.192|
00004c  4298              CMP      r0,r3
00004e  d017              BEQ      |L87.128|
000050  4b1c              LDR      r3,|L87.196|
000052  4298              CMP      r0,r3
000054  d014              BEQ      |L87.128|
000056  4b1c              LDR      r3,|L87.200|
000058  4298              CMP      r0,r3
00005a  d011              BEQ      |L87.128|
00005c  4b1b              LDR      r3,|L87.204|
00005e  4298              CMP      r0,r3
000060  d00e              BEQ      |L87.128|
000062  4b1b              LDR      r3,|L87.208|
000064  4298              CMP      r0,r3
000066  d00b              BEQ      |L87.128|
000068  4b1a              LDR      r3,|L87.212|
00006a  4298              CMP      r0,r3
00006c  d008              BEQ      |L87.128|
00006e  4b1a              LDR      r3,|L87.216|
000070  4298              CMP      r0,r3
000072  d005              BEQ      |L87.128|
000074  4b19              LDR      r3,|L87.220|
000076  4298              CMP      r0,r3
000078  d002              BEQ      |L87.128|
00007a  4b19              LDR      r3,|L87.224|
00007c  4298              CMP      r0,r3
00007e  d101              BNE      |L87.132|
                  |L87.128|
000080  2301              MOVS     r3,#1
000082  e000              B        |L87.134|
                  |L87.132|
000084  2300              MOVS     r3,#0
                  |L87.134|
000086  b11b              CBZ      r3,|L87.144|
;;;4485     {
;;;4486       /* Set the clock division */
;;;4487       tmpcr1 &= ~TIM_CR1_CKD;
000088  f4227240          BIC      r2,r2,#0x300
;;;4488       tmpcr1 |= (uint32_t)Structure->ClockDivision;
00008c  68cb              LDR      r3,[r1,#0xc]
00008e  431a              ORRS     r2,r2,r3
                  |L87.144|
;;;4489     }
;;;4490   
;;;4491     TIMx->CR1 = tmpcr1;
000090  6002              STR      r2,[r0,#0]
;;;4492   
;;;4493     /* Set the Auto-reload value */
;;;4494     TIMx->ARR = (uint32_t)Structure->Period ;
000092  688b              LDR      r3,[r1,#8]
000094  62c3              STR      r3,[r0,#0x2c]
;;;4495    
;;;4496     /* Set the Prescaler value */
;;;4497     TIMx->PSC = (uint32_t)Structure->Prescaler;
000096  680b              LDR      r3,[r1,#0]
000098  6283              STR      r3,[r0,#0x28]
;;;4498       
;;;4499     if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)  
00009a  4b07              LDR      r3,|L87.184|
00009c  4298              CMP      r0,r3
00009e  d002              BEQ      |L87.166|
0000a0  4b09              LDR      r3,|L87.200|
0000a2  4298              CMP      r0,r3
0000a4  d101              BNE      |L87.170|
                  |L87.166|
0000a6  2301              MOVS     r3,#1
0000a8  e000              B        |L87.172|
                  |L87.170|
0000aa  2300              MOVS     r3,#0
                  |L87.172|
0000ac  b10b              CBZ      r3,|L87.178|
;;;4500     {
;;;4501       /* Set the Repetition Counter value */
;;;4502       TIMx->RCR = Structure->RepetitionCounter;
0000ae  690b              LDR      r3,[r1,#0x10]
0000b0  6303              STR      r3,[r0,#0x30]
                  |L87.178|
;;;4503     }
;;;4504   
;;;4505     /* Generate an update event to reload the Prescaler 
;;;4506        and the repetition counter(only for TIM1 and TIM8) value immediately */
;;;4507     TIMx->EGR = TIM_EGR_UG;
0000b2  2301              MOVS     r3,#1
0000b4  6143              STR      r3,[r0,#0x14]
;;;4508   }
0000b6  4770              BX       lr
;;;4509   
                          ENDP

                  |L87.184|
                          DCD      0x40010000
                  |L87.188|
                          DCD      0x40000400
                  |L87.192|
                          DCD      0x40000800
                  |L87.196|
                          DCD      0x40000c00
                  |L87.200|
                          DCD      0x40010400
                  |L87.204|
                          DCD      0x40014000
                  |L87.208|
                          DCD      0x40014400
                  |L87.212|
                          DCD      0x40014800
                  |L87.216|
                          DCD      0x40001800
                  |L87.220|
                          DCD      0x40001c00
                  |L87.224|
                          DCD      0x40002000

                          AREA ||i.TIM_CCxChannelCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxChannelCmd PROC
;;;4728     */
;;;4729   void TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState)
000000  b530              PUSH     {r4,r5,lr}
;;;4730   {
;;;4731     uint32_t tmp = 0;
000002  2300              MOVS     r3,#0
;;;4732   
;;;4733     /* Check the parameters */
;;;4734     assert_param(IS_TIM_CC1_INSTANCE(TIMx)); 
;;;4735     assert_param(IS_TIM_CHANNELS(Channel));
;;;4736   
;;;4737     tmp = TIM_CCER_CC1E << Channel;
000004  2401              MOVS     r4,#1
000006  fa04f301          LSL      r3,r4,r1
;;;4738   
;;;4739     /* Reset the CCxE Bit */
;;;4740     TIMx->CCER &= ~tmp;
00000a  6a04              LDR      r4,[r0,#0x20]
00000c  439c              BICS     r4,r4,r3
00000e  6204              STR      r4,[r0,#0x20]
;;;4741   
;;;4742     /* Set or reset the CCxE Bit */ 
;;;4743     TIMx->CCER |= (uint32_t)(ChannelState << Channel);
000010  6a04              LDR      r4,[r0,#0x20]
000012  fa02f501          LSL      r5,r2,r1
000016  432c              ORRS     r4,r4,r5
000018  6204              STR      r4,[r0,#0x20]
;;;4744   }
00001a  bd30              POP      {r4,r5,pc}
;;;4745   
                          ENDP


                          AREA ||i.TIM_DMACaptureCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMACaptureCplt PROC
;;;4687     */
;;;4688   void TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;4689   {
000002  4605              MOV      r5,r0
;;;4690     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;4691     
;;;4692     htim->State= HAL_TIM_STATE_READY;
000006  2001              MOVS     r0,#1
000008  f8840039          STRB     r0,[r4,#0x39]
;;;4693     
;;;4694     if(hdma == htim->hdma[TIM_DMA_ID_CC1])
00000c  6a20              LDR      r0,[r4,#0x20]
00000e  42a8              CMP      r0,r5
000010  d102              BNE      |L89.24|
;;;4695     {
;;;4696       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
000012  2001              MOVS     r0,#1
000014  7620              STRB     r0,[r4,#0x18]
000016  e010              B        |L89.58|
                  |L89.24|
;;;4697     }
;;;4698     else if(hdma == htim->hdma[TIM_DMA_ID_CC2])
000018  6a60              LDR      r0,[r4,#0x24]
00001a  42a8              CMP      r0,r5
00001c  d102              BNE      |L89.36|
;;;4699     {
;;;4700       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
00001e  2002              MOVS     r0,#2
000020  7620              STRB     r0,[r4,#0x18]
000022  e00a              B        |L89.58|
                  |L89.36|
;;;4701     }
;;;4702     else if(hdma == htim->hdma[TIM_DMA_ID_CC3])
000024  6aa0              LDR      r0,[r4,#0x28]
000026  42a8              CMP      r0,r5
000028  d102              BNE      |L89.48|
;;;4703     {
;;;4704       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
00002a  2004              MOVS     r0,#4
00002c  7620              STRB     r0,[r4,#0x18]
00002e  e004              B        |L89.58|
                  |L89.48|
;;;4705     }
;;;4706     else if(hdma == htim->hdma[TIM_DMA_ID_CC4])
000030  6ae0              LDR      r0,[r4,#0x2c]
000032  42a8              CMP      r0,r5
000034  d101              BNE      |L89.58|
;;;4707     {
;;;4708       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
000036  2008              MOVS     r0,#8
000038  7620              STRB     r0,[r4,#0x18]
                  |L89.58|
;;;4709     }
;;;4710     
;;;4711     HAL_TIM_IC_CaptureCallback(htim); 
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
;;;4712     
;;;4713     htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000040  2000              MOVS     r0,#0
000042  7620              STRB     r0,[r4,#0x18]
;;;4714   }
000044  bd70              POP      {r4-r6,pc}
;;;4715   
                          ENDP


                          AREA ||i.TIM_DMADelayPulseCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMADelayPulseCplt PROC
;;;4638     */
;;;4639   void TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;4640   {
000002  4605              MOV      r5,r0
;;;4641     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;4642     
;;;4643     htim->State= HAL_TIM_STATE_READY; 
000006  2001              MOVS     r0,#1
000008  f8840039          STRB     r0,[r4,#0x39]
;;;4644     
;;;4645     if(hdma == htim->hdma[TIM_DMA_ID_CC1])
00000c  6a20              LDR      r0,[r4,#0x20]
00000e  42a8              CMP      r0,r5
000010  d102              BNE      |L90.24|
;;;4646     {
;;;4647       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
000012  2001              MOVS     r0,#1
000014  7620              STRB     r0,[r4,#0x18]
000016  e010              B        |L90.58|
                  |L90.24|
;;;4648     }
;;;4649     else if(hdma == htim->hdma[TIM_DMA_ID_CC2])
000018  6a60              LDR      r0,[r4,#0x24]
00001a  42a8              CMP      r0,r5
00001c  d102              BNE      |L90.36|
;;;4650     {
;;;4651       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
00001e  2002              MOVS     r0,#2
000020  7620              STRB     r0,[r4,#0x18]
000022  e00a              B        |L90.58|
                  |L90.36|
;;;4652     }
;;;4653     else if(hdma == htim->hdma[TIM_DMA_ID_CC3])
000024  6aa0              LDR      r0,[r4,#0x28]
000026  42a8              CMP      r0,r5
000028  d102              BNE      |L90.48|
;;;4654     {
;;;4655       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
00002a  2004              MOVS     r0,#4
00002c  7620              STRB     r0,[r4,#0x18]
00002e  e004              B        |L90.58|
                  |L90.48|
;;;4656     }
;;;4657     else if(hdma == htim->hdma[TIM_DMA_ID_CC4])
000030  6ae0              LDR      r0,[r4,#0x2c]
000032  42a8              CMP      r0,r5
000034  d101              BNE      |L90.58|
;;;4658     {
;;;4659       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
000036  2008              MOVS     r0,#8
000038  7620              STRB     r0,[r4,#0x18]
                  |L90.58|
;;;4660     }
;;;4661   
;;;4662     HAL_TIM_PWM_PulseFinishedCallback(htim);
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
;;;4663   
;;;4664     htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;  
000040  2000              MOVS     r0,#0
000042  7620              STRB     r0,[r4,#0x18]
;;;4665   }
000044  bd70              POP      {r4-r6,pc}
;;;4666   
                          ENDP


                          AREA ||i.TIM_DMAError||, CODE, READONLY, ALIGN=1

                  TIM_DMAError PROC
;;;4672     */
;;;4673   void TIM_DMAError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;4674   {
000002  4604              MOV      r4,r0
;;;4675     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6ba5              LDR      r5,[r4,#0x38]
;;;4676     
;;;4677     htim->State= HAL_TIM_STATE_READY;
000006  2001              MOVS     r0,#1
000008  f8850039          STRB     r0,[r5,#0x39]
;;;4678      
;;;4679     HAL_TIM_ErrorCallback(htim);
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       HAL_TIM_ErrorCallback
;;;4680   }
000012  bd70              POP      {r4-r6,pc}
;;;4681   
                          ENDP


                          AREA ||i.TIM_DMAPeriodElapsedCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMAPeriodElapsedCplt PROC
;;;4751     */
;;;4752   static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;4753   {
000002  4604              MOV      r4,r0
;;;4754     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6ba5              LDR      r5,[r4,#0x38]
;;;4755     
;;;4756     htim->State= HAL_TIM_STATE_READY;
000006  2001              MOVS     r0,#1
000008  f8850039          STRB     r0,[r5,#0x39]
;;;4757     
;;;4758     HAL_TIM_PeriodElapsedCallback(htim);
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       HAL_TIM_PeriodElapsedCallback
;;;4759   }
000012  bd70              POP      {r4-r6,pc}
;;;4760   
                          ENDP


                          AREA ||i.TIM_DMATriggerCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMATriggerCplt PROC
;;;4766     */
;;;4767   static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;4768   {
000002  4604              MOV      r4,r0
;;;4769     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;  
000004  6ba5              LDR      r5,[r4,#0x38]
;;;4770     
;;;4771     htim->State= HAL_TIM_STATE_READY; 
000006  2001              MOVS     r0,#1
000008  f8850039          STRB     r0,[r5,#0x39]
;;;4772     
;;;4773     HAL_TIM_TriggerCallback(htim);
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       HAL_TIM_TriggerCallback
;;;4774   }
000012  bd70              POP      {r4-r6,pc}
;;;4775   
                          ENDP


                          AREA ||i.TIM_ETR_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_ETR_SetConfig PROC
;;;5357     */
;;;5358   static void TIM_ETR_SetConfig(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler,
000000  b530              PUSH     {r4,r5,lr}
;;;5359                          uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
;;;5360   {
000002  460c              MOV      r4,r1
;;;5361     uint32_t tmpsmcr = 0;
000004  2100              MOVS     r1,#0
;;;5362   
;;;5363     tmpsmcr = TIMx->SMCR;
000006  6881              LDR      r1,[r0,#8]
;;;5364   
;;;5365     /* Reset the ETR Bits */
;;;5366     tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
000008  f421417f          BIC      r1,r1,#0xff00
;;;5367   
;;;5368     /* Set the Prescaler, the Filter value and the Polarity */
;;;5369     tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8)));
00000c  ea422503          ORR      r5,r2,r3,LSL #8
000010  4325              ORRS     r5,r5,r4
000012  4329              ORRS     r1,r1,r5
;;;5370   
;;;5371     /* Write to TIMx SMCR */
;;;5372     TIMx->SMCR = tmpsmcr;
000014  6081              STR      r1,[r0,#8]
;;;5373   } 
000016  bd30              POP      {r4,r5,pc}
;;;5374   
                          ENDP


                          AREA ||i.TIM_ITRx_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITRx_SetConfig PROC
;;;5326     */
;;;5327   static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint16_t TIM_ITRx)
000000  460a              MOV      r2,r1
;;;5328   {
;;;5329     uint32_t tmpsmcr = 0;
000002  2100              MOVS     r1,#0
;;;5330     
;;;5331      /* Get the TIMx SMCR register value */
;;;5332      tmpsmcr = TIMx->SMCR;
000004  6881              LDR      r1,[r0,#8]
;;;5333      /* Reset the TS Bits */
;;;5334      tmpsmcr &= ~TIM_SMCR_TS;
000006  f0210170          BIC      r1,r1,#0x70
;;;5335      /* Set the Input Trigger source and the slave mode*/
;;;5336      tmpsmcr |= TIM_ITRx | TIM_SLAVEMODE_EXTERNAL1;
00000a  f0420307          ORR      r3,r2,#7
00000e  4319              ORRS     r1,r1,r3
;;;5337      /* Write to TIMx SMCR */
;;;5338      TIMx->SMCR = tmpsmcr;
000010  6081              STR      r1,[r0,#8]
;;;5339   }
000012  4770              BX       lr
;;;5340   
                          ENDP


                          AREA ||i.TIM_OC1_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC1_SetConfig PROC
;;;4781     */
;;;4782   static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b530              PUSH     {r4,r5,lr}
;;;4783   {
;;;4784     uint32_t tmpccmrx = 0;
000002  2400              MOVS     r4,#0
;;;4785     uint32_t tmpccer = 0;
000004  2200              MOVS     r2,#0
;;;4786     uint32_t tmpcr2 = 0;  
000006  2300              MOVS     r3,#0
;;;4787   
;;;4788     /* Disable the Channel 1: Reset the CC1E Bit */
;;;4789     TIMx->CCER &= ~TIM_CCER_CC1E;
000008  6a05              LDR      r5,[r0,#0x20]
00000a  f0250501          BIC      r5,r5,#1
00000e  6205              STR      r5,[r0,#0x20]
;;;4790     
;;;4791     /* Get the TIMx CCER register value */
;;;4792     tmpccer = TIMx->CCER;
000010  6a02              LDR      r2,[r0,#0x20]
;;;4793     /* Get the TIMx CR2 register value */
;;;4794     tmpcr2 = TIMx->CR2;
000012  6843              LDR      r3,[r0,#4]
;;;4795     
;;;4796     /* Get the TIMx CCMR1 register value */
;;;4797     tmpccmrx = TIMx->CCMR1;
000014  6984              LDR      r4,[r0,#0x18]
;;;4798       
;;;4799     /* Reset the Output Compare Mode Bits */
;;;4800     tmpccmrx &= ~TIM_CCMR1_OC1M;
000016  f0240470          BIC      r4,r4,#0x70
;;;4801     tmpccmrx &= ~TIM_CCMR1_CC1S;
00001a  f0240403          BIC      r4,r4,#3
;;;4802     /* Select the Output Compare Mode */
;;;4803     tmpccmrx |= OC_Config->OCMode;
00001e  680d              LDR      r5,[r1,#0]
000020  432c              ORRS     r4,r4,r5
;;;4804     
;;;4805     /* Reset the Output Polarity level */
;;;4806     tmpccer &= ~TIM_CCER_CC1P;
000022  f0220202          BIC      r2,r2,#2
;;;4807     /* Set the Output Compare Polarity */
;;;4808     tmpccer |= OC_Config->OCPolarity;
000026  688d              LDR      r5,[r1,#8]
000028  432a              ORRS     r2,r2,r5
;;;4809   
;;;4810       
;;;4811     if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
00002a  4d0f              LDR      r5,|L96.104|
00002c  42a8              CMP      r0,r5
00002e  d002              BEQ      |L96.54|
000030  4d0e              LDR      r5,|L96.108|
000032  42a8              CMP      r0,r5
000034  d101              BNE      |L96.58|
                  |L96.54|
000036  2501              MOVS     r5,#1
000038  e000              B        |L96.60|
                  |L96.58|
00003a  2500              MOVS     r5,#0
                  |L96.60|
00003c  b16d              CBZ      r5,|L96.90|
;;;4812     {   
;;;4813       /* Reset the Output N Polarity level */
;;;4814       tmpccer &= ~TIM_CCER_CC1NP;
00003e  f0220208          BIC      r2,r2,#8
;;;4815       /* Set the Output N Polarity */
;;;4816       tmpccer |= OC_Config->OCNPolarity;
000042  68cd              LDR      r5,[r1,#0xc]
000044  432a              ORRS     r2,r2,r5
;;;4817       /* Reset the Output N State */
;;;4818       tmpccer &= ~TIM_CCER_CC1NE;
000046  f0220204          BIC      r2,r2,#4
;;;4819       
;;;4820       /* Reset the Output Compare and Output Compare N IDLE State */
;;;4821       tmpcr2 &= ~TIM_CR2_OIS1;
00004a  f4237380          BIC      r3,r3,#0x100
;;;4822       tmpcr2 &= ~TIM_CR2_OIS1N;
00004e  f4237300          BIC      r3,r3,#0x200
;;;4823       /* Set the Output Idle state */
;;;4824       tmpcr2 |= OC_Config->OCIdleState;
000052  694d              LDR      r5,[r1,#0x14]
000054  432b              ORRS     r3,r3,r5
;;;4825       /* Set the Output N Idle state */
;;;4826       tmpcr2 |= OC_Config->OCNIdleState;
000056  698d              LDR      r5,[r1,#0x18]
000058  432b              ORRS     r3,r3,r5
                  |L96.90|
;;;4827     }
;;;4828     /* Write to TIMx CR2 */
;;;4829     TIMx->CR2 = tmpcr2;
00005a  6043              STR      r3,[r0,#4]
;;;4830     
;;;4831     /* Write to TIMx CCMR1 */
;;;4832     TIMx->CCMR1 = tmpccmrx;
00005c  6184              STR      r4,[r0,#0x18]
;;;4833     
;;;4834     /* Set the Capture Compare Register value */
;;;4835     TIMx->CCR1 = OC_Config->Pulse;
00005e  684d              LDR      r5,[r1,#4]
000060  6345              STR      r5,[r0,#0x34]
;;;4836     
;;;4837     /* Write to TIMx CCER */
;;;4838     TIMx->CCER = tmpccer;  
000062  6202              STR      r2,[r0,#0x20]
;;;4839   } 
000064  bd30              POP      {r4,r5,pc}
;;;4840   
                          ENDP

000066  0000              DCW      0x0000
                  |L96.104|
                          DCD      0x40010000
                  |L96.108|
                          DCD      0x40010400

                          AREA ||i.TIM_OC2_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC2_SetConfig PROC
;;;4571     */
;;;4572   void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b530              PUSH     {r4,r5,lr}
;;;4573   {
;;;4574     uint32_t tmpccmrx = 0;
000002  2400              MOVS     r4,#0
;;;4575     uint32_t tmpccer = 0;
000004  2200              MOVS     r2,#0
;;;4576     uint32_t tmpcr2 = 0;
000006  2300              MOVS     r3,#0
;;;4577      
;;;4578     /* Disable the Channel 2: Reset the CC2E Bit */
;;;4579     TIMx->CCER &= ~TIM_CCER_CC2E;
000008  6a05              LDR      r5,[r0,#0x20]
00000a  f0250510          BIC      r5,r5,#0x10
00000e  6205              STR      r5,[r0,#0x20]
;;;4580     
;;;4581     /* Get the TIMx CCER register value */  
;;;4582     tmpccer = TIMx->CCER;
000010  6a02              LDR      r2,[r0,#0x20]
;;;4583     /* Get the TIMx CR2 register value */
;;;4584     tmpcr2 = TIMx->CR2;
000012  6843              LDR      r3,[r0,#4]
;;;4585     
;;;4586     /* Get the TIMx CCMR1 register value */
;;;4587     tmpccmrx = TIMx->CCMR1;
000014  6984              LDR      r4,[r0,#0x18]
;;;4588       
;;;4589     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;4590     tmpccmrx &= ~TIM_CCMR1_OC2M;
000016  f42444e0          BIC      r4,r4,#0x7000
;;;4591     tmpccmrx &= ~TIM_CCMR1_CC2S;
00001a  f4247440          BIC      r4,r4,#0x300
;;;4592     
;;;4593     /* Select the Output Compare Mode */
;;;4594     tmpccmrx |= (OC_Config->OCMode << 8);
00001e  680d              LDR      r5,[r1,#0]
000020  ea442405          ORR      r4,r4,r5,LSL #8
;;;4595     
;;;4596     /* Reset the Output Polarity level */
;;;4597     tmpccer &= ~TIM_CCER_CC2P;
000024  f0220220          BIC      r2,r2,#0x20
;;;4598     /* Set the Output Compare Polarity */
;;;4599     tmpccer |= (OC_Config->OCPolarity << 4);
000028  688d              LDR      r5,[r1,#8]
00002a  ea421205          ORR      r2,r2,r5,LSL #4
;;;4600       
;;;4601     if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
00002e  4d10              LDR      r5,|L97.112|
000030  42a8              CMP      r0,r5
000032  d002              BEQ      |L97.58|
000034  4d0f              LDR      r5,|L97.116|
000036  42a8              CMP      r0,r5
000038  d101              BNE      |L97.62|
                  |L97.58|
00003a  2501              MOVS     r5,#1
00003c  e000              B        |L97.64|
                  |L97.62|
00003e  2500              MOVS     r5,#0
                  |L97.64|
000040  b185              CBZ      r5,|L97.100|
;;;4602     {
;;;4603       assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
;;;4604       
;;;4605       /* Reset the Output N Polarity level */
;;;4606       tmpccer &= ~TIM_CCER_CC2NP;
000042  f0220280          BIC      r2,r2,#0x80
;;;4607       /* Set the Output N Polarity */
;;;4608       tmpccer |= (OC_Config->OCNPolarity << 4);
000046  68cd              LDR      r5,[r1,#0xc]
000048  ea421205          ORR      r2,r2,r5,LSL #4
;;;4609       /* Reset the Output N State */
;;;4610       tmpccer &= ~TIM_CCER_CC2NE;
00004c  f0220240          BIC      r2,r2,#0x40
;;;4611       
;;;4612       /* Reset the Output Compare and Output Compare N IDLE State */
;;;4613       tmpcr2 &= ~TIM_CR2_OIS2;
000050  f4236380          BIC      r3,r3,#0x400
;;;4614       tmpcr2 &= ~TIM_CR2_OIS2N;
000054  f4236300          BIC      r3,r3,#0x800
;;;4615       /* Set the Output Idle state */
;;;4616       tmpcr2 |= (OC_Config->OCIdleState << 2);
000058  694d              LDR      r5,[r1,#0x14]
00005a  ea430385          ORR      r3,r3,r5,LSL #2
;;;4617       /* Set the Output N Idle state */
;;;4618       tmpcr2 |= (OC_Config->OCNIdleState << 2);
00005e  698d              LDR      r5,[r1,#0x18]
000060  ea430385          ORR      r3,r3,r5,LSL #2
                  |L97.100|
;;;4619     }
;;;4620     /* Write to TIMx CR2 */
;;;4621     TIMx->CR2 = tmpcr2;
000064  6043              STR      r3,[r0,#4]
;;;4622     
;;;4623     /* Write to TIMx CCMR1 */
;;;4624     TIMx->CCMR1 = tmpccmrx;
000066  6184              STR      r4,[r0,#0x18]
;;;4625     
;;;4626     /* Set the Capture Compare Register value */
;;;4627     TIMx->CCR2 = OC_Config->Pulse;
000068  684d              LDR      r5,[r1,#4]
00006a  6385              STR      r5,[r0,#0x38]
;;;4628     
;;;4629     /* Write to TIMx CCER */
;;;4630     TIMx->CCER = tmpccer;
00006c  6202              STR      r2,[r0,#0x20]
;;;4631   }
00006e  bd30              POP      {r4,r5,pc}
;;;4632   
                          ENDP

                  |L97.112|
                          DCD      0x40010000
                  |L97.116|
                          DCD      0x40010400

                          AREA ||i.TIM_OC3_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC3_SetConfig PROC
;;;4846     */
;;;4847   static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b530              PUSH     {r4,r5,lr}
;;;4848   {
;;;4849     uint32_t tmpccmrx = 0;
000002  2400              MOVS     r4,#0
;;;4850     uint32_t tmpccer = 0;
000004  2200              MOVS     r2,#0
;;;4851     uint32_t tmpcr2 = 0;   
000006  2300              MOVS     r3,#0
;;;4852   
;;;4853     /* Disable the Channel 3: Reset the CC2E Bit */
;;;4854     TIMx->CCER &= ~TIM_CCER_CC3E;
000008  6a05              LDR      r5,[r0,#0x20]
00000a  f4257580          BIC      r5,r5,#0x100
00000e  6205              STR      r5,[r0,#0x20]
;;;4855     
;;;4856     /* Get the TIMx CCER register value */
;;;4857     tmpccer = TIMx->CCER;
000010  6a02              LDR      r2,[r0,#0x20]
;;;4858     /* Get the TIMx CR2 register value */
;;;4859     tmpcr2 = TIMx->CR2;
000012  6843              LDR      r3,[r0,#4]
;;;4860     
;;;4861     /* Get the TIMx CCMR2 register value */
;;;4862     tmpccmrx = TIMx->CCMR2;
000014  69c4              LDR      r4,[r0,#0x1c]
;;;4863       
;;;4864     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;4865     tmpccmrx &= ~TIM_CCMR2_OC3M;
000016  f0240470          BIC      r4,r4,#0x70
;;;4866     tmpccmrx &= ~TIM_CCMR2_CC3S;  
00001a  f0240403          BIC      r4,r4,#3
;;;4867     /* Select the Output Compare Mode */
;;;4868     tmpccmrx |= OC_Config->OCMode;
00001e  680d              LDR      r5,[r1,#0]
000020  432c              ORRS     r4,r4,r5
;;;4869     
;;;4870     /* Reset the Output Polarity level */
;;;4871     tmpccer &= ~TIM_CCER_CC3P;
000022  f4227200          BIC      r2,r2,#0x200
;;;4872     /* Set the Output Compare Polarity */
;;;4873     tmpccer |= (OC_Config->OCPolarity << 8);
000026  688d              LDR      r5,[r1,#8]
000028  ea422205          ORR      r2,r2,r5,LSL #8
;;;4874       
;;;4875     if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
00002c  4d10              LDR      r5,|L98.112|
00002e  42a8              CMP      r0,r5
000030  d002              BEQ      |L98.56|
000032  4d10              LDR      r5,|L98.116|
000034  42a8              CMP      r0,r5
000036  d101              BNE      |L98.60|
                  |L98.56|
000038  2501              MOVS     r5,#1
00003a  e000              B        |L98.62|
                  |L98.60|
00003c  2500              MOVS     r5,#0
                  |L98.62|
00003e  b185              CBZ      r5,|L98.98|
;;;4876     {
;;;4877       assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
;;;4878       assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
;;;4879       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;4880       
;;;4881       /* Reset the Output N Polarity level */
;;;4882       tmpccer &= ~TIM_CCER_CC3NP;
000040  f4226200          BIC      r2,r2,#0x800
;;;4883       /* Set the Output N Polarity */
;;;4884       tmpccer |= (OC_Config->OCNPolarity << 8);
000044  68cd              LDR      r5,[r1,#0xc]
000046  ea422205          ORR      r2,r2,r5,LSL #8
;;;4885       /* Reset the Output N State */
;;;4886       tmpccer &= ~TIM_CCER_CC3NE;
00004a  f4226280          BIC      r2,r2,#0x400
;;;4887       
;;;4888       /* Reset the Output Compare and Output Compare N IDLE State */
;;;4889       tmpcr2 &= ~TIM_CR2_OIS3;
00004e  f4235380          BIC      r3,r3,#0x1000
;;;4890       tmpcr2 &= ~TIM_CR2_OIS3N;
000052  f4235300          BIC      r3,r3,#0x2000
;;;4891       /* Set the Output Idle state */
;;;4892       tmpcr2 |= (OC_Config->OCIdleState << 4);
000056  694d              LDR      r5,[r1,#0x14]
000058  ea431305          ORR      r3,r3,r5,LSL #4
;;;4893       /* Set the Output N Idle state */
;;;4894       tmpcr2 |= (OC_Config->OCNIdleState << 4);
00005c  698d              LDR      r5,[r1,#0x18]
00005e  ea431305          ORR      r3,r3,r5,LSL #4
                  |L98.98|
;;;4895     }
;;;4896     /* Write to TIMx CR2 */
;;;4897     TIMx->CR2 = tmpcr2;
000062  6043              STR      r3,[r0,#4]
;;;4898     
;;;4899     /* Write to TIMx CCMR2 */
;;;4900     TIMx->CCMR2 = tmpccmrx;
000064  61c4              STR      r4,[r0,#0x1c]
;;;4901     
;;;4902     /* Set the Capture Compare Register value */
;;;4903     TIMx->CCR3 = OC_Config->Pulse;
000066  684d              LDR      r5,[r1,#4]
000068  63c5              STR      r5,[r0,#0x3c]
;;;4904     
;;;4905     /* Write to TIMx CCER */
;;;4906     TIMx->CCER = tmpccer;
00006a  6202              STR      r2,[r0,#0x20]
;;;4907   }
00006c  bd30              POP      {r4,r5,pc}
;;;4908   
                          ENDP

00006e  0000              DCW      0x0000
                  |L98.112|
                          DCD      0x40010000
                  |L98.116|
                          DCD      0x40010400

                          AREA ||i.TIM_OC4_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC4_SetConfig PROC
;;;4914     */
;;;4915   static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b530              PUSH     {r4,r5,lr}
;;;4916   {
;;;4917     uint32_t tmpccmrx = 0;
000002  2200              MOVS     r2,#0
;;;4918     uint32_t tmpccer = 0;
000004  2300              MOVS     r3,#0
;;;4919     uint32_t tmpcr2 = 0;
000006  2400              MOVS     r4,#0
;;;4920   
;;;4921     /* Disable the Channel 4: Reset the CC4E Bit */
;;;4922     TIMx->CCER &= ~TIM_CCER_CC4E;
000008  6a05              LDR      r5,[r0,#0x20]
00000a  f4255580          BIC      r5,r5,#0x1000
00000e  6205              STR      r5,[r0,#0x20]
;;;4923     
;;;4924     /* Get the TIMx CCER register value */
;;;4925     tmpccer = TIMx->CCER;
000010  6a03              LDR      r3,[r0,#0x20]
;;;4926     /* Get the TIMx CR2 register value */
;;;4927     tmpcr2 = TIMx->CR2;
000012  6844              LDR      r4,[r0,#4]
;;;4928     
;;;4929     /* Get the TIMx CCMR2 register value */
;;;4930     tmpccmrx = TIMx->CCMR2;
000014  69c2              LDR      r2,[r0,#0x1c]
;;;4931       
;;;4932     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;4933     tmpccmrx &= ~TIM_CCMR2_OC4M;
000016  f42242e0          BIC      r2,r2,#0x7000
;;;4934     tmpccmrx &= ~TIM_CCMR2_CC4S;
00001a  f4227240          BIC      r2,r2,#0x300
;;;4935     
;;;4936     /* Select the Output Compare Mode */
;;;4937     tmpccmrx |= (OC_Config->OCMode << 8);
00001e  680d              LDR      r5,[r1,#0]
000020  ea422205          ORR      r2,r2,r5,LSL #8
;;;4938     
;;;4939     /* Reset the Output Polarity level */
;;;4940     tmpccer &= ~TIM_CCER_CC4P;
000024  f4235300          BIC      r3,r3,#0x2000
;;;4941     /* Set the Output Compare Polarity */
;;;4942     tmpccer |= (OC_Config->OCPolarity << 12);
000028  688d              LDR      r5,[r1,#8]
00002a  ea433305          ORR      r3,r3,r5,LSL #12
;;;4943      
;;;4944     /*if((TIMx == TIM1) || (TIMx == TIM8))*/
;;;4945     if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
00002e  4d0a              LDR      r5,|L99.88|
000030  42a8              CMP      r0,r5
000032  d002              BEQ      |L99.58|
000034  4d09              LDR      r5,|L99.92|
000036  42a8              CMP      r0,r5
000038  d101              BNE      |L99.62|
                  |L99.58|
00003a  2501              MOVS     r5,#1
00003c  e000              B        |L99.64|
                  |L99.62|
00003e  2500              MOVS     r5,#0
                  |L99.64|
000040  b125              CBZ      r5,|L99.76|
;;;4946     {
;;;4947       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;4948       /* Reset the Output Compare IDLE State */
;;;4949       tmpcr2 &= ~TIM_CR2_OIS4;
000042  f4244480          BIC      r4,r4,#0x4000
;;;4950       /* Set the Output Idle state */
;;;4951       tmpcr2 |= (OC_Config->OCIdleState << 6);
000046  694d              LDR      r5,[r1,#0x14]
000048  ea441485          ORR      r4,r4,r5,LSL #6
                  |L99.76|
;;;4952     }
;;;4953     /* Write to TIMx CR2 */
;;;4954     TIMx->CR2 = tmpcr2;
00004c  6044              STR      r4,[r0,#4]
;;;4955     
;;;4956     /* Write to TIMx CCMR2 */  
;;;4957     TIMx->CCMR2 = tmpccmrx;
00004e  61c2              STR      r2,[r0,#0x1c]
;;;4958       
;;;4959     /* Set the Capture Compare Register value */
;;;4960     TIMx->CCR4 = OC_Config->Pulse;
000050  684d              LDR      r5,[r1,#4]
000052  6405              STR      r5,[r0,#0x40]
;;;4961     
;;;4962     /* Write to TIMx CCER */
;;;4963     TIMx->CCER = tmpccer;
000054  6203              STR      r3,[r0,#0x20]
;;;4964   }
000056  bd30              POP      {r4,r5,pc}
;;;4965   
                          ENDP

                  |L99.88|
                          DCD      0x40010000
                  |L99.92|
                          DCD      0x40010400

                          AREA ||i.TIM_SlaveTimer_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_SlaveTimer_SetConfig PROC
;;;4972     */
;;;4973   static void TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;4974                                 TIM_SlaveConfigTypeDef * sSlaveConfig)
;;;4975   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;4976     uint32_t tmpsmcr = 0;
000008  2600              MOVS     r6,#0
;;;4977     uint32_t tmpccmr1 = 0;
00000a  2700              MOVS     r7,#0
;;;4978     uint32_t tmpccer = 0;
00000c  46b0              MOV      r8,r6
;;;4979   
;;;4980    /* Get the TIMx SMCR register value */
;;;4981     tmpsmcr = htim->Instance->SMCR;
00000e  6820              LDR      r0,[r4,#0]
000010  6886              LDR      r6,[r0,#8]
;;;4982   
;;;4983     /* Reset the Trigger Selection Bits */
;;;4984     tmpsmcr &= ~TIM_SMCR_TS;
000012  f0260670          BIC      r6,r6,#0x70
;;;4985     /* Set the Input Trigger source */
;;;4986     tmpsmcr |= sSlaveConfig->InputTrigger;
000016  6868              LDR      r0,[r5,#4]
000018  4306              ORRS     r6,r6,r0
;;;4987   
;;;4988     /* Reset the slave mode Bits */
;;;4989     tmpsmcr &= ~TIM_SMCR_SMS;
00001a  f0260607          BIC      r6,r6,#7
;;;4990     /* Set the slave mode */
;;;4991     tmpsmcr |= sSlaveConfig->SlaveMode;
00001e  6828              LDR      r0,[r5,#0]
000020  4306              ORRS     r6,r6,r0
;;;4992   
;;;4993     /* Write to TIMx SMCR */
;;;4994     htim->Instance->SMCR = tmpsmcr;
000022  6820              LDR      r0,[r4,#0]
000024  6086              STR      r6,[r0,#8]
;;;4995     
;;;4996     /* Configure the trigger prescaler, filter, and polarity */
;;;4997     switch (sSlaveConfig->InputTrigger)
000026  6868              LDR      r0,[r5,#4]
000028  f000010f          AND      r1,r0,#0xf
00002c  2900              CMP      r1,#0
00002e  d135              BNE      |L100.156|
000030  1100              ASRS     r0,r0,#4
000032  2808              CMP      r0,#8
000034  d232              BCS      |L100.156|
000036  e8dff000          TBB      [pc,r0]
00003a  2d2e              DCB      0x2d,0x2e
00003c  2f300b21          DCB      0x2f,0x30,0x0b,0x21
000040  2704              DCB      0x27,0x04
;;;4998     {
;;;4999     case TIM_TS_ETRF:
;;;5000       {
;;;5001         /* Check the parameters */
;;;5002         assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
;;;5003         assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
;;;5004         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;5005         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;5006         /* Configure the ETR Trigger source */
;;;5007         TIM_ETR_SetConfig(htim->Instance, 
000042  e9d51303          LDRD     r1,r3,[r5,#0xc]
000046  68aa              LDR      r2,[r5,#8]
000048  6820              LDR      r0,[r4,#0]
00004a  f7fffffe          BL       TIM_ETR_SetConfig
;;;5008                           sSlaveConfig->TriggerPrescaler, 
;;;5009                           sSlaveConfig->TriggerPolarity, 
;;;5010                           sSlaveConfig->TriggerFilter);
;;;5011       }
;;;5012       break;
00004e  e026              B        |L100.158|
;;;5013       
;;;5014     case TIM_TS_TI1F_ED:
;;;5015       {
;;;5016         /* Check the parameters */
;;;5017         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;5018         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;5019         
;;;5020         /* Disable the Channel 1: Reset the CC1E Bit */
;;;5021         tmpccer = htim->Instance->CCER;
000050  6820              LDR      r0,[r4,#0]
000052  f8d08020          LDR      r8,[r0,#0x20]
;;;5022         htim->Instance->CCER &= ~TIM_CCER_CC1E;
000056  6820              LDR      r0,[r4,#0]
000058  6a00              LDR      r0,[r0,#0x20]
00005a  f0200001          BIC      r0,r0,#1
00005e  6821              LDR      r1,[r4,#0]
000060  6208              STR      r0,[r1,#0x20]
;;;5023         tmpccmr1 = htim->Instance->CCMR1;    
000062  6820              LDR      r0,[r4,#0]
000064  6987              LDR      r7,[r0,#0x18]
;;;5024         
;;;5025         /* Set the filter */
;;;5026         tmpccmr1 &= ~TIM_CCMR1_IC1F;
000066  f02707f0          BIC      r7,r7,#0xf0
;;;5027         tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4);
00006a  6928              LDR      r0,[r5,#0x10]
00006c  ea471700          ORR      r7,r7,r0,LSL #4
;;;5028         
;;;5029         /* Write to TIMx CCMR1 and CCER registers */
;;;5030         htim->Instance->CCMR1 = tmpccmr1;
000070  6820              LDR      r0,[r4,#0]
000072  6187              STR      r7,[r0,#0x18]
;;;5031         htim->Instance->CCER = tmpccer;                               
000074  6820              LDR      r0,[r4,#0]
000076  f8c08020          STR      r8,[r0,#0x20]
;;;5032                                  
;;;5033       }
;;;5034       break;
00007a  e010              B        |L100.158|
;;;5035       
;;;5036     case TIM_TS_TI1FP1:
;;;5037       {
;;;5038         /* Check the parameters */
;;;5039         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;5040         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;5041         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;5042   
;;;5043         /* Configure TI1 Filter and Polarity */
;;;5044         TIM_TI1_ConfigInputStage(htim->Instance,
00007c  692a              LDR      r2,[r5,#0x10]
00007e  68a9              LDR      r1,[r5,#8]
000080  6820              LDR      r0,[r4,#0]
000082  f7fffffe          BL       TIM_TI1_ConfigInputStage
;;;5045                                  sSlaveConfig->TriggerPolarity,
;;;5046                                  sSlaveConfig->TriggerFilter);
;;;5047       }
;;;5048       break;
000086  e00a              B        |L100.158|
;;;5049       
;;;5050     case TIM_TS_TI2FP2:
;;;5051       {
;;;5052         /* Check the parameters */
;;;5053         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5054         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;5055         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;5056         
;;;5057         /* Configure TI2 Filter and Polarity */
;;;5058         TIM_TI2_ConfigInputStage(htim->Instance,
000088  692a              LDR      r2,[r5,#0x10]
00008a  68a9              LDR      r1,[r5,#8]
00008c  6820              LDR      r0,[r4,#0]
00008e  f7fffffe          BL       TIM_TI2_ConfigInputStage
;;;5059                                   sSlaveConfig->TriggerPolarity,
;;;5060                                   sSlaveConfig->TriggerFilter);
;;;5061       }
;;;5062       break;
000092  e004              B        |L100.158|
;;;5063       
;;;5064     case TIM_TS_ITR0:
;;;5065       {
;;;5066         /* Check the parameter */
;;;5067         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5068       }
;;;5069       break;
000094  e003              B        |L100.158|
;;;5070       
;;;5071     case TIM_TS_ITR1:
;;;5072       {
;;;5073         /* Check the parameter */
;;;5074         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5075       }
;;;5076       break;
000096  e002              B        |L100.158|
;;;5077       
;;;5078     case TIM_TS_ITR2:
;;;5079       {
;;;5080         /* Check the parameter */
;;;5081         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5082       }
;;;5083       break;
000098  e001              B        |L100.158|
;;;5084       
;;;5085     case TIM_TS_ITR3:
;;;5086       {
;;;5087         /* Check the parameter */
;;;5088         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5089       }
;;;5090       break;
00009a  e000              B        |L100.158|
                  |L100.156|
;;;5091          
;;;5092     default:
;;;5093       break;
00009c  bf00              NOP      
                  |L100.158|
00009e  bf00              NOP                            ;5012
;;;5094     }
;;;5095   }
0000a0  e8bd81f0          POP      {r4-r8,pc}
;;;5096   
                          ENDP


                          AREA ||i.TIM_TI1_ConfigInputStage||, CODE, READONLY, ALIGN=1

                  TIM_TI1_ConfigInputStage PROC
;;;5109     */
;;;5110   static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
000000  b530              PUSH     {r4,r5,lr}
;;;5111   {
000002  460b              MOV      r3,r1
000004  4614              MOV      r4,r2
;;;5112     uint32_t tmpccmr1 = 0;
000006  2100              MOVS     r1,#0
;;;5113     uint32_t tmpccer = 0;
000008  2200              MOVS     r2,#0
;;;5114     
;;;5115     /* Disable the Channel 1: Reset the CC1E Bit */
;;;5116     tmpccer = TIMx->CCER;
00000a  6a02              LDR      r2,[r0,#0x20]
;;;5117     TIMx->CCER &= ~TIM_CCER_CC1E;
00000c  6a05              LDR      r5,[r0,#0x20]
00000e  f0250501          BIC      r5,r5,#1
000012  6205              STR      r5,[r0,#0x20]
;;;5118     tmpccmr1 = TIMx->CCMR1;    
000014  6981              LDR      r1,[r0,#0x18]
;;;5119     
;;;5120     /* Set the filter */
;;;5121     tmpccmr1 &= ~TIM_CCMR1_IC1F;
000016  f02101f0          BIC      r1,r1,#0xf0
;;;5122     tmpccmr1 |= (TIM_ICFilter << 4);
00001a  ea411104          ORR      r1,r1,r4,LSL #4
;;;5123     
;;;5124     /* Select the Polarity and set the CC1E Bit */
;;;5125     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
00001e  f022020a          BIC      r2,r2,#0xa
;;;5126     tmpccer |= TIM_ICPolarity;
000022  431a              ORRS     r2,r2,r3
;;;5127     
;;;5128     /* Write to TIMx CCMR1 and CCER registers */
;;;5129     TIMx->CCMR1 = tmpccmr1;
000024  6181              STR      r1,[r0,#0x18]
;;;5130     TIMx->CCER = tmpccer;
000026  6202              STR      r2,[r0,#0x20]
;;;5131   }
000028  bd30              POP      {r4,r5,pc}
;;;5132   
                          ENDP


                          AREA ||i.TIM_TI1_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_TI1_SetConfig PROC
;;;4529     */
;;;4530   void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b570              PUSH     {r4-r6,lr}
;;;4531                          uint32_t TIM_ICFilter)
;;;4532   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;4533     uint32_t tmpccmr1 = 0;
000006  2100              MOVS     r1,#0
;;;4534     uint32_t tmpccer = 0;
000008  2200              MOVS     r2,#0
;;;4535     
;;;4536     /* Disable the Channel 1: Reset the CC1E Bit */
;;;4537     TIMx->CCER &= ~TIM_CCER_CC1E;
00000a  6a06              LDR      r6,[r0,#0x20]
00000c  f0260601          BIC      r6,r6,#1
000010  6206              STR      r6,[r0,#0x20]
;;;4538     tmpccmr1 = TIMx->CCMR1;
000012  6981              LDR      r1,[r0,#0x18]
;;;4539     tmpccer = TIMx->CCER;
000014  6a02              LDR      r2,[r0,#0x20]
;;;4540   
;;;4541     /* Select the Input */
;;;4542     if(IS_TIM_CC2_INSTANCE(TIMx) != RESET)
000016  4e19              LDR      r6,|L102.124|
000018  42b0              CMP      r0,r6
00001a  d014              BEQ      |L102.70|
00001c  f1b04f80          CMP      r0,#0x40000000
000020  d011              BEQ      |L102.70|
000022  4e17              LDR      r6,|L102.128|
000024  42b0              CMP      r0,r6
000026  d00e              BEQ      |L102.70|
000028  4e16              LDR      r6,|L102.132|
00002a  42b0              CMP      r0,r6
00002c  d00b              BEQ      |L102.70|
00002e  4e16              LDR      r6,|L102.136|
000030  42b0              CMP      r0,r6
000032  d008              BEQ      |L102.70|
000034  4e15              LDR      r6,|L102.140|
000036  42b0              CMP      r0,r6
000038  d005              BEQ      |L102.70|
00003a  4e15              LDR      r6,|L102.144|
00003c  42b0              CMP      r0,r6
00003e  d002              BEQ      |L102.70|
000040  4e14              LDR      r6,|L102.148|
000042  42b0              CMP      r0,r6
000044  d101              BNE      |L102.74|
                  |L102.70|
000046  2601              MOVS     r6,#1
000048  e000              B        |L102.76|
                  |L102.74|
00004a  2600              MOVS     r6,#0
                  |L102.76|
00004c  b11e              CBZ      r6,|L102.86|
;;;4543     {
;;;4544       tmpccmr1 &= ~TIM_CCMR1_CC1S;
00004e  f0210103          BIC      r1,r1,#3
;;;4545       tmpccmr1 |= TIM_ICSelection;
000052  4329              ORRS     r1,r1,r5
000054  e003              B        |L102.94|
                  |L102.86|
;;;4546     } 
;;;4547     else
;;;4548     {
;;;4549       tmpccmr1 &= ~TIM_CCMR1_CC1S;
000056  f0210103          BIC      r1,r1,#3
;;;4550       tmpccmr1 |= TIM_CCMR1_CC1S_0;
00005a  f0410101          ORR      r1,r1,#1
                  |L102.94|
;;;4551     }
;;;4552   
;;;4553     /* Set the filter */
;;;4554     tmpccmr1 &= ~TIM_CCMR1_IC1F;
00005e  f02101f0          BIC      r1,r1,#0xf0
;;;4555     tmpccmr1 |= ((TIM_ICFilter << 4) & TIM_CCMR1_IC1F);
000062  26f0              MOVS     r6,#0xf0
000064  ea061603          AND      r6,r6,r3,LSL #4
000068  4331              ORRS     r1,r1,r6
;;;4556   
;;;4557     /* Select the Polarity and set the CC1E Bit */
;;;4558     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
00006a  f022020a          BIC      r2,r2,#0xa
;;;4559     tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
00006e  f004060a          AND      r6,r4,#0xa
000072  4332              ORRS     r2,r2,r6
;;;4560   
;;;4561     /* Write to TIMx CCMR1 and CCER registers */
;;;4562     TIMx->CCMR1 = tmpccmr1;
000074  6181              STR      r1,[r0,#0x18]
;;;4563     TIMx->CCER = tmpccer;
000076  6202              STR      r2,[r0,#0x20]
;;;4564   }
000078  bd70              POP      {r4-r6,pc}
;;;4565   
                          ENDP

00007a  0000              DCW      0x0000
                  |L102.124|
                          DCD      0x40010000
                  |L102.128|
                          DCD      0x40000400
                  |L102.132|
                          DCD      0x40000800
                  |L102.136|
                          DCD      0x40000c00
                  |L102.140|
                          DCD      0x40010400
                  |L102.144|
                          DCD      0x40014000
                  |L102.148|
                          DCD      0x40001800

                          AREA ||i.TIM_TI2_ConfigInputStage||, CODE, READONLY, ALIGN=1

                  TIM_TI2_ConfigInputStage PROC
;;;5192     */
;;;5193   static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
000000  b530              PUSH     {r4,r5,lr}
;;;5194   {
000002  460b              MOV      r3,r1
000004  4614              MOV      r4,r2
;;;5195     uint32_t tmpccmr1 = 0;
000006  2100              MOVS     r1,#0
;;;5196     uint32_t tmpccer = 0;
000008  2200              MOVS     r2,#0
;;;5197     
;;;5198     /* Disable the Channel 2: Reset the CC2E Bit */
;;;5199     TIMx->CCER &= ~TIM_CCER_CC2E;
00000a  6a05              LDR      r5,[r0,#0x20]
00000c  f0250510          BIC      r5,r5,#0x10
000010  6205              STR      r5,[r0,#0x20]
;;;5200     tmpccmr1 = TIMx->CCMR1;
000012  6981              LDR      r1,[r0,#0x18]
;;;5201     tmpccer = TIMx->CCER;
000014  6a02              LDR      r2,[r0,#0x20]
;;;5202     
;;;5203     /* Set the filter */
;;;5204     tmpccmr1 &= ~TIM_CCMR1_IC2F;
000016  f4214170          BIC      r1,r1,#0xf000
;;;5205     tmpccmr1 |= (TIM_ICFilter << 12);
00001a  ea413104          ORR      r1,r1,r4,LSL #12
;;;5206   
;;;5207     /* Select the Polarity and set the CC2E Bit */
;;;5208     tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
00001e  f02202a0          BIC      r2,r2,#0xa0
;;;5209     tmpccer |= (TIM_ICPolarity << 4);
000022  ea421203          ORR      r2,r2,r3,LSL #4
;;;5210   
;;;5211     /* Write to TIMx CCMR1 and CCER registers */
;;;5212     TIMx->CCMR1 = tmpccmr1 ;
000026  6181              STR      r1,[r0,#0x18]
;;;5213     TIMx->CCER = tmpccer;
000028  6202              STR      r2,[r0,#0x20]
;;;5214   }
00002a  bd30              POP      {r4,r5,pc}
;;;5215   
                          ENDP


                          AREA ||i.TIM_TI2_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_TI2_SetConfig PROC
;;;5152     */
;;;5153   static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b570              PUSH     {r4-r6,lr}
;;;5154                          uint32_t TIM_ICFilter)
;;;5155   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;5156     uint32_t tmpccmr1 = 0;
000006  2100              MOVS     r1,#0
;;;5157     uint32_t tmpccer = 0;
000008  2200              MOVS     r2,#0
;;;5158   
;;;5159     /* Disable the Channel 2: Reset the CC2E Bit */
;;;5160     TIMx->CCER &= ~TIM_CCER_CC2E;
00000a  6a06              LDR      r6,[r0,#0x20]
00000c  f0260610          BIC      r6,r6,#0x10
000010  6206              STR      r6,[r0,#0x20]
;;;5161     tmpccmr1 = TIMx->CCMR1;
000012  6981              LDR      r1,[r0,#0x18]
;;;5162     tmpccer = TIMx->CCER;
000014  6a02              LDR      r2,[r0,#0x20]
;;;5163     
;;;5164     /* Select the Input */
;;;5165     tmpccmr1 &= ~TIM_CCMR1_CC2S;
000016  f4217140          BIC      r1,r1,#0x300
;;;5166     tmpccmr1 |= (TIM_ICSelection << 8);
00001a  ea412105          ORR      r1,r1,r5,LSL #8
;;;5167     
;;;5168     /* Set the filter */
;;;5169     tmpccmr1 &= ~TIM_CCMR1_IC2F;
00001e  f4214170          BIC      r1,r1,#0xf000
;;;5170     tmpccmr1 |= ((TIM_ICFilter << 12) & TIM_CCMR1_IC2F);
000022  f44f4670          MOV      r6,#0xf000
000026  ea063603          AND      r6,r6,r3,LSL #12
00002a  4331              ORRS     r1,r1,r6
;;;5171   
;;;5172     /* Select the Polarity and set the CC2E Bit */
;;;5173     tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
00002c  f02202a0          BIC      r2,r2,#0xa0
;;;5174     tmpccer |= ((TIM_ICPolarity << 4) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
000030  26a0              MOVS     r6,#0xa0
000032  ea061604          AND      r6,r6,r4,LSL #4
000036  4332              ORRS     r2,r2,r6
;;;5175   
;;;5176     /* Write to TIMx CCMR1 and CCER registers */
;;;5177     TIMx->CCMR1 = tmpccmr1 ;
000038  6181              STR      r1,[r0,#0x18]
;;;5178     TIMx->CCER = tmpccer;
00003a  6202              STR      r2,[r0,#0x20]
;;;5179   }
00003c  bd70              POP      {r4-r6,pc}
;;;5180   
                          ENDP


                          AREA ||i.TIM_TI3_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_TI3_SetConfig PROC
;;;5235     */
;;;5236   static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b570              PUSH     {r4-r6,lr}
;;;5237                          uint32_t TIM_ICFilter)
;;;5238   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;5239     uint32_t tmpccmr2 = 0;
000006  2100              MOVS     r1,#0
;;;5240     uint32_t tmpccer = 0;
000008  2200              MOVS     r2,#0
;;;5241   
;;;5242     /* Disable the Channel 3: Reset the CC3E Bit */
;;;5243     TIMx->CCER &= ~TIM_CCER_CC3E;
00000a  6a06              LDR      r6,[r0,#0x20]
00000c  f4267680          BIC      r6,r6,#0x100
000010  6206              STR      r6,[r0,#0x20]
;;;5244     tmpccmr2 = TIMx->CCMR2;
000012  69c1              LDR      r1,[r0,#0x1c]
;;;5245     tmpccer = TIMx->CCER;
000014  6a02              LDR      r2,[r0,#0x20]
;;;5246   
;;;5247     /* Select the Input */
;;;5248     tmpccmr2 &= ~TIM_CCMR2_CC3S;
000016  f0210103          BIC      r1,r1,#3
;;;5249     tmpccmr2 |= TIM_ICSelection;
00001a  4329              ORRS     r1,r1,r5
;;;5250   
;;;5251     /* Set the filter */
;;;5252     tmpccmr2 &= ~TIM_CCMR2_IC3F;
00001c  f02101f0          BIC      r1,r1,#0xf0
;;;5253     tmpccmr2 |= ((TIM_ICFilter << 4) & TIM_CCMR2_IC3F);
000020  26f0              MOVS     r6,#0xf0
000022  ea061603          AND      r6,r6,r3,LSL #4
000026  4331              ORRS     r1,r1,r6
;;;5254   
;;;5255     /* Select the Polarity and set the CC3E Bit */
;;;5256     tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
000028  f4226220          BIC      r2,r2,#0xa00
;;;5257     tmpccer |= ((TIM_ICPolarity << 8) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
00002c  f44f6620          MOV      r6,#0xa00
000030  ea062604          AND      r6,r6,r4,LSL #8
000034  4332              ORRS     r2,r2,r6
;;;5258   
;;;5259     /* Write to TIMx CCMR2 and CCER registers */
;;;5260     TIMx->CCMR2 = tmpccmr2;
000036  61c1              STR      r1,[r0,#0x1c]
;;;5261     TIMx->CCER = tmpccer;
000038  6202              STR      r2,[r0,#0x20]
;;;5262   }
00003a  bd70              POP      {r4-r6,pc}
;;;5263   
                          ENDP


                          AREA ||i.TIM_TI4_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_TI4_SetConfig PROC
;;;5283     */
;;;5284   static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b570              PUSH     {r4-r6,lr}
;;;5285                          uint32_t TIM_ICFilter)
;;;5286   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;5287     uint32_t tmpccmr2 = 0;
000006  2100              MOVS     r1,#0
;;;5288     uint32_t tmpccer = 0;
000008  2200              MOVS     r2,#0
;;;5289   
;;;5290     /* Disable the Channel 4: Reset the CC4E Bit */
;;;5291     TIMx->CCER &= ~TIM_CCER_CC4E;
00000a  6a06              LDR      r6,[r0,#0x20]
00000c  f4265680          BIC      r6,r6,#0x1000
000010  6206              STR      r6,[r0,#0x20]
;;;5292     tmpccmr2 = TIMx->CCMR2;
000012  69c1              LDR      r1,[r0,#0x1c]
;;;5293     tmpccer = TIMx->CCER;
000014  6a02              LDR      r2,[r0,#0x20]
;;;5294   
;;;5295     /* Select the Input */
;;;5296     tmpccmr2 &= ~TIM_CCMR2_CC4S;
000016  f4217140          BIC      r1,r1,#0x300
;;;5297     tmpccmr2 |= (TIM_ICSelection << 8);
00001a  ea412105          ORR      r1,r1,r5,LSL #8
;;;5298   
;;;5299     /* Set the filter */
;;;5300     tmpccmr2 &= ~TIM_CCMR2_IC4F;
00001e  f4214170          BIC      r1,r1,#0xf000
;;;5301     tmpccmr2 |= ((TIM_ICFilter << 12) & TIM_CCMR2_IC4F);
000022  f44f4670          MOV      r6,#0xf000
000026  ea063603          AND      r6,r6,r3,LSL #12
00002a  4331              ORRS     r1,r1,r6
;;;5302   
;;;5303     /* Select the Polarity and set the CC4E Bit */
;;;5304     tmpccer &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
00002c  f4224220          BIC      r2,r2,#0xa000
;;;5305     tmpccer |= ((TIM_ICPolarity << 12) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));
000030  f44f4620          MOV      r6,#0xa000
000034  ea063604          AND      r6,r6,r4,LSL #12
000038  4332              ORRS     r2,r2,r6
;;;5306   
;;;5307     /* Write to TIMx CCMR2 and CCER registers */
;;;5308     TIMx->CCMR2 = tmpccmr2;
00003a  61c1              STR      r1,[r0,#0x1c]
;;;5309     TIMx->CCER = tmpccer ;
00003c  6202              STR      r2,[r0,#0x20]
;;;5310   }
00003e  bd70              POP      {r4-r6,pc}
;;;5311   
                          ENDP


;*** Start embedded assembler ***

#line 1 "HALLIB\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_tim.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_tim_c_a9d95b52____REV16|
#line 388 ".\\CORE\\cmsis_armcc.h"
|__asm___19_stm32f4xx_hal_tim_c_a9d95b52____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_tim_c_a9d95b52____REVSH|
#line 402
|__asm___19_stm32f4xx_hal_tim_c_a9d95b52____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_tim_c_a9d95b52____RRX|
#line 587
|__asm___19_stm32f4xx_hal_tim_c_a9d95b52____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
