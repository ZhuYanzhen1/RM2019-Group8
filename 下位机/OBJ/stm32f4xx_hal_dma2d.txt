; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\stm32f4xx_hal_dma2d.o --asm_dir=.\OBJ\ --list_dir=.\OBJ\ --depend=.\obj\stm32f4xx_hal_dma2d.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I.\CORE -I.\USER -I.\HALLIB\STM32F4xx_HAL_Driver\Inc -I.\SYSTEM -I.\Hardware -I.\App -I.\DSP_LIB\Include -I.\FreeRTOS -I.\MPU9250\DMP -I.\MPU9250 -I.\RTE\_Project -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=526 -DSTM32F427xx -DSTM32F4 -DUSE_HAL_DRIVER -DSTM32F427xx -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=.\obj\stm32f4xx_hal_dma2d.crf HALLIB\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_dma2d.c]
                          THUMB

                          AREA ||i.DMA2D_SetConfig||, CODE, READONLY, ALIGN=1

                  DMA2D_SetConfig PROC
;;;1190     */
;;;1191   static void DMA2D_SetConfig(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width, uint32_t Height)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1192   {  
000004  460c              MOV      r4,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
00000a  f8dd8020          LDR      r8,[sp,#0x20]
;;;1193     uint32_t tmp = 0;
00000e  f04f0c00          MOV      r12,#0
;;;1194     uint32_t tmp1 = 0;
000012  2500              MOVS     r5,#0
;;;1195     uint32_t tmp2 = 0;
000014  2100              MOVS     r1,#0
;;;1196     uint32_t tmp3 = 0;
000016  2200              MOVS     r2,#0
;;;1197     uint32_t tmp4 = 0;
000018  2300              MOVS     r3,#0
;;;1198     
;;;1199     tmp = Width << 16;
00001a  ea4f4c07          LSL      r12,r7,#16
;;;1200     
;;;1201     /* Configure DMA2D data size */
;;;1202     hdma2d->Instance->NLR = (Height | tmp);
00001e  ea48090c          ORR      r9,r8,r12
000022  f8d0a000          LDR      r10,[r0,#0]
000026  f8ca9044          STR      r9,[r10,#0x44]
;;;1203     
;;;1204     /* Configure DMA2D destination address */
;;;1205     hdma2d->Instance->OMAR = DstAddress;
00002a  f8d09000          LDR      r9,[r0,#0]
00002e  f8c9603c          STR      r6,[r9,#0x3c]
;;;1206    
;;;1207     /* Register to memory DMA2D mode selected */
;;;1208     if (hdma2d->Init.Mode == DMA2D_R2M)
000032  f8d09004          LDR      r9,[r0,#4]
000036  f5b93f40          CMP      r9,#0x30000
00003a  d14e              BNE      |L1.218|
;;;1209     {    
;;;1210       tmp1 = pdata & DMA2D_OCOLR_ALPHA_1;
00003c  f004457f          AND      r5,r4,#0xff000000
;;;1211       tmp2 = pdata & DMA2D_OCOLR_RED_1;
000040  f404017f          AND      r1,r4,#0xff0000
;;;1212       tmp3 = pdata & DMA2D_OCOLR_GREEN_1;
000044  f404427f          AND      r2,r4,#0xff00
;;;1213       tmp4 = pdata & DMA2D_OCOLR_BLUE_1;
000048  b2e3              UXTB     r3,r4
;;;1214       
;;;1215       /* Prepare the value to be wrote to the OCOLR register according to the color mode */
;;;1216       if (hdma2d->Init.ColorMode == DMA2D_ARGB8888)
00004a  f8d09008          LDR      r9,[r0,#8]
00004e  f1b90f00          CMP      r9,#0
000052  d106              BNE      |L1.98|
;;;1217       {
;;;1218         tmp = (tmp3 | tmp2 | tmp1| tmp4);
000054  ea420901          ORR      r9,r2,r1
000058  ea490905          ORR      r9,r9,r5
00005c  ea490c03          ORR      r12,r9,r3
000060  e036              B        |L1.208|
                  |L1.98|
;;;1219       }
;;;1220       else if (hdma2d->Init.ColorMode == DMA2D_RGB888)
000062  f8d09008          LDR      r9,[r0,#8]
000066  f1b90f01          CMP      r9,#1
00006a  d104              BNE      |L1.118|
;;;1221       {
;;;1222         tmp = (tmp3 | tmp2 | tmp4);  
00006c  ea420901          ORR      r9,r2,r1
000070  ea490c03          ORR      r12,r9,r3
000074  e02c              B        |L1.208|
                  |L1.118|
;;;1223       }
;;;1224       else if (hdma2d->Init.ColorMode == DMA2D_RGB565)
000076  f8d09008          LDR      r9,[r0,#8]
00007a  f1b90f02          CMP      r9,#2
00007e  d109              BNE      |L1.148|
;;;1225       {
;;;1226         tmp2 = (tmp2 >> 19);
000080  0cc9              LSRS     r1,r1,#19
;;;1227         tmp3 = (tmp3 >> 10);
000082  0a92              LSRS     r2,r2,#10
;;;1228         tmp4 = (tmp4 >> 3 );
000084  08db              LSRS     r3,r3,#3
;;;1229         tmp  = ((tmp3 << 5) | (tmp2 << 11) | tmp4); 
000086  ea4f1942          LSL      r9,r2,#5
00008a  ea4929c1          ORR      r9,r9,r1,LSL #11
00008e  ea490c03          ORR      r12,r9,r3
000092  e01d              B        |L1.208|
                  |L1.148|
;;;1230       }
;;;1231       else if (hdma2d->Init.ColorMode == DMA2D_ARGB1555)
000094  f8d09008          LDR      r9,[r0,#8]
000098  f1b90f03          CMP      r9,#3
00009c  d10c              BNE      |L1.184|
;;;1232       { 
;;;1233         tmp1 = (tmp1 >> 31);
00009e  0fed              LSRS     r5,r5,#31
;;;1234         tmp2 = (tmp2 >> 19);
0000a0  0cc9              LSRS     r1,r1,#19
;;;1235         tmp3 = (tmp3 >> 11);
0000a2  0ad2              LSRS     r2,r2,#11
;;;1236         tmp4 = (tmp4 >> 3 );      
0000a4  08db              LSRS     r3,r3,#3
;;;1237         tmp  = ((tmp3 << 5) | (tmp2 << 10) | (tmp1 << 15) | tmp4);    
0000a6  ea4f1942          LSL      r9,r2,#5
0000aa  ea492981          ORR      r9,r9,r1,LSL #10
0000ae  ea4939c5          ORR      r9,r9,r5,LSL #15
0000b2  ea490c03          ORR      r12,r9,r3
0000b6  e00b              B        |L1.208|
                  |L1.184|
;;;1238       } 
;;;1239       else /* DMA2D_CMode = DMA2D_ARGB4444 */
;;;1240       {
;;;1241         tmp1 = (tmp1 >> 28);
0000b8  0f2d              LSRS     r5,r5,#28
;;;1242         tmp2 = (tmp2 >> 20);
0000ba  0d09              LSRS     r1,r1,#20
;;;1243         tmp3 = (tmp3 >> 12);
0000bc  0b12              LSRS     r2,r2,#12
;;;1244         tmp4 = (tmp4 >> 4 );
0000be  091b              LSRS     r3,r3,#4
;;;1245         tmp  = ((tmp3 << 4) | (tmp2 << 8) | (tmp1 << 12) | tmp4);
0000c0  ea4f1902          LSL      r9,r2,#4
0000c4  ea492901          ORR      r9,r9,r1,LSL #8
0000c8  ea493905          ORR      r9,r9,r5,LSL #12
0000cc  ea490c03          ORR      r12,r9,r3
                  |L1.208|
;;;1246       }    
;;;1247       /* Write to DMA2D OCOLR register */
;;;1248       hdma2d->Instance->OCOLR = tmp;
0000d0  f8d09000          LDR      r9,[r0,#0]
0000d4  f8c9c038          STR      r12,[r9,#0x38]
0000d8  e003              B        |L1.226|
                  |L1.218|
;;;1249     } 
;;;1250     else /* M2M, M2M_PFC or M2M_Blending DMA2D Mode */
;;;1251     {
;;;1252       /* Configure DMA2D source address */
;;;1253       hdma2d->Instance->FGMAR = pdata;
0000da  f8d09000          LDR      r9,[r0,#0]
0000de  f8c9400c          STR      r4,[r9,#0xc]
                  |L1.226|
;;;1254     }
;;;1255   }
0000e2  e8bd87f0          POP      {r4-r10,pc}
;;;1256   
                          ENDP


                          AREA ||i.HAL_DMA2D_Abort||, CODE, READONLY, ALIGN=1

                  HAL_DMA2D_Abort PROC
;;;522      */
;;;523    HAL_StatusTypeDef HAL_DMA2D_Abort(DMA2D_HandleTypeDef *hdma2d)
000000  b570              PUSH     {r4-r6,lr}
;;;524    {
000002  4604              MOV      r4,r0
;;;525      uint32_t tickstart = 0;
000004  2500              MOVS     r5,#0
;;;526    
;;;527      /* Disable the DMA2D */
;;;528      __HAL_DMA2D_DISABLE(hdma2d);
000006  6820              LDR      r0,[r4,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  f0200001          BIC      r0,r0,#1
00000e  6821              LDR      r1,[r4,#0]
000010  6008              STR      r0,[r1,#0]
;;;529    
;;;530      /* Get tick */
;;;531      tickstart = HAL_GetTick();
000012  f7fffffe          BL       HAL_GetTick
000016  4605              MOV      r5,r0
;;;532    
;;;533      /* Check if the DMA2D is effectively disabled */
;;;534      while((hdma2d->Instance->CR & DMA2D_CR_START) != 0)
000018  e013              B        |L2.66|
                  |L2.26|
;;;535      {
;;;536        if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA2D_ABORT)
00001a  f7fffffe          BL       HAL_GetTick
00001e  1b40              SUBS     r0,r0,r5
000020  f5b07f7a          CMP      r0,#0x3e8
000024  d90d              BLS      |L2.66|
;;;537        {
;;;538          /* Update error code */
;;;539          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
000026  6be0              LDR      r0,[r4,#0x3c]
000028  f0400020          ORR      r0,r0,#0x20
00002c  63e0              STR      r0,[r4,#0x3c]
;;;540          
;;;541          /* Change the DMA2D state */
;;;542          hdma2d->State= HAL_DMA2D_STATE_TIMEOUT;
00002e  2003              MOVS     r0,#3
000030  f8840039          STRB     r0,[r4,#0x39]
;;;543          
;;;544          /* Process Unlocked */
;;;545          __HAL_UNLOCK(hdma2d);
000034  bf00              NOP      
000036  2000              MOVS     r0,#0
000038  f8840038          STRB     r0,[r4,#0x38]
00003c  bf00              NOP      
;;;546          
;;;547          return HAL_TIMEOUT;
00003e  2003              MOVS     r0,#3
                  |L2.64|
;;;548        }
;;;549      }
;;;550      /* Process Unlocked */
;;;551      __HAL_UNLOCK(hdma2d);
;;;552    
;;;553      /* Change the DMA2D state*/
;;;554      hdma2d->State = HAL_DMA2D_STATE_READY;
;;;555    
;;;556      return HAL_OK;
;;;557    }
000040  bd70              POP      {r4-r6,pc}
                  |L2.66|
000042  6820              LDR      r0,[r4,#0]            ;534
000044  6800              LDR      r0,[r0,#0]            ;534
000046  f0000001          AND      r0,r0,#1              ;534
00004a  2800              CMP      r0,#0                 ;534
00004c  d1e5              BNE      |L2.26|
00004e  bf00              NOP                            ;551
000050  f8840038          STRB     r0,[r4,#0x38]         ;551
000054  bf00              NOP                            ;551
000056  2001              MOVS     r0,#1                 ;554
000058  f8840039          STRB     r0,[r4,#0x39]         ;554
00005c  2000              MOVS     r0,#0                 ;556
00005e  e7ef              B        |L2.64|
;;;558    
                          ENDP


                          AREA ||i.HAL_DMA2D_BlendingStart||, CODE, READONLY, ALIGN=1

                  HAL_DMA2D_BlendingStart PROC
;;;442      */
;;;443    HAL_StatusTypeDef HAL_DMA2D_BlendingStart(DMA2D_HandleTypeDef *hdma2d, uint32_t SrcAddress1, uint32_t  SrcAddress2, uint32_t DstAddress, uint32_t Width,  uint32_t Height)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;444    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
00000c  e9dd8908          LDRD     r8,r9,[sp,#0x20]
;;;445      /* Process locked */
;;;446      __HAL_LOCK(hdma2d);
000010  bf00              NOP      
000012  f8940038          LDRB     r0,[r4,#0x38]
000016  2801              CMP      r0,#1
000018  d102              BNE      |L3.32|
00001a  2002              MOVS     r0,#2
                  |L3.28|
;;;447    
;;;448      /* Change DMA2D peripheral state */
;;;449      hdma2d->State = HAL_DMA2D_STATE_BUSY; 
;;;450    
;;;451      /* Check the parameters */
;;;452      assert_param(IS_DMA2D_LINE(Height));
;;;453      assert_param(IS_DMA2D_PIXEL(Width));
;;;454    
;;;455      /* Disable the Peripheral */
;;;456      __HAL_DMA2D_DISABLE(hdma2d);
;;;457    
;;;458      /* Configure DMA2D Stream source2 address */
;;;459      hdma2d->Instance->BGMAR = SrcAddress2;
;;;460    
;;;461      /* Configure the source, destination address and the data size */
;;;462      DMA2D_SetConfig(hdma2d, SrcAddress1, DstAddress, Width, Height);
;;;463    
;;;464      /* Enable the Peripheral */
;;;465      __HAL_DMA2D_ENABLE(hdma2d);
;;;466    
;;;467      return HAL_OK;
;;;468    }
00001c  e8bd83f8          POP      {r3-r9,pc}
                  |L3.32|
000020  2001              MOVS     r0,#1                 ;446
000022  f8840038          STRB     r0,[r4,#0x38]         ;446
000026  bf00              NOP                            ;446
000028  2002              MOVS     r0,#2                 ;449
00002a  f8840039          STRB     r0,[r4,#0x39]         ;449
00002e  6820              LDR      r0,[r4,#0]            ;456
000030  6800              LDR      r0,[r0,#0]            ;456
000032  f0200001          BIC      r0,r0,#1              ;456
000036  6821              LDR      r1,[r4,#0]            ;456
000038  6008              STR      r0,[r1,#0]            ;456
00003a  6820              LDR      r0,[r4,#0]            ;459
00003c  6145              STR      r5,[r0,#0x14]         ;459
00003e  4643              MOV      r3,r8                 ;462
000040  4632              MOV      r2,r6                 ;462
000042  4639              MOV      r1,r7                 ;462
000044  4620              MOV      r0,r4                 ;462
000046  f8cd9000          STR      r9,[sp,#0]            ;462
00004a  f7fffffe          BL       DMA2D_SetConfig
00004e  6820              LDR      r0,[r4,#0]            ;465
000050  6800              LDR      r0,[r0,#0]            ;465
000052  f0400001          ORR      r0,r0,#1              ;465
000056  6821              LDR      r1,[r4,#0]            ;465
000058  6008              STR      r0,[r1,#0]            ;465
00005a  2000              MOVS     r0,#0                 ;467
00005c  e7de              B        |L3.28|
;;;469    
                          ENDP


                          AREA ||i.HAL_DMA2D_BlendingStart_IT||, CODE, READONLY, ALIGN=1

                  HAL_DMA2D_BlendingStart_IT PROC
;;;480      */
;;;481    HAL_StatusTypeDef HAL_DMA2D_BlendingStart_IT(DMA2D_HandleTypeDef *hdma2d, uint32_t SrcAddress1, uint32_t  SrcAddress2, uint32_t DstAddress, uint32_t Width,  uint32_t Height)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;482    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
00000c  e9dd8908          LDRD     r8,r9,[sp,#0x20]
;;;483      /* Process locked */
;;;484      __HAL_LOCK(hdma2d);
000010  bf00              NOP      
000012  f8940038          LDRB     r0,[r4,#0x38]
000016  2801              CMP      r0,#1
000018  d102              BNE      |L4.32|
00001a  2002              MOVS     r0,#2
                  |L4.28|
;;;485    
;;;486      /* Change DMA2D peripheral state */
;;;487      hdma2d->State = HAL_DMA2D_STATE_BUSY;
;;;488    
;;;489      /* Check the parameters */
;;;490      assert_param(IS_DMA2D_LINE(Height));
;;;491      assert_param(IS_DMA2D_PIXEL(Width));
;;;492    
;;;493      /* Disable the Peripheral */
;;;494      __HAL_DMA2D_DISABLE(hdma2d);
;;;495     
;;;496      /* Configure DMA2D Stream source2 address */
;;;497      hdma2d->Instance->BGMAR = SrcAddress2;
;;;498    
;;;499      /* Configure the source, destination address and the data size */
;;;500      DMA2D_SetConfig(hdma2d, SrcAddress1, DstAddress, Width, Height);
;;;501    
;;;502      /* Enable the configuration error interrupt */
;;;503      __HAL_DMA2D_ENABLE_IT(hdma2d, DMA2D_IT_CE);
;;;504    
;;;505      /* Enable the transfer complete interrupt */
;;;506      __HAL_DMA2D_ENABLE_IT(hdma2d, DMA2D_IT_TC);
;;;507    
;;;508      /* Enable the transfer Error interrupt */
;;;509      __HAL_DMA2D_ENABLE_IT(hdma2d, DMA2D_IT_TE);
;;;510    
;;;511      /* Enable the Peripheral */
;;;512      __HAL_DMA2D_ENABLE(hdma2d);
;;;513    
;;;514      return HAL_OK;
;;;515    }
00001c  e8bd83f8          POP      {r3-r9,pc}
                  |L4.32|
000020  2001              MOVS     r0,#1                 ;484
000022  f8840038          STRB     r0,[r4,#0x38]         ;484
000026  bf00              NOP                            ;484
000028  2002              MOVS     r0,#2                 ;487
00002a  f8840039          STRB     r0,[r4,#0x39]         ;487
00002e  6820              LDR      r0,[r4,#0]            ;494
000030  6800              LDR      r0,[r0,#0]            ;494
000032  f0200001          BIC      r0,r0,#1              ;494
000036  6821              LDR      r1,[r4,#0]            ;494
000038  6008              STR      r0,[r1,#0]            ;494
00003a  6820              LDR      r0,[r4,#0]            ;497
00003c  6145              STR      r5,[r0,#0x14]         ;497
00003e  4643              MOV      r3,r8                 ;500
000040  4632              MOV      r2,r6                 ;500
000042  4639              MOV      r1,r7                 ;500
000044  4620              MOV      r0,r4                 ;500
000046  f8cd9000          STR      r9,[sp,#0]            ;500
00004a  f7fffffe          BL       DMA2D_SetConfig
00004e  6820              LDR      r0,[r4,#0]            ;503
000050  6800              LDR      r0,[r0,#0]            ;503
000052  f4405000          ORR      r0,r0,#0x2000         ;503
000056  6821              LDR      r1,[r4,#0]            ;503
000058  6008              STR      r0,[r1,#0]            ;503
00005a  6820              LDR      r0,[r4,#0]            ;506
00005c  6800              LDR      r0,[r0,#0]            ;506
00005e  f4407000          ORR      r0,r0,#0x200          ;506
000062  6821              LDR      r1,[r4,#0]            ;506
000064  6008              STR      r0,[r1,#0]            ;506
000066  6820              LDR      r0,[r4,#0]            ;509
000068  6800              LDR      r0,[r0,#0]            ;509
00006a  f4407080          ORR      r0,r0,#0x100          ;509
00006e  6821              LDR      r1,[r4,#0]            ;509
000070  6008              STR      r0,[r1,#0]            ;509
000072  6820              LDR      r0,[r4,#0]            ;512
000074  6800              LDR      r0,[r0,#0]            ;512
000076  f0400001          ORR      r0,r0,#1              ;512
00007a  6821              LDR      r1,[r4,#0]            ;512
00007c  6008              STR      r0,[r1,#0]            ;512
00007e  2000              MOVS     r0,#0                 ;514
000080  e7cc              B        |L4.28|
;;;516    
                          ENDP


                          AREA ||i.HAL_DMA2D_ConfigCLUT||, CODE, READONLY, ALIGN=1

                  HAL_DMA2D_ConfigCLUT PROC
;;;973      */
;;;974    HAL_StatusTypeDef HAL_DMA2D_ConfigCLUT(DMA2D_HandleTypeDef *hdma2d, DMA2D_CLUTCfgTypeDef CLUTCfg, uint32_t LayerIdx)
000000  b53f              PUSH     {r0-r5,lr}
;;;975    {
000002  4604              MOV      r4,r0
000004  9d07              LDR      r5,[sp,#0x1c]
;;;976      uint32_t tmp = 0, tmp1 = 0;
000006  2100              MOVS     r1,#0
000008  2200              MOVS     r2,#0
;;;977    
;;;978      /* Check the parameters */
;;;979      assert_param(IS_DMA2D_LAYER(LayerIdx));   
;;;980      assert_param(IS_DMA2D_CLUT_CM(CLUTCfg.CLUTColorMode));
;;;981      assert_param(IS_DMA2D_CLUT_SIZE(CLUTCfg.Size));
;;;982      
;;;983      /* Configure the CLUT of the background DMA2D layer */
;;;984      if(LayerIdx == 0)
00000a  b99d              CBNZ     r5,|L5.52|
;;;985      {
;;;986        /* Get the BGCMAR register value */
;;;987        tmp = hdma2d->Instance->BGCMAR;
00000c  6820              LDR      r0,[r4,#0]
00000e  6b01              LDR      r1,[r0,#0x30]
;;;988    
;;;989        /* Clear CLUT address bits */
;;;990        tmp &= (uint32_t)~DMA2D_BGCMAR_MA; 
000010  2100              MOVS     r1,#0
;;;991      
;;;992        /* Prepare the value to be wrote to the BGCMAR register */
;;;993        tmp |= (uint32_t)CLUTCfg.pCLUT;
000012  9801              LDR      r0,[sp,#4]
000014  4301              ORRS     r1,r1,r0
;;;994      
;;;995        /* Write to DMA2D BGCMAR register */
;;;996        hdma2d->Instance->BGCMAR = tmp;
000016  6820              LDR      r0,[r4,#0]
000018  6301              STR      r1,[r0,#0x30]
;;;997        
;;;998        /* Get the BGPFCCR register value */
;;;999        tmp = hdma2d->Instance->BGPFCCR;
00001a  6820              LDR      r0,[r4,#0]
00001c  6a41              LDR      r1,[r0,#0x24]
;;;1000   
;;;1001       /* Clear CLUT size and CLUT address bits */
;;;1002       tmp &= (uint32_t)~(DMA2D_BGPFCCR_CS | DMA2D_BGPFCCR_CCM); 
00001e  f64f7010          MOV      r0,#0xff10
000022  4381              BICS     r1,r1,r0
;;;1003   
;;;1004       /* Get the CLUT size */
;;;1005       tmp1 = CLUTCfg.Size << 16;
000024  9803              LDR      r0,[sp,#0xc]
000026  0402              LSLS     r2,r0,#16
;;;1006       
;;;1007       /* Prepare the value to be wrote to the BGPFCCR register */
;;;1008       tmp |= (CLUTCfg.CLUTColorMode | tmp1);
000028  9802              LDR      r0,[sp,#8]
00002a  4310              ORRS     r0,r0,r2
00002c  4301              ORRS     r1,r1,r0
;;;1009     
;;;1010       /* Write to DMA2D BGPFCCR register */
;;;1011       hdma2d->Instance->BGPFCCR = tmp;       
00002e  6820              LDR      r0,[r4,#0]
000030  6241              STR      r1,[r0,#0x24]
000032  e012              B        |L5.90|
                  |L5.52|
;;;1012     }
;;;1013     /* Configure the CLUT of the foreground DMA2D layer */
;;;1014     else
;;;1015     {
;;;1016       /* Get the FGCMAR register value */
;;;1017       tmp = hdma2d->Instance->FGCMAR;
000034  6820              LDR      r0,[r4,#0]
000036  6ac1              LDR      r1,[r0,#0x2c]
;;;1018   
;;;1019       /* Clear CLUT address bits */
;;;1020       tmp &= (uint32_t)~DMA2D_FGCMAR_MA; 
000038  2100              MOVS     r1,#0
;;;1021     
;;;1022       /* Prepare the value to be wrote to the FGCMAR register */
;;;1023       tmp |= (uint32_t)CLUTCfg.pCLUT;
00003a  9801              LDR      r0,[sp,#4]
00003c  4301              ORRS     r1,r1,r0
;;;1024     
;;;1025       /* Write to DMA2D FGCMAR register */
;;;1026       hdma2d->Instance->FGCMAR = tmp;
00003e  6820              LDR      r0,[r4,#0]
000040  62c1              STR      r1,[r0,#0x2c]
;;;1027       
;;;1028       /* Get the FGPFCCR register value */
;;;1029       tmp = hdma2d->Instance->FGPFCCR;
000042  6820              LDR      r0,[r4,#0]
000044  69c1              LDR      r1,[r0,#0x1c]
;;;1030   
;;;1031       /* Clear CLUT size and CLUT address bits */
;;;1032       tmp &= (uint32_t)~(DMA2D_FGPFCCR_CS | DMA2D_FGPFCCR_CCM); 
000046  f64f7010          MOV      r0,#0xff10
00004a  4381              BICS     r1,r1,r0
;;;1033   
;;;1034       /* Get the CLUT size */
;;;1035       tmp1 = CLUTCfg.Size << 8;
00004c  9803              LDR      r0,[sp,#0xc]
00004e  0202              LSLS     r2,r0,#8
;;;1036       
;;;1037       /* Prepare the value to be wrote to the FGPFCCR register */
;;;1038       tmp |= (CLUTCfg.CLUTColorMode | tmp1);
000050  9802              LDR      r0,[sp,#8]
000052  4310              ORRS     r0,r0,r2
000054  4301              ORRS     r1,r1,r0
;;;1039     
;;;1040       /* Write to DMA2D FGPFCCR register */
;;;1041       hdma2d->Instance->FGPFCCR = tmp;    
000056  6820              LDR      r0,[r4,#0]
000058  61c1              STR      r1,[r0,#0x1c]
                  |L5.90|
;;;1042     }
;;;1043     
;;;1044     return HAL_OK;
00005a  2000              MOVS     r0,#0
;;;1045   }
00005c  b004              ADD      sp,sp,#0x10
00005e  bd30              POP      {r4,r5,pc}
;;;1046   
                          ENDP


                          AREA ||i.HAL_DMA2D_ConfigLayer||, CODE, READONLY, ALIGN=2

                  HAL_DMA2D_ConfigLayer PROC
;;;837      */
;;;838    HAL_StatusTypeDef HAL_DMA2D_ConfigLayer(DMA2D_HandleTypeDef *hdma2d, uint32_t LayerIdx)
000000  b530              PUSH     {r4,r5,lr}
;;;839    { 
000002  4602              MOV      r2,r0
000004  460c              MOV      r4,r1
;;;840      DMA2D_LayerCfgTypeDef *pLayerCfg = &hdma2d->LayerCfg[LayerIdx];
000006  f1020018          ADD      r0,r2,#0x18
00000a  eb001104          ADD      r1,r0,r4,LSL #4
;;;841      
;;;842      uint32_t tmp = 0;
00000e  2300              MOVS     r3,#0
;;;843      
;;;844      /* Process locked */
;;;845      __HAL_LOCK(hdma2d);
000010  bf00              NOP      
000012  f8920038          LDRB     r0,[r2,#0x38]
000016  2801              CMP      r0,#1
000018  d101              BNE      |L6.30|
00001a  2002              MOVS     r0,#2
                  |L6.28|
;;;846      
;;;847      /* Change DMA2D peripheral state */
;;;848      hdma2d->State = HAL_DMA2D_STATE_BUSY; 
;;;849      
;;;850      /* Check the parameters */
;;;851      assert_param(IS_DMA2D_LAYER(LayerIdx));  
;;;852      assert_param(IS_DMA2D_OFFSET(pLayerCfg->InputOffset));  
;;;853      if(hdma2d->Init.Mode != DMA2D_R2M)
;;;854      {  
;;;855        assert_param(IS_DMA2D_INPUT_COLOR_MODE(pLayerCfg->InputColorMode));
;;;856        if(hdma2d->Init.Mode != DMA2D_M2M)
;;;857        {
;;;858          assert_param(IS_DMA2D_ALPHA_MODE(pLayerCfg->AlphaMode));
;;;859        }
;;;860      }
;;;861      
;;;862      /* Configure the background DMA2D layer */
;;;863      if(LayerIdx == 0)
;;;864      {
;;;865        /* DMA2D BGPFCR register configuration -----------------------------------*/
;;;866        /* Get the BGPFCCR register value */
;;;867        tmp = hdma2d->Instance->BGPFCCR;
;;;868        
;;;869        /* Clear Input color mode, alpha value and alpha mode bits */
;;;870        tmp &= (uint32_t)~(DMA2D_BGPFCCR_CM | DMA2D_BGPFCCR_AM | DMA2D_BGPFCCR_ALPHA); 
;;;871        
;;;872        if ((pLayerCfg->InputColorMode == CM_A4) || (pLayerCfg->InputColorMode == CM_A8))
;;;873        {
;;;874          /* Prepare the value to be wrote to the BGPFCCR register */
;;;875          tmp |= (pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << 16) | ((pLayerCfg->InputAlpha) & 0xFF000000));
;;;876        }
;;;877        else
;;;878        {
;;;879          /* Prepare the value to be wrote to the BGPFCCR register */
;;;880          tmp |= (pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << 16) | (pLayerCfg->InputAlpha << 24));
;;;881        }
;;;882        
;;;883        /* Write to DMA2D BGPFCCR register */
;;;884        hdma2d->Instance->BGPFCCR = tmp; 
;;;885        
;;;886        /* DMA2D BGOR register configuration -------------------------------------*/  
;;;887        /* Get the BGOR register value */
;;;888        tmp = hdma2d->Instance->BGOR;
;;;889        
;;;890        /* Clear colors bits */
;;;891        tmp &= (uint32_t)~DMA2D_BGOR_LO; 
;;;892        
;;;893        /* Prepare the value to be wrote to the BGOR register */
;;;894        tmp |= pLayerCfg->InputOffset;
;;;895        
;;;896        /* Write to DMA2D BGOR register */
;;;897        hdma2d->Instance->BGOR = tmp;
;;;898        
;;;899        if ((pLayerCfg->InputColorMode == CM_A4) || (pLayerCfg->InputColorMode == CM_A8))
;;;900        {
;;;901          /* Prepare the value to be wrote to the BGCOLR register */
;;;902          tmp = ((pLayerCfg->InputAlpha) & 0x00FFFFFF);
;;;903        
;;;904          /* Write to DMA2D BGCOLR register */
;;;905          hdma2d->Instance->BGCOLR = tmp;
;;;906        }    
;;;907      }
;;;908      /* Configure the foreground DMA2D layer */
;;;909      else
;;;910      {
;;;911        /* DMA2D FGPFCR register configuration -----------------------------------*/
;;;912        /* Get the FGPFCCR register value */
;;;913        tmp = hdma2d->Instance->FGPFCCR;
;;;914        
;;;915        /* Clear Input color mode, alpha value and alpha mode bits */
;;;916        tmp &= (uint32_t)~(DMA2D_FGPFCCR_CM | DMA2D_FGPFCCR_AM | DMA2D_FGPFCCR_ALPHA); 
;;;917        
;;;918        if ((pLayerCfg->InputColorMode == CM_A4) || (pLayerCfg->InputColorMode == CM_A8))
;;;919        {
;;;920          /* Prepare the value to be wrote to the FGPFCCR register */
;;;921          tmp |= (pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << 16) | ((pLayerCfg->InputAlpha) & 0xFF000000));
;;;922        }
;;;923        else
;;;924        {
;;;925          /* Prepare the value to be wrote to the FGPFCCR register */
;;;926          tmp |= (pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << 16) | (pLayerCfg->InputAlpha << 24));
;;;927        }
;;;928        
;;;929        /* Write to DMA2D FGPFCCR register */
;;;930        hdma2d->Instance->FGPFCCR = tmp; 
;;;931        
;;;932        /* DMA2D FGOR register configuration -------------------------------------*/  
;;;933        /* Get the FGOR register value */
;;;934        tmp = hdma2d->Instance->FGOR;
;;;935        
;;;936        /* Clear colors bits */
;;;937        tmp &= (uint32_t)~DMA2D_FGOR_LO; 
;;;938        
;;;939        /* Prepare the value to be wrote to the FGOR register */
;;;940        tmp |= pLayerCfg->InputOffset;
;;;941        
;;;942        /* Write to DMA2D FGOR register */
;;;943        hdma2d->Instance->FGOR = tmp;
;;;944       
;;;945        if ((pLayerCfg->InputColorMode == CM_A4) || (pLayerCfg->InputColorMode == CM_A8))
;;;946        {
;;;947          /* Prepare the value to be wrote to the FGCOLR register */
;;;948          tmp = ((pLayerCfg->InputAlpha) & 0x00FFFFFF);
;;;949        
;;;950          /* Write to DMA2D FGCOLR register */
;;;951          hdma2d->Instance->FGCOLR = tmp;
;;;952        }   
;;;953      }    
;;;954      /* Initialize the DMA2D state*/
;;;955      hdma2d->State  = HAL_DMA2D_STATE_READY;
;;;956      
;;;957      /* Process unlocked */
;;;958      __HAL_UNLOCK(hdma2d);  
;;;959      
;;;960      return HAL_OK;
;;;961    }
00001c  bd30              POP      {r4,r5,pc}
                  |L6.30|
00001e  2001              MOVS     r0,#1                 ;845
000020  f8820038          STRB     r0,[r2,#0x38]         ;845
000024  bf00              NOP                            ;845
000026  2002              MOVS     r0,#2                 ;848
000028  f8820039          STRB     r0,[r2,#0x39]         ;848
00002c  6850              LDR      r0,[r2,#4]            ;853
00002e  f5b03f40          CMP      r0,#0x30000           ;853
000032  d002              BEQ      |L6.58|
000034  6850              LDR      r0,[r2,#4]            ;856
000036  b100              CBZ      r0,|L6.58|
000038  bf00              NOP                            ;858
                  |L6.58|
00003a  bb8c              CBNZ     r4,|L6.160|
00003c  6810              LDR      r0,[r2,#0]            ;867
00003e  6a43              LDR      r3,[r0,#0x24]         ;867
000040  4835              LDR      r0,|L6.280|
000042  4003              ANDS     r3,r3,r0              ;870
000044  6848              LDR      r0,[r1,#4]            ;872
000046  280a              CMP      r0,#0xa               ;872
000048  d002              BEQ      |L6.80|
00004a  6848              LDR      r0,[r1,#4]            ;872
00004c  2809              CMP      r0,#9                 ;872
00004e  d109              BNE      |L6.100|
                  |L6.80|
000050  890d              LDRH     r5,[r1,#8]            ;875
000052  6848              LDR      r0,[r1,#4]            ;875
000054  ea404005          ORR      r0,r0,r5,LSL #16      ;875
000058  68cd              LDR      r5,[r1,#0xc]          ;875
00005a  f005457f          AND      r5,r5,#0xff000000     ;875
00005e  4328              ORRS     r0,r0,r5              ;875
000060  4303              ORRS     r3,r3,r0              ;875
000062  e007              B        |L6.116|
                  |L6.100|
000064  890d              LDRH     r5,[r1,#8]            ;880
000066  6848              LDR      r0,[r1,#4]            ;880
000068  ea404005          ORR      r0,r0,r5,LSL #16      ;880
00006c  7b0d              LDRB     r5,[r1,#0xc]          ;880
00006e  ea406005          ORR      r0,r0,r5,LSL #24      ;880
000072  4303              ORRS     r3,r3,r0              ;880
                  |L6.116|
000074  6810              LDR      r0,[r2,#0]            ;884
000076  6243              STR      r3,[r0,#0x24]         ;884
000078  6810              LDR      r0,[r2,#0]            ;888
00007a  6983              LDR      r3,[r0,#0x18]         ;888
00007c  f36f030d          BFC      r3,#0,#14             ;891
000080  6808              LDR      r0,[r1,#0]            ;894
000082  4303              ORRS     r3,r3,r0              ;894
000084  6810              LDR      r0,[r2,#0]            ;897
000086  6183              STR      r3,[r0,#0x18]         ;897
000088  6848              LDR      r0,[r1,#4]            ;899
00008a  280a              CMP      r0,#0xa               ;899
00008c  d002              BEQ      |L6.148|
00008e  6848              LDR      r0,[r1,#4]            ;899
000090  2809              CMP      r0,#9                 ;899
000092  d137              BNE      |L6.260|
                  |L6.148|
000094  68c8              LDR      r0,[r1,#0xc]          ;902
000096  f020437f          BIC      r3,r0,#0xff000000     ;902
00009a  6810              LDR      r0,[r2,#0]            ;905
00009c  6283              STR      r3,[r0,#0x28]         ;905
00009e  e031              B        |L6.260|
                  |L6.160|
0000a0  e7ff              B        |L6.162|
                  |L6.162|
0000a2  6810              LDR      r0,[r2,#0]            ;913
0000a4  69c3              LDR      r3,[r0,#0x1c]         ;913
0000a6  481c              LDR      r0,|L6.280|
0000a8  4003              ANDS     r3,r3,r0              ;916
0000aa  6848              LDR      r0,[r1,#4]            ;918
0000ac  280a              CMP      r0,#0xa               ;918
0000ae  d002              BEQ      |L6.182|
0000b0  6848              LDR      r0,[r1,#4]            ;918
0000b2  2809              CMP      r0,#9                 ;918
0000b4  d109              BNE      |L6.202|
                  |L6.182|
0000b6  890d              LDRH     r5,[r1,#8]            ;921
0000b8  6848              LDR      r0,[r1,#4]            ;921
0000ba  ea404005          ORR      r0,r0,r5,LSL #16      ;921
0000be  68cd              LDR      r5,[r1,#0xc]          ;921
0000c0  f005457f          AND      r5,r5,#0xff000000     ;921
0000c4  4328              ORRS     r0,r0,r5              ;921
0000c6  4303              ORRS     r3,r3,r0              ;921
0000c8  e007              B        |L6.218|
                  |L6.202|
0000ca  890d              LDRH     r5,[r1,#8]            ;926
0000cc  6848              LDR      r0,[r1,#4]            ;926
0000ce  ea404005          ORR      r0,r0,r5,LSL #16      ;926
0000d2  7b0d              LDRB     r5,[r1,#0xc]          ;926
0000d4  ea406005          ORR      r0,r0,r5,LSL #24      ;926
0000d8  4303              ORRS     r3,r3,r0              ;926
                  |L6.218|
0000da  6810              LDR      r0,[r2,#0]            ;930
0000dc  61c3              STR      r3,[r0,#0x1c]         ;930
0000de  6810              LDR      r0,[r2,#0]            ;934
0000e0  6903              LDR      r3,[r0,#0x10]         ;934
0000e2  f36f030d          BFC      r3,#0,#14             ;937
0000e6  6808              LDR      r0,[r1,#0]            ;940
0000e8  4303              ORRS     r3,r3,r0              ;940
0000ea  6810              LDR      r0,[r2,#0]            ;943
0000ec  6103              STR      r3,[r0,#0x10]         ;943
0000ee  6848              LDR      r0,[r1,#4]            ;945
0000f0  280a              CMP      r0,#0xa               ;945
0000f2  d002              BEQ      |L6.250|
0000f4  6848              LDR      r0,[r1,#4]            ;945
0000f6  2809              CMP      r0,#9                 ;945
0000f8  d104              BNE      |L6.260|
                  |L6.250|
0000fa  68c8              LDR      r0,[r1,#0xc]          ;948
0000fc  f020437f          BIC      r3,r0,#0xff000000     ;948
000100  6810              LDR      r0,[r2,#0]            ;951
000102  6203              STR      r3,[r0,#0x20]         ;951
                  |L6.260|
000104  2001              MOVS     r0,#1                 ;955
000106  f8820039          STRB     r0,[r2,#0x39]         ;955
00010a  bf00              NOP                            ;958
00010c  2000              MOVS     r0,#0                 ;958
00010e  f8820038          STRB     r0,[r2,#0x38]         ;958
000112  bf00              NOP                            ;958
000114  bf00              NOP                            ;960
000116  e781              B        |L6.28|
;;;962    
                          ENDP

                  |L6.280|
                          DCD      0x00fcfff0

                          AREA ||i.HAL_DMA2D_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_DMA2D_DeInit PROC
;;;265    
;;;266    HAL_StatusTypeDef HAL_DMA2D_DeInit(DMA2D_HandleTypeDef *hdma2d)
000000  b510              PUSH     {r4,lr}
;;;267    {
000002  4604              MOV      r4,r0
;;;268      /* Check the DMA2D peripheral state */
;;;269      if(hdma2d == NULL)
000004  b90c              CBNZ     r4,|L7.10|
;;;270      {
;;;271         return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L7.8|
;;;272      }
;;;273    
;;;274      /* DeInit the low level hardware */
;;;275      HAL_DMA2D_MspDeInit(hdma2d);
;;;276    
;;;277      /* Update error code */
;;;278      hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
;;;279    
;;;280      /* Initialize the DMA2D state*/
;;;281      hdma2d->State  = HAL_DMA2D_STATE_RESET;
;;;282    
;;;283      /* Release Lock */
;;;284      __HAL_UNLOCK(hdma2d);
;;;285    
;;;286      return HAL_OK;
;;;287    }
000008  bd10              POP      {r4,pc}
                  |L7.10|
00000a  4620              MOV      r0,r4                 ;275
00000c  f7fffffe          BL       HAL_DMA2D_MspDeInit
000010  2000              MOVS     r0,#0                 ;278
000012  63e0              STR      r0,[r4,#0x3c]         ;278
000014  f8840039          STRB     r0,[r4,#0x39]         ;281
000018  bf00              NOP                            ;284
00001a  f8840038          STRB     r0,[r4,#0x38]         ;284
00001e  bf00              NOP                            ;284
000020  bf00              NOP                            ;286
000022  e7f1              B        |L7.8|
;;;288    
                          ENDP


                          AREA ||i.HAL_DMA2D_DisableCLUT||, CODE, READONLY, ALIGN=1

                  HAL_DMA2D_DisableCLUT PROC
;;;1083     */
;;;1084   HAL_StatusTypeDef HAL_DMA2D_DisableCLUT(DMA2D_HandleTypeDef *hdma2d, uint32_t LayerIdx)
000000  4602              MOV      r2,r0
;;;1085   {
;;;1086     /* Check the parameters */
;;;1087     assert_param(IS_DMA2D_LAYER(LayerIdx));
;;;1088     
;;;1089     if(LayerIdx == 0)
000002  b931              CBNZ     r1,|L8.18|
;;;1090     {
;;;1091       /* Disable the CLUT loading for the background */
;;;1092       hdma2d->Instance->BGPFCCR &= ~DMA2D_BGPFCCR_START;
000004  6810              LDR      r0,[r2,#0]
000006  6a40              LDR      r0,[r0,#0x24]
000008  f0200020          BIC      r0,r0,#0x20
00000c  6813              LDR      r3,[r2,#0]
00000e  6258              STR      r0,[r3,#0x24]
000010  e005              B        |L8.30|
                  |L8.18|
;;;1093     }
;;;1094     else
;;;1095     {
;;;1096       /* Disable the CLUT loading for the foreground */
;;;1097       hdma2d->Instance->FGPFCCR &= ~DMA2D_FGPFCCR_START;
000012  6810              LDR      r0,[r2,#0]
000014  69c0              LDR      r0,[r0,#0x1c]
000016  f0200020          BIC      r0,r0,#0x20
00001a  6813              LDR      r3,[r2,#0]
00001c  61d8              STR      r0,[r3,#0x1c]
                  |L8.30|
;;;1098     } 
;;;1099     
;;;1100     return HAL_OK;
00001e  2000              MOVS     r0,#0
;;;1101   }
000020  4770              BX       lr
;;;1102   
                          ENDP


                          AREA ||i.HAL_DMA2D_EnableCLUT||, CODE, READONLY, ALIGN=1

                  HAL_DMA2D_EnableCLUT PROC
;;;1055     */
;;;1056   HAL_StatusTypeDef HAL_DMA2D_EnableCLUT(DMA2D_HandleTypeDef *hdma2d, uint32_t LayerIdx)
000000  4602              MOV      r2,r0
;;;1057   {  
;;;1058     /* Check the parameters */
;;;1059     assert_param(IS_DMA2D_LAYER(LayerIdx));
;;;1060     
;;;1061     if(LayerIdx == 0)
000002  b931              CBNZ     r1,|L9.18|
;;;1062     {
;;;1063       /* Enable the CLUT loading for the background */
;;;1064       hdma2d->Instance->BGPFCCR |= DMA2D_BGPFCCR_START;
000004  6810              LDR      r0,[r2,#0]
000006  6a40              LDR      r0,[r0,#0x24]
000008  f0400020          ORR      r0,r0,#0x20
00000c  6813              LDR      r3,[r2,#0]
00000e  6258              STR      r0,[r3,#0x24]
000010  e005              B        |L9.30|
                  |L9.18|
;;;1065     }
;;;1066     else
;;;1067     {
;;;1068       /* Enable the CLUT loading for the foreground */
;;;1069       hdma2d->Instance->FGPFCCR |= DMA2D_FGPFCCR_START;
000012  6810              LDR      r0,[r2,#0]
000014  69c0              LDR      r0,[r0,#0x1c]
000016  f0400020          ORR      r0,r0,#0x20
00001a  6813              LDR      r3,[r2,#0]
00001c  61d8              STR      r0,[r3,#0x1c]
                  |L9.30|
;;;1070     }
;;;1071     
;;;1072     return HAL_OK;
00001e  2000              MOVS     r0,#0
;;;1073   }
000020  4770              BX       lr
;;;1074   
                          ENDP


                          AREA ||i.HAL_DMA2D_GetError||, CODE, READONLY, ALIGN=1

                  HAL_DMA2D_GetError PROC
;;;1170     */
;;;1171   uint32_t HAL_DMA2D_GetError(DMA2D_HandleTypeDef *hdma2d)
000000  4601              MOV      r1,r0
;;;1172   {
;;;1173     return hdma2d->ErrorCode;
000002  6bc8              LDR      r0,[r1,#0x3c]
;;;1174   }
000004  4770              BX       lr
;;;1175   
                          ENDP


                          AREA ||i.HAL_DMA2D_GetState||, CODE, READONLY, ALIGN=1

                  HAL_DMA2D_GetState PROC
;;;1159     */
;;;1160   HAL_DMA2D_StateTypeDef HAL_DMA2D_GetState(DMA2D_HandleTypeDef *hdma2d)
000000  4601              MOV      r1,r0
;;;1161   {  
;;;1162     return hdma2d->State;
000002  f8910039          LDRB     r0,[r1,#0x39]
;;;1163   }
000006  4770              BX       lr
;;;1164   
                          ENDP


                          AREA ||i.HAL_DMA2D_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_DMA2D_IRQHandler PROC
;;;721      */
;;;722    void HAL_DMA2D_IRQHandler(DMA2D_HandleTypeDef *hdma2d)
000000  b510              PUSH     {r4,lr}
;;;723    {    
000002  4604              MOV      r4,r0
;;;724      /* Transfer Error Interrupt management ***************************************/
;;;725      if(__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TE) != RESET)
000004  6820              LDR      r0,[r4,#0]
000006  6840              LDR      r0,[r0,#4]
000008  f0000001          AND      r0,r0,#1
00000c  b1f0              CBZ      r0,|L12.76|
;;;726      {
;;;727        if(__HAL_DMA2D_GET_IT_SOURCE(hdma2d, DMA2D_IT_TE) != RESET)
00000e  6820              LDR      r0,[r4,#0]
000010  6800              LDR      r0,[r0,#0]
000012  f4007080          AND      r0,r0,#0x100
000016  b1c8              CBZ      r0,|L12.76|
;;;728        {
;;;729          /* Disable the transfer Error interrupt */
;;;730          __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_TE);  
000018  6820              LDR      r0,[r4,#0]
00001a  6800              LDR      r0,[r0,#0]
00001c  f4207080          BIC      r0,r0,#0x100
000020  6821              LDR      r1,[r4,#0]
000022  6008              STR      r0,[r1,#0]
;;;731    
;;;732          /* Update error code */
;;;733          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;
000024  6be0              LDR      r0,[r4,#0x3c]
000026  f0400001          ORR      r0,r0,#1
00002a  63e0              STR      r0,[r4,#0x3c]
;;;734        
;;;735          /* Clear the transfer error flag */
;;;736          __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TE);
00002c  2001              MOVS     r0,#1
00002e  6821              LDR      r1,[r4,#0]
000030  6088              STR      r0,[r1,#8]
;;;737    
;;;738          /* Change DMA2D state */
;;;739          hdma2d->State = HAL_DMA2D_STATE_ERROR;
000032  2004              MOVS     r0,#4
000034  f8840039          STRB     r0,[r4,#0x39]
;;;740    
;;;741          /* Process Unlocked */
;;;742          __HAL_UNLOCK(hdma2d);       
000038  bf00              NOP      
00003a  2000              MOVS     r0,#0
00003c  f8840038          STRB     r0,[r4,#0x38]
000040  bf00              NOP      
;;;743          
;;;744          if(hdma2d->XferErrorCallback != NULL)
000042  6960              LDR      r0,[r4,#0x14]
000044  b110              CBZ      r0,|L12.76|
;;;745          {
;;;746            /* Transfer error Callback */
;;;747            hdma2d->XferErrorCallback(hdma2d);
000046  4620              MOV      r0,r4
000048  6961              LDR      r1,[r4,#0x14]
00004a  4788              BLX      r1
                  |L12.76|
;;;748          }
;;;749        }
;;;750      }
;;;751      /* Configuration Error Interrupt management **********************************/
;;;752      if(__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CE) != RESET)
00004c  6820              LDR      r0,[r4,#0]
00004e  6840              LDR      r0,[r0,#4]
000050  f0000020          AND      r0,r0,#0x20
000054  b1f0              CBZ      r0,|L12.148|
;;;753      {
;;;754        if(__HAL_DMA2D_GET_IT_SOURCE(hdma2d, DMA2D_IT_CE) != RESET)
000056  6820              LDR      r0,[r4,#0]
000058  6800              LDR      r0,[r0,#0]
00005a  f4005000          AND      r0,r0,#0x2000
00005e  b1c8              CBZ      r0,|L12.148|
;;;755        {
;;;756          /* Disable the Configuration Error interrupt */
;;;757          __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_CE);
000060  6820              LDR      r0,[r4,#0]
000062  6800              LDR      r0,[r0,#0]
000064  f4205000          BIC      r0,r0,#0x2000
000068  6821              LDR      r1,[r4,#0]
00006a  6008              STR      r0,[r1,#0]
;;;758      
;;;759          /* Clear the Configuration error flag */
;;;760          __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CE);
00006c  2020              MOVS     r0,#0x20
00006e  6821              LDR      r1,[r4,#0]
000070  6088              STR      r0,[r1,#8]
;;;761    
;;;762          /* Update error code */
;;;763          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;    
000072  6be0              LDR      r0,[r4,#0x3c]
000074  f0400002          ORR      r0,r0,#2
000078  63e0              STR      r0,[r4,#0x3c]
;;;764        
;;;765          /* Change DMA2D state */
;;;766          hdma2d->State = HAL_DMA2D_STATE_ERROR;
00007a  2004              MOVS     r0,#4
00007c  f8840039          STRB     r0,[r4,#0x39]
;;;767    
;;;768          /* Process Unlocked */
;;;769          __HAL_UNLOCK(hdma2d);       
000080  bf00              NOP      
000082  2000              MOVS     r0,#0
000084  f8840038          STRB     r0,[r4,#0x38]
000088  bf00              NOP      
;;;770          
;;;771          if(hdma2d->XferErrorCallback != NULL)
00008a  6960              LDR      r0,[r4,#0x14]
00008c  b110              CBZ      r0,|L12.148|
;;;772          {
;;;773            /* Transfer error Callback */
;;;774            hdma2d->XferErrorCallback(hdma2d);
00008e  4620              MOV      r0,r4
000090  6961              LDR      r1,[r4,#0x14]
000092  4788              BLX      r1
                  |L12.148|
;;;775          }
;;;776        }
;;;777      }
;;;778      /* Transfer Complete Interrupt management ************************************/
;;;779      if(__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TC) != RESET)
000094  6820              LDR      r0,[r4,#0]
000096  6840              LDR      r0,[r0,#4]
000098  f0000002          AND      r0,r0,#2
00009c  b1e0              CBZ      r0,|L12.216|
;;;780      {
;;;781        if(__HAL_DMA2D_GET_IT_SOURCE(hdma2d, DMA2D_IT_TC) != RESET)
00009e  6820              LDR      r0,[r4,#0]
0000a0  6800              LDR      r0,[r0,#0]
0000a2  f4007000          AND      r0,r0,#0x200
0000a6  b1b8              CBZ      r0,|L12.216|
;;;782        { 
;;;783          /* Disable the transfer complete interrupt */
;;;784          __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_TC);
0000a8  6820              LDR      r0,[r4,#0]
0000aa  6800              LDR      r0,[r0,#0]
0000ac  f4207000          BIC      r0,r0,#0x200
0000b0  6821              LDR      r1,[r4,#0]
0000b2  6008              STR      r0,[r1,#0]
;;;785      
;;;786          /* Clear the transfer complete flag */  
;;;787          __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TC);
0000b4  2002              MOVS     r0,#2
0000b6  6821              LDR      r1,[r4,#0]
0000b8  6088              STR      r0,[r1,#8]
;;;788    
;;;789          /* Update error code */
;;;790          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_NONE;    
0000ba  6be0              LDR      r0,[r4,#0x3c]
0000bc  63e0              STR      r0,[r4,#0x3c]
;;;791        
;;;792          /* Change DMA2D state */
;;;793          hdma2d->State = HAL_DMA2D_STATE_READY;
0000be  2001              MOVS     r0,#1
0000c0  f8840039          STRB     r0,[r4,#0x39]
;;;794        
;;;795          /* Process Unlocked */
;;;796          __HAL_UNLOCK(hdma2d);       
0000c4  bf00              NOP      
0000c6  2000              MOVS     r0,#0
0000c8  f8840038          STRB     r0,[r4,#0x38]
0000cc  bf00              NOP      
;;;797          
;;;798          if(hdma2d->XferCpltCallback != NULL)
0000ce  6920              LDR      r0,[r4,#0x10]
0000d0  b110              CBZ      r0,|L12.216|
;;;799          {
;;;800            /* Transfer complete Callback */
;;;801            hdma2d->XferCpltCallback(hdma2d);
0000d2  4620              MOV      r0,r4
0000d4  6921              LDR      r1,[r4,#0x10]
0000d6  4788              BLX      r1
                  |L12.216|
;;;802          }         
;;;803        }
;;;804      }
;;;805    } 
0000d8  bd10              POP      {r4,pc}
;;;806    
                          ENDP


                          AREA ||i.HAL_DMA2D_Init||, CODE, READONLY, ALIGN=1

                  HAL_DMA2D_Init PROC
;;;182      */
;;;183    HAL_StatusTypeDef HAL_DMA2D_Init(DMA2D_HandleTypeDef *hdma2d)
000000  b570              PUSH     {r4-r6,lr}
;;;184    { 
000002  4604              MOV      r4,r0
;;;185      uint32_t tmp = 0;
000004  2500              MOVS     r5,#0
;;;186    
;;;187      /* Check the DMA2D peripheral state */
;;;188      if(hdma2d == NULL)
000006  b90c              CBNZ     r4,|L13.12|
;;;189      {
;;;190         return HAL_ERROR;
000008  2001              MOVS     r0,#1
                  |L13.10|
;;;191      }
;;;192    
;;;193      /* Check the parameters */
;;;194      assert_param(IS_DMA2D_ALL_INSTANCE(hdma2d->Instance));
;;;195      assert_param(IS_DMA2D_MODE(hdma2d->Init.Mode));
;;;196      assert_param(IS_DMA2D_CMODE(hdma2d->Init.ColorMode));
;;;197      assert_param(IS_DMA2D_OFFSET(hdma2d->Init.OutputOffset));
;;;198    
;;;199      if(hdma2d->State == HAL_DMA2D_STATE_RESET)
;;;200      {
;;;201        /* Allocate lock resource and initialize it */
;;;202        hdma2d->Lock = HAL_UNLOCKED;
;;;203        /* Init the low level hardware */
;;;204        HAL_DMA2D_MspInit(hdma2d);
;;;205      }
;;;206      
;;;207      /* Change DMA2D peripheral state */
;;;208      hdma2d->State = HAL_DMA2D_STATE_BUSY;  
;;;209    
;;;210    /* DMA2D CR register configuration -------------------------------------------*/
;;;211      /* Get the CR register value */
;;;212      tmp = hdma2d->Instance->CR;
;;;213    
;;;214      /* Clear Mode bits */
;;;215      tmp &= (uint32_t)~DMA2D_CR_MODE;
;;;216    
;;;217      /* Prepare the value to be wrote to the CR register */
;;;218      tmp |= hdma2d->Init.Mode;
;;;219    
;;;220      /* Write to DMA2D CR register */
;;;221      hdma2d->Instance->CR = tmp;
;;;222    
;;;223    /* DMA2D OPFCCR register configuration ---------------------------------------*/
;;;224      /* Get the OPFCCR register value */
;;;225      tmp = hdma2d->Instance->OPFCCR;
;;;226    
;;;227      /* Clear Color Mode bits */
;;;228      tmp &= (uint32_t)~DMA2D_OPFCCR_CM;
;;;229    
;;;230      /* Prepare the value to be wrote to the OPFCCR register */
;;;231      tmp |= hdma2d->Init.ColorMode;
;;;232    
;;;233      /* Write to DMA2D OPFCCR register */
;;;234      hdma2d->Instance->OPFCCR = tmp;
;;;235    
;;;236    /* DMA2D OOR register configuration ------------------------------------------*/  
;;;237      /* Get the OOR register value */
;;;238      tmp = hdma2d->Instance->OOR;
;;;239    
;;;240      /* Clear Offset bits */
;;;241      tmp &= (uint32_t)~DMA2D_OOR_LO;
;;;242    
;;;243      /* Prepare the value to be wrote to the OOR register */
;;;244      tmp |= hdma2d->Init.OutputOffset;
;;;245    
;;;246      /* Write to DMA2D OOR register */
;;;247      hdma2d->Instance->OOR = tmp;
;;;248    
;;;249      /* Update error code */
;;;250      hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
;;;251    
;;;252      /* Initialize the DMA2D state*/
;;;253      hdma2d->State  = HAL_DMA2D_STATE_READY;
;;;254    
;;;255      return HAL_OK;
;;;256    }
00000a  bd70              POP      {r4-r6,pc}
                  |L13.12|
00000c  f8940039          LDRB     r0,[r4,#0x39]         ;199
000010  b928              CBNZ     r0,|L13.30|
000012  2000              MOVS     r0,#0                 ;202
000014  f8840038          STRB     r0,[r4,#0x38]         ;202
000018  4620              MOV      r0,r4                 ;204
00001a  f7fffffe          BL       HAL_DMA2D_MspInit
                  |L13.30|
00001e  2002              MOVS     r0,#2                 ;208
000020  f8840039          STRB     r0,[r4,#0x39]         ;208
000024  6820              LDR      r0,[r4,#0]            ;212
000026  6805              LDR      r5,[r0,#0]            ;212
000028  f4253540          BIC      r5,r5,#0x30000        ;215
00002c  6860              LDR      r0,[r4,#4]            ;218
00002e  4305              ORRS     r5,r5,r0              ;218
000030  6820              LDR      r0,[r4,#0]            ;221
000032  6005              STR      r5,[r0,#0]            ;221
000034  6820              LDR      r0,[r4,#0]            ;225
000036  6b45              LDR      r5,[r0,#0x34]         ;225
000038  f0250507          BIC      r5,r5,#7              ;228
00003c  68a0              LDR      r0,[r4,#8]            ;231
00003e  4305              ORRS     r5,r5,r0              ;231
000040  6820              LDR      r0,[r4,#0]            ;234
000042  6345              STR      r5,[r0,#0x34]         ;234
000044  6820              LDR      r0,[r4,#0]            ;238
000046  6c05              LDR      r5,[r0,#0x40]         ;238
000048  f36f050d          BFC      r5,#0,#14             ;241
00004c  68e0              LDR      r0,[r4,#0xc]          ;244
00004e  4305              ORRS     r5,r5,r0              ;244
000050  6820              LDR      r0,[r4,#0]            ;247
000052  6405              STR      r5,[r0,#0x40]         ;247
000054  2000              MOVS     r0,#0                 ;250
000056  63e0              STR      r0,[r4,#0x3c]         ;250
000058  2001              MOVS     r0,#1                 ;253
00005a  f8840039          STRB     r0,[r4,#0x39]         ;253
00005e  2000              MOVS     r0,#0                 ;255
000060  e7d3              B        |L13.10|
;;;257    
                          ENDP


                          AREA ||i.HAL_DMA2D_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_DMA2D_MspDeInit PROC
;;;309      */
;;;310    __weak void HAL_DMA2D_MspDeInit(DMA2D_HandleTypeDef* hdma2d)
000000  4770              BX       lr
;;;311    {
;;;312      /* Prevent unused argument(s) compilation warning */
;;;313      UNUSED(hdma2d);
;;;314      /* NOTE : This function Should not be modified, when the callback is needed,
;;;315                the HAL_DMA2D_MspDeInit could be implemented in the user file
;;;316       */ 
;;;317    }
;;;318    
                          ENDP


                          AREA ||i.HAL_DMA2D_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_DMA2D_MspInit PROC
;;;294      */
;;;295    __weak void HAL_DMA2D_MspInit(DMA2D_HandleTypeDef* hdma2d)
000000  4770              BX       lr
;;;296    {
;;;297      /* Prevent unused argument(s) compilation warning */
;;;298      UNUSED(hdma2d);
;;;299      /* NOTE : This function Should not be modified, when the callback is needed,
;;;300                the HAL_DMA2D_MspInit could be implemented in the user file
;;;301       */ 
;;;302    }
;;;303    
                          ENDP


                          AREA ||i.HAL_DMA2D_PollForTransfer||, CODE, READONLY, ALIGN=1

                  HAL_DMA2D_PollForTransfer PROC
;;;618      */
;;;619    HAL_StatusTypeDef HAL_DMA2D_PollForTransfer(DMA2D_HandleTypeDef *hdma2d, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;620    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;621      uint32_t tmp, tmp1;
;;;622      uint32_t tickstart = 0;
000008  2700              MOVS     r7,#0
;;;623    
;;;624      /* Polling for DMA2D transfer */
;;;625      if((hdma2d->Instance->CR & DMA2D_CR_START) != 0)
00000a  6820              LDR      r0,[r4,#0]
00000c  6800              LDR      r0,[r0,#0]
00000e  f0000001          AND      r0,r0,#1
000012  2800              CMP      r0,#0
000014  d03b              BEQ      |L16.142|
;;;626      {
;;;627       /* Get tick */
;;;628       tickstart = HAL_GetTick();
000016  f7fffffe          BL       HAL_GetTick
00001a  4607              MOV      r7,r0
;;;629    
;;;630        while(__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TC) == RESET)
00001c  e031              B        |L16.130|
                  |L16.30|
;;;631        {
;;;632          tmp  = __HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CE);
00001e  6820              LDR      r0,[r4,#0]
000020  6840              LDR      r0,[r0,#4]
000022  f0000820          AND      r8,r0,#0x20
;;;633          tmp1 = __HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TE);
000026  6820              LDR      r0,[r4,#0]
000028  6840              LDR      r0,[r0,#4]
00002a  f0000601          AND      r6,r0,#1
;;;634    
;;;635          if((tmp != RESET) || (tmp1 != RESET))
00002e  f1b80f00          CMP      r8,#0
000032  d100              BNE      |L16.54|
000034  b186              CBZ      r6,|L16.88|
                  |L16.54|
;;;636          {
;;;637            /* Clear the transfer and configuration error flags */
;;;638            __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CE);
000036  2020              MOVS     r0,#0x20
000038  6821              LDR      r1,[r4,#0]
00003a  6088              STR      r0,[r1,#8]
;;;639            __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TE);
00003c  2001              MOVS     r0,#1
00003e  6821              LDR      r1,[r4,#0]
000040  6088              STR      r0,[r1,#8]
;;;640    
;;;641            /* Change DMA2D state */
;;;642            hdma2d->State= HAL_DMA2D_STATE_ERROR;
000042  2004              MOVS     r0,#4
000044  f8840039          STRB     r0,[r4,#0x39]
;;;643    
;;;644            /* Process unlocked */
;;;645            __HAL_UNLOCK(hdma2d);
000048  bf00              NOP      
00004a  2000              MOVS     r0,#0
00004c  f8840038          STRB     r0,[r4,#0x38]
000050  bf00              NOP      
;;;646            
;;;647            return HAL_ERROR;
000052  2001              MOVS     r0,#1
                  |L16.84|
;;;648          }
;;;649          /* Check for the Timeout */
;;;650          if(Timeout != HAL_MAX_DELAY)
;;;651          {
;;;652            if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
;;;653            {
;;;654              /* Process unlocked */
;;;655              __HAL_UNLOCK(hdma2d);
;;;656            
;;;657              /* Update error code */
;;;658              hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
;;;659    
;;;660              /* Change the DMA2D state */
;;;661              hdma2d->State= HAL_DMA2D_STATE_TIMEOUT;
;;;662              
;;;663              return HAL_TIMEOUT;
;;;664            }
;;;665          }        
;;;666        }
;;;667      }
;;;668      /* Polling for CLUT loading */
;;;669      if((hdma2d->Instance->FGPFCCR & DMA2D_FGPFCCR_START) != 0)
;;;670      {
;;;671        /* Get tick */
;;;672        tickstart = HAL_GetTick();
;;;673       
;;;674        while(__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CTC) == RESET)
;;;675        {
;;;676          if((__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CAE) != RESET))
;;;677          {      
;;;678            /* Clear the transfer and configuration error flags */
;;;679            __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CAE);
;;;680            
;;;681            /* Change DMA2D state */
;;;682            hdma2d->State= HAL_DMA2D_STATE_ERROR;
;;;683            
;;;684            return HAL_ERROR;      
;;;685          }      
;;;686          /* Check for the Timeout */
;;;687          if(Timeout != HAL_MAX_DELAY)
;;;688          {
;;;689            if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
;;;690            {
;;;691              /* Update error code */
;;;692              hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
;;;693        
;;;694              /* Change the DMA2D state */
;;;695              hdma2d->State= HAL_DMA2D_STATE_TIMEOUT;
;;;696              
;;;697              return HAL_TIMEOUT;
;;;698            }
;;;699          }      
;;;700        }
;;;701      }
;;;702      /* Clear the transfer complete flag */
;;;703      __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TC);
;;;704      
;;;705      /* Clear the CLUT loading flag */
;;;706      __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CTC);  
;;;707      
;;;708      /* Change DMA2D state */
;;;709      hdma2d->State = HAL_DMA2D_STATE_READY;
;;;710      
;;;711      /* Process unlocked */
;;;712      __HAL_UNLOCK(hdma2d);
;;;713      
;;;714      return HAL_OK;
;;;715    }
000054  e8bd81f0          POP      {r4-r8,pc}
                  |L16.88|
000058  1c68              ADDS     r0,r5,#1              ;650
00005a  b190              CBZ      r0,|L16.130|
00005c  b125              CBZ      r5,|L16.104|
00005e  f7fffffe          BL       HAL_GetTick
000062  1bc0              SUBS     r0,r0,r7              ;652
000064  42a8              CMP      r0,r5                 ;652
000066  d90c              BLS      |L16.130|
                  |L16.104|
000068  bf00              NOP                            ;655
00006a  2000              MOVS     r0,#0                 ;655
00006c  f8840038          STRB     r0,[r4,#0x38]         ;655
000070  bf00              NOP                            ;655
000072  6be0              LDR      r0,[r4,#0x3c]         ;658
000074  f0400020          ORR      r0,r0,#0x20           ;658
000078  63e0              STR      r0,[r4,#0x3c]         ;658
00007a  2003              MOVS     r0,#3                 ;661
00007c  f8840039          STRB     r0,[r4,#0x39]         ;661
000080  e7e8              B        |L16.84|
                  |L16.130|
000082  6820              LDR      r0,[r4,#0]            ;630
000084  6840              LDR      r0,[r0,#4]            ;630
000086  f0000002          AND      r0,r0,#2              ;630
00008a  2800              CMP      r0,#0                 ;630
00008c  d0c7              BEQ      |L16.30|
                  |L16.142|
00008e  6820              LDR      r0,[r4,#0]            ;669
000090  69c0              LDR      r0,[r0,#0x1c]         ;669
000092  f0000020          AND      r0,r0,#0x20           ;669
000096  b330              CBZ      r0,|L16.230|
000098  f7fffffe          BL       HAL_GetTick
00009c  4607              MOV      r7,r0                 ;672
00009e  e01c              B        |L16.218|
                  |L16.160|
0000a0  6820              LDR      r0,[r4,#0]            ;676
0000a2  6840              LDR      r0,[r0,#4]            ;676
0000a4  f0000008          AND      r0,r0,#8              ;676
0000a8  b138              CBZ      r0,|L16.186|
0000aa  2008              MOVS     r0,#8                 ;679
0000ac  6821              LDR      r1,[r4,#0]            ;679
0000ae  6088              STR      r0,[r1,#8]            ;679
0000b0  2004              MOVS     r0,#4                 ;682
0000b2  f8840039          STRB     r0,[r4,#0x39]         ;682
0000b6  2001              MOVS     r0,#1                 ;684
0000b8  e7cc              B        |L16.84|
                  |L16.186|
0000ba  1c68              ADDS     r0,r5,#1              ;687
0000bc  b168              CBZ      r0,|L16.218|
0000be  b125              CBZ      r5,|L16.202|
0000c0  f7fffffe          BL       HAL_GetTick
0000c4  1bc0              SUBS     r0,r0,r7              ;689
0000c6  42a8              CMP      r0,r5                 ;689
0000c8  d907              BLS      |L16.218|
                  |L16.202|
0000ca  6be0              LDR      r0,[r4,#0x3c]         ;692
0000cc  f0400020          ORR      r0,r0,#0x20           ;692
0000d0  63e0              STR      r0,[r4,#0x3c]         ;692
0000d2  2003              MOVS     r0,#3                 ;695
0000d4  f8840039          STRB     r0,[r4,#0x39]         ;695
0000d8  e7bc              B        |L16.84|
                  |L16.218|
0000da  6820              LDR      r0,[r4,#0]            ;674
0000dc  6840              LDR      r0,[r0,#4]            ;674
0000de  f0000010          AND      r0,r0,#0x10           ;674
0000e2  2800              CMP      r0,#0                 ;674
0000e4  d0dc              BEQ      |L16.160|
                  |L16.230|
0000e6  2002              MOVS     r0,#2                 ;703
0000e8  6821              LDR      r1,[r4,#0]            ;703
0000ea  6088              STR      r0,[r1,#8]            ;703
0000ec  2010              MOVS     r0,#0x10              ;706
0000ee  6821              LDR      r1,[r4,#0]            ;706
0000f0  6088              STR      r0,[r1,#8]            ;706
0000f2  2001              MOVS     r0,#1                 ;709
0000f4  f8840039          STRB     r0,[r4,#0x39]         ;709
0000f8  bf00              NOP                            ;712
0000fa  2000              MOVS     r0,#0                 ;712
0000fc  f8840038          STRB     r0,[r4,#0x38]         ;712
000100  bf00              NOP                            ;712
000102  bf00              NOP                            ;714
000104  e7a6              B        |L16.84|
;;;716    /**
                          ENDP


                          AREA ||i.HAL_DMA2D_ProgramLineEvent||, CODE, READONLY, ALIGN=2

                  HAL_DMA2D_ProgramLineEvent PROC
;;;1110   
;;;1111   HAL_StatusTypeDef HAL_DMA2D_ProgramLineEvent(DMA2D_HandleTypeDef *hdma2d, uint32_t Line)
000000  4602              MOV      r2,r0
;;;1112   {
;;;1113     /* Process locked */
;;;1114     __HAL_LOCK(hdma2d);
000002  bf00              NOP      
000004  f8920038          LDRB     r0,[r2,#0x38]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L17.16|
00000c  2002              MOVS     r0,#2
                  |L17.14|
;;;1115     
;;;1116     /* Change DMA2D peripheral state */
;;;1117     hdma2d->State = HAL_DMA2D_STATE_BUSY;
;;;1118     
;;;1119     /* Check the parameters */
;;;1120     assert_param(IS_DMA2D_LineWatermark(Line));
;;;1121   
;;;1122     /* Sets the Line watermark configuration */
;;;1123     DMA2D->LWR = (uint32_t)Line;
;;;1124     
;;;1125     /* Initialize the DMA2D state*/
;;;1126     hdma2d->State = HAL_DMA2D_STATE_READY;
;;;1127     
;;;1128     /* Process unlocked */
;;;1129     __HAL_UNLOCK(hdma2d);  
;;;1130     
;;;1131     return HAL_OK;  
;;;1132   }
00000e  4770              BX       lr
                  |L17.16|
000010  2001              MOVS     r0,#1                 ;1114
000012  f8820038          STRB     r0,[r2,#0x38]         ;1114
000016  bf00              NOP                            ;1114
000018  2002              MOVS     r0,#2                 ;1117
00001a  f8820039          STRB     r0,[r2,#0x39]         ;1117
00001e  4806              LDR      r0,|L17.56|
000020  6481              STR      r1,[r0,#0x48]         ;1123
000022  2001              MOVS     r0,#1                 ;1126
000024  f8820039          STRB     r0,[r2,#0x39]         ;1126
000028  bf00              NOP                            ;1129
00002a  2000              MOVS     r0,#0                 ;1129
00002c  f8820038          STRB     r0,[r2,#0x38]         ;1129
000030  bf00              NOP                            ;1129
000032  bf00              NOP                            ;1131
000034  e7eb              B        |L17.14|
;;;1133   
                          ENDP

000036  0000              DCW      0x0000
                  |L17.56|
                          DCD      0x4002b000

                          AREA ||i.HAL_DMA2D_Resume||, CODE, READONLY, ALIGN=1

                  HAL_DMA2D_Resume PROC
;;;600      */
;;;601    HAL_StatusTypeDef HAL_DMA2D_Resume(DMA2D_HandleTypeDef *hdma2d)
000000  4601              MOV      r1,r0
;;;602    {
;;;603      /* Resume the DMA2D transfer */
;;;604      hdma2d->Instance->CR &= ~DMA2D_CR_SUSP;
000002  6808              LDR      r0,[r1,#0]
000004  6800              LDR      r0,[r0,#0]
000006  f0200002          BIC      r0,r0,#2
00000a  680a              LDR      r2,[r1,#0]
00000c  6010              STR      r0,[r2,#0]
;;;605    
;;;606      /* Change the DMA2D state*/
;;;607      hdma2d->State = HAL_DMA2D_STATE_BUSY;
00000e  2002              MOVS     r0,#2
000010  f8810039          STRB     r0,[r1,#0x39]
;;;608    
;;;609      return HAL_OK;
000014  2000              MOVS     r0,#0
;;;610    }
000016  4770              BX       lr
;;;611    
                          ENDP


                          AREA ||i.HAL_DMA2D_Start||, CODE, READONLY, ALIGN=1

                  HAL_DMA2D_Start PROC
;;;361      */
;;;362    HAL_StatusTypeDef HAL_DMA2D_Start(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width,  uint32_t Height)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;363    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8020          LDR      r8,[sp,#0x20]
;;;364      /* Process locked */
;;;365      __HAL_LOCK(hdma2d);
000010  bf00              NOP      
000012  f8940038          LDRB     r0,[r4,#0x38]
000016  2801              CMP      r0,#1
000018  d102              BNE      |L19.32|
00001a  2002              MOVS     r0,#2
                  |L19.28|
;;;366    
;;;367      /* Change DMA2D peripheral state */
;;;368      hdma2d->State = HAL_DMA2D_STATE_BUSY;
;;;369    
;;;370      /* Check the parameters */
;;;371      assert_param(IS_DMA2D_LINE(Height));
;;;372      assert_param(IS_DMA2D_PIXEL(Width));
;;;373    
;;;374      /* Disable the Peripheral */
;;;375      __HAL_DMA2D_DISABLE(hdma2d);
;;;376    
;;;377      /* Configure the source, destination address and the data size */
;;;378      DMA2D_SetConfig(hdma2d, pdata, DstAddress, Width, Height);
;;;379    
;;;380      /* Enable the Peripheral */
;;;381      __HAL_DMA2D_ENABLE(hdma2d);
;;;382    
;;;383      return HAL_OK;
;;;384    }
00001c  e8bd83f8          POP      {r3-r9,pc}
                  |L19.32|
000020  2001              MOVS     r0,#1                 ;365
000022  f8840038          STRB     r0,[r4,#0x38]         ;365
000026  bf00              NOP                            ;365
000028  2002              MOVS     r0,#2                 ;368
00002a  f8840039          STRB     r0,[r4,#0x39]         ;368
00002e  6820              LDR      r0,[r4,#0]            ;375
000030  6800              LDR      r0,[r0,#0]            ;375
000032  f0200001          BIC      r0,r0,#1              ;375
000036  6821              LDR      r1,[r4,#0]            ;375
000038  6008              STR      r0,[r1,#0]            ;375
00003a  463b              MOV      r3,r7                 ;378
00003c  4632              MOV      r2,r6                 ;378
00003e  4629              MOV      r1,r5                 ;378
000040  4620              MOV      r0,r4                 ;378
000042  f8cd8000          STR      r8,[sp,#0]            ;378
000046  f7fffffe          BL       DMA2D_SetConfig
00004a  6820              LDR      r0,[r4,#0]            ;381
00004c  6800              LDR      r0,[r0,#0]            ;381
00004e  f0400001          ORR      r0,r0,#1              ;381
000052  6821              LDR      r1,[r4,#0]            ;381
000054  6008              STR      r0,[r1,#0]            ;381
000056  2000              MOVS     r0,#0                 ;383
000058  e7e0              B        |L19.28|
;;;385    
                          ENDP


                          AREA ||i.HAL_DMA2D_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_DMA2D_Start_IT PROC
;;;398      */
;;;399    HAL_StatusTypeDef HAL_DMA2D_Start_IT(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width,  uint32_t Height)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;400    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8020          LDR      r8,[sp,#0x20]
;;;401      /* Process locked */
;;;402      __HAL_LOCK(hdma2d);
000010  bf00              NOP      
000012  f8940038          LDRB     r0,[r4,#0x38]
000016  2801              CMP      r0,#1
000018  d102              BNE      |L20.32|
00001a  2002              MOVS     r0,#2
                  |L20.28|
;;;403    
;;;404      /* Change DMA2D peripheral state */
;;;405      hdma2d->State = HAL_DMA2D_STATE_BUSY;
;;;406    
;;;407      /* Check the parameters */
;;;408      assert_param(IS_DMA2D_LINE(Height));
;;;409      assert_param(IS_DMA2D_PIXEL(Width));
;;;410    
;;;411      /* Disable the Peripheral */
;;;412      __HAL_DMA2D_DISABLE(hdma2d);
;;;413    
;;;414      /* Configure the source, destination address and the data size */
;;;415      DMA2D_SetConfig(hdma2d, pdata, DstAddress, Width, Height);
;;;416    
;;;417      /* Enable the transfer complete interrupt */
;;;418      __HAL_DMA2D_ENABLE_IT(hdma2d, DMA2D_IT_TC);
;;;419    
;;;420      /* Enable the transfer Error interrupt */
;;;421      __HAL_DMA2D_ENABLE_IT(hdma2d, DMA2D_IT_TE);
;;;422    
;;;423      /* Enable the Peripheral */
;;;424      __HAL_DMA2D_ENABLE(hdma2d);
;;;425    
;;;426      /* Enable the configuration error interrupt */
;;;427      __HAL_DMA2D_ENABLE_IT(hdma2d, DMA2D_IT_CE);
;;;428    
;;;429      return HAL_OK;
;;;430    }
00001c  e8bd83f8          POP      {r3-r9,pc}
                  |L20.32|
000020  2001              MOVS     r0,#1                 ;402
000022  f8840038          STRB     r0,[r4,#0x38]         ;402
000026  bf00              NOP                            ;402
000028  2002              MOVS     r0,#2                 ;405
00002a  f8840039          STRB     r0,[r4,#0x39]         ;405
00002e  6820              LDR      r0,[r4,#0]            ;412
000030  6800              LDR      r0,[r0,#0]            ;412
000032  f0200001          BIC      r0,r0,#1              ;412
000036  6821              LDR      r1,[r4,#0]            ;412
000038  6008              STR      r0,[r1,#0]            ;412
00003a  463b              MOV      r3,r7                 ;415
00003c  4632              MOV      r2,r6                 ;415
00003e  4629              MOV      r1,r5                 ;415
000040  4620              MOV      r0,r4                 ;415
000042  f8cd8000          STR      r8,[sp,#0]            ;415
000046  f7fffffe          BL       DMA2D_SetConfig
00004a  6820              LDR      r0,[r4,#0]            ;418
00004c  6800              LDR      r0,[r0,#0]            ;418
00004e  f4407000          ORR      r0,r0,#0x200          ;418
000052  6821              LDR      r1,[r4,#0]            ;418
000054  6008              STR      r0,[r1,#0]            ;418
000056  6820              LDR      r0,[r4,#0]            ;421
000058  6800              LDR      r0,[r0,#0]            ;421
00005a  f4407080          ORR      r0,r0,#0x100          ;421
00005e  6821              LDR      r1,[r4,#0]            ;421
000060  6008              STR      r0,[r1,#0]            ;421
000062  6820              LDR      r0,[r4,#0]            ;424
000064  6800              LDR      r0,[r0,#0]            ;424
000066  f0400001          ORR      r0,r0,#1              ;424
00006a  6821              LDR      r1,[r4,#0]            ;424
00006c  6008              STR      r0,[r1,#0]            ;424
00006e  6820              LDR      r0,[r4,#0]            ;427
000070  6800              LDR      r0,[r0,#0]            ;427
000072  f4405000          ORR      r0,r0,#0x2000         ;427
000076  6821              LDR      r1,[r4,#0]            ;427
000078  6008              STR      r0,[r1,#0]            ;427
00007a  2000              MOVS     r0,#0                 ;429
00007c  e7ce              B        |L20.28|
;;;431    
                          ENDP


                          AREA ||i.HAL_DMA2D_Suspend||, CODE, READONLY, ALIGN=1

                  HAL_DMA2D_Suspend PROC
;;;564      */
;;;565    HAL_StatusTypeDef HAL_DMA2D_Suspend(DMA2D_HandleTypeDef *hdma2d)
000000  b570              PUSH     {r4-r6,lr}
;;;566    {
000002  4604              MOV      r4,r0
;;;567      uint32_t tickstart = 0;
000004  2500              MOVS     r5,#0
;;;568    
;;;569      /* Suspend the DMA2D transfer */
;;;570      hdma2d->Instance->CR |= DMA2D_CR_SUSP;
000006  6820              LDR      r0,[r4,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  f0400002          ORR      r0,r0,#2
00000e  6821              LDR      r1,[r4,#0]
000010  6008              STR      r0,[r1,#0]
;;;571    
;;;572      /* Get tick */
;;;573      tickstart = HAL_GetTick();
000012  f7fffffe          BL       HAL_GetTick
000016  4605              MOV      r5,r0
;;;574    
;;;575      /* Check if the DMA2D is effectively suspended */
;;;576      while((hdma2d->Instance->CR & DMA2D_CR_SUSP) != DMA2D_CR_SUSP)
000018  e00d              B        |L21.54|
                  |L21.26|
;;;577      {
;;;578        if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA2D_SUSPEND)
00001a  f7fffffe          BL       HAL_GetTick
00001e  1b40              SUBS     r0,r0,r5
000020  f5b07f7a          CMP      r0,#0x3e8
000024  d907              BLS      |L21.54|
;;;579        {
;;;580          /* Update error code */
;;;581          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
000026  6be0              LDR      r0,[r4,#0x3c]
000028  f0400020          ORR      r0,r0,#0x20
00002c  63e0              STR      r0,[r4,#0x3c]
;;;582          
;;;583          /* Change the DMA2D state */
;;;584          hdma2d->State= HAL_DMA2D_STATE_TIMEOUT;
00002e  2003              MOVS     r0,#3
000030  f8840039          STRB     r0,[r4,#0x39]
                  |L21.52|
;;;585          
;;;586          return HAL_TIMEOUT;
;;;587        }
;;;588      }
;;;589      /* Change the DMA2D state*/
;;;590      hdma2d->State = HAL_DMA2D_STATE_SUSPEND;
;;;591    
;;;592      return HAL_OK;
;;;593    }
000034  bd70              POP      {r4-r6,pc}
                  |L21.54|
000036  6820              LDR      r0,[r4,#0]            ;576
000038  6800              LDR      r0,[r0,#0]            ;576
00003a  f0000002          AND      r0,r0,#2              ;576
00003e  2802              CMP      r0,#2                 ;576
000040  d1eb              BNE      |L21.26|
000042  2005              MOVS     r0,#5                 ;590
000044  f8840039          STRB     r0,[r4,#0x39]         ;590
000048  2000              MOVS     r0,#0                 ;592
00004a  e7f3              B        |L21.52|
;;;594    
                          ENDP


;*** Start embedded assembler ***

#line 1 "HALLIB\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_dma2d.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f4xx_hal_dma2d_c_16a0ba09____REV16|
#line 388 ".\\CORE\\cmsis_armcc.h"
|__asm___21_stm32f4xx_hal_dma2d_c_16a0ba09____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f4xx_hal_dma2d_c_16a0ba09____REVSH|
#line 402
|__asm___21_stm32f4xx_hal_dma2d_c_16a0ba09____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f4xx_hal_dma2d_c_16a0ba09____RRX|
#line 587
|__asm___21_stm32f4xx_hal_dma2d_c_16a0ba09____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
