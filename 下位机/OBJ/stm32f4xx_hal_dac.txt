; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\stm32f4xx_hal_dac.o --asm_dir=.\OBJ\ --list_dir=.\OBJ\ --depend=.\obj\stm32f4xx_hal_dac.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I.\CORE -I.\USER -I.\HALLIB\STM32F4xx_HAL_Driver\Inc -I.\SYSTEM -I.\Hardware -I.\App -I.\DSP_LIB\Include -I.\FreeRTOS -I.\MPU9250\DMP -I.\MPU9250 -I.\RTE\_Project -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=526 -DSTM32F427xx -DSTM32F4 -DUSE_HAL_DRIVER -DSTM32F427xx -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=.\obj\stm32f4xx_hal_dac.crf HALLIB\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_dac.c]
                          THUMB

                          AREA ||i.DAC_DMAConvCpltCh1||, CODE, READONLY, ALIGN=1

                  DAC_DMAConvCpltCh1 PROC
;;;908      */
;;;909    static void DAC_DMAConvCpltCh1(DMA_HandleTypeDef *hdma)   
000000  b570              PUSH     {r4-r6,lr}
;;;910    {
000002  4604              MOV      r4,r0
;;;911      DAC_HandleTypeDef* hdac = ( DAC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6ba5              LDR      r5,[r4,#0x38]
;;;912      
;;;913      HAL_DAC_ConvCpltCallbackCh1(hdac); 
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_DAC_ConvCpltCallbackCh1
;;;914      
;;;915      hdac->State= HAL_DAC_STATE_READY;
00000c  2001              MOVS     r0,#1
00000e  7128              STRB     r0,[r5,#4]
;;;916    }
000010  bd70              POP      {r4-r6,pc}
;;;917    
                          ENDP


                          AREA ||i.DAC_DMAErrorCh1||, CODE, READONLY, ALIGN=1

                  DAC_DMAErrorCh1 PROC
;;;936      */
;;;937    static void DAC_DMAErrorCh1(DMA_HandleTypeDef *hdma)   
000000  b570              PUSH     {r4-r6,lr}
;;;938    {
000002  4605              MOV      r5,r0
;;;939      DAC_HandleTypeDef* hdac = ( DAC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;940        
;;;941      /* Set DAC error code to DMA error */
;;;942      hdac->ErrorCode |= HAL_DAC_ERROR_DMA;
000006  6920              LDR      r0,[r4,#0x10]
000008  f0400004          ORR      r0,r0,#4
00000c  6120              STR      r0,[r4,#0x10]
;;;943        
;;;944      HAL_DAC_ErrorCallbackCh1(hdac); 
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       HAL_DAC_ErrorCallbackCh1
;;;945        
;;;946      hdac->State= HAL_DAC_STATE_READY;
000014  2001              MOVS     r0,#1
000016  7120              STRB     r0,[r4,#4]
;;;947    }
000018  bd70              POP      {r4-r6,pc}
;;;948    
                          ENDP


                          AREA ||i.DAC_DMAHalfConvCpltCh1||, CODE, READONLY, ALIGN=1

                  DAC_DMAHalfConvCpltCh1 PROC
;;;923      */
;;;924    static void DAC_DMAHalfConvCpltCh1(DMA_HandleTypeDef *hdma)   
000000  b570              PUSH     {r4-r6,lr}
;;;925    {
000002  4604              MOV      r4,r0
;;;926        DAC_HandleTypeDef* hdac = ( DAC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6ba5              LDR      r5,[r4,#0x38]
;;;927        /* Conversion complete callback */
;;;928        HAL_DAC_ConvHalfCpltCallbackCh1(hdac); 
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_DAC_ConvHalfCpltCallbackCh1
;;;929    }
00000c  bd70              POP      {r4-r6,pc}
;;;930    
                          ENDP


                          AREA ||i.HAL_DAC_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_DAC_ConfigChannel PROC
;;;772      */
;;;773    HAL_StatusTypeDef HAL_DAC_ConfigChannel(DAC_HandleTypeDef* hdac, DAC_ChannelConfTypeDef* sConfig, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;774    {
000002  4603              MOV      r3,r0
;;;775      uint32_t tmpreg1 = 0, tmpreg2 = 0;
000004  2400              MOVS     r4,#0
000006  2500              MOVS     r5,#0
;;;776    
;;;777      /* Check the DAC parameters */
;;;778      assert_param(IS_DAC_TRIGGER(sConfig->DAC_Trigger));
;;;779      assert_param(IS_DAC_OUTPUT_BUFFER_STATE(sConfig->DAC_OutputBuffer));
;;;780      assert_param(IS_DAC_CHANNEL(Channel));
;;;781      
;;;782      /* Process locked */
;;;783      __HAL_LOCK(hdac);
000008  bf00              NOP      
00000a  7958              LDRB     r0,[r3,#5]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L4.20|
000010  2002              MOVS     r0,#2
                  |L4.18|
;;;784      
;;;785      /* Change DAC state */
;;;786      hdac->State = HAL_DAC_STATE_BUSY;
;;;787      
;;;788      /* Get the DAC CR value */
;;;789      tmpreg1 = hdac->Instance->CR;
;;;790      /* Clear BOFFx, TENx, TSELx, WAVEx and MAMPx bits */
;;;791      tmpreg1 &= ~(((uint32_t)(DAC_CR_MAMP1 | DAC_CR_WAVE1 | DAC_CR_TSEL1 | DAC_CR_TEN1 | DAC_CR_BOFF1)) << Channel);
;;;792      /* Configure for the selected DAC channel: buffer output, trigger */
;;;793      /* Set TSELx and TENx bits according to DAC_Trigger value */
;;;794      /* Set BOFFx bit according to DAC_OutputBuffer value */   
;;;795      tmpreg2 = (sConfig->DAC_Trigger | sConfig->DAC_OutputBuffer);
;;;796      /* Calculate CR register value depending on DAC_Channel */
;;;797      tmpreg1 |= tmpreg2 << Channel;
;;;798      /* Write to DAC CR */
;;;799      hdac->Instance->CR = tmpreg1;
;;;800      /* Disable wave generation */
;;;801      hdac->Instance->CR &= ~(DAC_CR_WAVE1 << Channel);
;;;802      
;;;803      /* Change DAC state */
;;;804      hdac->State = HAL_DAC_STATE_READY;
;;;805      
;;;806      /* Process unlocked */
;;;807      __HAL_UNLOCK(hdac);
;;;808      
;;;809      /* Return function status */
;;;810      return HAL_OK;
;;;811    }
000012  bd70              POP      {r4-r6,pc}
                  |L4.20|
000014  2001              MOVS     r0,#1                 ;783
000016  7158              STRB     r0,[r3,#5]            ;783
000018  bf00              NOP                            ;783
00001a  2002              MOVS     r0,#2                 ;786
00001c  7118              STRB     r0,[r3,#4]            ;786
00001e  6818              LDR      r0,[r3,#0]            ;789
000020  6804              LDR      r4,[r0,#0]            ;789
000022  f64070fe          MOV      r0,#0xffe             ;791
000026  4090              LSLS     r0,r0,r2              ;791
000028  4384              BICS     r4,r4,r0              ;791
00002a  e9d10600          LDRD     r0,r6,[r1,#0]         ;795
00002e  ea400506          ORR      r5,r0,r6              ;795
000032  fa05f002          LSL      r0,r5,r2              ;797
000036  4304              ORRS     r4,r4,r0              ;797
000038  6818              LDR      r0,[r3,#0]            ;799
00003a  6004              STR      r4,[r0,#0]            ;799
00003c  6818              LDR      r0,[r3,#0]            ;801
00003e  6806              LDR      r6,[r0,#0]            ;801
000040  20c0              MOVS     r0,#0xc0              ;801
000042  4090              LSLS     r0,r0,r2              ;801
000044  4386              BICS     r6,r6,r0              ;801
000046  6818              LDR      r0,[r3,#0]            ;801
000048  6006              STR      r6,[r0,#0]            ;801
00004a  2001              MOVS     r0,#1                 ;804
00004c  7118              STRB     r0,[r3,#4]            ;804
00004e  bf00              NOP                            ;807
000050  2000              MOVS     r0,#0                 ;807
000052  7158              STRB     r0,[r3,#5]            ;807
000054  bf00              NOP                            ;807
000056  bf00              NOP                            ;810
000058  e7db              B        |L4.18|
;;;812    
                          ENDP


                          AREA ||i.HAL_DAC_ConvCpltCallbackCh1||, CODE, READONLY, ALIGN=1

                  HAL_DAC_ConvCpltCallbackCh1 PROC
;;;688      */
;;;689    __weak void HAL_DAC_ConvCpltCallbackCh1(DAC_HandleTypeDef* hdac)
000000  4770              BX       lr
;;;690    {
;;;691      /* Prevent unused argument(s) compilation warning */
;;;692      UNUSED(hdac);
;;;693      /* NOTE : This function Should not be modified, when the callback is needed,
;;;694                the HAL_DAC_ConvCpltCallback could be implemented in the user file
;;;695       */
;;;696    }
;;;697    
                          ENDP


                          AREA ||i.HAL_DAC_ConvHalfCpltCallbackCh1||, CODE, READONLY, ALIGN=1

                  HAL_DAC_ConvHalfCpltCallbackCh1 PROC
;;;703      */
;;;704    __weak void HAL_DAC_ConvHalfCpltCallbackCh1(DAC_HandleTypeDef* hdac)
000000  4770              BX       lr
;;;705    {
;;;706      /* Prevent unused argument(s) compilation warning */
;;;707      UNUSED(hdac);
;;;708      /* NOTE : This function Should not be modified, when the callback is needed,
;;;709                the HAL_DAC_ConvHalfCpltCallbackCh1 could be implemented in the user file
;;;710       */
;;;711    }
;;;712    
                          ENDP


                          AREA ||i.HAL_DAC_DMAUnderrunCallbackCh1||, CODE, READONLY, ALIGN=1

                  HAL_DAC_DMAUnderrunCallbackCh1 PROC
;;;733      */
;;;734    __weak void HAL_DAC_DMAUnderrunCallbackCh1(DAC_HandleTypeDef *hdac)
000000  4770              BX       lr
;;;735    {
;;;736      /* Prevent unused argument(s) compilation warning */
;;;737      UNUSED(hdac);
;;;738      /* NOTE : This function Should not be modified, when the callback is needed,
;;;739                the HAL_DAC_DMAUnderrunCallbackCh1 could be implemented in the user file
;;;740       */
;;;741    }
;;;742    
                          ENDP


                          AREA ||i.HAL_DAC_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_DAC_DeInit PROC
;;;268      */
;;;269    HAL_StatusTypeDef HAL_DAC_DeInit(DAC_HandleTypeDef* hdac)
000000  b510              PUSH     {r4,lr}
;;;270    {
000002  4604              MOV      r4,r0
;;;271      /* Check DAC handle */
;;;272      if(hdac == NULL)
000004  b90c              CBNZ     r4,|L8.10|
;;;273      {
;;;274         return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L8.8|
;;;275      }
;;;276    
;;;277      /* Check the parameters */
;;;278      assert_param(IS_DAC_ALL_INSTANCE(hdac->Instance));
;;;279    
;;;280      /* Change DAC state */
;;;281      hdac->State = HAL_DAC_STATE_BUSY;
;;;282    
;;;283      /* DeInit the low level hardware */
;;;284      HAL_DAC_MspDeInit(hdac);
;;;285    
;;;286      /* Set DAC error code to none */
;;;287      hdac->ErrorCode = HAL_DAC_ERROR_NONE;
;;;288    
;;;289      /* Change DAC state */
;;;290      hdac->State = HAL_DAC_STATE_RESET;
;;;291    
;;;292      /* Release Lock */
;;;293      __HAL_UNLOCK(hdac);
;;;294    
;;;295      /* Return function status */
;;;296      return HAL_OK;
;;;297    }
000008  bd10              POP      {r4,pc}
                  |L8.10|
00000a  2002              MOVS     r0,#2                 ;281
00000c  7120              STRB     r0,[r4,#4]            ;281
00000e  4620              MOV      r0,r4                 ;284
000010  f7fffffe          BL       HAL_DAC_MspDeInit
000014  2000              MOVS     r0,#0                 ;287
000016  6120              STR      r0,[r4,#0x10]         ;287
000018  7120              STRB     r0,[r4,#4]            ;290
00001a  bf00              NOP                            ;293
00001c  7160              STRB     r0,[r4,#5]            ;293
00001e  bf00              NOP                            ;293
000020  bf00              NOP                            ;296
000022  e7f1              B        |L8.8|
;;;298    
                          ENDP


                          AREA ||i.HAL_DAC_ErrorCallbackCh1||, CODE, READONLY, ALIGN=1

                  HAL_DAC_ErrorCallbackCh1 PROC
;;;718      */
;;;719    __weak void HAL_DAC_ErrorCallbackCh1(DAC_HandleTypeDef *hdac)
000000  4770              BX       lr
;;;720    {
;;;721      /* Prevent unused argument(s) compilation warning */
;;;722      UNUSED(hdac);
;;;723      /* NOTE : This function Should not be modified, when the callback is needed,
;;;724                the HAL_DAC_ErrorCallbackCh1 could be implemented in the user file
;;;725       */
;;;726    }
;;;727    
                          ENDP


                          AREA ||i.HAL_DAC_GetError||, CODE, READONLY, ALIGN=1

                  HAL_DAC_GetError PROC
;;;893      */
;;;894    uint32_t HAL_DAC_GetError(DAC_HandleTypeDef *hdac)
000000  4601              MOV      r1,r0
;;;895    {
;;;896      return hdac->ErrorCode;
000002  6908              LDR      r0,[r1,#0x10]
;;;897    }
000004  4770              BX       lr
;;;898    
                          ENDP


                          AREA ||i.HAL_DAC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_DAC_GetState PROC
;;;880      */
;;;881    HAL_DAC_StateTypeDef HAL_DAC_GetState(DAC_HandleTypeDef* hdac)
000000  4601              MOV      r1,r0
;;;882    {
;;;883      /* Return DAC state */
;;;884      return hdac->State;
000002  7908              LDRB     r0,[r1,#4]
;;;885    }
000004  4770              BX       lr
;;;886    
                          ENDP


                          AREA ||i.HAL_DAC_GetValue||, CODE, READONLY, ALIGN=1

                  HAL_DAC_GetValue PROC
;;;620      */
;;;621    uint32_t HAL_DAC_GetValue(DAC_HandleTypeDef* hdac, uint32_t Channel)
000000  4602              MOV      r2,r0
;;;622    {
;;;623      /* Check the parameters */
;;;624      assert_param(IS_DAC_CHANNEL(Channel));
;;;625      
;;;626      /* Returns the DAC channel data output register value */
;;;627      if(Channel == DAC_CHANNEL_1)
000002  b911              CBNZ     r1,|L12.10|
;;;628      {
;;;629        return hdac->Instance->DOR1;
000004  6810              LDR      r0,[r2,#0]
000006  6ac0              LDR      r0,[r0,#0x2c]
                  |L12.8|
;;;630      }
;;;631      else
;;;632      {
;;;633        return hdac->Instance->DOR2;
;;;634      }
;;;635    }
000008  4770              BX       lr
                  |L12.10|
00000a  6810              LDR      r0,[r2,#0]            ;633
00000c  6b00              LDR      r0,[r0,#0x30]         ;633
00000e  e7fb              B        |L12.8|
;;;636    
                          ENDP


                          AREA ||i.HAL_DAC_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_DAC_IRQHandler PROC
;;;642      */
;;;643    void HAL_DAC_IRQHandler(DAC_HandleTypeDef* hdac)
000000  b510              PUSH     {r4,lr}
;;;644    {
000002  4604              MOV      r4,r0
;;;645      /* Check underrun channel 1 flag */
;;;646      if(__HAL_DAC_GET_FLAG(hdac, DAC_FLAG_DMAUDR1))
000004  6820              LDR      r0,[r4,#0]
000006  6b40              LDR      r0,[r0,#0x34]
000008  f4005000          AND      r0,r0,#0x2000
00000c  f5b05f00          CMP      r0,#0x2000
000010  d112              BNE      |L13.56|
;;;647      {
;;;648        /* Change DAC state to error state */
;;;649        hdac->State = HAL_DAC_STATE_ERROR;
000012  2004              MOVS     r0,#4
000014  7120              STRB     r0,[r4,#4]
;;;650        
;;;651        /* Set DAC error code to channel1 DMA underrun error */
;;;652        hdac->ErrorCode |= HAL_DAC_ERROR_DMAUNDERRUNCH1;
000016  6920              LDR      r0,[r4,#0x10]
000018  f0400001          ORR      r0,r0,#1
00001c  6120              STR      r0,[r4,#0x10]
;;;653        
;;;654        /* Clear the underrun flag */
;;;655        __HAL_DAC_CLEAR_FLAG(hdac,DAC_FLAG_DMAUDR1);
00001e  f44f5000          MOV      r0,#0x2000
000022  6821              LDR      r1,[r4,#0]
000024  6348              STR      r0,[r1,#0x34]
;;;656        
;;;657        /* Disable the selected DAC channel1 DMA request */
;;;658        hdac->Instance->CR &= ~DAC_CR_DMAEN1;
000026  6820              LDR      r0,[r4,#0]
000028  6800              LDR      r0,[r0,#0]
00002a  f4205080          BIC      r0,r0,#0x1000
00002e  6821              LDR      r1,[r4,#0]
000030  6008              STR      r0,[r1,#0]
;;;659        
;;;660        /* Error callback */ 
;;;661        HAL_DAC_DMAUnderrunCallbackCh1(hdac);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       HAL_DAC_DMAUnderrunCallbackCh1
                  |L13.56|
;;;662      }
;;;663      /* Check underrun channel 2 flag */
;;;664      if(__HAL_DAC_GET_FLAG(hdac, DAC_FLAG_DMAUDR2))
000038  6820              LDR      r0,[r4,#0]
00003a  6b40              LDR      r0,[r0,#0x34]
00003c  f0005000          AND      r0,r0,#0x20000000
000040  f1b05f00          CMP      r0,#0x20000000
000044  d112              BNE      |L13.108|
;;;665      {
;;;666        /* Change DAC state to error state */
;;;667        hdac->State = HAL_DAC_STATE_ERROR;
000046  2004              MOVS     r0,#4
000048  7120              STRB     r0,[r4,#4]
;;;668        
;;;669        /* Set DAC error code to channel2 DMA underrun error */
;;;670        hdac->ErrorCode |= HAL_DAC_ERROR_DMAUNDERRUNCH2;
00004a  6920              LDR      r0,[r4,#0x10]
00004c  f0400002          ORR      r0,r0,#2
000050  6120              STR      r0,[r4,#0x10]
;;;671        
;;;672        /* Clear the underrun flag */
;;;673        __HAL_DAC_CLEAR_FLAG(hdac,DAC_FLAG_DMAUDR2);
000052  f04f5000          MOV      r0,#0x20000000
000056  6821              LDR      r1,[r4,#0]
000058  6348              STR      r0,[r1,#0x34]
;;;674        
;;;675        /* Disable the selected DAC channel1 DMA request */
;;;676        hdac->Instance->CR &= ~DAC_CR_DMAEN2;
00005a  6820              LDR      r0,[r4,#0]
00005c  6800              LDR      r0,[r0,#0]
00005e  f0205080          BIC      r0,r0,#0x10000000
000062  6821              LDR      r1,[r4,#0]
000064  6008              STR      r0,[r1,#0]
;;;677        
;;;678        /* Error callback */ 
;;;679        HAL_DACEx_DMAUnderrunCallbackCh2(hdac);
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       HAL_DACEx_DMAUnderrunCallbackCh2
                  |L13.108|
;;;680      }
;;;681    }
00006c  bd10              POP      {r4,pc}
;;;682    
                          ENDP


                          AREA ||i.HAL_DAC_Init||, CODE, READONLY, ALIGN=1

                  HAL_DAC_Init PROC
;;;231      */
;;;232    HAL_StatusTypeDef HAL_DAC_Init(DAC_HandleTypeDef* hdac)
000000  b510              PUSH     {r4,lr}
;;;233    { 
000002  4604              MOV      r4,r0
;;;234      /* Check DAC handle */
;;;235      if(hdac == NULL)
000004  b90c              CBNZ     r4,|L14.10|
;;;236      {
;;;237         return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L14.8|
;;;238      }
;;;239      /* Check the parameters */
;;;240      assert_param(IS_DAC_ALL_INSTANCE(hdac->Instance));
;;;241      
;;;242      if(hdac->State == HAL_DAC_STATE_RESET)
;;;243      {  
;;;244        /* Allocate lock resource and initialize it */
;;;245        hdac->Lock = HAL_UNLOCKED;
;;;246        /* Init the low level hardware */
;;;247        HAL_DAC_MspInit(hdac);
;;;248      }
;;;249      
;;;250      /* Initialize the DAC state*/
;;;251      hdac->State = HAL_DAC_STATE_BUSY;
;;;252      
;;;253      /* Set DAC error code to none */
;;;254      hdac->ErrorCode = HAL_DAC_ERROR_NONE;
;;;255      
;;;256      /* Initialize the DAC state*/
;;;257      hdac->State = HAL_DAC_STATE_READY;
;;;258      
;;;259      /* Return function status */
;;;260      return HAL_OK;
;;;261    }
000008  bd10              POP      {r4,pc}
                  |L14.10|
00000a  7920              LDRB     r0,[r4,#4]            ;242
00000c  b920              CBNZ     r0,|L14.24|
00000e  2000              MOVS     r0,#0                 ;245
000010  7160              STRB     r0,[r4,#5]            ;245
000012  4620              MOV      r0,r4                 ;247
000014  f7fffffe          BL       HAL_DAC_MspInit
                  |L14.24|
000018  2002              MOVS     r0,#2                 ;251
00001a  7120              STRB     r0,[r4,#4]            ;251
00001c  2000              MOVS     r0,#0                 ;254
00001e  6120              STR      r0,[r4,#0x10]         ;254
000020  2001              MOVS     r0,#1                 ;257
000022  7120              STRB     r0,[r4,#4]            ;257
000024  2000              MOVS     r0,#0                 ;260
000026  e7ef              B        |L14.8|
;;;262    
                          ENDP


                          AREA ||i.HAL_DAC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_DAC_MspDeInit PROC
;;;319      */
;;;320    __weak void HAL_DAC_MspDeInit(DAC_HandleTypeDef* hdac)
000000  4770              BX       lr
;;;321    {
;;;322      /* Prevent unused argument(s) compilation warning */
;;;323      UNUSED(hdac);
;;;324      /* NOTE : This function Should not be modified, when the callback is needed,
;;;325                the HAL_DAC_MspDeInit could be implemented in the user file
;;;326       */ 
;;;327    }
;;;328    
                          ENDP


                          AREA ||i.HAL_DAC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_DAC_MspInit PROC
;;;304      */
;;;305    __weak void HAL_DAC_MspInit(DAC_HandleTypeDef* hdac)
000000  4770              BX       lr
;;;306    {
;;;307      /* Prevent unused argument(s) compilation warning */
;;;308      UNUSED(hdac);
;;;309      /* NOTE : This function Should not be modified, when the callback is needed,
;;;310                the HAL_DAC_MspInit could be implemented in the user file
;;;311       */ 
;;;312    }
;;;313    
                          ENDP


                          AREA ||i.HAL_DAC_SetValue||, CODE, READONLY, ALIGN=1

                  HAL_DAC_SetValue PROC
;;;828      */
;;;829    HAL_StatusTypeDef HAL_DAC_SetValue(DAC_HandleTypeDef* hdac, uint32_t Channel, uint32_t Alignment, uint32_t Data)
000000  b538              PUSH     {r3-r5,lr}
;;;830    {  
000002  4604              MOV      r4,r0
;;;831      __IO uint32_t tmp = 0;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;832      
;;;833      /* Check the parameters */
;;;834      assert_param(IS_DAC_CHANNEL(Channel));
;;;835      assert_param(IS_DAC_ALIGN(Alignment));
;;;836      assert_param(IS_DAC_DATA(Data));
;;;837      
;;;838      tmp = (uint32_t)hdac->Instance; 
000008  6820              LDR      r0,[r4,#0]
00000a  9000              STR      r0,[sp,#0]
;;;839      if(Channel == DAC_CHANNEL_1)
00000c  b929              CBNZ     r1,|L17.26|
;;;840      {
;;;841        tmp += DAC_DHR12R1_ALIGNMENT(Alignment);
00000e  f1020008          ADD      r0,r2,#8
000012  9d00              LDR      r5,[sp,#0]
000014  4428              ADD      r0,r0,r5
000016  9000              STR      r0,[sp,#0]
000018  e004              B        |L17.36|
                  |L17.26|
;;;842      }
;;;843      else
;;;844      {
;;;845        tmp += DAC_DHR12R2_ALIGNMENT(Alignment);
00001a  f1020014          ADD      r0,r2,#0x14
00001e  9d00              LDR      r5,[sp,#0]
000020  4428              ADD      r0,r0,r5
000022  9000              STR      r0,[sp,#0]
                  |L17.36|
;;;846      }
;;;847    
;;;848      /* Set the DAC channel1 selected data holding register */
;;;849      *(__IO uint32_t *) tmp = Data;
000024  9800              LDR      r0,[sp,#0]
000026  6003              STR      r3,[r0,#0]
;;;850      
;;;851      /* Return function status */
;;;852      return HAL_OK;
000028  2000              MOVS     r0,#0
;;;853    }
00002a  bd38              POP      {r3-r5,pc}
;;;854    
                          ENDP


                          AREA ||i.HAL_DAC_Start||, CODE, READONLY, ALIGN=1

                  HAL_DAC_Start PROC
;;;360      */
;;;361    HAL_StatusTypeDef HAL_DAC_Start(DAC_HandleTypeDef* hdac, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;362    {
000002  4602              MOV      r2,r0
;;;363      uint32_t tmp1 = 0, tmp2 = 0;
000004  2300              MOVS     r3,#0
000006  2400              MOVS     r4,#0
;;;364      
;;;365      /* Check the parameters */
;;;366      assert_param(IS_DAC_CHANNEL(Channel));
;;;367      
;;;368      /* Process locked */
;;;369      __HAL_LOCK(hdac);
000008  bf00              NOP      
00000a  7950              LDRB     r0,[r2,#5]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L18.20|
000010  2002              MOVS     r0,#2
                  |L18.18|
;;;370      
;;;371      /* Change DAC state */
;;;372      hdac->State = HAL_DAC_STATE_BUSY;
;;;373      
;;;374      /* Enable the Peripheral */
;;;375      __HAL_DAC_ENABLE(hdac, Channel);
;;;376      
;;;377      if(Channel == DAC_CHANNEL_1)
;;;378      {
;;;379        tmp1 = hdac->Instance->CR & DAC_CR_TEN1;
;;;380        tmp2 = hdac->Instance->CR & DAC_CR_TSEL1;
;;;381        /* Check if software trigger enabled */
;;;382        if((tmp1 ==  DAC_CR_TEN1) && (tmp2 ==  DAC_CR_TSEL1))
;;;383        {
;;;384          /* Enable the selected DAC software conversion */
;;;385          hdac->Instance->SWTRIGR |= (uint32_t)DAC_SWTRIGR_SWTRIG1;
;;;386        }
;;;387      }
;;;388      else
;;;389      {
;;;390        tmp1 = hdac->Instance->CR & DAC_CR_TEN2;
;;;391        tmp2 = hdac->Instance->CR & DAC_CR_TSEL2;    
;;;392        /* Check if software trigger enabled */
;;;393        if((tmp1 == DAC_CR_TEN2) && (tmp2 == DAC_CR_TSEL2))
;;;394        {
;;;395          /* Enable the selected DAC software conversion*/
;;;396          hdac->Instance->SWTRIGR |= (uint32_t)DAC_SWTRIGR_SWTRIG2;
;;;397        }
;;;398      }
;;;399      
;;;400      /* Change DAC state */
;;;401      hdac->State = HAL_DAC_STATE_READY;
;;;402      
;;;403      /* Process unlocked */
;;;404      __HAL_UNLOCK(hdac);
;;;405        
;;;406      /* Return function status */
;;;407      return HAL_OK;
;;;408    }
000012  bd30              POP      {r4,r5,pc}
                  |L18.20|
000014  2001              MOVS     r0,#1                 ;369
000016  7150              STRB     r0,[r2,#5]            ;369
000018  bf00              NOP                            ;369
00001a  2002              MOVS     r0,#2                 ;372
00001c  7110              STRB     r0,[r2,#4]            ;372
00001e  6810              LDR      r0,[r2,#0]            ;375
000020  6800              LDR      r0,[r0,#0]            ;375
000022  2501              MOVS     r5,#1                 ;375
000024  408d              LSLS     r5,r5,r1              ;375
000026  4328              ORRS     r0,r0,r5              ;375
000028  6815              LDR      r5,[r2,#0]            ;375
00002a  6028              STR      r0,[r5,#0]            ;375
00002c  b991              CBNZ     r1,|L18.84|
00002e  6810              LDR      r0,[r2,#0]            ;379
000030  6800              LDR      r0,[r0,#0]            ;379
000032  f0000304          AND      r3,r0,#4              ;379
000036  6810              LDR      r0,[r2,#0]            ;380
000038  6800              LDR      r0,[r0,#0]            ;380
00003a  f0000438          AND      r4,r0,#0x38           ;380
00003e  2b04              CMP      r3,#4                 ;382
000040  d11c              BNE      |L18.124|
000042  2c38              CMP      r4,#0x38              ;382
000044  d11a              BNE      |L18.124|
000046  6810              LDR      r0,[r2,#0]            ;385
000048  6840              LDR      r0,[r0,#4]            ;385
00004a  f0400001          ORR      r0,r0,#1              ;385
00004e  6815              LDR      r5,[r2,#0]            ;385
000050  6068              STR      r0,[r5,#4]            ;385
000052  e013              B        |L18.124|
                  |L18.84|
000054  6810              LDR      r0,[r2,#0]            ;390
000056  6800              LDR      r0,[r0,#0]            ;390
000058  f4002380          AND      r3,r0,#0x40000        ;390
00005c  6810              LDR      r0,[r2,#0]            ;391
00005e  6800              LDR      r0,[r0,#0]            ;391
000060  f4001460          AND      r4,r0,#0x380000       ;391
000064  f5b32f80          CMP      r3,#0x40000           ;393
000068  d108              BNE      |L18.124|
00006a  f5b41f60          CMP      r4,#0x380000          ;393
00006e  d105              BNE      |L18.124|
000070  6810              LDR      r0,[r2,#0]            ;396
000072  6840              LDR      r0,[r0,#4]            ;396
000074  f0400002          ORR      r0,r0,#2              ;396
000078  6815              LDR      r5,[r2,#0]            ;396
00007a  6068              STR      r0,[r5,#4]            ;396
                  |L18.124|
00007c  2001              MOVS     r0,#1                 ;401
00007e  7110              STRB     r0,[r2,#4]            ;401
000080  bf00              NOP                            ;404
000082  2000              MOVS     r0,#0                 ;404
000084  7150              STRB     r0,[r2,#5]            ;404
000086  bf00              NOP                            ;404
000088  bf00              NOP                            ;407
00008a  e7c2              B        |L18.18|
;;;409    
                          ENDP


                          AREA ||i.HAL_DAC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_DAC_Start_DMA PROC
;;;451      */
;;;452    HAL_StatusTypeDef HAL_DAC_Start_DMA(DAC_HandleTypeDef* hdac, uint32_t Channel, uint32_t* pData, uint32_t Length, uint32_t Alignment)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;453    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  4698              MOV      r8,r3
00000c  9f08              LDR      r7,[sp,#0x20]
;;;454      uint32_t tmpreg = 0;
00000e  f04f0900          MOV      r9,#0
;;;455        
;;;456      /* Check the parameters */
;;;457      assert_param(IS_DAC_CHANNEL(Channel));
;;;458      assert_param(IS_DAC_ALIGN(Alignment));
;;;459      
;;;460      /* Process locked */
;;;461      __HAL_LOCK(hdac);
000012  bf00              NOP      
000014  7960              LDRB     r0,[r4,#5]
000016  2801              CMP      r0,#1
000018  d102              BNE      |L19.32|
00001a  2002              MOVS     r0,#2
                  |L19.28|
;;;462      
;;;463      /* Change DAC state */
;;;464      hdac->State = HAL_DAC_STATE_BUSY;
;;;465    
;;;466      if(Channel == DAC_CHANNEL_1)
;;;467      {
;;;468        /* Set the DMA transfer complete callback for channel1 */
;;;469        hdac->DMA_Handle1->XferCpltCallback = DAC_DMAConvCpltCh1;
;;;470    
;;;471        /* Set the DMA half transfer complete callback for channel1 */
;;;472        hdac->DMA_Handle1->XferHalfCpltCallback = DAC_DMAHalfConvCpltCh1;
;;;473    
;;;474        /* Set the DMA error callback for channel1 */
;;;475        hdac->DMA_Handle1->XferErrorCallback = DAC_DMAErrorCh1;
;;;476    
;;;477        /* Enable the selected DAC channel1 DMA request */
;;;478        hdac->Instance->CR |= DAC_CR_DMAEN1;
;;;479        
;;;480        /* Case of use of channel 1 */
;;;481        switch(Alignment)
;;;482        {
;;;483          case DAC_ALIGN_12B_R:
;;;484            /* Get DHR12R1 address */
;;;485            tmpreg = (uint32_t)&hdac->Instance->DHR12R1;
;;;486            break;
;;;487          case DAC_ALIGN_12B_L:
;;;488            /* Get DHR12L1 address */
;;;489            tmpreg = (uint32_t)&hdac->Instance->DHR12L1;
;;;490            break;
;;;491          case DAC_ALIGN_8B_R:
;;;492            /* Get DHR8R1 address */
;;;493            tmpreg = (uint32_t)&hdac->Instance->DHR8R1;
;;;494            break;
;;;495          default:
;;;496            break;
;;;497        }
;;;498      }
;;;499      else
;;;500      {
;;;501        /* Set the DMA transfer complete callback for channel2 */
;;;502        hdac->DMA_Handle2->XferCpltCallback = DAC_DMAConvCpltCh2;
;;;503    
;;;504        /* Set the DMA half transfer complete callback for channel2 */
;;;505        hdac->DMA_Handle2->XferHalfCpltCallback = DAC_DMAHalfConvCpltCh2;
;;;506    
;;;507        /* Set the DMA error callback for channel2 */
;;;508        hdac->DMA_Handle2->XferErrorCallback = DAC_DMAErrorCh2;
;;;509    
;;;510        /* Enable the selected DAC channel2 DMA request */
;;;511        hdac->Instance->CR |= DAC_CR_DMAEN2;
;;;512    
;;;513        /* Case of use of channel 2 */
;;;514        switch(Alignment)
;;;515        {
;;;516          case DAC_ALIGN_12B_R:
;;;517            /* Get DHR12R2 address */
;;;518            tmpreg = (uint32_t)&hdac->Instance->DHR12R2;
;;;519            break;
;;;520          case DAC_ALIGN_12B_L:
;;;521            /* Get DHR12L2 address */
;;;522            tmpreg = (uint32_t)&hdac->Instance->DHR12L2;
;;;523            break;
;;;524          case DAC_ALIGN_8B_R:
;;;525            /* Get DHR8R2 address */
;;;526            tmpreg = (uint32_t)&hdac->Instance->DHR8R2;
;;;527            break;
;;;528          default:
;;;529            break;
;;;530        }
;;;531      }
;;;532      
;;;533      /* Enable the DMA Stream */
;;;534      if(Channel == DAC_CHANNEL_1)
;;;535      {
;;;536        /* Enable the DAC DMA underrun interrupt */
;;;537        __HAL_DAC_ENABLE_IT(hdac, DAC_IT_DMAUDR1);
;;;538        
;;;539        /* Enable the DMA Stream */
;;;540        HAL_DMA_Start_IT(hdac->DMA_Handle1, (uint32_t)pData, tmpreg, Length);
;;;541      } 
;;;542      else
;;;543      {
;;;544        /* Enable the DAC DMA underrun interrupt */
;;;545        __HAL_DAC_ENABLE_IT(hdac, DAC_IT_DMAUDR2);
;;;546        
;;;547        /* Enable the DMA Stream */
;;;548        HAL_DMA_Start_IT(hdac->DMA_Handle2, (uint32_t)pData, tmpreg, Length);
;;;549      }
;;;550      
;;;551      /* Enable the Peripheral */
;;;552      __HAL_DAC_ENABLE(hdac, Channel);
;;;553      
;;;554      /* Process Unlocked */
;;;555      __HAL_UNLOCK(hdac);
;;;556      
;;;557      /* Return function status */
;;;558      return HAL_OK;
;;;559    }
00001c  e8bd87f0          POP      {r4-r10,pc}
                  |L19.32|
000020  2001              MOVS     r0,#1                 ;461
000022  7160              STRB     r0,[r4,#5]            ;461
000024  bf00              NOP                            ;461
000026  2002              MOVS     r0,#2                 ;464
000028  7120              STRB     r0,[r4,#4]            ;464
00002a  bb15              CBNZ     r5,|L19.114|
00002c  4836              LDR      r0,|L19.264|
00002e  68a1              LDR      r1,[r4,#8]            ;469
000030  63c8              STR      r0,[r1,#0x3c]         ;469
000032  4836              LDR      r0,|L19.268|
000034  68a1              LDR      r1,[r4,#8]            ;472
000036  6408              STR      r0,[r1,#0x40]         ;472
000038  4835              LDR      r0,|L19.272|
00003a  68a1              LDR      r1,[r4,#8]            ;475
00003c  6488              STR      r0,[r1,#0x48]         ;475
00003e  6820              LDR      r0,[r4,#0]            ;478
000040  6800              LDR      r0,[r0,#0]            ;478
000042  f4405080          ORR      r0,r0,#0x1000         ;478
000046  6821              LDR      r1,[r4,#0]            ;478
000048  6008              STR      r0,[r1,#0]            ;478
00004a  b127              CBZ      r7,|L19.86|
00004c  2f04              CMP      r7,#4                 ;481
00004e  d006              BEQ      |L19.94|
000050  2f08              CMP      r7,#8                 ;481
000052  d10c              BNE      |L19.110|
000054  e007              B        |L19.102|
                  |L19.86|
000056  6820              LDR      r0,[r4,#0]            ;485
000058  f1000908          ADD      r9,r0,#8              ;485
00005c  e008              B        |L19.112|
                  |L19.94|
00005e  6820              LDR      r0,[r4,#0]            ;489
000060  f100090c          ADD      r9,r0,#0xc            ;489
000064  e004              B        |L19.112|
                  |L19.102|
000066  6820              LDR      r0,[r4,#0]            ;493
000068  f1000910          ADD      r9,r0,#0x10           ;493
00006c  e000              B        |L19.112|
                  |L19.110|
00006e  bf00              NOP                            ;496
                  |L19.112|
000070  e022              B        |L19.184|
                  |L19.114|
000072  4828              LDR      r0,|L19.276|
000074  68e1              LDR      r1,[r4,#0xc]          ;502
000076  63c8              STR      r0,[r1,#0x3c]         ;502
000078  4827              LDR      r0,|L19.280|
00007a  68e1              LDR      r1,[r4,#0xc]          ;505
00007c  6408              STR      r0,[r1,#0x40]         ;505
00007e  4827              LDR      r0,|L19.284|
000080  68e1              LDR      r1,[r4,#0xc]          ;508
000082  6488              STR      r0,[r1,#0x48]         ;508
000084  6820              LDR      r0,[r4,#0]            ;511
000086  6800              LDR      r0,[r0,#0]            ;511
000088  f0405080          ORR      r0,r0,#0x10000000     ;511
00008c  6821              LDR      r1,[r4,#0]            ;511
00008e  6008              STR      r0,[r1,#0]            ;511
000090  b127              CBZ      r7,|L19.156|
000092  2f04              CMP      r7,#4                 ;514
000094  d006              BEQ      |L19.164|
000096  2f08              CMP      r7,#8                 ;514
000098  d10c              BNE      |L19.180|
00009a  e007              B        |L19.172|
                  |L19.156|
00009c  6820              LDR      r0,[r4,#0]            ;518
00009e  f1000914          ADD      r9,r0,#0x14           ;518
0000a2  e008              B        |L19.182|
                  |L19.164|
0000a4  6820              LDR      r0,[r4,#0]            ;522
0000a6  f1000918          ADD      r9,r0,#0x18           ;522
0000aa  e004              B        |L19.182|
                  |L19.172|
0000ac  6820              LDR      r0,[r4,#0]            ;526
0000ae  f100091c          ADD      r9,r0,#0x1c           ;526
0000b2  e000              B        |L19.182|
                  |L19.180|
0000b4  bf00              NOP                            ;529
                  |L19.182|
0000b6  bf00              NOP                            ;519
                  |L19.184|
0000b8  b965              CBNZ     r5,|L19.212|
0000ba  6820              LDR      r0,[r4,#0]            ;537
0000bc  6800              LDR      r0,[r0,#0]            ;537
0000be  f4405000          ORR      r0,r0,#0x2000         ;537
0000c2  6821              LDR      r1,[r4,#0]            ;537
0000c4  6008              STR      r0,[r1,#0]            ;537
0000c6  4643              MOV      r3,r8                 ;540
0000c8  464a              MOV      r2,r9                 ;540
0000ca  4631              MOV      r1,r6                 ;540
0000cc  68a0              LDR      r0,[r4,#8]            ;540
0000ce  f7fffffe          BL       HAL_DMA_Start_IT
0000d2  e00b              B        |L19.236|
                  |L19.212|
0000d4  6820              LDR      r0,[r4,#0]            ;545
0000d6  6800              LDR      r0,[r0,#0]            ;545
0000d8  f0405000          ORR      r0,r0,#0x20000000     ;545
0000dc  6821              LDR      r1,[r4,#0]            ;545
0000de  6008              STR      r0,[r1,#0]            ;545
0000e0  4643              MOV      r3,r8                 ;548
0000e2  464a              MOV      r2,r9                 ;548
0000e4  4631              MOV      r1,r6                 ;548
0000e6  68e0              LDR      r0,[r4,#0xc]          ;548
0000e8  f7fffffe          BL       HAL_DMA_Start_IT
                  |L19.236|
0000ec  6820              LDR      r0,[r4,#0]            ;552
0000ee  6800              LDR      r0,[r0,#0]            ;552
0000f0  2101              MOVS     r1,#1                 ;552
0000f2  40a9              LSLS     r1,r1,r5              ;552
0000f4  4308              ORRS     r0,r0,r1              ;552
0000f6  6821              LDR      r1,[r4,#0]            ;552
0000f8  6008              STR      r0,[r1,#0]            ;552
0000fa  bf00              NOP                            ;555
0000fc  2000              MOVS     r0,#0                 ;555
0000fe  7160              STRB     r0,[r4,#5]            ;555
000100  bf00              NOP                            ;555
000102  bf00              NOP                            ;558
000104  e78a              B        |L19.28|
;;;560    
                          ENDP

000106  0000              DCW      0x0000
                  |L19.264|
                          DCD      DAC_DMAConvCpltCh1
                  |L19.268|
                          DCD      DAC_DMAHalfConvCpltCh1
                  |L19.272|
                          DCD      DAC_DMAErrorCh1
                  |L19.276|
                          DCD      DAC_DMAConvCpltCh2
                  |L19.280|
                          DCD      DAC_DMAHalfConvCpltCh2
                  |L19.284|
                          DCD      DAC_DMAErrorCh2

                          AREA ||i.HAL_DAC_Stop||, CODE, READONLY, ALIGN=1

                  HAL_DAC_Stop PROC
;;;419      */
;;;420    HAL_StatusTypeDef HAL_DAC_Stop(DAC_HandleTypeDef* hdac, uint32_t Channel)
000000  4602              MOV      r2,r0
;;;421    {
;;;422      /* Check the parameters */
;;;423      assert_param(IS_DAC_CHANNEL(Channel));
;;;424      
;;;425      /* Disable the Peripheral */
;;;426      __HAL_DAC_DISABLE(hdac, Channel);
000002  6810              LDR      r0,[r2,#0]
000004  6800              LDR      r0,[r0,#0]
000006  2301              MOVS     r3,#1
000008  408b              LSLS     r3,r3,r1
00000a  4398              BICS     r0,r0,r3
00000c  6813              LDR      r3,[r2,#0]
00000e  6018              STR      r0,[r3,#0]
;;;427     
;;;428      /* Change DAC state */
;;;429      hdac->State = HAL_DAC_STATE_READY;
000010  2001              MOVS     r0,#1
000012  7110              STRB     r0,[r2,#4]
;;;430      
;;;431      /* Return function status */
;;;432      return HAL_OK;
000014  2000              MOVS     r0,#0
;;;433    }
000016  4770              BX       lr
;;;434    
                          ENDP


                          AREA ||i.HAL_DAC_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_DAC_Stop_DMA PROC
;;;570      */
;;;571    HAL_StatusTypeDef HAL_DAC_Stop_DMA(DAC_HandleTypeDef* hdac, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;572    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;573      HAL_StatusTypeDef status = HAL_OK;
000006  2600              MOVS     r6,#0
;;;574    
;;;575      /* Check the parameters */
;;;576      assert_param(IS_DAC_CHANNEL(Channel));
;;;577      
;;;578      /* Disable the selected DAC channel DMA request */
;;;579       hdac->Instance->CR &= ~(DAC_CR_DMAEN1 << Channel);
000008  6820              LDR      r0,[r4,#0]
00000a  6800              LDR      r0,[r0,#0]
00000c  f44f5180          MOV      r1,#0x1000
000010  40a9              LSLS     r1,r1,r5
000012  4388              BICS     r0,r0,r1
000014  6821              LDR      r1,[r4,#0]
000016  6008              STR      r0,[r1,#0]
;;;580        
;;;581      /* Disable the Peripheral */
;;;582      __HAL_DAC_DISABLE(hdac, Channel);
000018  6820              LDR      r0,[r4,#0]
00001a  6801              LDR      r1,[r0,#0]
00001c  2001              MOVS     r0,#1
00001e  40a8              LSLS     r0,r0,r5
000020  4381              BICS     r1,r1,r0
000022  6820              LDR      r0,[r4,#0]
000024  6001              STR      r1,[r0,#0]
;;;583      
;;;584      /* Disable the DMA Channel */
;;;585      /* Channel1 is used */
;;;586      if(Channel == DAC_CHANNEL_1)
000026  b925              CBNZ     r5,|L21.50|
;;;587      { 
;;;588        status = HAL_DMA_Abort(hdac->DMA_Handle1);
000028  68a0              LDR      r0,[r4,#8]
00002a  f7fffffe          BL       HAL_DMA_Abort
00002e  4606              MOV      r6,r0
000030  e003              B        |L21.58|
                  |L21.50|
;;;589      }
;;;590      else /* Channel2 is used for */
;;;591      { 
;;;592        status = HAL_DMA_Abort(hdac->DMA_Handle2); 
000032  68e0              LDR      r0,[r4,#0xc]
000034  f7fffffe          BL       HAL_DMA_Abort
000038  4606              MOV      r6,r0
                  |L21.58|
;;;593      }
;;;594    
;;;595      /* Check if DMA Channel effectively disabled */
;;;596      if(status != HAL_OK)
00003a  b116              CBZ      r6,|L21.66|
;;;597      {
;;;598        /* Update DAC state machine to error */
;;;599        hdac->State = HAL_DAC_STATE_ERROR;      
00003c  2004              MOVS     r0,#4
00003e  7120              STRB     r0,[r4,#4]
000040  e001              B        |L21.70|
                  |L21.66|
;;;600      }
;;;601      else
;;;602      {
;;;603        /* Change DAC state */
;;;604        hdac->State = HAL_DAC_STATE_READY;
000042  2001              MOVS     r0,#1
000044  7120              STRB     r0,[r4,#4]
                  |L21.70|
;;;605      }
;;;606    
;;;607      /* Return function status */
;;;608      return status;
000046  4630              MOV      r0,r6
;;;609    }
000048  bd70              POP      {r4-r6,pc}
;;;610    
                          ENDP


;*** Start embedded assembler ***

#line 1 "HALLIB\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_dac.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_dac_c_4837ae93____REV16|
#line 388 ".\\CORE\\cmsis_armcc.h"
|__asm___19_stm32f4xx_hal_dac_c_4837ae93____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_dac_c_4837ae93____REVSH|
#line 402
|__asm___19_stm32f4xx_hal_dac_c_4837ae93____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_dac_c_4837ae93____RRX|
#line 587
|__asm___19_stm32f4xx_hal_dac_c_4837ae93____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
