; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\stm32f4xx_hal_flash_ex.o --asm_dir=.\OBJ\ --list_dir=.\OBJ\ --depend=.\obj\stm32f4xx_hal_flash_ex.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I.\CORE -I.\USER -I.\HALLIB\STM32F4xx_HAL_Driver\Inc -I.\SYSTEM -I.\Hardware -I.\App -I.\DSP_LIB\Include -I.\FreeRTOS -I.\MPU9250\DMP -I.\MPU9250 -I.\RTE\_Project -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=526 -DSTM32F427xx -DSTM32F4 -DUSE_HAL_DRIVER -DSTM32F427xx -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=.\obj\stm32f4xx_hal_flash_ex.crf HALLIB\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_flash_ex.c]
                          THUMB

                          AREA ||i.FLASH_Erase_Sector||, CODE, READONLY, ALIGN=2

                  FLASH_Erase_Sector PROC
;;;595      */
;;;596    void FLASH_Erase_Sector(uint32_t Sector, uint8_t VoltageRange)
000000  b510              PUSH     {r4,lr}
;;;597    {
;;;598      uint32_t tmp_psize = 0;
000002  2200              MOVS     r2,#0
;;;599    
;;;600      /* Check the parameters */
;;;601      assert_param(IS_FLASH_SECTOR(Sector));
;;;602      assert_param(IS_VOLTAGERANGE(VoltageRange));
;;;603      
;;;604      if(VoltageRange == FLASH_VOLTAGE_RANGE_1)
000004  b901              CBNZ     r1,|L1.8|
;;;605      {
;;;606         tmp_psize = FLASH_PSIZE_BYTE;
000006  e009              B        |L1.28|
                  |L1.8|
;;;607      }
;;;608      else if(VoltageRange == FLASH_VOLTAGE_RANGE_2)
000008  2901              CMP      r1,#1
00000a  d101              BNE      |L1.16|
;;;609      {
;;;610        tmp_psize = FLASH_PSIZE_HALF_WORD;
00000c  020a              LSLS     r2,r1,#8
00000e  e005              B        |L1.28|
                  |L1.16|
;;;611      }
;;;612      else if(VoltageRange == FLASH_VOLTAGE_RANGE_3)
000010  2902              CMP      r1,#2
000012  d101              BNE      |L1.24|
;;;613      {
;;;614        tmp_psize = FLASH_PSIZE_WORD;
000014  020a              LSLS     r2,r1,#8
000016  e001              B        |L1.28|
                  |L1.24|
;;;615      }
;;;616      else
;;;617      {
;;;618        tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
000018  f44f7240          MOV      r2,#0x300
                  |L1.28|
;;;619      }
;;;620    
;;;621      /* Need to add offset of 4 when sector higher than FLASH_SECTOR_11 */
;;;622      if(Sector > FLASH_SECTOR_11) 
00001c  280b              CMP      r0,#0xb
00001e  d900              BLS      |L1.34|
;;;623      {
;;;624        Sector += 4;
000020  1d00              ADDS     r0,r0,#4
                  |L1.34|
;;;625      }
;;;626      /* If the previous operation is completed, proceed to erase the sector */
;;;627      CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
000022  4b11              LDR      r3,|L1.104|
000024  681b              LDR      r3,[r3,#0]
000026  f4237340          BIC      r3,r3,#0x300
00002a  4c0f              LDR      r4,|L1.104|
00002c  6023              STR      r3,[r4,#0]
;;;628      FLASH->CR |= tmp_psize;
00002e  4623              MOV      r3,r4
000030  681b              LDR      r3,[r3,#0]
000032  4313              ORRS     r3,r3,r2
000034  6023              STR      r3,[r4,#0]
;;;629      CLEAR_BIT(FLASH->CR, FLASH_CR_SNB);
000036  4623              MOV      r3,r4
000038  681b              LDR      r3,[r3,#0]
00003a  f02303f8          BIC      r3,r3,#0xf8
00003e  6023              STR      r3,[r4,#0]
;;;630      FLASH->CR |= FLASH_CR_SER | (Sector << POSITION_VAL(FLASH_CR_SNB));
000040  4623              MOV      r3,r4
000042  681b              LDR      r3,[r3,#0]
000044  24f8              MOVS     r4,#0xf8
000046  fa94f4a4          RBIT     r4,r4
00004a  fab4f484          CLZ      r4,r4
00004e  fa00f404          LSL      r4,r0,r4
000052  f0440402          ORR      r4,r4,#2
000056  4323              ORRS     r3,r3,r4
000058  4c03              LDR      r4,|L1.104|
00005a  6023              STR      r3,[r4,#0]
;;;631      FLASH->CR |= FLASH_CR_STRT;
00005c  4623              MOV      r3,r4
00005e  681b              LDR      r3,[r3,#0]
000060  f4433380          ORR      r3,r3,#0x10000
000064  6023              STR      r3,[r4,#0]
;;;632    }
000066  bd10              POP      {r4,pc}
;;;633    
                          ENDP

                  |L1.104|
                          DCD      0x40023c10

                          AREA ||i.FLASH_FlushCaches||, CODE, READONLY, ALIGN=2

                  FLASH_FlushCaches PROC
;;;1318     */
;;;1319   void FLASH_FlushCaches(void)
000000  481c              LDR      r0,|L2.116|
;;;1320   {
;;;1321     /* Flush instruction cache  */
;;;1322     if(READ_BIT(FLASH->ACR, FLASH_ACR_ICEN)!= RESET)
000002  6800              LDR      r0,[r0,#0]
000004  f4007000          AND      r0,r0,#0x200
000008  b1b0              CBZ      r0,|L2.56|
;;;1323     {
;;;1324       /* Disable instruction cache  */
;;;1325       __HAL_FLASH_INSTRUCTION_CACHE_DISABLE();
00000a  481a              LDR      r0,|L2.116|
00000c  6800              LDR      r0,[r0,#0]
00000e  f4207000          BIC      r0,r0,#0x200
000012  4918              LDR      r1,|L2.116|
000014  6008              STR      r0,[r1,#0]
;;;1326       /* Reset instruction cache */
;;;1327       __HAL_FLASH_INSTRUCTION_CACHE_RESET();
000016  bf00              NOP      
000018  4608              MOV      r0,r1
00001a  6800              LDR      r0,[r0,#0]
00001c  f4406000          ORR      r0,r0,#0x800
000020  6008              STR      r0,[r1,#0]
000022  4608              MOV      r0,r1
000024  6800              LDR      r0,[r0,#0]
000026  f4206000          BIC      r0,r0,#0x800
00002a  6008              STR      r0,[r1,#0]
00002c  bf00              NOP      
;;;1328       /* Enable instruction cache */
;;;1329       __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
00002e  4608              MOV      r0,r1
000030  6800              LDR      r0,[r0,#0]
000032  f4407000          ORR      r0,r0,#0x200
000036  6008              STR      r0,[r1,#0]
                  |L2.56|
;;;1330     }
;;;1331     
;;;1332     /* Flush data cache */
;;;1333     if(READ_BIT(FLASH->ACR, FLASH_ACR_DCEN) != RESET)
000038  480e              LDR      r0,|L2.116|
00003a  6800              LDR      r0,[r0,#0]
00003c  f4006080          AND      r0,r0,#0x400
000040  b1b0              CBZ      r0,|L2.112|
;;;1334     {
;;;1335       /* Disable data cache  */
;;;1336       __HAL_FLASH_DATA_CACHE_DISABLE();
000042  480c              LDR      r0,|L2.116|
000044  6800              LDR      r0,[r0,#0]
000046  f4206080          BIC      r0,r0,#0x400
00004a  490a              LDR      r1,|L2.116|
00004c  6008              STR      r0,[r1,#0]
;;;1337       /* Reset data cache */
;;;1338       __HAL_FLASH_DATA_CACHE_RESET();
00004e  bf00              NOP      
000050  4608              MOV      r0,r1
000052  6800              LDR      r0,[r0,#0]
000054  f4405080          ORR      r0,r0,#0x1000
000058  6008              STR      r0,[r1,#0]
00005a  4608              MOV      r0,r1
00005c  6800              LDR      r0,[r0,#0]
00005e  f4205080          BIC      r0,r0,#0x1000
000062  6008              STR      r0,[r1,#0]
000064  bf00              NOP      
;;;1339       /* Enable data cache */
;;;1340       __HAL_FLASH_DATA_CACHE_ENABLE();
000066  4608              MOV      r0,r1
000068  6800              LDR      r0,[r0,#0]
00006a  f4406080          ORR      r0,r0,#0x400
00006e  6008              STR      r0,[r1,#0]
                  |L2.112|
;;;1341     }
;;;1342   }
000070  4770              BX       lr
;;;1343   
                          ENDP

000072  0000              DCW      0x0000
                  |L2.116|
                          DCD      0x40023c00

                          AREA ||i.FLASH_MassErase||, CODE, READONLY, ALIGN=2

                  FLASH_MassErase PROC
;;;549      */
;;;550    static void FLASH_MassErase(uint8_t VoltageRange, uint32_t Banks)
000000  b510              PUSH     {r4,lr}
;;;551    {
000002  4602              MOV      r2,r0
;;;552      uint32_t tmp_psize = 0;
000004  2000              MOVS     r0,#0
;;;553      
;;;554      /* Check the parameters */
;;;555      assert_param(IS_VOLTAGERANGE(VoltageRange));
;;;556      assert_param(IS_FLASH_BANK(Banks));
;;;557    
;;;558      /* if the previous operation is completed, proceed to erase all sectors */
;;;559      CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
000006  4b14              LDR      r3,|L3.88|
000008  681b              LDR      r3,[r3,#0]
00000a  f4237340          BIC      r3,r3,#0x300
00000e  4c12              LDR      r4,|L3.88|
000010  6023              STR      r3,[r4,#0]
;;;560      FLASH->CR |= tmp_psize;
000012  4623              MOV      r3,r4
000014  681b              LDR      r3,[r3,#0]
000016  4303              ORRS     r3,r3,r0
000018  6023              STR      r3,[r4,#0]
;;;561      if(Banks == FLASH_BANK_BOTH)
00001a  2903              CMP      r1,#3
00001c  d106              BNE      |L3.44|
;;;562      {
;;;563        /* bank1 & bank2 will be erased*/
;;;564        FLASH->CR |= FLASH_MER_BIT;
00001e  4623              MOV      r3,r4
000020  681b              LDR      r3,[r3,#0]
000022  13e4              ASRS     r4,r4,#15
000024  4323              ORRS     r3,r3,r4
000026  4c0c              LDR      r4,|L3.88|
000028  6023              STR      r3,[r4,#0]
00002a  e00e              B        |L3.74|
                  |L3.44|
;;;565      }
;;;566      else if(Banks == FLASH_BANK_1)
00002c  2901              CMP      r1,#1
00002e  d106              BNE      |L3.62|
;;;567      {
;;;568        /*Only bank1 will be erased*/
;;;569        FLASH->CR |= FLASH_CR_MER1;
000030  4b09              LDR      r3,|L3.88|
000032  681b              LDR      r3,[r3,#0]
000034  f0430304          ORR      r3,r3,#4
000038  4c07              LDR      r4,|L3.88|
00003a  6023              STR      r3,[r4,#0]
00003c  e005              B        |L3.74|
                  |L3.62|
;;;570      }
;;;571      else
;;;572      {
;;;573        /*Only bank2 will be erased*/
;;;574        FLASH->CR |= FLASH_CR_MER2;
00003e  4b06              LDR      r3,|L3.88|
000040  681b              LDR      r3,[r3,#0]
000042  f4434300          ORR      r3,r3,#0x8000
000046  4c04              LDR      r4,|L3.88|
000048  6023              STR      r3,[r4,#0]
                  |L3.74|
;;;575      }
;;;576      FLASH->CR |= FLASH_CR_STRT;
00004a  4b03              LDR      r3,|L3.88|
00004c  681b              LDR      r3,[r3,#0]
00004e  f4433380          ORR      r3,r3,#0x10000
000052  4c01              LDR      r4,|L3.88|
000054  6023              STR      r3,[r4,#0]
;;;577    }
000056  bd10              POP      {r4,pc}
;;;578    
                          ENDP

                  |L3.88|
                          DCD      0x40023c10

                          AREA ||i.FLASH_OB_BOR_LevelConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_BOR_LevelConfig PROC
;;;1238     */
;;;1239   static HAL_StatusTypeDef FLASH_OB_BOR_LevelConfig(uint8_t Level)
000000  4601              MOV      r1,r0
;;;1240   {
;;;1241     /* Check the parameters */
;;;1242     assert_param(IS_OB_BOR_LEVEL(Level));
;;;1243   
;;;1244     /* Set the BOR Level */
;;;1245     *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS &= (~FLASH_OPTCR_BOR_LEV);
000002  4806              LDR      r0,|L4.28|
000004  7800              LDRB     r0,[r0,#0]
000006  f020000c          BIC      r0,r0,#0xc
00000a  4a04              LDR      r2,|L4.28|
00000c  7010              STRB     r0,[r2,#0]
;;;1246     *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= Level;
00000e  4610              MOV      r0,r2
000010  7800              LDRB     r0,[r0,#0]
000012  4308              ORRS     r0,r0,r1
000014  7010              STRB     r0,[r2,#0]
;;;1247     
;;;1248     return HAL_OK;
000016  2000              MOVS     r0,#0
;;;1249     
;;;1250   }
000018  4770              BX       lr
;;;1251   
                          ENDP

00001a  0000              DCW      0x0000
                  |L4.28|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_BootConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_BootConfig PROC
;;;787      */
;;;788    static HAL_StatusTypeDef FLASH_OB_BootConfig(uint8_t BootConfig)
000000  b570              PUSH     {r4-r6,lr}
;;;789    {
000002  4604              MOV      r4,r0
;;;790      HAL_StatusTypeDef status = HAL_OK;
000004  2500              MOVS     r5,#0
;;;791    
;;;792      /* Check the parameters */
;;;793      assert_param(IS_OB_BOOT(BootConfig));
;;;794    
;;;795      /* Wait for last operation to be completed */  
;;;796      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
000006  f24c3050          MOV      r0,#0xc350
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4605              MOV      r5,r0
;;;797    
;;;798      if(status == HAL_OK)
000010  b94d              CBNZ     r5,|L5.38|
;;;799      { 
;;;800        /* Set Dual Bank Boot */
;;;801        *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS &= (~FLASH_OPTCR_BFB2);
000012  4806              LDR      r0,|L5.44|
000014  7800              LDRB     r0,[r0,#0]
000016  f0200010          BIC      r0,r0,#0x10
00001a  4904              LDR      r1,|L5.44|
00001c  7008              STRB     r0,[r1,#0]
;;;802        *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= BootConfig;
00001e  4608              MOV      r0,r1
000020  7800              LDRB     r0,[r0,#0]
000022  4320              ORRS     r0,r0,r4
000024  7008              STRB     r0,[r1,#0]
                  |L5.38|
;;;803      }
;;;804      
;;;805      return status;
000026  4628              MOV      r0,r5
;;;806    }
000028  bd70              POP      {r4-r6,pc}
;;;807    
                          ENDP

00002a  0000              DCW      0x0000
                  |L5.44|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_DisablePCROP||, CODE, READONLY, ALIGN=2

                  FLASH_OB_DisablePCROP PROC
;;;891      */
;;;892    static HAL_StatusTypeDef FLASH_OB_DisablePCROP(uint32_t SectorBank1, uint32_t SectorBank2, uint32_t Banks)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;893    {  
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4614              MOV      r4,r2
;;;894      HAL_StatusTypeDef status = HAL_OK;
00000a  2600              MOVS     r6,#0
;;;895      
;;;896      /* Check the parameters */
;;;897      assert_param(IS_FLASH_BANK(Banks));
;;;898        
;;;899      /* Wait for last operation to be completed */
;;;900      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
00000c  f24c3050          MOV      r0,#0xc350
000010  f7fffffe          BL       FLASH_WaitForLastOperation
000014  4606              MOV      r6,r0
;;;901    
;;;902      if(status == HAL_OK)
000016  b9fe              CBNZ     r6,|L6.88|
;;;903      {
;;;904        if((Banks == FLASH_BANK_1) || (Banks == FLASH_BANK_BOTH))
000018  2c01              CMP      r4,#1
00001a  d001              BEQ      |L6.32|
00001c  2c03              CMP      r4,#3
00001e  d105              BNE      |L6.44|
                  |L6.32|
;;;905        {
;;;906          assert_param(IS_OB_PCROP(SectorBank1));
;;;907          /*Write protection done on sectors of BANK1*/
;;;908          *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~SectorBank1); 
000020  480f              LDR      r0,|L6.96|
000022  8800              LDRH     r0,[r0,#0]
000024  43b8              BICS     r0,r0,r7
000026  490e              LDR      r1,|L6.96|
000028  8008              STRH     r0,[r1,#0]
00002a  e006              B        |L6.58|
                  |L6.44|
;;;909        }
;;;910        else 
;;;911        {
;;;912          /*Write protection done on sectors of BANK2*/
;;;913          assert_param(IS_OB_PCROP(SectorBank2));
;;;914          *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS &= (~SectorBank2); 
00002c  480c              LDR      r0,|L6.96|
00002e  1d00              ADDS     r0,r0,#4
000030  8800              LDRH     r0,[r0,#0]
000032  43a8              BICS     r0,r0,r5
000034  490a              LDR      r1,|L6.96|
000036  1d09              ADDS     r1,r1,#4
000038  8008              STRH     r0,[r1,#0]
                  |L6.58|
;;;915        }
;;;916    
;;;917        /*Write protection on all sector  of BANK2*/
;;;918        if(Banks == FLASH_BANK_BOTH)
00003a  2c03              CMP      r4,#3
00003c  d10c              BNE      |L6.88|
;;;919        {
;;;920          assert_param(IS_OB_PCROP(SectorBank2));
;;;921         /* Wait for last operation to be completed */
;;;922          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
00003e  f24c3050          MOV      r0,#0xc350
000042  f7fffffe          BL       FLASH_WaitForLastOperation
000046  4606              MOV      r6,r0
;;;923          
;;;924          if(status == HAL_OK)
000048  b936              CBNZ     r6,|L6.88|
;;;925          { 
;;;926            /*Write protection done on sectors of BANK2*/
;;;927            *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS &= (~SectorBank2); 
00004a  4805              LDR      r0,|L6.96|
00004c  1d00              ADDS     r0,r0,#4
00004e  8800              LDRH     r0,[r0,#0]
000050  43a8              BICS     r0,r0,r5
000052  4903              LDR      r1,|L6.96|
000054  1d09              ADDS     r1,r1,#4
000056  8008              STRH     r0,[r1,#0]
                  |L6.88|
;;;928          }
;;;929        }
;;;930        
;;;931      }
;;;932      
;;;933      return status;
000058  4630              MOV      r0,r6
;;;934    
;;;935    }
00005a  e8bd81f0          POP      {r4-r8,pc}
;;;936    
                          ENDP

00005e  0000              DCW      0x0000
                  |L6.96|
                          DCD      0x40023c16

                          AREA ||i.FLASH_OB_DisableWRP||, CODE, READONLY, ALIGN=2

                  FLASH_OB_DisableWRP PROC
;;;726      */
;;;727    static HAL_StatusTypeDef FLASH_OB_DisableWRP(uint32_t WRPSector, uint32_t Banks)
000000  b570              PUSH     {r4-r6,lr}
;;;728    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;729      HAL_StatusTypeDef status = HAL_OK;
000006  2600              MOVS     r6,#0
;;;730      
;;;731      /* Check the parameters */
;;;732      assert_param(IS_OB_WRP_SECTOR(WRPSector));
;;;733      assert_param(IS_FLASH_BANK(Banks));
;;;734        
;;;735      /* Wait for last operation to be completed */
;;;736      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
000008  f24c3050          MOV      r0,#0xc350
00000c  f7fffffe          BL       FLASH_WaitForLastOperation
000010  4606              MOV      r6,r0
;;;737    
;;;738      if(status == HAL_OK)
000012  bbc6              CBNZ     r6,|L7.134|
;;;739      {
;;;740        if(((WRPSector == OB_WRP_SECTOR_All) && ((Banks == FLASH_BANK_1) || (Banks == FLASH_BANK_BOTH))) ||
000014  481d              LDR      r0,|L7.140|
000016  4284              CMP      r4,r0
000018  d103              BNE      |L7.34|
00001a  2d01              CMP      r5,#1
00001c  d004              BEQ      |L7.40|
00001e  2d03              CMP      r5,#3
000020  d002              BEQ      |L7.40|
                  |L7.34|
;;;741             (WRPSector < OB_WRP_SECTOR_12))
000022  f5b45f80          CMP      r4,#0x1000
000026  d211              BCS      |L7.76|
                  |L7.40|
;;;742        {
;;;743           if(WRPSector == OB_WRP_SECTOR_All)
000028  4818              LDR      r0,|L7.140|
00002a  4284              CMP      r4,r0
00002c  d107              BNE      |L7.62|
;;;744           {
;;;745              /*Write protection on all sector of BANK1*/
;;;746              *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)(WRPSector>>12); 
00002e  4818              LDR      r0,|L7.144|
000030  8800              LDRH     r0,[r0,#0]
000032  f3c4310f          UBFX     r1,r4,#12,#16
000036  4308              ORRS     r0,r0,r1
000038  4915              LDR      r1,|L7.144|
00003a  8008              STRH     r0,[r1,#0]
00003c  e00f              B        |L7.94|
                  |L7.62|
;;;747           }
;;;748           else
;;;749           {
;;;750              /*Write protection done on sectors of BANK1*/
;;;751              *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)WRPSector; 
00003e  4814              LDR      r0,|L7.144|
000040  8800              LDRH     r0,[r0,#0]
000042  b2a1              UXTH     r1,r4
000044  4308              ORRS     r0,r0,r1
000046  4912              LDR      r1,|L7.144|
000048  8008              STRH     r0,[r1,#0]
00004a  e008              B        |L7.94|
                  |L7.76|
;;;752           }
;;;753        }
;;;754        else 
;;;755        {
;;;756          /*Write protection done on sectors of BANK2*/
;;;757          *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS |= (uint16_t)(WRPSector>>12); 
00004c  4810              LDR      r0,|L7.144|
00004e  1d00              ADDS     r0,r0,#4
000050  8800              LDRH     r0,[r0,#0]
000052  f3c4310f          UBFX     r1,r4,#12,#16
000056  4308              ORRS     r0,r0,r1
000058  490d              LDR      r1,|L7.144|
00005a  1d09              ADDS     r1,r1,#4
00005c  8008              STRH     r0,[r1,#0]
                  |L7.94|
;;;758        }
;;;759    
;;;760        /*Write protection on all sector  of BANK2*/
;;;761        if((WRPSector == OB_WRP_SECTOR_All) && (Banks == FLASH_BANK_BOTH))
00005e  480b              LDR      r0,|L7.140|
000060  4284              CMP      r4,r0
000062  d110              BNE      |L7.134|
000064  2d03              CMP      r5,#3
000066  d10e              BNE      |L7.134|
;;;762        {
;;;763          /* Wait for last operation to be completed */
;;;764          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
000068  f24c3050          MOV      r0,#0xc350
00006c  f7fffffe          BL       FLASH_WaitForLastOperation
000070  4606              MOV      r6,r0
;;;765          
;;;766          if(status == HAL_OK)
000072  b946              CBNZ     r6,|L7.134|
;;;767          { 
;;;768            *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS |= (uint16_t)(WRPSector>>12); 
000074  4806              LDR      r0,|L7.144|
000076  1d00              ADDS     r0,r0,#4
000078  8800              LDRH     r0,[r0,#0]
00007a  f3c4310f          UBFX     r1,r4,#12,#16
00007e  4308              ORRS     r0,r0,r1
000080  4903              LDR      r1,|L7.144|
000082  1d09              ADDS     r1,r1,#4
000084  8008              STRH     r0,[r1,#0]
                  |L7.134|
;;;769          }
;;;770        }
;;;771        
;;;772      }
;;;773    
;;;774      return status;
000086  4630              MOV      r0,r6
;;;775    }
000088  bd70              POP      {r4-r6,pc}
;;;776    
                          ENDP

00008a  0000              DCW      0x0000
                  |L7.140|
                          DCD      0x00fff000
                  |L7.144|
                          DCD      0x40023c16

                          AREA ||i.FLASH_OB_EnablePCROP||, CODE, READONLY, ALIGN=2

                  FLASH_OB_EnablePCROP PROC
;;;827      */
;;;828    static HAL_StatusTypeDef FLASH_OB_EnablePCROP(uint32_t SectorBank1, uint32_t SectorBank2, uint32_t Banks)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;829    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4614              MOV      r4,r2
;;;830      HAL_StatusTypeDef status = HAL_OK;
00000a  2600              MOVS     r6,#0
;;;831      
;;;832      assert_param(IS_FLASH_BANK(Banks));
;;;833        
;;;834      /* Wait for last operation to be completed */
;;;835      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
00000c  f24c3050          MOV      r0,#0xc350
000010  f7fffffe          BL       FLASH_WaitForLastOperation
000014  4606              MOV      r6,r0
;;;836    
;;;837      if(status == HAL_OK)
000016  bb16              CBNZ     r6,|L8.94|
;;;838      {
;;;839        if((Banks == FLASH_BANK_1) || (Banks == FLASH_BANK_BOTH))
000018  2c01              CMP      r4,#1
00001a  d001              BEQ      |L8.32|
00001c  2c03              CMP      r4,#3
00001e  d106              BNE      |L8.46|
                  |L8.32|
;;;840        {
;;;841          assert_param(IS_OB_PCROP(SectorBank1));
;;;842          /*Write protection done on sectors of BANK1*/
;;;843          *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)SectorBank1; 
000020  4810              LDR      r0,|L8.100|
000022  8800              LDRH     r0,[r0,#0]
000024  b2b9              UXTH     r1,r7
000026  4308              ORRS     r0,r0,r1
000028  490e              LDR      r1,|L8.100|
00002a  8008              STRH     r0,[r1,#0]
00002c  e007              B        |L8.62|
                  |L8.46|
;;;844        }
;;;845        else 
;;;846        {
;;;847          assert_param(IS_OB_PCROP(SectorBank2));
;;;848          /*Write protection done on sectors of BANK2*/
;;;849          *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS |= (uint16_t)SectorBank2; 
00002e  480d              LDR      r0,|L8.100|
000030  1d00              ADDS     r0,r0,#4
000032  8800              LDRH     r0,[r0,#0]
000034  b2a9              UXTH     r1,r5
000036  4308              ORRS     r0,r0,r1
000038  490a              LDR      r1,|L8.100|
00003a  1d09              ADDS     r1,r1,#4
00003c  8008              STRH     r0,[r1,#0]
                  |L8.62|
;;;850        }
;;;851    
;;;852        /*Write protection on all sector  of BANK2*/
;;;853        if(Banks == FLASH_BANK_BOTH)
00003e  2c03              CMP      r4,#3
000040  d10d              BNE      |L8.94|
;;;854        {
;;;855          assert_param(IS_OB_PCROP(SectorBank2));
;;;856          /* Wait for last operation to be completed */
;;;857          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
000042  f24c3050          MOV      r0,#0xc350
000046  f7fffffe          BL       FLASH_WaitForLastOperation
00004a  4606              MOV      r6,r0
;;;858          
;;;859          if(status == HAL_OK)
00004c  b93e              CBNZ     r6,|L8.94|
;;;860          { 
;;;861            /*Write protection done on sectors of BANK2*/
;;;862            *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS |= (uint16_t)SectorBank2; 
00004e  4805              LDR      r0,|L8.100|
000050  1d00              ADDS     r0,r0,#4
000052  8800              LDRH     r0,[r0,#0]
000054  b2a9              UXTH     r1,r5
000056  4308              ORRS     r0,r0,r1
000058  4902              LDR      r1,|L8.100|
00005a  1d09              ADDS     r1,r1,#4
00005c  8008              STRH     r0,[r1,#0]
                  |L8.94|
;;;863          }
;;;864        }
;;;865        
;;;866      }
;;;867    
;;;868      return status;
00005e  4630              MOV      r0,r6
;;;869    }
000060  e8bd81f0          POP      {r4-r8,pc}
;;;870    
                          ENDP

                  |L8.100|
                          DCD      0x40023c16

                          AREA ||i.FLASH_OB_EnableWRP||, CODE, READONLY, ALIGN=2

                  FLASH_OB_EnableWRP PROC
;;;655      */
;;;656    static HAL_StatusTypeDef FLASH_OB_EnableWRP(uint32_t WRPSector, uint32_t Banks)
000000  b570              PUSH     {r4-r6,lr}
;;;657    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;658      HAL_StatusTypeDef status = HAL_OK;
000006  2600              MOVS     r6,#0
;;;659      
;;;660      /* Check the parameters */
;;;661      assert_param(IS_OB_WRP_SECTOR(WRPSector));
;;;662      assert_param(IS_FLASH_BANK(Banks));
;;;663        
;;;664      /* Wait for last operation to be completed */
;;;665      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
000008  f24c3050          MOV      r0,#0xc350
00000c  f7fffffe          BL       FLASH_WaitForLastOperation
000010  4606              MOV      r6,r0
;;;666    
;;;667      if(status == HAL_OK)
000012  bba6              CBNZ     r6,|L9.126|
;;;668      {
;;;669        if(((WRPSector == OB_WRP_SECTOR_All) && ((Banks == FLASH_BANK_1) || (Banks == FLASH_BANK_BOTH))) ||
000014  481b              LDR      r0,|L9.132|
000016  4284              CMP      r4,r0
000018  d103              BNE      |L9.34|
00001a  2d01              CMP      r5,#1
00001c  d004              BEQ      |L9.40|
00001e  2d03              CMP      r5,#3
000020  d002              BEQ      |L9.40|
                  |L9.34|
;;;670             (WRPSector < OB_WRP_SECTOR_12))
000022  f5b45f80          CMP      r4,#0x1000
000026  d20f              BCS      |L9.72|
                  |L9.40|
;;;671        {
;;;672           if(WRPSector == OB_WRP_SECTOR_All)
000028  4816              LDR      r0,|L9.132|
00002a  4284              CMP      r4,r0
00002c  d106              BNE      |L9.60|
;;;673           {
;;;674              /*Write protection on all sector of BANK1*/
;;;675              *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~(WRPSector>>12));  
00002e  4816              LDR      r0,|L9.136|
000030  8800              LDRH     r0,[r0,#0]
000032  ea203014          BIC      r0,r0,r4,LSR #12
000036  4914              LDR      r1,|L9.136|
000038  8008              STRH     r0,[r1,#0]
00003a  e00d              B        |L9.88|
                  |L9.60|
;;;676           }
;;;677           else
;;;678           {
;;;679              /*Write protection done on sectors of BANK1*/
;;;680              *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~WRPSector);  
00003c  4812              LDR      r0,|L9.136|
00003e  8800              LDRH     r0,[r0,#0]
000040  43a0              BICS     r0,r0,r4
000042  4911              LDR      r1,|L9.136|
000044  8008              STRH     r0,[r1,#0]
000046  e007              B        |L9.88|
                  |L9.72|
;;;681           }
;;;682        }
;;;683        else 
;;;684        {
;;;685          /*Write protection done on sectors of BANK2*/
;;;686          *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS &= (~(WRPSector>>12));  
000048  480f              LDR      r0,|L9.136|
00004a  1d00              ADDS     r0,r0,#4
00004c  8800              LDRH     r0,[r0,#0]
00004e  ea203014          BIC      r0,r0,r4,LSR #12
000052  490d              LDR      r1,|L9.136|
000054  1d09              ADDS     r1,r1,#4
000056  8008              STRH     r0,[r1,#0]
                  |L9.88|
;;;687        }
;;;688    
;;;689        /*Write protection on all sector of BANK2*/
;;;690        if((WRPSector == OB_WRP_SECTOR_All) && (Banks == FLASH_BANK_BOTH))
000058  480a              LDR      r0,|L9.132|
00005a  4284              CMP      r4,r0
00005c  d10f              BNE      |L9.126|
00005e  2d03              CMP      r5,#3
000060  d10d              BNE      |L9.126|
;;;691        {
;;;692          /* Wait for last operation to be completed */
;;;693          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
000062  f24c3050          MOV      r0,#0xc350
000066  f7fffffe          BL       FLASH_WaitForLastOperation
00006a  4606              MOV      r6,r0
;;;694          
;;;695          if(status == HAL_OK)
00006c  b93e              CBNZ     r6,|L9.126|
;;;696          { 
;;;697            *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS &= (~(WRPSector>>12));  
00006e  4806              LDR      r0,|L9.136|
000070  1d00              ADDS     r0,r0,#4
000072  8800              LDRH     r0,[r0,#0]
000074  ea203014          BIC      r0,r0,r4,LSR #12
000078  4903              LDR      r1,|L9.136|
00007a  1d09              ADDS     r1,r1,#4
00007c  8008              STRH     r0,[r1,#0]
                  |L9.126|
;;;698          }
;;;699        }
;;;700        
;;;701      }
;;;702      return status;
00007e  4630              MOV      r0,r6
;;;703    }
000080  bd70              POP      {r4-r6,pc}
;;;704    
                          ENDP

000082  0000              DCW      0x0000
                  |L9.132|
                          DCD      0x00fff000
                  |L9.136|
                          DCD      0x40023c16

                          AREA ||i.FLASH_OB_GetBOR||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetBOR PROC
;;;1308     */
;;;1309   static uint8_t FLASH_OB_GetBOR(void)
000000  4802              LDR      r0,|L10.12|
;;;1310   {
;;;1311     /* Return the FLASH BOR level */
;;;1312     return (uint8_t)(*(__IO uint8_t *)(OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0C);
000002  7800              LDRB     r0,[r0,#0]
000004  f000000c          AND      r0,r0,#0xc
;;;1313   }
000008  4770              BX       lr
;;;1314   
                          ENDP

00000a  0000              DCW      0x0000
                  |L10.12|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_GetRDP||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetRDP PROC
;;;1280     */
;;;1281   static uint8_t FLASH_OB_GetRDP(void)
000000  20aa              MOVS     r0,#0xaa
;;;1282   {
;;;1283     uint8_t readstatus = OB_RDP_LEVEL_0;
;;;1284   
;;;1285     if((*(__IO uint8_t*)(OPTCR_BYTE1_ADDRESS) == (uint8_t)OB_RDP_LEVEL_2))
000002  4907              LDR      r1,|L11.32|
000004  7809              LDRB     r1,[r1,#0]
000006  29cc              CMP      r1,#0xcc
000008  d101              BNE      |L11.14|
;;;1286     {
;;;1287       readstatus = OB_RDP_LEVEL_2;
00000a  20cc              MOVS     r0,#0xcc
00000c  e006              B        |L11.28|
                  |L11.14|
;;;1288     }
;;;1289     else if((*(__IO uint8_t*)(OPTCR_BYTE1_ADDRESS) == (uint8_t)OB_RDP_LEVEL_1))
00000e  4904              LDR      r1,|L11.32|
000010  7809              LDRB     r1,[r1,#0]
000012  2955              CMP      r1,#0x55
000014  d101              BNE      |L11.26|
;;;1290     {
;;;1291       readstatus = OB_RDP_LEVEL_1;
000016  2055              MOVS     r0,#0x55
000018  e000              B        |L11.28|
                  |L11.26|
;;;1292     }
;;;1293     else 
;;;1294     {
;;;1295       readstatus = OB_RDP_LEVEL_0;
00001a  20aa              MOVS     r0,#0xaa
                  |L11.28|
;;;1296     }
;;;1297   
;;;1298     return readstatus;
;;;1299   }
00001c  4770              BX       lr
;;;1300   
                          ENDP

00001e  0000              DCW      0x0000
                  |L11.32|
                          DCD      0x40023c15

                          AREA ||i.FLASH_OB_GetUser||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetUser PROC
;;;1256     */
;;;1257   static uint8_t FLASH_OB_GetUser(void)
000000  4802              LDR      r0,|L12.12|
;;;1258   {
;;;1259     /* Return the User Option Byte */
;;;1260     return ((uint8_t)(FLASH->OPTCR & 0xE0));
000002  6800              LDR      r0,[r0,#0]
000004  f00000e0          AND      r0,r0,#0xe0
;;;1261   }
000008  4770              BX       lr
;;;1262   
                          ENDP

00000a  0000              DCW      0x0000
                  |L12.12|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_GetWRP||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetWRP PROC
;;;1266     */
;;;1267   static uint16_t FLASH_OB_GetWRP(void)
000000  4801              LDR      r0,|L13.8|
;;;1268   {
;;;1269     /* Return the FLASH write protection Register value */
;;;1270     return (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));
000002  8800              LDRH     r0,[r0,#0]
;;;1271   }
000004  4770              BX       lr
;;;1272   
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      0x40023c16

                          AREA ||i.FLASH_OB_RDP_LevelConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_RDP_LevelConfig PROC
;;;1169     */
;;;1170   static HAL_StatusTypeDef FLASH_OB_RDP_LevelConfig(uint8_t Level)
000000  b570              PUSH     {r4-r6,lr}
;;;1171   {
000002  4604              MOV      r4,r0
;;;1172     HAL_StatusTypeDef status = HAL_OK;
000004  2500              MOVS     r5,#0
;;;1173     
;;;1174     /* Check the parameters */
;;;1175     assert_param(IS_OB_RDP_LEVEL(Level));
;;;1176       
;;;1177     /* Wait for last operation to be completed */
;;;1178     status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
000006  f24c3050          MOV      r0,#0xc350
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4605              MOV      r5,r0
;;;1179   
;;;1180     if(status == HAL_OK)
000010  b90d              CBNZ     r5,|L14.22|
;;;1181     { 
;;;1182       *(__IO uint8_t*)OPTCR_BYTE1_ADDRESS = Level;
000012  4802              LDR      r0,|L14.28|
000014  7004              STRB     r4,[r0,#0]
                  |L14.22|
;;;1183     }
;;;1184     
;;;1185     return status;
000016  4628              MOV      r0,r5
;;;1186   }
000018  bd70              POP      {r4-r6,pc}
;;;1187   
                          ENDP

00001a  0000              DCW      0x0000
                  |L14.28|
                          DCD      0x40023c15

                          AREA ||i.FLASH_OB_UserConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_UserConfig PROC
;;;1203     */
;;;1204   static HAL_StatusTypeDef FLASH_OB_UserConfig(uint8_t Iwdg, uint8_t Stop, uint8_t Stdby)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1205   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;1206     uint8_t optiontmp = 0xFF;
00000a  f04f08ff          MOV      r8,#0xff
;;;1207     HAL_StatusTypeDef status = HAL_OK;
00000e  2700              MOVS     r7,#0
;;;1208   
;;;1209     /* Check the parameters */
;;;1210     assert_param(IS_OB_IWDG_SOURCE(Iwdg));
;;;1211     assert_param(IS_OB_STOP_SOURCE(Stop));
;;;1212     assert_param(IS_OB_STDBY_SOURCE(Stdby));
;;;1213   
;;;1214     /* Wait for last operation to be completed */
;;;1215     status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
000010  f24c3050          MOV      r0,#0xc350
000014  f7fffffe          BL       FLASH_WaitForLastOperation
000018  4607              MOV      r7,r0
;;;1216     
;;;1217     if(status == HAL_OK)
00001a  b94f              CBNZ     r7,|L15.48|
;;;1218     {     
;;;1219       /* Mask OPTLOCK, OPTSTRT, BOR_LEV and BFB2 bits */
;;;1220       optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE0_ADDRESS) & (uint8_t)0x1F);
00001c  4806              LDR      r0,|L15.56|
00001e  7800              LDRB     r0,[r0,#0]
000020  f000081f          AND      r8,r0,#0x1f
;;;1221   
;;;1222       /* Update User Option Byte */
;;;1223       *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS = Iwdg | (uint8_t)(Stdby | (uint8_t)(Stop | ((uint8_t)optiontmp))); 
000024  ea450008          ORR      r0,r5,r8
000028  4330              ORRS     r0,r0,r6
00002a  4320              ORRS     r0,r0,r4
00002c  4902              LDR      r1,|L15.56|
00002e  7008              STRB     r0,[r1,#0]
                  |L15.48|
;;;1224     }
;;;1225     
;;;1226     return status; 
000030  4638              MOV      r0,r7
;;;1227   }
000032  e8bd81f0          POP      {r4-r8,pc}
;;;1228   
                          ENDP

000036  0000              DCW      0x0000
                  |L15.56|
                          DCD      0x40023c14

                          AREA ||i.HAL_FLASHEx_AdvOBGetConfig||, CODE, READONLY, ALIGN=2

                  HAL_FLASHEx_AdvOBGetConfig PROC
;;;440      */
;;;441    void HAL_FLASHEx_AdvOBGetConfig(FLASH_AdvOBProgramInitTypeDef *pAdvOBInit)
000000  4905              LDR      r1,|L16.24|
;;;442    {
;;;443    #if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) ||\
;;;444        defined(STM32F411xE) || defined(STM32F446xx)
;;;445      /*Get Sector*/
;;;446      pAdvOBInit->Sectors = (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));
;;;447    #else  /* STM32F427xx || STM32F437xx || STM32F429xx|| STM32F439xx || STM32F469xx || STM32F479xx */
;;;448      /*Get Sector for Bank1*/
;;;449      pAdvOBInit->SectorsBank1 = (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));
000002  8809              LDRH     r1,[r1,#0]
000004  8181              STRH     r1,[r0,#0xc]
;;;450    
;;;451      /*Get Sector for Bank2*/
;;;452      pAdvOBInit->SectorsBank2 = (*(__IO uint16_t *)(OPTCR1_BYTE2_ADDRESS));
000006  4904              LDR      r1,|L16.24|
000008  1d09              ADDS     r1,r1,#4
00000a  8809              LDRH     r1,[r1,#0]
00000c  81c1              STRH     r1,[r0,#0xe]
;;;453    
;;;454      /*Get Boot config OB*/
;;;455      pAdvOBInit->BootConfig = *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS;
00000e  4902              LDR      r1,|L16.24|
000010  1e89              SUBS     r1,r1,#2
000012  7809              LDRB     r1,[r1,#0]
000014  7401              STRB     r1,[r0,#0x10]
;;;456    #endif /* STM32F401xC || STM32F401xE || STM32F410xx || STM32F411xE || STM32F446xx */
;;;457    }
000016  4770              BX       lr
;;;458    
                          ENDP

                  |L16.24|
                          DCD      0x40023c16

                          AREA ||i.HAL_FLASHEx_AdvOBProgram||, CODE, READONLY, ALIGN=1

                  HAL_FLASHEx_AdvOBProgram PROC
;;;388      */
;;;389    HAL_StatusTypeDef HAL_FLASHEx_AdvOBProgram (FLASH_AdvOBProgramInitTypeDef *pAdvOBInit)
000000  b570              PUSH     {r4-r6,lr}
;;;390    {
000002  4604              MOV      r4,r0
;;;391      HAL_StatusTypeDef status = HAL_ERROR;
000004  2501              MOVS     r5,#1
;;;392      
;;;393      /* Check the parameters */
;;;394      assert_param(IS_OBEX(pAdvOBInit->OptionType));
;;;395    
;;;396      /*Program PCROP option byte*/
;;;397      if(((pAdvOBInit->OptionType) & OPTIONBYTE_PCROP) == OPTIONBYTE_PCROP)
000006  7820              LDRB     r0,[r4,#0]
000008  f0000001          AND      r0,r0,#1
00000c  b178              CBZ      r0,|L17.46|
;;;398      {
;;;399        /* Check the parameters */
;;;400        assert_param(IS_PCROPSTATE(pAdvOBInit->PCROPState));
;;;401        if((pAdvOBInit->PCROPState) == OB_PCROP_STATE_ENABLE)
00000e  6860              LDR      r0,[r4,#4]
000010  2801              CMP      r0,#1
000012  d106              BNE      |L17.34|
;;;402        {
;;;403          /*Enable of Write protection on the selected Sector*/
;;;404    #if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) ||\
;;;405        defined(STM32F411xE) || defined(STM32F446xx)
;;;406          status = FLASH_OB_EnablePCROP(pAdvOBInit->Sectors);
;;;407    #else  /* STM32F427xx || STM32F437xx || STM32F429xx|| STM32F439xx || STM32F469xx || STM32F479xx */
;;;408          status = FLASH_OB_EnablePCROP(pAdvOBInit->SectorsBank1, pAdvOBInit->SectorsBank2, pAdvOBInit->Banks);
000014  89e1              LDRH     r1,[r4,#0xe]
000016  89a0              LDRH     r0,[r4,#0xc]
000018  68a2              LDR      r2,[r4,#8]
00001a  f7fffffe          BL       FLASH_OB_EnablePCROP
00001e  4605              MOV      r5,r0
000020  e005              B        |L17.46|
                  |L17.34|
;;;409    #endif /* STM32F401xC || STM32F401xE || STM32F410xx || STM32F411xE || STM32F446xx */
;;;410        }
;;;411        else
;;;412        {
;;;413          /*Disable of Write protection on the selected Sector*/
;;;414    #if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) ||\
;;;415        defined(STM32F411xE) || defined(STM32F446xx) 
;;;416          status = FLASH_OB_DisablePCROP(pAdvOBInit->Sectors);
;;;417    #else /* STM32F427xx || STM32F437xx || STM32F429xx|| STM32F439xx || STM32F469xx || STM32F479xx */
;;;418          status = FLASH_OB_DisablePCROP(pAdvOBInit->SectorsBank1, pAdvOBInit->SectorsBank2, pAdvOBInit->Banks);
000022  89e1              LDRH     r1,[r4,#0xe]
000024  89a0              LDRH     r0,[r4,#0xc]
000026  68a2              LDR      r2,[r4,#8]
000028  f7fffffe          BL       FLASH_OB_DisablePCROP
00002c  4605              MOV      r5,r0
                  |L17.46|
;;;419    #endif /* STM32F401xC || STM32F401xE || STM32F410xx || STM32F411xE || STM32F446xx */
;;;420        }
;;;421      }
;;;422       
;;;423    #if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
;;;424      /*Program BOOT config option byte*/
;;;425      if(((pAdvOBInit->OptionType) & OPTIONBYTE_BOOTCONFIG) == OPTIONBYTE_BOOTCONFIG)
00002e  7820              LDRB     r0,[r4,#0]
000030  f0000002          AND      r0,r0,#2
000034  2802              CMP      r0,#2
000036  d103              BNE      |L17.64|
;;;426      {
;;;427        status = FLASH_OB_BootConfig(pAdvOBInit->BootConfig);
000038  7c20              LDRB     r0,[r4,#0x10]
00003a  f7fffffe          BL       FLASH_OB_BootConfig
00003e  4605              MOV      r5,r0
                  |L17.64|
;;;428      }
;;;429    #endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
;;;430    
;;;431      return status;
000040  4628              MOV      r0,r5
;;;432    }
000042  bd70              POP      {r4-r6,pc}
;;;433    
                          ENDP


                          AREA ||i.HAL_FLASHEx_Erase||, CODE, READONLY, ALIGN=2

                  HAL_FLASHEx_Erase PROC
;;;177      */
;;;178    HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *SectorError)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;179    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;180      HAL_StatusTypeDef status = HAL_ERROR;
000008  2701              MOVS     r7,#1
;;;181      uint32_t index = 0;
00000a  2500              MOVS     r5,#0
;;;182      
;;;183      /* Process Locked */
;;;184      __HAL_LOCK(&pFlash);
00000c  bf00              NOP      
00000e  4826              LDR      r0,|L18.168|
000010  7e00              LDRB     r0,[r0,#0x18]  ; pFlash
000012  2801              CMP      r0,#1
000014  d102              BNE      |L18.28|
000016  2002              MOVS     r0,#2
                  |L18.24|
;;;185    
;;;186      /* Check the parameters */
;;;187      assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
;;;188    
;;;189      /* Wait for last operation to be completed */
;;;190      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
;;;191    
;;;192      if(status == HAL_OK)
;;;193      {
;;;194        /*Initialization of SectorError variable*/
;;;195        *SectorError = 0xFFFFFFFF;
;;;196        
;;;197        if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
;;;198        {
;;;199          /*Mass erase to be done*/
;;;200          FLASH_MassErase((uint8_t) pEraseInit->VoltageRange, pEraseInit->Banks);
;;;201    
;;;202          /* Wait for last operation to be completed */
;;;203          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
;;;204          
;;;205          /* if the erase operation is completed, disable the MER Bit */
;;;206          FLASH->CR &= (~FLASH_MER_BIT);
;;;207        }
;;;208        else
;;;209        {
;;;210          /* Check the parameters */
;;;211          assert_param(IS_FLASH_NBSECTORS(pEraseInit->NbSectors + pEraseInit->Sector));
;;;212    
;;;213          /* Erase by sector by sector to be done*/
;;;214          for(index = pEraseInit->Sector; index < (pEraseInit->NbSectors + pEraseInit->Sector); index++)
;;;215          {
;;;216            FLASH_Erase_Sector(index, (uint8_t) pEraseInit->VoltageRange);
;;;217    
;;;218            /* Wait for last operation to be completed */
;;;219            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
;;;220            
;;;221            /* If the erase operation is completed, disable the SER and SNB Bits */
;;;222            CLEAR_BIT(FLASH->CR, (FLASH_CR_SER | FLASH_CR_SNB));
;;;223    
;;;224            if(status != HAL_OK) 
;;;225            {
;;;226              /* In case of error, stop erase procedure and return the faulty sector*/
;;;227              *SectorError = index;
;;;228              break;
;;;229            }
;;;230          }
;;;231        }
;;;232        /* Flush the caches to be sure of the data consistency */
;;;233        FLASH_FlushCaches();    
;;;234      }
;;;235    
;;;236      /* Process Unlocked */
;;;237      __HAL_UNLOCK(&pFlash);
;;;238    
;;;239      return status;
;;;240    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L18.28|
00001c  2001              MOVS     r0,#1                 ;184
00001e  4922              LDR      r1,|L18.168|
000020  7608              STRB     r0,[r1,#0x18]         ;184
000022  bf00              NOP                            ;184
000024  f24c3050          MOV      r0,#0xc350            ;190
000028  f7fffffe          BL       FLASH_WaitForLastOperation
00002c  4607              MOV      r7,r0                 ;190
00002e  2f00              CMP      r7,#0                 ;192
000030  d132              BNE      |L18.152|
000032  1e40              SUBS     r0,r0,#1              ;195
000034  6030              STR      r0,[r6,#0]            ;195
000036  6820              LDR      r0,[r4,#0]            ;197
000038  2801              CMP      r0,#1                 ;197
00003a  d110              BNE      |L18.94|
00003c  7c20              LDRB     r0,[r4,#0x10]         ;200
00003e  6861              LDR      r1,[r4,#4]            ;200
000040  f7fffffe          BL       FLASH_MassErase
000044  f24c3050          MOV      r0,#0xc350            ;203
000048  f7fffffe          BL       FLASH_WaitForLastOperation
00004c  4607              MOV      r7,r0                 ;203
00004e  4817              LDR      r0,|L18.172|
000050  6800              LDR      r0,[r0,#0]            ;206
000052  f2480104          MOV      r1,#0x8004            ;206
000056  4388              BICS     r0,r0,r1              ;206
000058  4914              LDR      r1,|L18.172|
00005a  6008              STR      r0,[r1,#0]            ;206
00005c  e01a              B        |L18.148|
                  |L18.94|
00005e  68a5              LDR      r5,[r4,#8]            ;214
000060  e012              B        |L18.136|
                  |L18.98|
000062  7c21              LDRB     r1,[r4,#0x10]         ;216
000064  4628              MOV      r0,r5                 ;216
000066  f7fffffe          BL       FLASH_Erase_Sector
00006a  f24c3050          MOV      r0,#0xc350            ;219
00006e  f7fffffe          BL       FLASH_WaitForLastOperation
000072  4607              MOV      r7,r0                 ;219
000074  480d              LDR      r0,|L18.172|
000076  6800              LDR      r0,[r0,#0]            ;222
000078  f02000fa          BIC      r0,r0,#0xfa           ;222
00007c  490b              LDR      r1,|L18.172|
00007e  6008              STR      r0,[r1,#0]            ;222
000080  b10f              CBZ      r7,|L18.134|
000082  6035              STR      r5,[r6,#0]            ;227
000084  e005              B        |L18.146|
                  |L18.134|
000086  1c6d              ADDS     r5,r5,#1              ;214
                  |L18.136|
000088  e9d41002          LDRD     r1,r0,[r4,#8]         ;214
00008c  4408              ADD      r0,r0,r1              ;214
00008e  42a8              CMP      r0,r5                 ;214
000090  d8e7              BHI      |L18.98|
                  |L18.146|
000092  bf00              NOP                            ;228
                  |L18.148|
000094  f7fffffe          BL       FLASH_FlushCaches
                  |L18.152|
000098  bf00              NOP                            ;237
00009a  2000              MOVS     r0,#0                 ;237
00009c  4902              LDR      r1,|L18.168|
00009e  7608              STRB     r0,[r1,#0x18]         ;237
0000a0  bf00              NOP                            ;237
0000a2  4638              MOV      r0,r7                 ;239
0000a4  e7b8              B        |L18.24|
;;;241    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L18.168|
                          DCD      pFlash
                  |L18.172|
                          DCD      0x40023c10

                          AREA ||i.HAL_FLASHEx_Erase_IT||, CODE, READONLY, ALIGN=2

                  HAL_FLASHEx_Erase_IT PROC
;;;248      */
;;;249    HAL_StatusTypeDef HAL_FLASHEx_Erase_IT(FLASH_EraseInitTypeDef *pEraseInit)
000000  b570              PUSH     {r4-r6,lr}
;;;250    {
000002  4604              MOV      r4,r0
;;;251      HAL_StatusTypeDef status = HAL_OK;
000004  2500              MOVS     r5,#0
;;;252    
;;;253      /* Process Locked */
;;;254      __HAL_LOCK(&pFlash);
000006  bf00              NOP      
000008  4819              LDR      r0,|L19.112|
00000a  7e00              LDRB     r0,[r0,#0x18]  ; pFlash
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L19.20|
000010  2002              MOVS     r0,#2
                  |L19.18|
;;;255    
;;;256      /* Check the parameters */
;;;257      assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
;;;258    
;;;259      /* Enable End of FLASH Operation interrupt */
;;;260      __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP);
;;;261      
;;;262      /* Enable Error source interrupt */
;;;263      __HAL_FLASH_ENABLE_IT(FLASH_IT_ERR);
;;;264      
;;;265      /* Clear pending flags (if any) */  
;;;266      __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP    | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR |\
;;;267                             FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR| FLASH_FLAG_PGSERR);  
;;;268      
;;;269      if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
;;;270      {
;;;271        /*Mass erase to be done*/
;;;272        pFlash.ProcedureOnGoing = FLASH_PROC_MASSERASE;
;;;273        pFlash.Bank = pEraseInit->Banks;
;;;274        FLASH_MassErase((uint8_t) pEraseInit->VoltageRange, pEraseInit->Banks);
;;;275      }
;;;276      else
;;;277      {
;;;278        /* Erase by sector to be done*/
;;;279    
;;;280        /* Check the parameters */
;;;281        assert_param(IS_FLASH_NBSECTORS(pEraseInit->NbSectors + pEraseInit->Sector));
;;;282    
;;;283        pFlash.ProcedureOnGoing = FLASH_PROC_SECTERASE;
;;;284        pFlash.NbSectorsToErase = pEraseInit->NbSectors;
;;;285        pFlash.Sector = pEraseInit->Sector;
;;;286        pFlash.VoltageForErase = (uint8_t)pEraseInit->VoltageRange;
;;;287    
;;;288        /*Erase 1st sector and wait for IT*/
;;;289        FLASH_Erase_Sector(pEraseInit->Sector, pEraseInit->VoltageRange);
;;;290      }
;;;291    
;;;292      return status;
;;;293    }
000012  bd70              POP      {r4-r6,pc}
                  |L19.20|
000014  2001              MOVS     r0,#1                 ;254
000016  4916              LDR      r1,|L19.112|
000018  7608              STRB     r0,[r1,#0x18]         ;254
00001a  bf00              NOP                            ;254
00001c  4815              LDR      r0,|L19.116|
00001e  6800              LDR      r0,[r0,#0]            ;260
000020  f0407080          ORR      r0,r0,#0x1000000      ;260
000024  4913              LDR      r1,|L19.116|
000026  6008              STR      r0,[r1,#0]            ;260
000028  4608              MOV      r0,r1                 ;263
00002a  6800              LDR      r0,[r0,#0]            ;263
00002c  f0407000          ORR      r0,r0,#0x2000000      ;263
000030  6008              STR      r0,[r1,#0]            ;263
000032  20f3              MOVS     r0,#0xf3              ;266
000034  1f09              SUBS     r1,r1,#4              ;266
000036  6008              STR      r0,[r1,#0]            ;266
000038  6820              LDR      r0,[r4,#0]            ;269
00003a  2801              CMP      r0,#1                 ;269
00003c  d109              BNE      |L19.82|
00003e  2002              MOVS     r0,#2                 ;272
000040  490b              LDR      r1,|L19.112|
000042  7008              STRB     r0,[r1,#0]            ;272
000044  6860              LDR      r0,[r4,#4]            ;273
000046  6108              STR      r0,[r1,#0x10]         ;273  ; pFlash
000048  7c20              LDRB     r0,[r4,#0x10]         ;274
00004a  6861              LDR      r1,[r4,#4]            ;274
00004c  f7fffffe          BL       FLASH_MassErase
000050  e00c              B        |L19.108|
                  |L19.82|
000052  2001              MOVS     r0,#1                 ;283
000054  4906              LDR      r1,|L19.112|
000056  7008              STRB     r0,[r1,#0]            ;283
000058  68e0              LDR      r0,[r4,#0xc]          ;284
00005a  6048              STR      r0,[r1,#4]            ;284  ; pFlash
00005c  68a0              LDR      r0,[r4,#8]            ;285
00005e  60c8              STR      r0,[r1,#0xc]          ;285  ; pFlash
000060  7c20              LDRB     r0,[r4,#0x10]         ;286
000062  7208              STRB     r0,[r1,#8]            ;286
000064  7c21              LDRB     r1,[r4,#0x10]         ;289
000066  68a0              LDR      r0,[r4,#8]            ;289
000068  f7fffffe          BL       FLASH_Erase_Sector
                  |L19.108|
00006c  4628              MOV      r0,r5                 ;292
00006e  e7d0              B        |L19.18|
;;;294    
                          ENDP

                  |L19.112|
                          DCD      pFlash
                  |L19.116|
                          DCD      0x40023c10

                          AREA ||i.HAL_FLASHEx_OBGetConfig||, CODE, READONLY, ALIGN=1

                  HAL_FLASHEx_OBGetConfig PROC
;;;360      */
;;;361    void HAL_FLASHEx_OBGetConfig(FLASH_OBProgramInitTypeDef *pOBInit)
000000  b510              PUSH     {r4,lr}
;;;362    {
000002  4604              MOV      r4,r0
;;;363      pOBInit->OptionType = OPTIONBYTE_WRP | OPTIONBYTE_RDP | OPTIONBYTE_USER | OPTIONBYTE_BOR;
000004  200f              MOVS     r0,#0xf
000006  6020              STR      r0,[r4,#0]
;;;364    
;;;365      /*Get WRP*/
;;;366      pOBInit->WRPSector = (uint32_t)FLASH_OB_GetWRP();
000008  f7fffffe          BL       FLASH_OB_GetWRP
00000c  60a0              STR      r0,[r4,#8]
;;;367    
;;;368      /*Get RDP Level*/
;;;369      pOBInit->RDPLevel = (uint32_t)FLASH_OB_GetRDP();
00000e  f7fffffe          BL       FLASH_OB_GetRDP
000012  6120              STR      r0,[r4,#0x10]
;;;370    
;;;371      /*Get USER*/
;;;372      pOBInit->USERConfig = (uint8_t)FLASH_OB_GetUser();
000014  f7fffffe          BL       FLASH_OB_GetUser
000018  7620              STRB     r0,[r4,#0x18]
;;;373    
;;;374      /*Get BOR Level*/
;;;375      pOBInit->BORLevel = (uint32_t)FLASH_OB_GetBOR();
00001a  f7fffffe          BL       FLASH_OB_GetBOR
00001e  6160              STR      r0,[r4,#0x14]
;;;376    }
000020  bd10              POP      {r4,pc}
;;;377    
                          ENDP


                          AREA ||i.HAL_FLASHEx_OBProgram||, CODE, READONLY, ALIGN=2

                  HAL_FLASHEx_OBProgram PROC
;;;301      */
;;;302    HAL_StatusTypeDef HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit)
000000  b570              PUSH     {r4-r6,lr}
;;;303    {
000002  4604              MOV      r4,r0
;;;304      HAL_StatusTypeDef status = HAL_ERROR;
000004  2501              MOVS     r5,#1
;;;305      
;;;306      /* Process Locked */
;;;307      __HAL_LOCK(&pFlash);
000006  bf00              NOP      
000008  4821              LDR      r0,|L21.144|
00000a  7e00              LDRB     r0,[r0,#0x18]  ; pFlash
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L21.20|
000010  2002              MOVS     r0,#2
                  |L21.18|
;;;308    
;;;309      /* Check the parameters */
;;;310      assert_param(IS_OPTIONBYTE(pOBInit->OptionType));
;;;311    
;;;312      /*Write protection configuration*/
;;;313      if((pOBInit->OptionType & OPTIONBYTE_WRP) == OPTIONBYTE_WRP)
;;;314      {
;;;315        assert_param(IS_WRPSTATE(pOBInit->WRPState));
;;;316        if(pOBInit->WRPState == OB_WRPSTATE_ENABLE)
;;;317        {
;;;318          /*Enable of Write protection on the selected Sector*/
;;;319          status = FLASH_OB_EnableWRP(pOBInit->WRPSector, pOBInit->Banks);
;;;320        }
;;;321        else
;;;322        {
;;;323          /*Disable of Write protection on the selected Sector*/
;;;324          status = FLASH_OB_DisableWRP(pOBInit->WRPSector, pOBInit->Banks);
;;;325        }
;;;326      }
;;;327    
;;;328      /*Read protection configuration*/
;;;329      if((pOBInit->OptionType & OPTIONBYTE_RDP) == OPTIONBYTE_RDP)
;;;330      {
;;;331        status = FLASH_OB_RDP_LevelConfig(pOBInit->RDPLevel);
;;;332      }
;;;333    
;;;334      /*USER  configuration*/
;;;335      if((pOBInit->OptionType & OPTIONBYTE_USER) == OPTIONBYTE_USER)
;;;336      {
;;;337        status = FLASH_OB_UserConfig(pOBInit->USERConfig&OB_IWDG_SW, 
;;;338                                         pOBInit->USERConfig&OB_STOP_NO_RST,
;;;339                                         pOBInit->USERConfig&OB_STDBY_NO_RST);
;;;340      }
;;;341    
;;;342      /*BOR Level  configuration*/
;;;343      if((pOBInit->OptionType & OPTIONBYTE_BOR) == OPTIONBYTE_BOR)
;;;344      {
;;;345        status = FLASH_OB_BOR_LevelConfig(pOBInit->BORLevel);
;;;346      }
;;;347    
;;;348      /* Process Unlocked */
;;;349      __HAL_UNLOCK(&pFlash);
;;;350    
;;;351      return status;
;;;352    }
000012  bd70              POP      {r4-r6,pc}
                  |L21.20|
000014  2001              MOVS     r0,#1                 ;307
000016  491e              LDR      r1,|L21.144|
000018  7608              STRB     r0,[r1,#0x18]         ;307
00001a  bf00              NOP                            ;307
00001c  7820              LDRB     r0,[r4,#0]            ;313
00001e  f0000001          AND      r0,r0,#1              ;313
000022  b168              CBZ      r0,|L21.64|
000024  6860              LDR      r0,[r4,#4]            ;316
000026  2801              CMP      r0,#1                 ;316
000028  d105              BNE      |L21.54|
00002a  e9d40102          LDRD     r0,r1,[r4,#8]         ;319
00002e  f7fffffe          BL       FLASH_OB_EnableWRP
000032  4605              MOV      r5,r0                 ;319
000034  e004              B        |L21.64|
                  |L21.54|
000036  e9d40102          LDRD     r0,r1,[r4,#8]         ;324
00003a  f7fffffe          BL       FLASH_OB_DisableWRP
00003e  4605              MOV      r5,r0                 ;324
                  |L21.64|
000040  7820              LDRB     r0,[r4,#0]            ;329
000042  f0000002          AND      r0,r0,#2              ;329
000046  2802              CMP      r0,#2                 ;329
000048  d103              BNE      |L21.82|
00004a  7c20              LDRB     r0,[r4,#0x10]         ;331
00004c  f7fffffe          BL       FLASH_OB_RDP_LevelConfig
000050  4605              MOV      r5,r0                 ;331
                  |L21.82|
000052  7820              LDRB     r0,[r4,#0]            ;335
000054  f0000004          AND      r0,r0,#4              ;335
000058  2804              CMP      r0,#4                 ;335
00005a  d109              BNE      |L21.112|
00005c  7e23              LDRB     r3,[r4,#0x18]         ;337
00005e  f0030280          AND      r2,r3,#0x80           ;337
000062  f0030140          AND      r1,r3,#0x40           ;337
000066  f0030020          AND      r0,r3,#0x20           ;337
00006a  f7fffffe          BL       FLASH_OB_UserConfig
00006e  4605              MOV      r5,r0                 ;337
                  |L21.112|
000070  7820              LDRB     r0,[r4,#0]            ;343
000072  f0000008          AND      r0,r0,#8              ;343
000076  2808              CMP      r0,#8                 ;343
000078  d103              BNE      |L21.130|
00007a  7d20              LDRB     r0,[r4,#0x14]         ;345
00007c  f7fffffe          BL       FLASH_OB_BOR_LevelConfig
000080  4605              MOV      r5,r0                 ;345
                  |L21.130|
000082  bf00              NOP                            ;349
000084  2000              MOVS     r0,#0                 ;349
000086  4902              LDR      r1,|L21.144|
000088  7608              STRB     r0,[r1,#0x18]         ;349
00008a  bf00              NOP                            ;349
00008c  4628              MOV      r0,r5                 ;351
00008e  e7c0              B        |L21.18|
;;;353    
                          ENDP

                  |L21.144|
                          DCD      pFlash

                          AREA ||i.HAL_FLASHEx_OB_DeSelectPCROP||, CODE, READONLY, ALIGN=2

                  HAL_FLASHEx_OB_DeSelectPCROP PROC
;;;495      */
;;;496    HAL_StatusTypeDef HAL_FLASHEx_OB_DeSelectPCROP(void)
000000  21ff              MOVS     r1,#0xff
;;;497    {
;;;498      uint8_t optiontmp = 0xFF;
;;;499      
;;;500      /* Mask SPRMOD bit */
;;;501      optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE3_ADDRESS) & (uint8_t)0x7F); 
000002  4804              LDR      r0,|L22.20|
000004  7800              LDRB     r0,[r0,#0]
000006  f000017f          AND      r1,r0,#0x7f
;;;502      
;;;503      /* Update Option Byte */
;;;504      *(__IO uint8_t *)OPTCR_BYTE3_ADDRESS = (uint8_t)(OB_PCROP_DESELECTED | optiontmp);  
00000a  4802              LDR      r0,|L22.20|
00000c  7001              STRB     r1,[r0,#0]
;;;505      
;;;506      return HAL_OK;
00000e  2000              MOVS     r0,#0
;;;507    }
000010  4770              BX       lr
;;;508    #endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F401xC || STM32F401xE || STM32F410xx ||\
                          ENDP

000012  0000              DCW      0x0000
                  |L22.20|
                          DCD      0x40023c17

                          AREA ||i.HAL_FLASHEx_OB_GetBank2WRP||, CODE, READONLY, ALIGN=2

                  HAL_FLASHEx_OB_GetBank2WRP PROC
;;;516      */
;;;517    uint16_t HAL_FLASHEx_OB_GetBank2WRP(void)
000000  4801              LDR      r0,|L23.8|
;;;518    {                            
;;;519      /* Return the FLASH write protection Register value */
;;;520      return (*(__IO uint16_t *)(OPTCR1_BYTE2_ADDRESS));
000002  8800              LDRH     r0,[r0,#0]
;;;521    }
000004  4770              BX       lr
;;;522    #endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
                          ENDP

000006  0000              DCW      0x0000
                  |L23.8|
                          DCD      0x40023c1a

                          AREA ||i.HAL_FLASHEx_OB_SelectPCROP||, CODE, READONLY, ALIGN=2

                  HAL_FLASHEx_OB_SelectPCROP PROC
;;;470      */
;;;471    HAL_StatusTypeDef HAL_FLASHEx_OB_SelectPCROP(void)
000000  21ff              MOVS     r1,#0xff
;;;472    {
;;;473      uint8_t optiontmp = 0xFF;
;;;474    
;;;475      /* Mask SPRMOD bit */
;;;476      optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE3_ADDRESS) & (uint8_t)0x7F); 
000002  4805              LDR      r0,|L24.24|
000004  7800              LDRB     r0,[r0,#0]
000006  f000017f          AND      r1,r0,#0x7f
;;;477      
;;;478      /* Update Option Byte */
;;;479      *(__IO uint8_t *)OPTCR_BYTE3_ADDRESS = (uint8_t)(OB_PCROP_SELECTED | optiontmp); 
00000a  f0410080          ORR      r0,r1,#0x80
00000e  4a02              LDR      r2,|L24.24|
000010  7010              STRB     r0,[r2,#0]
;;;480      
;;;481      return HAL_OK;
000012  2000              MOVS     r0,#0
;;;482    }
000014  4770              BX       lr
;;;483    
                          ENDP

000016  0000              DCW      0x0000
                  |L24.24|
                          DCD      0x40023c17

;*** Start embedded assembler ***

#line 1 "HALLIB\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_flash_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___24_stm32f4xx_hal_flash_ex_c_6648b60e____REV16|
#line 388 ".\\CORE\\cmsis_armcc.h"
|__asm___24_stm32f4xx_hal_flash_ex_c_6648b60e____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___24_stm32f4xx_hal_flash_ex_c_6648b60e____REVSH|
#line 402
|__asm___24_stm32f4xx_hal_flash_ex_c_6648b60e____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___24_stm32f4xx_hal_flash_ex_c_6648b60e____RRX|
#line 587
|__asm___24_stm32f4xx_hal_flash_ex_c_6648b60e____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
