; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\stm32f4xx_hal_gpio.o --asm_dir=.\OBJ\ --list_dir=.\OBJ\ --depend=.\obj\stm32f4xx_hal_gpio.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I.\CORE -I.\USER -I.\HALLIB\STM32F4xx_HAL_Driver\Inc -I.\SYSTEM -I.\Hardware -I.\App -I.\DSP_LIB\Include -I.\FreeRTOS -I.\MPU9250\DMP -I.\MPU9250 -I.\RTE\_Project -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=526 -DSTM32F427xx -DSTM32F4 -DUSE_HAL_DRIVER -DSTM32F427xx -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=.\obj\stm32f4xx_hal_gpio.crf HALLIB\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_gpio.c]
                          THUMB

                          AREA ||i.HAL_GPIO_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_DeInit PROC
;;;313      */
;;;314    void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
000000  b5f0              PUSH     {r4-r7,lr}
;;;315    {
000002  460c              MOV      r4,r1
;;;316      uint32_t position;
;;;317      uint32_t ioposition = 0x00;
000004  2500              MOVS     r5,#0
;;;318      uint32_t iocurrent = 0x00;
000006  2200              MOVS     r2,#0
;;;319      uint32_t tmp = 0x00;
000008  2300              MOVS     r3,#0
;;;320    
;;;321      /* Check the parameters */
;;;322      assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
;;;323      
;;;324      /* Configure the port pins */
;;;325      for(position = 0; position < GPIO_NUMBER; position++)
00000a  2100              MOVS     r1,#0
00000c  e09c              B        |L1.328|
                  |L1.14|
;;;326      {
;;;327        /* Get the IO position */
;;;328        ioposition = ((uint32_t)0x01) << position;
00000e  2601              MOVS     r6,#1
000010  fa06f501          LSL      r5,r6,r1
;;;329        /* Get the current IO position */
;;;330        iocurrent = (GPIO_Pin) & ioposition;
000014  ea040205          AND      r2,r4,r5
;;;331    
;;;332        if(iocurrent == ioposition)
000018  42aa              CMP      r2,r5
00001a  d17d              BNE      |L1.280|
;;;333        {
;;;334          /*------------------------- GPIO Mode Configuration --------------------*/
;;;335          /* Configure IO Direction in Input Floating Mode */
;;;336          GPIOx->MODER &= ~(GPIO_MODER_MODER0 << (position * 2));
00001c  6806              LDR      r6,[r0,#0]
00001e  ea4f0c41          LSL      r12,r1,#1
000022  2703              MOVS     r7,#3
000024  fa07f70c          LSL      r7,r7,r12
000028  43be              BICS     r6,r6,r7
00002a  6006              STR      r6,[r0,#0]
;;;337    
;;;338          /* Configure the default Alternate Function in current IO */
;;;339          GPIOx->AFR[position >> 3] &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
00002c  08cf              LSRS     r7,r1,#3
00002e  f1000620          ADD      r6,r0,#0x20
000032  f8566027          LDR      r6,[r6,r7,LSL #2]
000036  074f              LSLS     r7,r1,#29
000038  ea4f6cd7          LSR      r12,r7,#27
00003c  270f              MOVS     r7,#0xf
00003e  fa07f70c          LSL      r7,r7,r12
000042  43be              BICS     r6,r6,r7
000044  ea4f0cd1          LSR      r12,r1,#3
000048  f1000720          ADD      r7,r0,#0x20
00004c  f847602c          STR      r6,[r7,r12,LSL #2]
;;;340    
;;;341          /* Configure the default value for IO Speed */
;;;342          GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
000050  6886              LDR      r6,[r0,#8]
000052  ea4f0c41          LSL      r12,r1,#1
000056  2703              MOVS     r7,#3
000058  fa07f70c          LSL      r7,r7,r12
00005c  43be              BICS     r6,r6,r7
00005e  6086              STR      r6,[r0,#8]
;;;343    
;;;344          /* Configure the default value IO Output Type */
;;;345          GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT_0 << position) ;
000060  6847              LDR      r7,[r0,#4]
000062  2601              MOVS     r6,#1
000064  408e              LSLS     r6,r6,r1
000066  43b7              BICS     r7,r7,r6
000068  6047              STR      r7,[r0,#4]
;;;346    
;;;347          /* Deactivate the Pull-up and Pull-down resistor for the current IO */
;;;348          GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
00006a  68c6              LDR      r6,[r0,#0xc]
00006c  ea4f0c41          LSL      r12,r1,#1
000070  2703              MOVS     r7,#3
000072  fa07f70c          LSL      r7,r7,r12
000076  43be              BICS     r6,r6,r7
000078  60c6              STR      r6,[r0,#0xc]
;;;349    
;;;350          /*------------------------- EXTI Mode Configuration --------------------*/
;;;351          tmp = SYSCFG->EXTICR[position >> 2];
00007a  4e35              LDR      r6,|L1.336|
00007c  088f              LSRS     r7,r1,#2
00007e  f8563027          LDR      r3,[r6,r7,LSL #2]
;;;352          tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
000082  078e              LSLS     r6,r1,#30
000084  0f37              LSRS     r7,r6,#28
000086  260f              MOVS     r6,#0xf
000088  40be              LSLS     r6,r6,r7
00008a  4033              ANDS     r3,r3,r6
;;;353          if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03))))
00008c  4e31              LDR      r6,|L1.340|
00008e  42b0              CMP      r0,r6
000090  d101              BNE      |L1.150|
000092  2600              MOVS     r6,#0
000094  e02d              B        |L1.242|
                  |L1.150|
000096  4e30              LDR      r6,|L1.344|
000098  42b0              CMP      r0,r6
00009a  d101              BNE      |L1.160|
00009c  2601              MOVS     r6,#1
00009e  e028              B        |L1.242|
                  |L1.160|
0000a0  4e2e              LDR      r6,|L1.348|
0000a2  42b0              CMP      r0,r6
0000a4  d101              BNE      |L1.170|
0000a6  2602              MOVS     r6,#2
0000a8  e023              B        |L1.242|
                  |L1.170|
0000aa  4e2d              LDR      r6,|L1.352|
0000ac  42b0              CMP      r0,r6
0000ae  d101              BNE      |L1.180|
0000b0  2603              MOVS     r6,#3
0000b2  e01e              B        |L1.242|
                  |L1.180|
0000b4  4e2b              LDR      r6,|L1.356|
0000b6  42b0              CMP      r0,r6
0000b8  d101              BNE      |L1.190|
0000ba  2604              MOVS     r6,#4
0000bc  e019              B        |L1.242|
                  |L1.190|
0000be  4e2a              LDR      r6,|L1.360|
0000c0  42b0              CMP      r0,r6
0000c2  d101              BNE      |L1.200|
0000c4  2605              MOVS     r6,#5
0000c6  e014              B        |L1.242|
                  |L1.200|
0000c8  4e28              LDR      r6,|L1.364|
0000ca  42b0              CMP      r0,r6
0000cc  d101              BNE      |L1.210|
0000ce  2606              MOVS     r6,#6
0000d0  e00f              B        |L1.242|
                  |L1.210|
0000d2  4e27              LDR      r6,|L1.368|
0000d4  42b0              CMP      r0,r6
0000d6  d101              BNE      |L1.220|
0000d8  2607              MOVS     r6,#7
0000da  e00a              B        |L1.242|
                  |L1.220|
0000dc  4e25              LDR      r6,|L1.372|
0000de  42b0              CMP      r0,r6
0000e0  d101              BNE      |L1.230|
0000e2  2608              MOVS     r6,#8
0000e4  e005              B        |L1.242|
                  |L1.230|
0000e6  4e24              LDR      r6,|L1.376|
0000e8  42b0              CMP      r0,r6
0000ea  d101              BNE      |L1.240|
0000ec  2609              MOVS     r6,#9
0000ee  e000              B        |L1.242|
                  |L1.240|
0000f0  260a              MOVS     r6,#0xa
                  |L1.242|
0000f2  078f              LSLS     r7,r1,#30
0000f4  0f3f              LSRS     r7,r7,#28
0000f6  40be              LSLS     r6,r6,r7
0000f8  429e              CMP      r6,r3
0000fa  d124              BNE      |L1.326|
;;;354          {
;;;355            /* Configure the External Interrupt or event for the current IO */
;;;356            tmp = ((uint32_t)0x0F) << (4 * (position & 0x03));
0000fc  078e              LSLS     r6,r1,#30
0000fe  0f37              LSRS     r7,r6,#28
000100  260f              MOVS     r6,#0xf
000102  fa06f307          LSL      r3,r6,r7
;;;357            SYSCFG->EXTICR[position >> 2] &= ~tmp;
000106  4e12              LDR      r6,|L1.336|
000108  088f              LSRS     r7,r1,#2
00010a  f8566027          LDR      r6,[r6,r7,LSL #2]
00010e  439e              BICS     r6,r6,r3
000110  4f0f              LDR      r7,|L1.336|
000112  ea4f0c91          LSR      r12,r1,#2
000116  e000              B        |L1.282|
                  |L1.280|
000118  e015              B        |L1.326|
                  |L1.282|
00011a  f847602c          STR      r6,[r7,r12,LSL #2]
;;;358    
;;;359            /* Clear EXTI line configuration */
;;;360            EXTI->IMR &= ~((uint32_t)iocurrent);
00011e  4e17              LDR      r6,|L1.380|
000120  6836              LDR      r6,[r6,#0]
000122  4396              BICS     r6,r6,r2
000124  4f15              LDR      r7,|L1.380|
000126  603e              STR      r6,[r7,#0]
;;;361            EXTI->EMR &= ~((uint32_t)iocurrent);
000128  1d3e              ADDS     r6,r7,#4
00012a  6836              LDR      r6,[r6,#0]
00012c  4396              BICS     r6,r6,r2
00012e  1d3f              ADDS     r7,r7,#4
000130  603e              STR      r6,[r7,#0]
;;;362            
;;;363            /* Clear Rising Falling edge configuration */
;;;364            EXTI->RTSR &= ~((uint32_t)iocurrent);
000132  1d3e              ADDS     r6,r7,#4
000134  6836              LDR      r6,[r6,#0]
000136  4396              BICS     r6,r6,r2
000138  1d3f              ADDS     r7,r7,#4
00013a  603e              STR      r6,[r7,#0]
;;;365            EXTI->FTSR &= ~((uint32_t)iocurrent);
00013c  1d3e              ADDS     r6,r7,#4
00013e  6836              LDR      r6,[r6,#0]
000140  4396              BICS     r6,r6,r2
000142  1d3f              ADDS     r7,r7,#4
000144  603e              STR      r6,[r7,#0]
                  |L1.326|
000146  1c49              ADDS     r1,r1,#1              ;325
                  |L1.328|
000148  2910              CMP      r1,#0x10              ;325
00014a  f4ffaf60          BCC      |L1.14|
;;;366          }
;;;367        }
;;;368      }
;;;369    }
00014e  bdf0              POP      {r4-r7,pc}
;;;370    
                          ENDP

                  |L1.336|
                          DCD      0x40013808
                  |L1.340|
                          DCD      0x40020000
                  |L1.344|
                          DCD      0x40020400
                  |L1.348|
                          DCD      0x40020800
                  |L1.352|
                          DCD      0x40020c00
                  |L1.356|
                          DCD      0x40021000
                  |L1.360|
                          DCD      0x40021400
                  |L1.364|
                          DCD      0x40021800
                  |L1.368|
                          DCD      0x40021c00
                  |L1.372|
                          DCD      0x40022000
                  |L1.376|
                          DCD      0x40022400
                  |L1.380|
                          DCD      0x40013c00

                          AREA ||i.HAL_GPIO_EXTI_Callback||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_EXTI_Callback PROC
;;;519      */
;;;520    __weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
000000  b508              PUSH     {r3,lr}
;;;521    {
;;;522      /* Prevent unused argument(s) compilation warning */
;;;523      __IO uint32_t tmpreg = 0x00;
000002  2100              MOVS     r1,#0
000004  9100              STR      r1,[sp,#0]
;;;524      UNUSED(tmpreg); 
000006  bf00              NOP      
;;;525      /* NOTE: This function Should not be modified, when the callback is needed,
;;;526               the HAL_GPIO_EXTI_Callback could be implemented in the user file
;;;527       */
;;;528    }
000008  bd08              POP      {r3,pc}
;;;529    
                          ENDP


                          AREA ||i.HAL_GPIO_EXTI_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_EXTI_IRQHandler PROC
;;;504      */
;;;505    void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
000000  b510              PUSH     {r4,lr}
;;;506    {
000002  4604              MOV      r4,r0
;;;507      /* EXTI line interrupt detected */
;;;508      if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)
000004  4804              LDR      r0,|L3.24|
000006  6800              LDR      r0,[r0,#0]
000008  4020              ANDS     r0,r0,r4
00000a  b120              CBZ      r0,|L3.22|
;;;509      {
;;;510        __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
00000c  4802              LDR      r0,|L3.24|
00000e  6004              STR      r4,[r0,#0]
;;;511        HAL_GPIO_EXTI_Callback(GPIO_Pin);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       HAL_GPIO_EXTI_Callback
                  |L3.22|
;;;512      }
;;;513    }
000016  bd10              POP      {r4,pc}
;;;514    
                          ENDP

                  |L3.24|
                          DCD      0x40013c14

                          AREA ||i.HAL_GPIO_Init||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_Init PROC
;;;188      */
;;;189    void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
000000  b5f8              PUSH     {r3-r7,lr}
;;;190    {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;191      uint32_t position;
;;;192      uint32_t ioposition = 0x00;
000006  2500              MOVS     r5,#0
;;;193      uint32_t iocurrent = 0x00;
000008  2400              MOVS     r4,#0
;;;194      uint32_t temp = 0x00;
00000a  2000              MOVS     r0,#0
;;;195    
;;;196      /* Check the parameters */
;;;197      assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
;;;198      assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
;;;199      assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
;;;200      assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
;;;201    
;;;202      /* Configure the port pins */
;;;203      for(position = 0; position < GPIO_NUMBER; position++)
00000c  2100              MOVS     r1,#0
00000e  e0e6              B        |L4.478|
                  |L4.16|
;;;204      {
;;;205        /* Get the IO position */
;;;206        ioposition = ((uint32_t)0x01) << position;
000010  2601              MOVS     r6,#1
000012  fa06f501          LSL      r5,r6,r1
;;;207        /* Get the current IO position */
;;;208        iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
000016  681e              LDR      r6,[r3,#0]
000018  ea060405          AND      r4,r6,r5
;;;209    
;;;210        if(iocurrent == ioposition)
00001c  42ac              CMP      r4,r5
                  |L4.30|
00001e  d173              BNE      |L4.264|
;;;211        {
;;;212          /*--------------------- GPIO Mode Configuration ------------------------*/
;;;213          /* In case of Alternate function mode selection */
;;;214          if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
000020  685e              LDR      r6,[r3,#4]
000022  2e02              CMP      r6,#2
000024  d002              BEQ      |L4.44|
000026  685e              LDR      r6,[r3,#4]
000028  2e12              CMP      r6,#0x12
00002a  d113              BNE      |L4.84|
                  |L4.44|
;;;215          {
;;;216            /* Check the Alternate function parameter */
;;;217            assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
;;;218            /* Configure Alternate function mapped with the current IO */
;;;219            temp = GPIOx->AFR[position >> 3];
00002c  08cf              LSRS     r7,r1,#3
00002e  f1020620          ADD      r6,r2,#0x20
000032  f8560027          LDR      r0,[r6,r7,LSL #2]
;;;220            temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
000036  074e              LSLS     r6,r1,#29
000038  0ef7              LSRS     r7,r6,#27
00003a  260f              MOVS     r6,#0xf
00003c  40be              LSLS     r6,r6,r7
00003e  43b0              BICS     r0,r0,r6
;;;221            temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
000040  074f              LSLS     r7,r1,#29
000042  0eff              LSRS     r7,r7,#27
000044  691e              LDR      r6,[r3,#0x10]
000046  40be              LSLS     r6,r6,r7
000048  4330              ORRS     r0,r0,r6
;;;222            GPIOx->AFR[position >> 3] = temp;
00004a  08cf              LSRS     r7,r1,#3
00004c  f1020620          ADD      r6,r2,#0x20
000050  f8460027          STR      r0,[r6,r7,LSL #2]
                  |L4.84|
;;;223          }
;;;224    
;;;225          /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
;;;226          temp = GPIOx->MODER;
000054  6810              LDR      r0,[r2,#0]
;;;227          temp &= ~(GPIO_MODER_MODER0 << (position * 2));
000056  004f              LSLS     r7,r1,#1
000058  2603              MOVS     r6,#3
00005a  40be              LSLS     r6,r6,r7
00005c  43b0              BICS     r0,r0,r6
;;;228          temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
00005e  791e              LDRB     r6,[r3,#4]
000060  f0060603          AND      r6,r6,#3
000064  004f              LSLS     r7,r1,#1
000066  40be              LSLS     r6,r6,r7
000068  4330              ORRS     r0,r0,r6
;;;229          GPIOx->MODER = temp;
00006a  6010              STR      r0,[r2,#0]
;;;230    
;;;231          /* In case of Output or Alternate function mode selection */
;;;232          if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
00006c  685e              LDR      r6,[r3,#4]
00006e  2e01              CMP      r6,#1
000070  d008              BEQ      |L4.132|
000072  685e              LDR      r6,[r3,#4]
000074  2e02              CMP      r6,#2
000076  d005              BEQ      |L4.132|
;;;233             (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
000078  685e              LDR      r6,[r3,#4]
00007a  2e11              CMP      r6,#0x11
00007c  d002              BEQ      |L4.132|
00007e  685e              LDR      r6,[r3,#4]
000080  2e12              CMP      r6,#0x12
000082  d113              BNE      |L4.172|
                  |L4.132|
;;;234          {
;;;235            /* Check the Speed parameter */
;;;236            assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
;;;237            /* Configure the IO Speed */
;;;238            temp = GPIOx->OSPEEDR; 
000084  6890              LDR      r0,[r2,#8]
;;;239            temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
000086  004f              LSLS     r7,r1,#1
000088  2603              MOVS     r6,#3
00008a  40be              LSLS     r6,r6,r7
00008c  43b0              BICS     r0,r0,r6
;;;240            temp |= (GPIO_Init->Speed << (position * 2));
00008e  004f              LSLS     r7,r1,#1
000090  68de              LDR      r6,[r3,#0xc]
000092  40be              LSLS     r6,r6,r7
000094  4330              ORRS     r0,r0,r6
;;;241            GPIOx->OSPEEDR = temp;
000096  6090              STR      r0,[r2,#8]
;;;242    
;;;243            /* Configure the IO Output Type */
;;;244            temp = GPIOx->OTYPER;
000098  6850              LDR      r0,[r2,#4]
;;;245            temp &= ~(GPIO_OTYPER_OT_0 << position) ;
00009a  2601              MOVS     r6,#1
00009c  408e              LSLS     r6,r6,r1
00009e  43b0              BICS     r0,r0,r6
;;;246            temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
0000a0  791e              LDRB     r6,[r3,#4]
0000a2  f3c61600          UBFX     r6,r6,#4,#1
0000a6  408e              LSLS     r6,r6,r1
0000a8  4330              ORRS     r0,r0,r6
;;;247            GPIOx->OTYPER = temp;
0000aa  6050              STR      r0,[r2,#4]
                  |L4.172|
;;;248          }
;;;249    
;;;250          /* Activate the Pull-up or Pull down resistor for the current IO */
;;;251          temp = GPIOx->PUPDR;
0000ac  68d0              LDR      r0,[r2,#0xc]
;;;252          temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
0000ae  004f              LSLS     r7,r1,#1
0000b0  2603              MOVS     r6,#3
0000b2  40be              LSLS     r6,r6,r7
0000b4  43b0              BICS     r0,r0,r6
;;;253          temp |= ((GPIO_Init->Pull) << (position * 2));
0000b6  004f              LSLS     r7,r1,#1
0000b8  689e              LDR      r6,[r3,#8]
0000ba  40be              LSLS     r6,r6,r7
0000bc  4330              ORRS     r0,r0,r6
;;;254          GPIOx->PUPDR = temp;
0000be  60d0              STR      r0,[r2,#0xc]
;;;255    
;;;256          /*--------------------- EXTI Mode Configuration ------------------------*/
;;;257          /* Configure the External Interrupt or event for the current IO */
;;;258          if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
0000c0  685e              LDR      r6,[r3,#4]
0000c2  f0065680          AND      r6,r6,#0x10000000
0000c6  f1b65f80          CMP      r6,#0x10000000
0000ca  d1a8              BNE      |L4.30|
;;;259          {
;;;260            /* Enable SYSCFG Clock */
;;;261            __HAL_RCC_SYSCFG_CLK_ENABLE();
0000cc  bf00              NOP      
0000ce  2600              MOVS     r6,#0
0000d0  9600              STR      r6,[sp,#0]
0000d2  4e45              LDR      r6,|L4.488|
0000d4  6836              LDR      r6,[r6,#0]
0000d6  f4464680          ORR      r6,r6,#0x4000
0000da  4f43              LDR      r7,|L4.488|
0000dc  603e              STR      r6,[r7,#0]
0000de  463e              MOV      r6,r7
0000e0  6836              LDR      r6,[r6,#0]
0000e2  f4064680          AND      r6,r6,#0x4000
0000e6  9600              STR      r6,[sp,#0]
0000e8  bf00              NOP      
0000ea  bf00              NOP      
;;;262    
;;;263            temp = SYSCFG->EXTICR[position >> 2];
0000ec  4e3f              LDR      r6,|L4.492|
0000ee  088f              LSRS     r7,r1,#2
0000f0  f8560027          LDR      r0,[r6,r7,LSL #2]
;;;264            temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
0000f4  078e              LSLS     r6,r1,#30
0000f6  0f37              LSRS     r7,r6,#28
0000f8  260f              MOVS     r6,#0xf
0000fa  40be              LSLS     r6,r6,r7
0000fc  43b0              BICS     r0,r0,r6
;;;265            temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
0000fe  4e3c              LDR      r6,|L4.496|
000100  42b2              CMP      r2,r6
000102  d102              BNE      |L4.266|
000104  2600              MOVS     r6,#0
000106  e02e              B        |L4.358|
                  |L4.264|
000108  e068              B        |L4.476|
                  |L4.266|
00010a  4e3a              LDR      r6,|L4.500|
00010c  42b2              CMP      r2,r6
00010e  d101              BNE      |L4.276|
000110  2601              MOVS     r6,#1
000112  e028              B        |L4.358|
                  |L4.276|
000114  4e38              LDR      r6,|L4.504|
000116  42b2              CMP      r2,r6
000118  d101              BNE      |L4.286|
00011a  2602              MOVS     r6,#2
00011c  e023              B        |L4.358|
                  |L4.286|
00011e  4e37              LDR      r6,|L4.508|
000120  42b2              CMP      r2,r6
000122  d101              BNE      |L4.296|
000124  2603              MOVS     r6,#3
000126  e01e              B        |L4.358|
                  |L4.296|
000128  4e35              LDR      r6,|L4.512|
00012a  42b2              CMP      r2,r6
00012c  d101              BNE      |L4.306|
00012e  2604              MOVS     r6,#4
000130  e019              B        |L4.358|
                  |L4.306|
000132  4e34              LDR      r6,|L4.516|
000134  42b2              CMP      r2,r6
000136  d101              BNE      |L4.316|
000138  2605              MOVS     r6,#5
00013a  e014              B        |L4.358|
                  |L4.316|
00013c  4e32              LDR      r6,|L4.520|
00013e  42b2              CMP      r2,r6
000140  d101              BNE      |L4.326|
000142  2606              MOVS     r6,#6
000144  e00f              B        |L4.358|
                  |L4.326|
000146  4e31              LDR      r6,|L4.524|
000148  42b2              CMP      r2,r6
00014a  d101              BNE      |L4.336|
00014c  2607              MOVS     r6,#7
00014e  e00a              B        |L4.358|
                  |L4.336|
000150  4e2f              LDR      r6,|L4.528|
000152  42b2              CMP      r2,r6
000154  d101              BNE      |L4.346|
000156  2608              MOVS     r6,#8
000158  e005              B        |L4.358|
                  |L4.346|
00015a  4e2e              LDR      r6,|L4.532|
00015c  42b2              CMP      r2,r6
00015e  d101              BNE      |L4.356|
000160  2609              MOVS     r6,#9
000162  e000              B        |L4.358|
                  |L4.356|
000164  260a              MOVS     r6,#0xa
                  |L4.358|
000166  078f              LSLS     r7,r1,#30
000168  0f3f              LSRS     r7,r7,#28
00016a  40be              LSLS     r6,r6,r7
00016c  4330              ORRS     r0,r0,r6
;;;266            SYSCFG->EXTICR[position >> 2] = temp;
00016e  4e1f              LDR      r6,|L4.492|
000170  088f              LSRS     r7,r1,#2
000172  f8460027          STR      r0,[r6,r7,LSL #2]
;;;267    
;;;268            /* Clear EXTI line configuration */
;;;269            temp = EXTI->IMR;
000176  4e28              LDR      r6,|L4.536|
000178  6830              LDR      r0,[r6,#0]
;;;270            temp &= ~((uint32_t)iocurrent);
00017a  43a0              BICS     r0,r0,r4
;;;271            if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
00017c  685e              LDR      r6,[r3,#4]
00017e  f4063680          AND      r6,r6,#0x10000
000182  f5b63f80          CMP      r6,#0x10000
000186  d100              BNE      |L4.394|
;;;272            {
;;;273              temp |= iocurrent;
000188  4320              ORRS     r0,r0,r4
                  |L4.394|
;;;274            }
;;;275            EXTI->IMR = temp;
00018a  4e23              LDR      r6,|L4.536|
00018c  6030              STR      r0,[r6,#0]
;;;276    
;;;277            temp = EXTI->EMR;
00018e  1d36              ADDS     r6,r6,#4
000190  6830              LDR      r0,[r6,#0]
;;;278            temp &= ~((uint32_t)iocurrent);
000192  43a0              BICS     r0,r0,r4
;;;279            if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
000194  685e              LDR      r6,[r3,#4]
000196  f4063600          AND      r6,r6,#0x20000
00019a  f5b63f00          CMP      r6,#0x20000
00019e  d100              BNE      |L4.418|
;;;280            {
;;;281              temp |= iocurrent;
0001a0  4320              ORRS     r0,r0,r4
                  |L4.418|
;;;282            }
;;;283            EXTI->EMR = temp;
0001a2  4e1d              LDR      r6,|L4.536|
0001a4  1d36              ADDS     r6,r6,#4
0001a6  6030              STR      r0,[r6,#0]
;;;284    
;;;285            /* Clear Rising Falling edge configuration */
;;;286            temp = EXTI->RTSR;
0001a8  1d36              ADDS     r6,r6,#4
0001aa  6830              LDR      r0,[r6,#0]
;;;287            temp &= ~((uint32_t)iocurrent);
0001ac  43a0              BICS     r0,r0,r4
;;;288            if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
0001ae  685e              LDR      r6,[r3,#4]
0001b0  f4061680          AND      r6,r6,#0x100000
0001b4  f5b61f80          CMP      r6,#0x100000
0001b8  d100              BNE      |L4.444|
;;;289            {
;;;290              temp |= iocurrent;
0001ba  4320              ORRS     r0,r0,r4
                  |L4.444|
;;;291            }
;;;292            EXTI->RTSR = temp;
0001bc  4e16              LDR      r6,|L4.536|
0001be  3608              ADDS     r6,r6,#8
0001c0  6030              STR      r0,[r6,#0]
;;;293    
;;;294            temp = EXTI->FTSR;
0001c2  1d36              ADDS     r6,r6,#4
0001c4  6830              LDR      r0,[r6,#0]
;;;295            temp &= ~((uint32_t)iocurrent);
0001c6  43a0              BICS     r0,r0,r4
;;;296            if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
0001c8  685e              LDR      r6,[r3,#4]
0001ca  f4061600          AND      r6,r6,#0x200000
0001ce  f5b61f00          CMP      r6,#0x200000
0001d2  d100              BNE      |L4.470|
;;;297            {
;;;298              temp |= iocurrent;
0001d4  4320              ORRS     r0,r0,r4
                  |L4.470|
;;;299            }
;;;300            EXTI->FTSR = temp;
0001d6  4e10              LDR      r6,|L4.536|
0001d8  360c              ADDS     r6,r6,#0xc
0001da  6030              STR      r0,[r6,#0]
                  |L4.476|
0001dc  1c49              ADDS     r1,r1,#1              ;203
                  |L4.478|
0001de  2910              CMP      r1,#0x10              ;203
0001e0  f4ffaf16          BCC      |L4.16|
;;;301          }
;;;302        }
;;;303      }
;;;304    }
0001e4  bdf8              POP      {r3-r7,pc}
;;;305    
                          ENDP

0001e6  0000              DCW      0x0000
                  |L4.488|
                          DCD      0x40023844
                  |L4.492|
                          DCD      0x40013808
                  |L4.496|
                          DCD      0x40020000
                  |L4.500|
                          DCD      0x40020400
                  |L4.504|
                          DCD      0x40020800
                  |L4.508|
                          DCD      0x40020c00
                  |L4.512|
                          DCD      0x40021000
                  |L4.516|
                          DCD      0x40021400
                  |L4.520|
                          DCD      0x40021800
                  |L4.524|
                          DCD      0x40021c00
                  |L4.528|
                          DCD      0x40022000
                  |L4.532|
                          DCD      0x40022400
                  |L4.536|
                          DCD      0x40013c00

                          AREA ||i.HAL_GPIO_LockPin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_LockPin PROC
;;;471      */
;;;472    HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  b508              PUSH     {r3,lr}
;;;473    {
000002  4602              MOV      r2,r0
;;;474      __IO uint32_t tmp = GPIO_LCKR_LCKK;
000004  f44f3080          MOV      r0,#0x10000
000008  9000              STR      r0,[sp,#0]
;;;475    
;;;476      /* Check the parameters */
;;;477      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;478    
;;;479      /* Apply lock key write sequence */
;;;480      tmp |= GPIO_Pin;
00000a  9800              LDR      r0,[sp,#0]
00000c  4308              ORRS     r0,r0,r1
00000e  9000              STR      r0,[sp,#0]
;;;481      /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
;;;482      GPIOx->LCKR = tmp;
000010  9800              LDR      r0,[sp,#0]
000012  61d0              STR      r0,[r2,#0x1c]
;;;483      /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
;;;484      GPIOx->LCKR = GPIO_Pin;
000014  61d1              STR      r1,[r2,#0x1c]
;;;485      /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
;;;486      GPIOx->LCKR = tmp;
000016  9800              LDR      r0,[sp,#0]
000018  61d0              STR      r0,[r2,#0x1c]
;;;487      /* Read LCKK bit*/
;;;488      tmp = GPIOx->LCKR;
00001a  69d0              LDR      r0,[r2,#0x1c]
00001c  9000              STR      r0,[sp,#0]
;;;489    
;;;490     if((GPIOx->LCKR & GPIO_LCKR_LCKK) != RESET)
00001e  69d0              LDR      r0,[r2,#0x1c]
000020  f4003080          AND      r0,r0,#0x10000
000024  b108              CBZ      r0,|L5.42|
;;;491      {
;;;492        return HAL_OK;
000026  2000              MOVS     r0,#0
                  |L5.40|
;;;493      }
;;;494      else
;;;495      {
;;;496        return HAL_ERROR;
;;;497      }
;;;498    }
000028  bd08              POP      {r3,pc}
                  |L5.42|
00002a  2001              MOVS     r0,#1                 ;496
00002c  e7fc              B        |L5.40|
;;;499    
                          ENDP


                          AREA ||i.HAL_GPIO_ReadPin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_ReadPin PROC
;;;394      */
;;;395    GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  4602              MOV      r2,r0
;;;396    {
;;;397      GPIO_PinState bitstatus;
;;;398    
;;;399      /* Check the parameters */
;;;400      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;401    
;;;402      if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
000002  6913              LDR      r3,[r2,#0x10]
000004  400b              ANDS     r3,r3,r1
000006  b10b              CBZ      r3,|L6.12|
;;;403      {
;;;404        bitstatus = GPIO_PIN_SET;
000008  2001              MOVS     r0,#1
00000a  e000              B        |L6.14|
                  |L6.12|
;;;405      }
;;;406      else
;;;407      {
;;;408        bitstatus = GPIO_PIN_RESET;
00000c  2000              MOVS     r0,#0
                  |L6.14|
;;;409      }
;;;410      return bitstatus;
;;;411    }
00000e  4770              BX       lr
;;;412    
                          ENDP


                          AREA ||i.HAL_GPIO_TogglePin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_TogglePin PROC
;;;452      */
;;;453    void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  6942              LDR      r2,[r0,#0x14]
;;;454    {
;;;455      /* Check the parameters */
;;;456      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;457    
;;;458      GPIOx->ODR ^= GPIO_Pin;
000002  404a              EORS     r2,r2,r1
000004  6142              STR      r2,[r0,#0x14]
;;;459    }
000006  4770              BX       lr
;;;460    
                          ENDP


                          AREA ||i.HAL_GPIO_WritePin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_WritePin PROC
;;;429      */
;;;430    void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
000000  b10a              CBZ      r2,|L8.6|
;;;431    {
;;;432      /* Check the parameters */
;;;433      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;434      assert_param(IS_GPIO_PIN_ACTION(PinState));
;;;435    
;;;436      if(PinState != GPIO_PIN_RESET)
;;;437      {
;;;438        GPIOx->BSRR = GPIO_Pin;
000002  6181              STR      r1,[r0,#0x18]
000004  e001              B        |L8.10|
                  |L8.6|
;;;439      }
;;;440      else
;;;441      {
;;;442        GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
000006  040b              LSLS     r3,r1,#16
000008  6183              STR      r3,[r0,#0x18]
                  |L8.10|
;;;443      }
;;;444    }
00000a  4770              BX       lr
;;;445    
                          ENDP


;*** Start embedded assembler ***

#line 1 "HALLIB\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_gpio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_hal_gpio_c_ea787061____REV16|
#line 388 ".\\CORE\\cmsis_armcc.h"
|__asm___20_stm32f4xx_hal_gpio_c_ea787061____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_hal_gpio_c_ea787061____REVSH|
#line 402
|__asm___20_stm32f4xx_hal_gpio_c_ea787061____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_hal_gpio_c_ea787061____RRX|
#line 587
|__asm___20_stm32f4xx_hal_gpio_c_ea787061____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
