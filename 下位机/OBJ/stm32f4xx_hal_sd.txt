; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\stm32f4xx_hal_sd.o --asm_dir=.\OBJ\ --list_dir=.\OBJ\ --depend=.\obj\stm32f4xx_hal_sd.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I.\CORE -I.\USER -I.\HALLIB\STM32F4xx_HAL_Driver\Inc -I.\SYSTEM -I.\Hardware -I.\App -I.\DSP_LIB\Include -I.\FreeRTOS -I.\MPU9250\DMP -I.\MPU9250 -I.\RTE\_Project -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=526 -DSTM32F427xx -DSTM32F4 -DUSE_HAL_DRIVER -DSTM32F427xx -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=.\obj\stm32f4xx_hal_sd.crf HALLIB\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_sd.c]
                          THUMB

                          AREA ||i.HAL_SD_CheckReadOperation||, CODE, READONLY, ALIGN=1

                  HAL_SD_CheckReadOperation PROC
;;;1137     */
;;;1138   HAL_SD_ErrorTypedef HAL_SD_CheckReadOperation(SD_HandleTypeDef *hsd, uint32_t Timeout)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1139   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;1140     HAL_SD_ErrorTypedef errorstate = SD_OK;
000008  2700              MOVS     r7,#0
;;;1141     uint32_t timeout = Timeout;
00000a  4635              MOV      r5,r6
;;;1142     uint32_t tmp1, tmp2;
;;;1143     HAL_SD_ErrorTypedef tmp3;
;;;1144     
;;;1145     /* Wait for DMA/SD transfer end or SD error variables to be in SD handle */
;;;1146     tmp1 = hsd->DmaTransferCplt; 
00000c  f8d48050          LDR      r8,[r4,#0x50]
;;;1147     tmp2 = hsd->SdTransferCplt;
000010  f8d49048          LDR      r9,[r4,#0x48]
;;;1148     tmp3 = (HAL_SD_ErrorTypedef)hsd->SdTransferErr;
000014  6ce0              LDR      r0,[r4,#0x4c]
000016  f0000aff          AND      r10,r0,#0xff
;;;1149       
;;;1150     while ((tmp1 == 0) && (tmp2 == 0) && (tmp3 == SD_OK) && (timeout > 0))
00001a  e007              B        |L1.44|
                  |L1.28|
;;;1151     {
;;;1152       tmp1 = hsd->DmaTransferCplt; 
00001c  f8d48050          LDR      r8,[r4,#0x50]
;;;1153       tmp2 = hsd->SdTransferCplt;
000020  f8d49048          LDR      r9,[r4,#0x48]
;;;1154       tmp3 = (HAL_SD_ErrorTypedef)hsd->SdTransferErr;    
000024  6ce0              LDR      r0,[r4,#0x4c]
000026  f0000aff          AND      r10,r0,#0xff
;;;1155       timeout--;
00002a  1e6d              SUBS     r5,r5,#1
                  |L1.44|
00002c  f1b80f00          CMP      r8,#0                 ;1150
000030  d107              BNE      |L1.66|
000032  f1b90f00          CMP      r9,#0                 ;1150
000036  d104              BNE      |L1.66|
000038  f1ba0f00          CMP      r10,#0                ;1150
00003c  d101              BNE      |L1.66|
00003e  2d00              CMP      r5,#0                 ;1150
000040  d1ec              BNE      |L1.28|
                  |L1.66|
;;;1156     }
;;;1157     
;;;1158     timeout = Timeout;
000042  4635              MOV      r5,r6
;;;1159     
;;;1160     /* Wait until the Rx transfer is no longer active */
;;;1161     while((__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXACT)) && (timeout > 0))
000044  e000              B        |L1.72|
                  |L1.70|
;;;1162     {
;;;1163       timeout--;  
000046  1e6d              SUBS     r5,r5,#1
                  |L1.72|
000048  6820              LDR      r0,[r4,#0]            ;1161
00004a  6b40              LDR      r0,[r0,#0x34]         ;1161
00004c  f4005000          AND      r0,r0,#0x2000         ;1161
000050  b108              CBZ      r0,|L1.86|
000052  2d00              CMP      r5,#0                 ;1161
000054  d1f7              BNE      |L1.70|
                  |L1.86|
;;;1164     }
;;;1165     
;;;1166     /* Send stop command in multiblock read */
;;;1167     if (hsd->SdOperation == SD_READ_MULTIPLE_BLOCK)
000056  6d60              LDR      r0,[r4,#0x54]
000058  2801              CMP      r0,#1
00005a  d103              BNE      |L1.100|
;;;1168     {
;;;1169       errorstate = HAL_SD_StopTransfer(hsd);
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       HAL_SD_StopTransfer
000062  4607              MOV      r7,r0
                  |L1.100|
;;;1170     }
;;;1171     
;;;1172     if ((timeout == 0) && (errorstate == SD_OK))
000064  b90d              CBNZ     r5,|L1.106|
000066  b907              CBNZ     r7,|L1.106|
;;;1173     {
;;;1174       errorstate = SD_DATA_TIMEOUT;
000068  2704              MOVS     r7,#4
                  |L1.106|
;;;1175     }
;;;1176     
;;;1177     /* Clear all the static flags */
;;;1178     __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
00006a  f24050ff          MOV      r0,#0x5ff
00006e  6821              LDR      r1,[r4,#0]
000070  6388              STR      r0,[r1,#0x38]
;;;1179     
;;;1180     /* Return error state */
;;;1181     if (hsd->SdTransferErr != SD_OK)
000072  6ce0              LDR      r0,[r4,#0x4c]
000074  b118              CBZ      r0,|L1.126|
;;;1182     {
;;;1183       return (HAL_SD_ErrorTypedef)(hsd->SdTransferErr);
000076  6ce0              LDR      r0,[r4,#0x4c]
000078  b2c0              UXTB     r0,r0
                  |L1.122|
;;;1184     }
;;;1185     
;;;1186     return errorstate;
;;;1187   }
00007a  e8bd87f0          POP      {r4-r10,pc}
                  |L1.126|
00007e  4638              MOV      r0,r7                 ;1186
000080  e7fb              B        |L1.122|
;;;1188   
                          ENDP


                          AREA ||i.HAL_SD_CheckWriteOperation||, CODE, READONLY, ALIGN=1

                  HAL_SD_CheckWriteOperation PROC
;;;1197     */
;;;1198   HAL_SD_ErrorTypedef HAL_SD_CheckWriteOperation(SD_HandleTypeDef *hsd, uint32_t Timeout)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1199   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;1200     HAL_SD_ErrorTypedef errorstate = SD_OK;
000008  2700              MOVS     r7,#0
;;;1201     uint32_t timeout = Timeout;
00000a  4635              MOV      r5,r6
;;;1202     uint32_t tmp1, tmp2;
;;;1203     HAL_SD_ErrorTypedef tmp3;
;;;1204   
;;;1205     /* Wait for DMA/SD transfer end or SD error variables to be in SD handle */
;;;1206     tmp1 = hsd->DmaTransferCplt; 
00000c  f8d48050          LDR      r8,[r4,#0x50]
;;;1207     tmp2 = hsd->SdTransferCplt;
000010  f8d49048          LDR      r9,[r4,#0x48]
;;;1208     tmp3 = (HAL_SD_ErrorTypedef)hsd->SdTransferErr;
000014  6ce0              LDR      r0,[r4,#0x4c]
000016  f0000aff          AND      r10,r0,#0xff
;;;1209       
;;;1210     while ((tmp1 == 0) && (tmp2 == 0) && (tmp3 == SD_OK) && (timeout > 0))
00001a  e007              B        |L2.44|
                  |L2.28|
;;;1211     {
;;;1212       tmp1 = hsd->DmaTransferCplt; 
00001c  f8d48050          LDR      r8,[r4,#0x50]
;;;1213       tmp2 = hsd->SdTransferCplt;
000020  f8d49048          LDR      r9,[r4,#0x48]
;;;1214       tmp3 = (HAL_SD_ErrorTypedef)hsd->SdTransferErr;
000024  6ce0              LDR      r0,[r4,#0x4c]
000026  f0000aff          AND      r10,r0,#0xff
;;;1215       timeout--;
00002a  1e6d              SUBS     r5,r5,#1
                  |L2.44|
00002c  f1b80f00          CMP      r8,#0                 ;1210
000030  d107              BNE      |L2.66|
000032  f1b90f00          CMP      r9,#0                 ;1210
000036  d104              BNE      |L2.66|
000038  f1ba0f00          CMP      r10,#0                ;1210
00003c  d101              BNE      |L2.66|
00003e  2d00              CMP      r5,#0                 ;1210
000040  d1ec              BNE      |L2.28|
                  |L2.66|
;;;1216     }
;;;1217     
;;;1218     timeout = Timeout;
000042  4635              MOV      r5,r6
;;;1219     
;;;1220     /* Wait until the Tx transfer is no longer active */
;;;1221     while((__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXACT))  && (timeout > 0))
000044  e000              B        |L2.72|
                  |L2.70|
;;;1222     {
;;;1223       timeout--;  
000046  1e6d              SUBS     r5,r5,#1
                  |L2.72|
000048  6820              LDR      r0,[r4,#0]            ;1221
00004a  6b40              LDR      r0,[r0,#0x34]         ;1221
00004c  f4005080          AND      r0,r0,#0x1000         ;1221
000050  b108              CBZ      r0,|L2.86|
000052  2d00              CMP      r5,#0                 ;1221
000054  d1f7              BNE      |L2.70|
                  |L2.86|
;;;1224     }
;;;1225   
;;;1226     /* Send stop command in multiblock write */
;;;1227     if (hsd->SdOperation == SD_WRITE_MULTIPLE_BLOCK)
000056  6d60              LDR      r0,[r4,#0x54]
000058  2803              CMP      r0,#3
00005a  d103              BNE      |L2.100|
;;;1228     {
;;;1229       errorstate = HAL_SD_StopTransfer(hsd);
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       HAL_SD_StopTransfer
000062  4607              MOV      r7,r0
                  |L2.100|
;;;1230     }
;;;1231     
;;;1232     if ((timeout == 0) && (errorstate == SD_OK))
000064  b90d              CBNZ     r5,|L2.106|
000066  b907              CBNZ     r7,|L2.106|
;;;1233     {
;;;1234       errorstate = SD_DATA_TIMEOUT;
000068  2704              MOVS     r7,#4
                  |L2.106|
;;;1235     }
;;;1236     
;;;1237     /* Clear all the static flags */
;;;1238     __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
00006a  f24050ff          MOV      r0,#0x5ff
00006e  6821              LDR      r1,[r4,#0]
000070  6388              STR      r0,[r1,#0x38]
;;;1239     
;;;1240     /* Return error state */
;;;1241     if (hsd->SdTransferErr != SD_OK)
000072  6ce0              LDR      r0,[r4,#0x4c]
000074  b118              CBZ      r0,|L2.126|
;;;1242     {
;;;1243       return (HAL_SD_ErrorTypedef)(hsd->SdTransferErr);
000076  6ce0              LDR      r0,[r4,#0x4c]
000078  b2c0              UXTB     r0,r0
                  |L2.122|
;;;1244     }
;;;1245     
;;;1246     /* Wait until write is complete */
;;;1247     while(HAL_SD_GetStatus(hsd) != SD_TRANSFER_OK)
;;;1248     {    
;;;1249     }
;;;1250   
;;;1251     return errorstate; 
;;;1252   }
00007a  e8bd87f0          POP      {r4-r10,pc}
                  |L2.126|
00007e  bf00              NOP                            ;1247
                  |L2.128|
000080  4620              MOV      r0,r4                 ;1247
000082  f7fffffe          BL       HAL_SD_GetStatus
000086  2800              CMP      r0,#0                 ;1247
000088  d1fa              BNE      |L2.128|
00008a  4638              MOV      r0,r7                 ;1251
00008c  e7f5              B        |L2.122|
;;;1253   
                          ENDP


                          AREA ||i.HAL_SD_DMA_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SD_DMA_RxCpltCallback PROC
;;;1474     */
;;;1475   __weak void HAL_SD_DMA_RxCpltCallback(DMA_HandleTypeDef *hdma)
000000  4770              BX       lr
;;;1476   {
;;;1477     /* Prevent unused argument(s) compilation warning */
;;;1478     UNUSED(hdma);
;;;1479     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1480               the HAL_SD_DMA_RxCpltCallback could be implemented in the user file
;;;1481      */ 
;;;1482   }  
;;;1483   
                          ENDP


                          AREA ||i.HAL_SD_DMA_RxErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_SD_DMA_RxErrorCallback PROC
;;;1489     */
;;;1490   __weak void HAL_SD_DMA_RxErrorCallback(DMA_HandleTypeDef *hdma)
000000  4770              BX       lr
;;;1491   {
;;;1492     /* Prevent unused argument(s) compilation warning */
;;;1493     UNUSED(hdma);
;;;1494     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1495               the HAL_SD_DMA_RxErrorCallback could be implemented in the user file
;;;1496      */ 
;;;1497   }
;;;1498   
                          ENDP


                          AREA ||i.HAL_SD_DMA_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SD_DMA_TxCpltCallback PROC
;;;1504     */
;;;1505   __weak void HAL_SD_DMA_TxCpltCallback(DMA_HandleTypeDef *hdma)
000000  4770              BX       lr
;;;1506   {
;;;1507     /* Prevent unused argument(s) compilation warning */
;;;1508     UNUSED(hdma);
;;;1509     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1510               the HAL_SD_DMA_TxCpltCallback could be implemented in the user file
;;;1511      */ 
;;;1512   }  
;;;1513   
                          ENDP


                          AREA ||i.HAL_SD_DMA_TxErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_SD_DMA_TxErrorCallback PROC
;;;1519     */
;;;1520   __weak void HAL_SD_DMA_TxErrorCallback(DMA_HandleTypeDef *hdma)
000000  4770              BX       lr
;;;1521   {
;;;1522     /* Prevent unused argument(s) compilation warning */
;;;1523     UNUSED(hdma);
;;;1524     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1525               the HAL_SD_DMA_TxErrorCallback could be implemented in the user file
;;;1526      */ 
;;;1527   }
;;;1528   
                          ENDP


                          AREA ||i.HAL_SD_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_SD_DeInit PROC
;;;397      */
;;;398    HAL_StatusTypeDef HAL_SD_DeInit(SD_HandleTypeDef *hsd)
000000  b510              PUSH     {r4,lr}
;;;399    {
000002  4604              MOV      r4,r0
;;;400      
;;;401      /* Set SD power state to off */ 
;;;402      SD_PowerOFF(hsd);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       SD_PowerOFF
;;;403      
;;;404      /* De-Initialize the MSP layer */
;;;405      HAL_SD_MspDeInit(hsd);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       HAL_SD_MspDeInit
;;;406      
;;;407      return HAL_OK;
000010  2000              MOVS     r0,#0
;;;408    }
000012  bd10              POP      {r4,pc}
;;;409    
                          ENDP


                          AREA ||i.HAL_SD_Erase||, CODE, READONLY, ALIGN=2

                  HAL_SD_Erase PROC
;;;1260     */
;;;1261   HAL_SD_ErrorTypedef HAL_SD_Erase(SD_HandleTypeDef *hsd, uint64_t startaddr, uint64_t endaddr)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1262   {
000004  b088              SUB      sp,sp,#0x20
000006  4604              MOV      r4,r0
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
00000c  e9dd7810          LDRD     r7,r8,[sp,#0x40]
;;;1263     HAL_SD_ErrorTypedef errorstate = SD_OK;
000010  f04f0900          MOV      r9,#0
;;;1264     SDIO_CmdInitTypeDef sdio_cmdinitstructure;
;;;1265     
;;;1266     uint32_t delay         = 0;
000014  46ca              MOV      r10,r9
;;;1267     __IO uint32_t maxdelay = 0;
000016  2000              MOVS     r0,#0
000018  9002              STR      r0,[sp,#8]
;;;1268     uint8_t cardstate      = 0;
00001a  9001              STR      r0,[sp,#4]
;;;1269     
;;;1270     /* Check if the card command class supports erase command */
;;;1271     if (((hsd->CSD[1] >> 20) & SD_CCCC_ERASE) == 0)
00001c  2120              MOVS     r1,#0x20
00001e  6ae0              LDR      r0,[r4,#0x2c]
000020  ea015010          AND      r0,r1,r0,LSR #20
000024  b928              CBNZ     r0,|L8.50|
;;;1272     {
;;;1273       errorstate = SD_REQUEST_NOT_APPLICABLE;
000026  f04f0925          MOV      r9,#0x25
;;;1274       
;;;1275       return errorstate;
00002a  4648              MOV      r0,r9
                  |L8.44|
;;;1276     }
;;;1277     
;;;1278     /* Get max delay value */
;;;1279     maxdelay = 120000 / (((hsd->Instance->CLKCR) & 0xFF) + 2);
;;;1280     
;;;1281     if((SDIO_GetResponse(SDIO_RESP1) & SD_CARD_LOCKED) == SD_CARD_LOCKED)
;;;1282     {
;;;1283       errorstate = SD_LOCK_UNLOCK_FAILED;
;;;1284       
;;;1285       return errorstate;
;;;1286     }
;;;1287     
;;;1288     /* Get start and end block for high capacity cards */
;;;1289     if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
;;;1290     {
;;;1291       startaddr /= 512;
;;;1292       endaddr   /= 512;
;;;1293     }
;;;1294     
;;;1295     /* According to sd-card spec 1.0 ERASE_GROUP_START (CMD32) and erase_group_end(CMD33) */
;;;1296     if ((hsd->CardType == STD_CAPACITY_SD_CARD_V1_1) || (hsd->CardType == STD_CAPACITY_SD_CARD_V2_0) ||\
;;;1297       (hsd->CardType == HIGH_CAPACITY_SD_CARD))
;;;1298     {
;;;1299       /* Send CMD32 SD_ERASE_GRP_START with argument as addr  */
;;;1300       sdio_cmdinitstructure.Argument         =(uint32_t)startaddr;
;;;1301       sdio_cmdinitstructure.CmdIndex         = SD_CMD_SD_ERASE_GRP_START;
;;;1302       sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
;;;1303       sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
;;;1304       sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
;;;1305       SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
;;;1306       
;;;1307       /* Check for error conditions */
;;;1308       errorstate = SD_CmdResp1Error(hsd, SD_CMD_SD_ERASE_GRP_START);
;;;1309       
;;;1310       if (errorstate != SD_OK)
;;;1311       {
;;;1312         return errorstate;
;;;1313       }
;;;1314       
;;;1315       /* Send CMD33 SD_ERASE_GRP_END with argument as addr  */
;;;1316       sdio_cmdinitstructure.Argument         = (uint32_t)endaddr;
;;;1317       sdio_cmdinitstructure.CmdIndex         = SD_CMD_SD_ERASE_GRP_END;
;;;1318       SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
;;;1319       
;;;1320       /* Check for error conditions */
;;;1321       errorstate = SD_CmdResp1Error(hsd, SD_CMD_SD_ERASE_GRP_END);
;;;1322       
;;;1323       if (errorstate != SD_OK)
;;;1324       {
;;;1325         return errorstate;
;;;1326       }
;;;1327     }
;;;1328     
;;;1329     /* Send CMD38 ERASE */
;;;1330     sdio_cmdinitstructure.Argument         = 0;
;;;1331     sdio_cmdinitstructure.CmdIndex         = SD_CMD_ERASE;
;;;1332     SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
;;;1333     
;;;1334     /* Check for error conditions */
;;;1335     errorstate = SD_CmdResp1Error(hsd, SD_CMD_ERASE);
;;;1336     
;;;1337     if (errorstate != SD_OK)
;;;1338     {
;;;1339       return errorstate;
;;;1340     }
;;;1341     
;;;1342     for (; delay < maxdelay; delay++)
;;;1343     {
;;;1344     }
;;;1345     
;;;1346     /* Wait until the card is in programming state */
;;;1347     errorstate = SD_IsCardProgramming(hsd, &cardstate);
;;;1348     
;;;1349     delay = SD_DATATIMEOUT;
;;;1350     
;;;1351     while ((delay > 0) && (errorstate == SD_OK) && ((cardstate == SD_CARD_PROGRAMMING) || (cardstate == SD_CARD_RECEIVING)))
;;;1352     {
;;;1353       errorstate = SD_IsCardProgramming(hsd, &cardstate);
;;;1354       delay--;
;;;1355     }
;;;1356     
;;;1357     return errorstate;
;;;1358   }
00002c  b008              ADD      sp,sp,#0x20
00002e  e8bd87f0          POP      {r4-r10,pc}
                  |L8.50|
000032  6820              LDR      r0,[r4,#0]            ;1279
000034  6840              LDR      r0,[r0,#4]            ;1279
000036  b2c0              UXTB     r0,r0                 ;1279
000038  1c80              ADDS     r0,r0,#2              ;1279
00003a  4946              LDR      r1,|L8.340|
00003c  fbb1f0f0          UDIV     r0,r1,r0              ;1279
000040  9002              STR      r0,[sp,#8]            ;1279
000042  2000              MOVS     r0,#0                 ;1281
000044  f7fffffe          BL       SDIO_GetResponse
000048  f0007000          AND      r0,r0,#0x2000000      ;1281
00004c  f1b07f00          CMP      r0,#0x2000000         ;1281
000050  d103              BNE      |L8.90|
000052  f04f090e          MOV      r9,#0xe               ;1283
000056  4648              MOV      r0,r9                 ;1285
000058  e7e8              B        |L8.44|
                  |L8.90|
00005a  6a20              LDR      r0,[r4,#0x20]         ;1289
00005c  2802              CMP      r0,#2                 ;1289
00005e  d110              BNE      |L8.130|
000060  0202              LSLS     r2,r0,#8              ;1291
000062  2300              MOVS     r3,#0                 ;1291
000064  4628              MOV      r0,r5                 ;1291
000066  4631              MOV      r1,r6                 ;1291
000068  f7fffffe          BL       __aeabi_uldivmod
00006c  4605              MOV      r5,r0                 ;1291
00006e  460e              MOV      r6,r1                 ;1291
000070  f44f7200          MOV      r2,#0x200             ;1292
000074  2300              MOVS     r3,#0                 ;1292
000076  4638              MOV      r0,r7                 ;1292
000078  4641              MOV      r1,r8                 ;1292
00007a  f7fffffe          BL       __aeabi_uldivmod
00007e  4607              MOV      r7,r0                 ;1292
000080  4688              MOV      r8,r1                 ;1292
                  |L8.130|
000082  6a20              LDR      r0,[r4,#0x20]         ;1296
000084  b128              CBZ      r0,|L8.146|
000086  6a20              LDR      r0,[r4,#0x20]         ;1296
000088  2801              CMP      r0,#1                 ;1296
00008a  d002              BEQ      |L8.146|
00008c  6a20              LDR      r0,[r4,#0x20]         ;1297
00008e  2802              CMP      r0,#2                 ;1297
000090  d128              BNE      |L8.228|
                  |L8.146|
000092  9503              STR      r5,[sp,#0xc]          ;1300
000094  2020              MOVS     r0,#0x20              ;1301
000096  9004              STR      r0,[sp,#0x10]         ;1301
000098  2040              MOVS     r0,#0x40              ;1302
00009a  9005              STR      r0,[sp,#0x14]         ;1302
00009c  2000              MOVS     r0,#0                 ;1303
00009e  9006              STR      r0,[sp,#0x18]         ;1303
0000a0  f44f6080          MOV      r0,#0x400             ;1304
0000a4  9007              STR      r0,[sp,#0x1c]         ;1304
0000a6  a903              ADD      r1,sp,#0xc            ;1305
0000a8  6820              LDR      r0,[r4,#0]            ;1305
0000aa  f7fffffe          BL       SDIO_SendCommand
0000ae  2120              MOVS     r1,#0x20              ;1308
0000b0  4620              MOV      r0,r4                 ;1308
0000b2  f7fffffe          BL       SD_CmdResp1Error
0000b6  4681              MOV      r9,r0                 ;1308
0000b8  f1b90f00          CMP      r9,#0                 ;1310
0000bc  d001              BEQ      |L8.194|
0000be  4648              MOV      r0,r9                 ;1312
0000c0  e7b4              B        |L8.44|
                  |L8.194|
0000c2  9703              STR      r7,[sp,#0xc]          ;1316
0000c4  2021              MOVS     r0,#0x21              ;1317
0000c6  9004              STR      r0,[sp,#0x10]         ;1317
0000c8  a903              ADD      r1,sp,#0xc            ;1318
0000ca  6820              LDR      r0,[r4,#0]            ;1318
0000cc  f7fffffe          BL       SDIO_SendCommand
0000d0  2121              MOVS     r1,#0x21              ;1321
0000d2  4620              MOV      r0,r4                 ;1321
0000d4  f7fffffe          BL       SD_CmdResp1Error
0000d8  4681              MOV      r9,r0                 ;1321
0000da  f1b90f00          CMP      r9,#0                 ;1323
0000de  d001              BEQ      |L8.228|
0000e0  4648              MOV      r0,r9                 ;1325
0000e2  e7a3              B        |L8.44|
                  |L8.228|
0000e4  2000              MOVS     r0,#0                 ;1330
0000e6  9003              STR      r0,[sp,#0xc]          ;1330
0000e8  2026              MOVS     r0,#0x26              ;1331
0000ea  9004              STR      r0,[sp,#0x10]         ;1331
0000ec  a903              ADD      r1,sp,#0xc            ;1332
0000ee  6820              LDR      r0,[r4,#0]            ;1332
0000f0  f7fffffe          BL       SDIO_SendCommand
0000f4  2126              MOVS     r1,#0x26              ;1335
0000f6  4620              MOV      r0,r4                 ;1335
0000f8  f7fffffe          BL       SD_CmdResp1Error
0000fc  4681              MOV      r9,r0                 ;1335
0000fe  f1b90f00          CMP      r9,#0                 ;1337
000102  d001              BEQ      |L8.264|
000104  4648              MOV      r0,r9                 ;1339
000106  e791              B        |L8.44|
                  |L8.264|
000108  e001              B        |L8.270|
                  |L8.266|
00010a  f10a0a01          ADD      r10,r10,#1            ;1342
                  |L8.270|
00010e  9802              LDR      r0,[sp,#8]            ;1342
000110  4582              CMP      r10,r0                ;1342
000112  d3fa              BCC      |L8.266|
000114  a901              ADD      r1,sp,#4              ;1347
000116  4620              MOV      r0,r4                 ;1347
000118  f7fffffe          BL       SD_IsCardProgramming
00011c  4681              MOV      r9,r0                 ;1347
00011e  f04f3aff          MOV      r10,#0xffffffff       ;1349
000122  e006              B        |L8.306|
                  |L8.292|
000124  a901              ADD      r1,sp,#4              ;1353
000126  4620              MOV      r0,r4                 ;1353
000128  f7fffffe          BL       SD_IsCardProgramming
00012c  4681              MOV      r9,r0                 ;1353
00012e  f1aa0a01          SUB      r10,r10,#1            ;1354
                  |L8.306|
000132  f1ba0f00          CMP      r10,#0                ;1351
000136  d00a              BEQ      |L8.334|
000138  f1b90f00          CMP      r9,#0                 ;1351
00013c  d107              BNE      |L8.334|
00013e  f89d0004          LDRB     r0,[sp,#4]            ;1351
000142  2807              CMP      r0,#7                 ;1351
000144  d0ee              BEQ      |L8.292|
000146  f89d0004          LDRB     r0,[sp,#4]            ;1351
00014a  2806              CMP      r0,#6                 ;1351
00014c  d0ea              BEQ      |L8.292|
                  |L8.334|
00014e  4648              MOV      r0,r9                 ;1357
000150  e76c              B        |L8.44|
;;;1359   
                          ENDP

000152  0000              DCW      0x0000
                  |L8.340|
                          DCD      0x0001d4c0

                          AREA ||i.HAL_SD_GetCardStatus||, CODE, READONLY, ALIGN=1

                  HAL_SD_GetCardStatus PROC
;;;2190     */
;;;2191   HAL_SD_ErrorTypedef HAL_SD_GetCardStatus(SD_HandleTypeDef *hsd, HAL_SD_CardStatusTypedef *pCardStatus)
000000  b5f0              PUSH     {r4-r7,lr}
;;;2192   {
000002  b091              SUB      sp,sp,#0x44
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
;;;2193     HAL_SD_ErrorTypedef errorstate = SD_OK;
000008  2600              MOVS     r6,#0
;;;2194     uint32_t tmp = 0;
00000a  2400              MOVS     r4,#0
;;;2195     uint32_t sd_status[16];
;;;2196     
;;;2197     errorstate = HAL_SD_SendSDStatus(hsd, sd_status);
00000c  a901              ADD      r1,sp,#4
00000e  4638              MOV      r0,r7
000010  f7fffffe          BL       HAL_SD_SendSDStatus
000014  4606              MOV      r6,r0
;;;2198     
;;;2199     if (errorstate  != SD_OK)
000016  b116              CBZ      r6,|L9.30|
;;;2200     {
;;;2201       return errorstate;
000018  4630              MOV      r0,r6
                  |L9.26|
;;;2202     }
;;;2203     
;;;2204     /* Byte 0 */
;;;2205     tmp = (sd_status[0] & 0xC0) >> 6;
;;;2206     pCardStatus->DAT_BUS_WIDTH = (uint8_t)tmp;
;;;2207     
;;;2208     /* Byte 0 */
;;;2209     tmp = (sd_status[0] & 0x20) >> 5;
;;;2210     pCardStatus->SECURED_MODE = (uint8_t)tmp;
;;;2211     
;;;2212     /* Byte 2 */
;;;2213     tmp = (sd_status[2] & 0xFF);
;;;2214     pCardStatus->SD_CARD_TYPE = (uint8_t)(tmp << 8);
;;;2215     
;;;2216     /* Byte 3 */
;;;2217     tmp = (sd_status[3] & 0xFF);
;;;2218     pCardStatus->SD_CARD_TYPE |= (uint8_t)tmp;
;;;2219     
;;;2220     /* Byte 4 */
;;;2221     tmp = (sd_status[4] & 0xFF);
;;;2222     pCardStatus->SIZE_OF_PROTECTED_AREA = (uint8_t)(tmp << 24);
;;;2223     
;;;2224     /* Byte 5 */
;;;2225     tmp = (sd_status[5] & 0xFF);
;;;2226     pCardStatus->SIZE_OF_PROTECTED_AREA |= (uint8_t)(tmp << 16);
;;;2227     
;;;2228     /* Byte 6 */
;;;2229     tmp = (sd_status[6] & 0xFF);
;;;2230     pCardStatus->SIZE_OF_PROTECTED_AREA |= (uint8_t)(tmp << 8);
;;;2231     
;;;2232     /* Byte 7 */
;;;2233     tmp = (sd_status[7] & 0xFF);
;;;2234     pCardStatus->SIZE_OF_PROTECTED_AREA |= (uint8_t)tmp;
;;;2235     
;;;2236     /* Byte 8 */
;;;2237     tmp = (sd_status[8] & 0xFF);
;;;2238     pCardStatus->SPEED_CLASS = (uint8_t)tmp;
;;;2239     
;;;2240     /* Byte 9 */
;;;2241     tmp = (sd_status[9] & 0xFF);
;;;2242     pCardStatus->PERFORMANCE_MOVE = (uint8_t)tmp;
;;;2243     
;;;2244     /* Byte 10 */
;;;2245     tmp = (sd_status[10] & 0xF0) >> 4;
;;;2246     pCardStatus->AU_SIZE = (uint8_t)tmp;
;;;2247     
;;;2248     /* Byte 11 */
;;;2249     tmp = (sd_status[11] & 0xFF);
;;;2250     pCardStatus->ERASE_SIZE = (uint8_t)(tmp << 8);
;;;2251     
;;;2252     /* Byte 12 */
;;;2253     tmp = (sd_status[12] & 0xFF);
;;;2254     pCardStatus->ERASE_SIZE |= (uint8_t)tmp;
;;;2255     
;;;2256     /* Byte 13 */
;;;2257     tmp = (sd_status[13] & 0xFC) >> 2;
;;;2258     pCardStatus->ERASE_TIMEOUT = (uint8_t)tmp;
;;;2259     
;;;2260     /* Byte 13 */
;;;2261     tmp = (sd_status[13] & 0x3);
;;;2262     pCardStatus->ERASE_OFFSET = (uint8_t)tmp;
;;;2263     
;;;2264     return errorstate;
;;;2265   }
00001a  b011              ADD      sp,sp,#0x44
00001c  bdf0              POP      {r4-r7,pc}
                  |L9.30|
00001e  9801              LDR      r0,[sp,#4]            ;2205
000020  f3c01481          UBFX     r4,r0,#6,#2           ;2205
000024  702c              STRB     r4,[r5,#0]            ;2206
000026  9801              LDR      r0,[sp,#4]            ;2209
000028  f3c01440          UBFX     r4,r0,#5,#1           ;2209
00002c  706c              STRB     r4,[r5,#1]            ;2210
00002e  9803              LDR      r0,[sp,#0xc]          ;2213
000030  b2c4              UXTB     r4,r0                 ;2213
000032  0220              LSLS     r0,r4,#8              ;2214
000034  b2c0              UXTB     r0,r0                 ;2214
000036  8068              STRH     r0,[r5,#2]            ;2214
000038  9804              LDR      r0,[sp,#0x10]         ;2217
00003a  b2c4              UXTB     r4,r0                 ;2217
00003c  8868              LDRH     r0,[r5,#2]            ;2218
00003e  4320              ORRS     r0,r0,r4              ;2218
000040  8068              STRH     r0,[r5,#2]            ;2218
000042  9805              LDR      r0,[sp,#0x14]         ;2221
000044  b2c4              UXTB     r4,r0                 ;2221
000046  0620              LSLS     r0,r4,#24             ;2222
000048  b2c0              UXTB     r0,r0                 ;2222
00004a  6068              STR      r0,[r5,#4]            ;2222
00004c  9806              LDR      r0,[sp,#0x18]         ;2225
00004e  b2c4              UXTB     r4,r0                 ;2225
000050  6868              LDR      r0,[r5,#4]            ;2226
000052  0421              LSLS     r1,r4,#16             ;2226
000054  b2c9              UXTB     r1,r1                 ;2226
000056  4308              ORRS     r0,r0,r1              ;2226
000058  6068              STR      r0,[r5,#4]            ;2226
00005a  9807              LDR      r0,[sp,#0x1c]         ;2229
00005c  b2c4              UXTB     r4,r0                 ;2229
00005e  6868              LDR      r0,[r5,#4]            ;2230
000060  0221              LSLS     r1,r4,#8              ;2230
000062  b2c9              UXTB     r1,r1                 ;2230
000064  4308              ORRS     r0,r0,r1              ;2230
000066  6068              STR      r0,[r5,#4]            ;2230
000068  9808              LDR      r0,[sp,#0x20]         ;2233
00006a  b2c4              UXTB     r4,r0                 ;2233
00006c  6868              LDR      r0,[r5,#4]            ;2234
00006e  4320              ORRS     r0,r0,r4              ;2234
000070  6068              STR      r0,[r5,#4]            ;2234
000072  9809              LDR      r0,[sp,#0x24]         ;2237
000074  b2c4              UXTB     r4,r0                 ;2237
000076  722c              STRB     r4,[r5,#8]            ;2238
000078  980a              LDR      r0,[sp,#0x28]         ;2241
00007a  b2c4              UXTB     r4,r0                 ;2241
00007c  726c              STRB     r4,[r5,#9]            ;2242
00007e  980b              LDR      r0,[sp,#0x2c]         ;2245
000080  f3c01403          UBFX     r4,r0,#4,#4           ;2245
000084  72ac              STRB     r4,[r5,#0xa]          ;2246
000086  980c              LDR      r0,[sp,#0x30]         ;2249
000088  b2c4              UXTB     r4,r0                 ;2249
00008a  0220              LSLS     r0,r4,#8              ;2250
00008c  b2c0              UXTB     r0,r0                 ;2250
00008e  81a8              STRH     r0,[r5,#0xc]          ;2250
000090  980d              LDR      r0,[sp,#0x34]         ;2253
000092  b2c4              UXTB     r4,r0                 ;2253
000094  89a8              LDRH     r0,[r5,#0xc]          ;2254
000096  4320              ORRS     r0,r0,r4              ;2254
000098  81a8              STRH     r0,[r5,#0xc]          ;2254
00009a  980e              LDR      r0,[sp,#0x38]         ;2257
00009c  f3c00485          UBFX     r4,r0,#2,#6           ;2257
0000a0  73ac              STRB     r4,[r5,#0xe]          ;2258
0000a2  980e              LDR      r0,[sp,#0x38]         ;2261
0000a4  f0000403          AND      r4,r0,#3              ;2261
0000a8  73ec              STRB     r4,[r5,#0xf]          ;2262
0000aa  4630              MOV      r0,r6                 ;2264
0000ac  e7b5              B        |L9.26|
;;;2266            
                          ENDP


                          AREA ||i.HAL_SD_GetStatus||, CODE, READONLY, ALIGN=1

                  HAL_SD_GetStatus PROC
;;;2161     */
;;;2162   HAL_SD_TransferStateTypedef HAL_SD_GetStatus(SD_HandleTypeDef *hsd)
000000  b570              PUSH     {r4-r6,lr}
;;;2163   {
000002  4605              MOV      r5,r0
;;;2164     HAL_SD_CardStateTypedef cardstate =  SD_CARD_TRANSFER;
000004  2404              MOVS     r4,#4
;;;2165   
;;;2166     /* Get SD card state */
;;;2167     cardstate = SD_GetState(hsd);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       SD_GetState
00000c  4604              MOV      r4,r0
;;;2168     
;;;2169     /* Find SD status according to card state*/
;;;2170     if (cardstate == SD_CARD_TRANSFER)
00000e  2c04              CMP      r4,#4
000010  d101              BNE      |L10.22|
;;;2171     {
;;;2172       return SD_TRANSFER_OK;
000012  2000              MOVS     r0,#0
                  |L10.20|
;;;2173     }
;;;2174     else if(cardstate == SD_CARD_ERROR)
;;;2175     {
;;;2176       return SD_TRANSFER_ERROR;
;;;2177     }
;;;2178     else
;;;2179     {
;;;2180       return SD_TRANSFER_BUSY;
;;;2181     }
;;;2182   }
000014  bd70              POP      {r4-r6,pc}
                  |L10.22|
000016  2cff              CMP      r4,#0xff              ;2174
000018  d101              BNE      |L10.30|
00001a  2002              MOVS     r0,#2                 ;2176
00001c  e7fa              B        |L10.20|
                  |L10.30|
00001e  2001              MOVS     r0,#1                 ;2180
000020  e7f8              B        |L10.20|
;;;2183   
                          ENDP


                          AREA ||i.HAL_SD_Get_CardInfo||, CODE, READONLY, ALIGN=1

                  HAL_SD_Get_CardInfo PROC
;;;1554     */
;;;1555   HAL_SD_ErrorTypedef HAL_SD_Get_CardInfo(SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypedef *pCardInfo)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1556   {
000004  4603              MOV      r3,r0
;;;1557     HAL_SD_ErrorTypedef errorstate = SD_OK;
000006  2000              MOVS     r0,#0
;;;1558     uint32_t tmp = 0;
000008  2200              MOVS     r2,#0
;;;1559     
;;;1560     pCardInfo->CardType = (uint8_t)(hsd->CardType);
00000a  f8934020          LDRB     r4,[r3,#0x20]
00000e  f8814056          STRB     r4,[r1,#0x56]
;;;1561     pCardInfo->RCA      = (uint16_t)(hsd->RCA);
000012  8c9c              LDRH     r4,[r3,#0x24]
000014  f8a14054          STRH     r4,[r1,#0x54]
;;;1562     
;;;1563     /* Byte 0 */
;;;1564     tmp = (hsd->CSD[0] & 0xFF000000) >> 24;
000018  6a9c              LDR      r4,[r3,#0x28]
00001a  0e22              LSRS     r2,r4,#24
;;;1565     pCardInfo->SD_csd.CSDStruct      = (uint8_t)((tmp & 0xC0) >> 6);
00001c  0994              LSRS     r4,r2,#6
00001e  700c              STRB     r4,[r1,#0]
;;;1566     pCardInfo->SD_csd.SysSpecVersion = (uint8_t)((tmp & 0x3C) >> 2);
000020  f3c20483          UBFX     r4,r2,#2,#4
000024  704c              STRB     r4,[r1,#1]
;;;1567     pCardInfo->SD_csd.Reserved1      = tmp & 0x03;
000026  f0020403          AND      r4,r2,#3
00002a  708c              STRB     r4,[r1,#2]
;;;1568     
;;;1569     /* Byte 1 */
;;;1570     tmp = (hsd->CSD[0] & 0x00FF0000) >> 16;
00002c  6a9c              LDR      r4,[r3,#0x28]
00002e  f3c44207          UBFX     r2,r4,#16,#8
;;;1571     pCardInfo->SD_csd.TAAC = (uint8_t)tmp;
000032  70ca              STRB     r2,[r1,#3]
;;;1572     
;;;1573     /* Byte 2 */
;;;1574     tmp = (hsd->CSD[0] & 0x0000FF00) >> 8;
000034  8d1c              LDRH     r4,[r3,#0x28]
000036  f3c42207          UBFX     r2,r4,#8,#8
;;;1575     pCardInfo->SD_csd.NSAC = (uint8_t)tmp;
00003a  710a              STRB     r2,[r1,#4]
;;;1576     
;;;1577     /* Byte 3 */
;;;1578     tmp = hsd->CSD[0] & 0x000000FF;
00003c  f8932028          LDRB     r2,[r3,#0x28]
;;;1579     pCardInfo->SD_csd.MaxBusClkFrec = (uint8_t)tmp;
000040  714a              STRB     r2,[r1,#5]
;;;1580     
;;;1581     /* Byte 4 */
;;;1582     tmp = (hsd->CSD[1] & 0xFF000000) >> 24;
000042  6adc              LDR      r4,[r3,#0x2c]
000044  0e22              LSRS     r2,r4,#24
;;;1583     pCardInfo->SD_csd.CardComdClasses = (uint16_t)(tmp << 4);
000046  f64f74ff          MOV      r4,#0xffff
00004a  ea041402          AND      r4,r4,r2,LSL #4
00004e  80cc              STRH     r4,[r1,#6]
;;;1584     
;;;1585     /* Byte 5 */
;;;1586     tmp = (hsd->CSD[1] & 0x00FF0000) >> 16;
000050  6adc              LDR      r4,[r3,#0x2c]
000052  f3c44207          UBFX     r2,r4,#16,#8
;;;1587     pCardInfo->SD_csd.CardComdClasses |= (uint16_t)((tmp & 0xF0) >> 4);
000056  88cc              LDRH     r4,[r1,#6]
000058  ea441412          ORR      r4,r4,r2,LSR #4
00005c  80cc              STRH     r4,[r1,#6]
;;;1588     pCardInfo->SD_csd.RdBlockLen       = (uint8_t)(tmp & 0x0F);
00005e  f002040f          AND      r4,r2,#0xf
000062  720c              STRB     r4,[r1,#8]
;;;1589     
;;;1590     /* Byte 6 */
;;;1591     tmp = (hsd->CSD[1] & 0x0000FF00) >> 8;
000064  8d9c              LDRH     r4,[r3,#0x2c]
000066  f3c42207          UBFX     r2,r4,#8,#8
;;;1592     pCardInfo->SD_csd.PartBlockRead   = (uint8_t)((tmp & 0x80) >> 7);
00006a  09d4              LSRS     r4,r2,#7
00006c  724c              STRB     r4,[r1,#9]
;;;1593     pCardInfo->SD_csd.WrBlockMisalign = (uint8_t)((tmp & 0x40) >> 6);
00006e  f3c21480          UBFX     r4,r2,#6,#1
000072  728c              STRB     r4,[r1,#0xa]
;;;1594     pCardInfo->SD_csd.RdBlockMisalign = (uint8_t)((tmp & 0x20) >> 5);
000074  f3c21440          UBFX     r4,r2,#5,#1
000078  72cc              STRB     r4,[r1,#0xb]
;;;1595     pCardInfo->SD_csd.DSRImpl         = (uint8_t)((tmp & 0x10) >> 4);
00007a  f3c21400          UBFX     r4,r2,#4,#1
00007e  730c              STRB     r4,[r1,#0xc]
;;;1596     pCardInfo->SD_csd.Reserved2       = 0; /*!< Reserved */
000080  2400              MOVS     r4,#0
000082  734c              STRB     r4,[r1,#0xd]
;;;1597     
;;;1598     if ((hsd->CardType == STD_CAPACITY_SD_CARD_V1_1) || (hsd->CardType == STD_CAPACITY_SD_CARD_V2_0))
000084  6a1c              LDR      r4,[r3,#0x20]
000086  b114              CBZ      r4,|L11.142|
000088  6a1c              LDR      r4,[r3,#0x20]
00008a  2c01              CMP      r4,#1
00008c  d14d              BNE      |L11.298|
                  |L11.142|
;;;1599     {
;;;1600       pCardInfo->SD_csd.DeviceSize = (tmp & 0x03) << 10;
00008e  0794              LSLS     r4,r2,#30
000090  0d24              LSRS     r4,r4,#20
000092  610c              STR      r4,[r1,#0x10]
;;;1601       
;;;1602       /* Byte 7 */
;;;1603       tmp = (uint8_t)(hsd->CSD[1] & 0x000000FF);
000094  242c              MOVS     r4,#0x2c
000096  5ce2              LDRB     r2,[r4,r3]
;;;1604       pCardInfo->SD_csd.DeviceSize |= (tmp) << 2;
000098  690c              LDR      r4,[r1,#0x10]
00009a  ea440482          ORR      r4,r4,r2,LSL #2
00009e  610c              STR      r4,[r1,#0x10]
;;;1605       
;;;1606       /* Byte 8 */
;;;1607       tmp = (uint8_t)((hsd->CSD[2] & 0xFF000000) >> 24);
0000a0  6b1c              LDR      r4,[r3,#0x30]
0000a2  0e22              LSRS     r2,r4,#24
;;;1608       pCardInfo->SD_csd.DeviceSize |= (tmp & 0xC0) >> 6;
0000a4  690c              LDR      r4,[r1,#0x10]
0000a6  ea441492          ORR      r4,r4,r2,LSR #6
0000aa  610c              STR      r4,[r1,#0x10]
;;;1609       
;;;1610       pCardInfo->SD_csd.MaxRdCurrentVDDMin = (tmp & 0x38) >> 3;
0000ac  f3c204c2          UBFX     r4,r2,#3,#3
0000b0  750c              STRB     r4,[r1,#0x14]
;;;1611       pCardInfo->SD_csd.MaxRdCurrentVDDMax = (tmp & 0x07);
0000b2  f0020407          AND      r4,r2,#7
0000b6  754c              STRB     r4,[r1,#0x15]
;;;1612       
;;;1613       /* Byte 9 */
;;;1614       tmp = (uint8_t)((hsd->CSD[2] & 0x00FF0000) >> 16);
0000b8  6b1c              LDR      r4,[r3,#0x30]
0000ba  f3c44207          UBFX     r2,r4,#16,#8
;;;1615       pCardInfo->SD_csd.MaxWrCurrentVDDMin = (tmp & 0xE0) >> 5;
0000be  0954              LSRS     r4,r2,#5
0000c0  758c              STRB     r4,[r1,#0x16]
;;;1616       pCardInfo->SD_csd.MaxWrCurrentVDDMax = (tmp & 0x1C) >> 2;
0000c2  f3c20482          UBFX     r4,r2,#2,#3
0000c6  75cc              STRB     r4,[r1,#0x17]
;;;1617       pCardInfo->SD_csd.DeviceSizeMul      = (tmp & 0x03) << 1;
0000c8  0794              LSLS     r4,r2,#30
0000ca  0f64              LSRS     r4,r4,#29
0000cc  760c              STRB     r4,[r1,#0x18]
;;;1618       /* Byte 10 */
;;;1619       tmp = (uint8_t)((hsd->CSD[2] & 0x0000FF00) >> 8);
0000ce  8e1c              LDRH     r4,[r3,#0x30]
0000d0  f3c42207          UBFX     r2,r4,#8,#8
;;;1620       pCardInfo->SD_csd.DeviceSizeMul |= (tmp & 0x80) >> 7;
0000d4  7e0c              LDRB     r4,[r1,#0x18]
0000d6  ea4414d2          ORR      r4,r4,r2,LSR #7
0000da  760c              STRB     r4,[r1,#0x18]
;;;1621       
;;;1622       pCardInfo->CardCapacity  = (pCardInfo->SD_csd.DeviceSize + 1) ;
0000dc  690c              LDR      r4,[r1,#0x10]
0000de  1c64              ADDS     r4,r4,#1
0000e0  2500              MOVS     r5,#0
0000e2  e9c14512          STRD     r4,r5,[r1,#0x48]
;;;1623       pCardInfo->CardCapacity *= (1 << (pCardInfo->SD_csd.DeviceSizeMul + 2));
0000e6  7e0c              LDRB     r4,[r1,#0x18]
0000e8  e9d16712          LDRD     r6,r7,[r1,#0x48]
0000ec  1ca4              ADDS     r4,r4,#2
0000ee  2501              MOVS     r5,#1
0000f0  fa05f404          LSL      r4,r5,r4
0000f4  ea4f7ce4          ASR      r12,r4,#31
0000f8  fba65804          UMULL    r5,r8,r6,r4
0000fc  fb078404          MLA      r4,r7,r4,r8
000100  fb06440c          MLA      r4,r6,r12,r4
000104  e9c15412          STRD     r5,r4,[r1,#0x48]
;;;1624       pCardInfo->CardBlockSize = 1 << (pCardInfo->SD_csd.RdBlockLen);
000108  7a0d              LDRB     r5,[r1,#8]
00010a  2401              MOVS     r4,#1
00010c  40ac              LSLS     r4,r4,r5
00010e  650c              STR      r4,[r1,#0x50]
;;;1625       pCardInfo->CardCapacity *= pCardInfo->CardBlockSize;
000110  2600              MOVS     r6,#0
000112  e9d15712          LDRD     r5,r7,[r1,#0x48]
000116  6d0c              LDR      r4,[r1,#0x50]
000118  fba5c804          UMULL    r12,r8,r5,r4
00011c  fb078404          MLA      r4,r7,r4,r8
000120  fb054406          MLA      r4,r5,r6,r4
000124  e9c1c412          STRD     r12,r4,[r1,#0x48]
000128  e035              B        |L11.406|
                  |L11.298|
;;;1626     }
;;;1627     else if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
00012a  6a1c              LDR      r4,[r3,#0x20]
00012c  2c02              CMP      r4,#2
00012e  d131              BNE      |L11.404|
;;;1628     {
;;;1629       /* Byte 7 */
;;;1630       tmp = (uint8_t)(hsd->CSD[1] & 0x000000FF);
000130  242c              MOVS     r4,#0x2c
000132  5ce2              LDRB     r2,[r4,r3]
;;;1631       pCardInfo->SD_csd.DeviceSize = (tmp & 0x3F) << 16;
000134  0694              LSLS     r4,r2,#26
000136  0aa4              LSRS     r4,r4,#10
000138  610c              STR      r4,[r1,#0x10]
;;;1632       
;;;1633       /* Byte 8 */
;;;1634       tmp = (uint8_t)((hsd->CSD[2] & 0xFF000000) >> 24);
00013a  6b1c              LDR      r4,[r3,#0x30]
00013c  0e22              LSRS     r2,r4,#24
;;;1635       
;;;1636       pCardInfo->SD_csd.DeviceSize |= (tmp << 8);
00013e  690c              LDR      r4,[r1,#0x10]
000140  ea442402          ORR      r4,r4,r2,LSL #8
000144  610c              STR      r4,[r1,#0x10]
;;;1637       
;;;1638       /* Byte 9 */
;;;1639       tmp = (uint8_t)((hsd->CSD[2] & 0x00FF0000) >> 16);
000146  6b1c              LDR      r4,[r3,#0x30]
000148  f3c44207          UBFX     r2,r4,#16,#8
;;;1640       
;;;1641       pCardInfo->SD_csd.DeviceSize |= (tmp);
00014c  690c              LDR      r4,[r1,#0x10]
00014e  4314              ORRS     r4,r4,r2
000150  610c              STR      r4,[r1,#0x10]
;;;1642       
;;;1643       /* Byte 10 */
;;;1644       tmp = (uint8_t)((hsd->CSD[2] & 0x0000FF00) >> 8);
000152  8e1c              LDRH     r4,[r3,#0x30]
000154  f3c42207          UBFX     r2,r4,#8,#8
;;;1645       
;;;1646       pCardInfo->CardCapacity = (uint64_t)((((uint64_t)pCardInfo->SD_csd.DeviceSize + 1)) * 512 * 1024);
000158  690c              LDR      r4,[r1,#0x10]
00015a  2500              MOVS     r5,#0
00015c  1c64              ADDS     r4,r4,#1
00015e  eb450c05          ADC      r12,r5,r5
000162  f44f7700          MOV      r7,#0x200
000166  2600              MOVS     r6,#0
000168  fba45807          UMULL    r5,r8,r4,r7
00016c  fb0c8707          MLA      r7,r12,r7,r8
000170  fb047c06          MLA      r12,r4,r6,r7
000174  f44f6780          MOV      r7,#0x400
000178  462c              MOV      r4,r5
00017a  4665              MOV      r5,r12
00017c  46b4              MOV      r12,r6
00017e  fba46807          UMULL    r6,r8,r4,r7
000182  fb058507          MLA      r5,r5,r7,r8
000186  fb04540c          MLA      r4,r4,r12,r5
00018a  e9c16412          STRD     r6,r4,[r1,#0x48]
;;;1647       pCardInfo->CardBlockSize = 512;    
00018e  107c              ASRS     r4,r7,#1
000190  650c              STR      r4,[r1,#0x50]
000192  e000              B        |L11.406|
                  |L11.404|
;;;1648     }
;;;1649     else
;;;1650     {
;;;1651       /* Not supported card type */
;;;1652       errorstate = SD_ERROR;
000194  2029              MOVS     r0,#0x29
                  |L11.406|
;;;1653     }
;;;1654       
;;;1655     pCardInfo->SD_csd.EraseGrSize = (tmp & 0x40) >> 6;
000196  f3c21480          UBFX     r4,r2,#6,#1
00019a  f8014f19          STRB     r4,[r1,#0x19]!
;;;1656     pCardInfo->SD_csd.EraseGrMul  = (tmp & 0x3F) << 1;
00019e  0694              LSLS     r4,r2,#26
0001a0  0e64              LSRS     r4,r4,#25
0001a2  704c              STRB     r4,[r1,#1]
;;;1657     
;;;1658     /* Byte 11 */
;;;1659     tmp = (uint8_t)(hsd->CSD[2] & 0x000000FF);
0001a4  2430              MOVS     r4,#0x30
0001a6  5ce2              LDRB     r2,[r4,r3]
;;;1660     pCardInfo->SD_csd.EraseGrMul     |= (tmp & 0x80) >> 7;
0001a8  784c              LDRB     r4,[r1,#1]
0001aa  ea4414d2          ORR      r4,r4,r2,LSR #7
0001ae  704c              STRB     r4,[r1,#1]
;;;1661     pCardInfo->SD_csd.WrProtectGrSize = (tmp & 0x7F);
0001b0  f002047f          AND      r4,r2,#0x7f
0001b4  708c              STRB     r4,[r1,#2]
;;;1662     
;;;1663     /* Byte 12 */
;;;1664     tmp = (uint8_t)((hsd->CSD[3] & 0xFF000000) >> 24);
0001b6  6b5c              LDR      r4,[r3,#0x34]
0001b8  0e22              LSRS     r2,r4,#24
;;;1665     pCardInfo->SD_csd.WrProtectGrEnable = (tmp & 0x80) >> 7;
0001ba  09d4              LSRS     r4,r2,#7
0001bc  70cc              STRB     r4,[r1,#3]
;;;1666     pCardInfo->SD_csd.ManDeflECC        = (tmp & 0x60) >> 5;
0001be  f3c21441          UBFX     r4,r2,#5,#2
0001c2  710c              STRB     r4,[r1,#4]
;;;1667     pCardInfo->SD_csd.WrSpeedFact       = (tmp & 0x1C) >> 2;
0001c4  f3c20482          UBFX     r4,r2,#2,#3
0001c8  714c              STRB     r4,[r1,#5]
;;;1668     pCardInfo->SD_csd.MaxWrBlockLen     = (tmp & 0x03) << 2;
0001ca  0794              LSLS     r4,r2,#30
0001cc  0f24              LSRS     r4,r4,#28
0001ce  718c              STRB     r4,[r1,#6]
;;;1669     
;;;1670     /* Byte 13 */
;;;1671     tmp = (uint8_t)((hsd->CSD[3] & 0x00FF0000) >> 16);
0001d0  6b5c              LDR      r4,[r3,#0x34]
0001d2  f3c44207          UBFX     r2,r4,#16,#8
;;;1672     pCardInfo->SD_csd.MaxWrBlockLen      |= (tmp & 0xC0) >> 6;
0001d6  798c              LDRB     r4,[r1,#6]
0001d8  ea441492          ORR      r4,r4,r2,LSR #6
0001dc  718c              STRB     r4,[r1,#6]
;;;1673     pCardInfo->SD_csd.WriteBlockPaPartial = (tmp & 0x20) >> 5;
0001de  f3c21440          UBFX     r4,r2,#5,#1
0001e2  71cc              STRB     r4,[r1,#7]
;;;1674     pCardInfo->SD_csd.Reserved3           = 0;
0001e4  2400              MOVS     r4,#0
0001e6  720c              STRB     r4,[r1,#8]
;;;1675     pCardInfo->SD_csd.ContentProtectAppli = (tmp & 0x01);
0001e8  f0020401          AND      r4,r2,#1
0001ec  724c              STRB     r4,[r1,#9]
;;;1676     
;;;1677     /* Byte 14 */
;;;1678     tmp = (uint8_t)((hsd->CSD[3] & 0x0000FF00) >> 8);
0001ee  8e9c              LDRH     r4,[r3,#0x34]
0001f0  f3c42207          UBFX     r2,r4,#8,#8
;;;1679     pCardInfo->SD_csd.FileFormatGrouop = (tmp & 0x80) >> 7;
0001f4  09d4              LSRS     r4,r2,#7
0001f6  728c              STRB     r4,[r1,#0xa]
;;;1680     pCardInfo->SD_csd.CopyFlag         = (tmp & 0x40) >> 6;
0001f8  f3c21480          UBFX     r4,r2,#6,#1
0001fc  72cc              STRB     r4,[r1,#0xb]
;;;1681     pCardInfo->SD_csd.PermWrProtect    = (tmp & 0x20) >> 5;
0001fe  f3c21440          UBFX     r4,r2,#5,#1
000202  730c              STRB     r4,[r1,#0xc]
;;;1682     pCardInfo->SD_csd.TempWrProtect    = (tmp & 0x10) >> 4;
000204  f3c21400          UBFX     r4,r2,#4,#1
000208  734c              STRB     r4,[r1,#0xd]
;;;1683     pCardInfo->SD_csd.FileFormat       = (tmp & 0x0C) >> 2;
00020a  f3c20481          UBFX     r4,r2,#2,#2
00020e  738c              STRB     r4,[r1,#0xe]
;;;1684     pCardInfo->SD_csd.ECC              = (tmp & 0x03);
000210  f0020403          AND      r4,r2,#3
000214  73cc              STRB     r4,[r1,#0xf]
;;;1685     
;;;1686     /* Byte 15 */
;;;1687     tmp = (uint8_t)(hsd->CSD[3] & 0x000000FF);
000216  2434              MOVS     r4,#0x34
000218  5ce2              LDRB     r2,[r4,r3]
;;;1688     pCardInfo->SD_csd.CSD_CRC   = (tmp & 0xFE) >> 1;
00021a  0854              LSRS     r4,r2,#1
00021c  740c              STRB     r4,[r1,#0x10]
;;;1689     pCardInfo->SD_csd.Reserved4 = 1;
00021e  2401              MOVS     r4,#1
000220  744c              STRB     r4,[r1,#0x11]
;;;1690     
;;;1691     /* Byte 0 */
;;;1692     tmp = (uint8_t)((hsd->CID[0] & 0xFF000000) >> 24);
000222  6b9c              LDR      r4,[r3,#0x38]
000224  0e22              LSRS     r2,r4,#24
;;;1693     pCardInfo->SD_cid.ManufacturerID = tmp;
000226  74ca              STRB     r2,[r1,#0x13]
000228  3919              SUBS     r1,r1,#0x19
;;;1694     
;;;1695     /* Byte 1 */
;;;1696     tmp = (uint8_t)((hsd->CID[0] & 0x00FF0000) >> 16);
00022a  6b9c              LDR      r4,[r3,#0x38]
00022c  f3c44207          UBFX     r2,r4,#16,#8
;;;1697     pCardInfo->SD_cid.OEM_AppliID = tmp << 8;
000230  f64f74ff          MOV      r4,#0xffff
000234  ea042502          AND      r5,r4,r2,LSL #8
000238  85cd              STRH     r5,[r1,#0x2e]
;;;1698     
;;;1699     /* Byte 2 */
;;;1700     tmp = (uint8_t)((hsd->CID[0] & 0x000000FF00) >> 8);
00023a  8f1c              LDRH     r4,[r3,#0x38]
00023c  f3c42207          UBFX     r2,r4,#8,#8
;;;1701     pCardInfo->SD_cid.OEM_AppliID |= tmp;
000240  8dcc              LDRH     r4,[r1,#0x2e]
000242  4314              ORRS     r4,r4,r2
000244  85cc              STRH     r4,[r1,#0x2e]
;;;1702     
;;;1703     /* Byte 3 */
;;;1704     tmp = (uint8_t)(hsd->CID[0] & 0x000000FF);
000246  f8932038          LDRB     r2,[r3,#0x38]
;;;1705     pCardInfo->SD_cid.ProdName1 = tmp << 24;
00024a  0615              LSLS     r5,r2,#24
00024c  630d              STR      r5,[r1,#0x30]
;;;1706     
;;;1707     /* Byte 4 */
;;;1708     tmp = (uint8_t)((hsd->CID[1] & 0xFF000000) >> 24);
00024e  6bdc              LDR      r4,[r3,#0x3c]
000250  0e22              LSRS     r2,r4,#24
;;;1709     pCardInfo->SD_cid.ProdName1 |= tmp << 16;
000252  6b0c              LDR      r4,[r1,#0x30]
000254  ea444502          ORR      r5,r4,r2,LSL #16
000258  630d              STR      r5,[r1,#0x30]
;;;1710     
;;;1711     /* Byte 5 */
;;;1712     tmp = (uint8_t)((hsd->CID[1] & 0x00FF0000) >> 16);
00025a  6bdc              LDR      r4,[r3,#0x3c]
00025c  f3c44207          UBFX     r2,r4,#16,#8
;;;1713     pCardInfo->SD_cid.ProdName1 |= tmp << 8;
000260  6b0c              LDR      r4,[r1,#0x30]
000262  ea442502          ORR      r5,r4,r2,LSL #8
000266  630d              STR      r5,[r1,#0x30]
;;;1714     
;;;1715     /* Byte 6 */
;;;1716     tmp = (uint8_t)((hsd->CID[1] & 0x0000FF00) >> 8);
000268  8f9c              LDRH     r4,[r3,#0x3c]
00026a  f3c42207          UBFX     r2,r4,#8,#8
;;;1717     pCardInfo->SD_cid.ProdName1 |= tmp;
00026e  6b0c              LDR      r4,[r1,#0x30]
000270  4314              ORRS     r4,r4,r2
000272  630c              STR      r4,[r1,#0x30]
;;;1718     
;;;1719     /* Byte 7 */
;;;1720     tmp = (uint8_t)(hsd->CID[1] & 0x000000FF);
000274  243c              MOVS     r4,#0x3c
000276  5ce2              LDRB     r2,[r4,r3]
;;;1721     pCardInfo->SD_cid.ProdName2 = tmp;
000278  2434              MOVS     r4,#0x34
00027a  5462              STRB     r2,[r4,r1]
;;;1722     
;;;1723     /* Byte 8 */
;;;1724     tmp = (uint8_t)((hsd->CID[2] & 0xFF000000) >> 24);
00027c  6c1c              LDR      r4,[r3,#0x40]
00027e  0e22              LSRS     r2,r4,#24
;;;1725     pCardInfo->SD_cid.ProdRev = tmp;
000280  2435              MOVS     r4,#0x35
000282  5462              STRB     r2,[r4,r1]
;;;1726     
;;;1727     /* Byte 9 */
;;;1728     tmp = (uint8_t)((hsd->CID[2] & 0x00FF0000) >> 16);
000284  6c1c              LDR      r4,[r3,#0x40]
000286  f3c44207          UBFX     r2,r4,#16,#8
;;;1729     pCardInfo->SD_cid.ProdSN = tmp << 24;
00028a  0615              LSLS     r5,r2,#24
00028c  638d              STR      r5,[r1,#0x38]
;;;1730     
;;;1731     /* Byte 10 */
;;;1732     tmp = (uint8_t)((hsd->CID[2] & 0x0000FF00) >> 8);
00028e  2440              MOVS     r4,#0x40
000290  5ae4              LDRH     r4,[r4,r3]
000292  f3c42207          UBFX     r2,r4,#8,#8
;;;1733     pCardInfo->SD_cid.ProdSN |= tmp << 16;
000296  6b8c              LDR      r4,[r1,#0x38]
000298  ea444502          ORR      r5,r4,r2,LSL #16
00029c  638d              STR      r5,[r1,#0x38]
;;;1734     
;;;1735     /* Byte 11 */
;;;1736     tmp = (uint8_t)(hsd->CID[2] & 0x000000FF);
00029e  2440              MOVS     r4,#0x40
0002a0  5ce2              LDRB     r2,[r4,r3]
;;;1737     pCardInfo->SD_cid.ProdSN |= tmp << 8;
0002a2  6b8c              LDR      r4,[r1,#0x38]
0002a4  ea442502          ORR      r5,r4,r2,LSL #8
0002a8  638d              STR      r5,[r1,#0x38]
;;;1738     
;;;1739     /* Byte 12 */
;;;1740     tmp = (uint8_t)((hsd->CID[3] & 0xFF000000) >> 24);
0002aa  6c5c              LDR      r4,[r3,#0x44]
0002ac  0e22              LSRS     r2,r4,#24
;;;1741     pCardInfo->SD_cid.ProdSN |= tmp;
0002ae  6b8c              LDR      r4,[r1,#0x38]
0002b0  4314              ORRS     r4,r4,r2
0002b2  638c              STR      r4,[r1,#0x38]
;;;1742     
;;;1743     /* Byte 13 */
;;;1744     tmp = (uint8_t)((hsd->CID[3] & 0x00FF0000) >> 16);
0002b4  6c5c              LDR      r4,[r3,#0x44]
0002b6  f3c44207          UBFX     r2,r4,#16,#8
;;;1745     pCardInfo->SD_cid.Reserved1   |= (tmp & 0xF0) >> 4;
0002ba  243c              MOVS     r4,#0x3c
0002bc  5c64              LDRB     r4,[r4,r1]
0002be  ea441412          ORR      r4,r4,r2,LSR #4
0002c2  253c              MOVS     r5,#0x3c
0002c4  546c              STRB     r4,[r5,r1]
;;;1746     pCardInfo->SD_cid.ManufactDate = (tmp & 0x0F) << 8;
0002c6  0714              LSLS     r4,r2,#28
0002c8  0d25              LSRS     r5,r4,#20
0002ca  87cd              STRH     r5,[r1,#0x3e]
;;;1747     
;;;1748     /* Byte 14 */
;;;1749     tmp = (uint8_t)((hsd->CID[3] & 0x0000FF00) >> 8);
0002cc  2444              MOVS     r4,#0x44
0002ce  5ae4              LDRH     r4,[r4,r3]
0002d0  f3c42207          UBFX     r2,r4,#8,#8
;;;1750     pCardInfo->SD_cid.ManufactDate |= tmp;
0002d4  8fcc              LDRH     r4,[r1,#0x3e]
0002d6  4314              ORRS     r4,r4,r2
0002d8  87cc              STRH     r4,[r1,#0x3e]
;;;1751     
;;;1752     /* Byte 15 */
;;;1753     tmp = (uint8_t)(hsd->CID[3] & 0x000000FF);
0002da  2444              MOVS     r4,#0x44
0002dc  5ce2              LDRB     r2,[r4,r3]
;;;1754     pCardInfo->SD_cid.CID_CRC   = (tmp & 0xFE) >> 1;
0002de  0855              LSRS     r5,r2,#1
0002e0  2440              MOVS     r4,#0x40
0002e2  5465              STRB     r5,[r4,r1]
;;;1755     pCardInfo->SD_cid.Reserved2 = 1;
0002e4  2501              MOVS     r5,#1
0002e6  2441              MOVS     r4,#0x41
0002e8  5465              STRB     r5,[r4,r1]
;;;1756     
;;;1757     return errorstate;
;;;1758   }
0002ea  e8bd81f0          POP      {r4-r8,pc}
;;;1759   
                          ENDP


                          AREA ||i.HAL_SD_HighSpeed||, CODE, READONLY, ALIGN=2

                  HAL_SD_HighSpeed PROC
;;;1851     */
;;;1852   HAL_SD_ErrorTypedef HAL_SD_HighSpeed (SD_HandleTypeDef *hsd)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1853   {
000004  b09e              SUB      sp,sp,#0x78
000006  4604              MOV      r4,r0
;;;1854     HAL_SD_ErrorTypedef errorstate = SD_OK;
000008  2600              MOVS     r6,#0
;;;1855     SDIO_CmdInitTypeDef sdio_cmdinitstructure;
;;;1856     SDIO_DataInitTypeDef sdio_datainitstructure;
;;;1857     
;;;1858     uint8_t SD_hs[64]  = {0};
00000a  2140              MOVS     r1,#0x40
00000c  a803              ADD      r0,sp,#0xc
00000e  f7fffffe          BL       __aeabi_memclr4
;;;1859     uint32_t SD_scr[2] = {0, 0};
000012  2000              MOVS     r0,#0
000014  9001              STR      r0,[sp,#4]
000016  9002              STR      r0,[sp,#8]
;;;1860     uint32_t SD_SPEC   = 0 ;
000018  4680              MOV      r8,r0
;;;1861     uint32_t count = 0, *tempbuff = (uint32_t *)SD_hs;
00001a  2500              MOVS     r5,#0
00001c  af03              ADD      r7,sp,#0xc
;;;1862     
;;;1863     /* Initialize the Data control register */
;;;1864     hsd->Instance->DCTRL = 0;
00001e  6821              LDR      r1,[r4,#0]
000020  62c8              STR      r0,[r1,#0x2c]
;;;1865     
;;;1866     /* Get SCR Register */
;;;1867     errorstate = SD_FindSCR(hsd, SD_scr);
000022  a901              ADD      r1,sp,#4
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       SD_FindSCR
00002a  4606              MOV      r6,r0
;;;1868     
;;;1869     if (errorstate != SD_OK)
00002c  b11e              CBZ      r6,|L12.54|
;;;1870     {
;;;1871       return errorstate;
00002e  4630              MOV      r0,r6
                  |L12.48|
;;;1872     }
;;;1873     
;;;1874     /* Test the Version supported by the card*/ 
;;;1875     SD_SPEC = (SD_scr[1]  & 0x01000000) | (SD_scr[1]  & 0x02000000);
;;;1876     
;;;1877     if (SD_SPEC != SD_ALLZERO)
;;;1878     {
;;;1879       /* Set Block Size for Card */
;;;1880       sdio_cmdinitstructure.Argument         = (uint32_t)64;
;;;1881       sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
;;;1882       sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
;;;1883       sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
;;;1884       sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
;;;1885       SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
;;;1886       
;;;1887       /* Check for error conditions */
;;;1888       errorstate = SD_CmdResp1Error(hsd, SD_CMD_SET_BLOCKLEN);
;;;1889       
;;;1890       if (errorstate != SD_OK)
;;;1891       {
;;;1892         return errorstate;
;;;1893       }
;;;1894       
;;;1895       /* Configure the SD DPSM (Data Path State Machine) */
;;;1896       sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
;;;1897       sdio_datainitstructure.DataLength    = 64;
;;;1898       sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_64B ;
;;;1899       sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
;;;1900       sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
;;;1901       sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
;;;1902       SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
;;;1903       
;;;1904       /* Send CMD6 switch mode */
;;;1905       sdio_cmdinitstructure.Argument         = 0x80FFFF01;
;;;1906       sdio_cmdinitstructure.CmdIndex         = SD_CMD_HS_SWITCH;
;;;1907       SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure); 
;;;1908       
;;;1909       /* Check for error conditions */
;;;1910       errorstate = SD_CmdResp1Error(hsd, SD_CMD_HS_SWITCH);
;;;1911       
;;;1912       if (errorstate != SD_OK)
;;;1913       {
;;;1914         return errorstate;
;;;1915       }
;;;1916   #ifdef SDIO_STA_STBITERR        
;;;1917       while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND | SDIO_FLAG_STBITERR))
;;;1918   #else /* SDIO_STA_STBITERR */
;;;1919       while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND))      
;;;1920   #endif /* SDIO_STA_STBITERR */
;;;1921       {
;;;1922         if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXFIFOHF))
;;;1923         {
;;;1924           for (count = 0; count < 8; count++)
;;;1925           {
;;;1926             *(tempbuff + count) = SDIO_ReadFIFO(hsd->Instance);
;;;1927           }
;;;1928           
;;;1929           tempbuff += 8;
;;;1930         }
;;;1931       }
;;;1932       
;;;1933       if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DTIMEOUT))
;;;1934       {
;;;1935         __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DTIMEOUT);
;;;1936         
;;;1937         errorstate = SD_DATA_TIMEOUT;
;;;1938         
;;;1939         return errorstate;
;;;1940       }
;;;1941       else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DCRCFAIL))
;;;1942       {
;;;1943         __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DCRCFAIL);
;;;1944         
;;;1945         errorstate = SD_DATA_CRC_FAIL;
;;;1946         
;;;1947         return errorstate;
;;;1948       }
;;;1949       else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR))
;;;1950       {
;;;1951         __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_RXOVERR);
;;;1952         
;;;1953         errorstate = SD_RX_OVERRUN;
;;;1954         
;;;1955         return errorstate;
;;;1956       }
;;;1957   #ifdef SDIO_STA_STBITERR
;;;1958       else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_STBITERR))
;;;1959       {
;;;1960         __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_STBITERR);
;;;1961         
;;;1962         errorstate = SD_START_BIT_ERR;
;;;1963         
;;;1964         return errorstate;
;;;1965       }
;;;1966   #endif /* SDIO_STA_STBITERR */
;;;1967       else
;;;1968       {
;;;1969         /* No error flag set */
;;;1970       }
;;;1971       
;;;1972       count = SD_DATATIMEOUT;
;;;1973       
;;;1974       while ((__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXDAVL)) && (count > 0))
;;;1975       {
;;;1976         *tempbuff = SDIO_ReadFIFO(hsd->Instance);
;;;1977         tempbuff++;
;;;1978         count--;
;;;1979       }
;;;1980       
;;;1981       /* Clear all the static flags */
;;;1982       __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;1983       
;;;1984       /* Test if the switch mode HS is ok */
;;;1985       if ((SD_hs[13]& 2) != 2)
;;;1986       {
;;;1987         errorstate = SD_UNSUPPORTED_FEATURE;
;;;1988       } 
;;;1989     }
;;;1990     
;;;1991     return errorstate;
;;;1992   }
000030  b01e              ADD      sp,sp,#0x78
000032  e8bd81f0          POP      {r4-r8,pc}
                  |L12.54|
000036  9802              LDR      r0,[sp,#8]            ;1875
000038  f0007080          AND      r0,r0,#0x1000000      ;1875
00003c  9902              LDR      r1,[sp,#8]            ;1875
00003e  f0017100          AND      r1,r1,#0x2000000      ;1875
000042  ea400801          ORR      r8,r0,r1              ;1875
000046  f1b80f00          CMP      r8,#0                 ;1877
00004a  d070              BEQ      |L12.302|
00004c  2040              MOVS     r0,#0x40              ;1880
00004e  9019              STR      r0,[sp,#0x64]         ;1880
000050  2010              MOVS     r0,#0x10              ;1881
000052  901a              STR      r0,[sp,#0x68]         ;1881
000054  2040              MOVS     r0,#0x40              ;1882
000056  901b              STR      r0,[sp,#0x6c]         ;1882
000058  2000              MOVS     r0,#0                 ;1883
00005a  901c              STR      r0,[sp,#0x70]         ;1883
00005c  f44f6080          MOV      r0,#0x400             ;1884
000060  901d              STR      r0,[sp,#0x74]         ;1884
000062  a919              ADD      r1,sp,#0x64           ;1885
000064  6820              LDR      r0,[r4,#0]            ;1885
000066  f7fffffe          BL       SDIO_SendCommand
00006a  2110              MOVS     r1,#0x10              ;1888
00006c  4620              MOV      r0,r4                 ;1888
00006e  f7fffffe          BL       SD_CmdResp1Error
000072  4606              MOV      r6,r0                 ;1888
000074  b10e              CBZ      r6,|L12.122|
000076  4630              MOV      r0,r6                 ;1892
000078  e7da              B        |L12.48|
                  |L12.122|
00007a  f04f30ff          MOV      r0,#0xffffffff        ;1896
00007e  9013              STR      r0,[sp,#0x4c]         ;1896
000080  2040              MOVS     r0,#0x40              ;1897
000082  9014              STR      r0,[sp,#0x50]         ;1897
000084  2060              MOVS     r0,#0x60              ;1898
000086  9015              STR      r0,[sp,#0x54]         ;1898
000088  2002              MOVS     r0,#2                 ;1899
00008a  9016              STR      r0,[sp,#0x58]         ;1899
00008c  2000              MOVS     r0,#0                 ;1900
00008e  9017              STR      r0,[sp,#0x5c]         ;1900
000090  2001              MOVS     r0,#1                 ;1901
000092  9018              STR      r0,[sp,#0x60]         ;1901
000094  a913              ADD      r1,sp,#0x4c           ;1902
000096  6820              LDR      r0,[r4,#0]            ;1902
000098  f7fffffe          BL       SDIO_DataConfig
00009c  4839              LDR      r0,|L12.388|
00009e  9019              STR      r0,[sp,#0x64]         ;1905
0000a0  2006              MOVS     r0,#6                 ;1906
0000a2  901a              STR      r0,[sp,#0x68]         ;1906
0000a4  a919              ADD      r1,sp,#0x64           ;1907
0000a6  6820              LDR      r0,[r4,#0]            ;1907
0000a8  f7fffffe          BL       SDIO_SendCommand
0000ac  2106              MOVS     r1,#6                 ;1910
0000ae  4620              MOV      r0,r4                 ;1910
0000b0  f7fffffe          BL       SD_CmdResp1Error
0000b4  4606              MOV      r6,r0                 ;1910
0000b6  b10e              CBZ      r6,|L12.188|
0000b8  4630              MOV      r0,r6                 ;1914
0000ba  e7b9              B        |L12.48|
                  |L12.188|
0000bc  e00f              B        |L12.222|
                  |L12.190|
0000be  6820              LDR      r0,[r4,#0]            ;1922
0000c0  6b40              LDR      r0,[r0,#0x34]         ;1922
0000c2  f4004000          AND      r0,r0,#0x8000         ;1922
0000c6  b150              CBZ      r0,|L12.222|
0000c8  2500              MOVS     r5,#0                 ;1924
0000ca  e005              B        |L12.216|
                  |L12.204|
0000cc  6820              LDR      r0,[r4,#0]            ;1926
0000ce  f7fffffe          BL       SDIO_ReadFIFO
0000d2  f8470025          STR      r0,[r7,r5,LSL #2]     ;1926
0000d6  1c6d              ADDS     r5,r5,#1              ;1924
                  |L12.216|
0000d8  2d08              CMP      r5,#8                 ;1924
0000da  d3f7              BCC      |L12.204|
0000dc  3720              ADDS     r7,r7,#0x20           ;1929
                  |L12.222|
0000de  6820              LDR      r0,[r4,#0]            ;1917
0000e0  6b40              LDR      r0,[r0,#0x34]         ;1917
0000e2  f240612a          MOV      r1,#0x62a             ;1917
0000e6  4008              ANDS     r0,r0,r1              ;1917
0000e8  2800              CMP      r0,#0                 ;1917
0000ea  d0e8              BEQ      |L12.190|
0000ec  6820              LDR      r0,[r4,#0]            ;1933
0000ee  6b40              LDR      r0,[r0,#0x34]         ;1933
0000f0  f0000008          AND      r0,r0,#8              ;1933
0000f4  b128              CBZ      r0,|L12.258|
0000f6  2008              MOVS     r0,#8                 ;1935
0000f8  6821              LDR      r1,[r4,#0]            ;1935
0000fa  6388              STR      r0,[r1,#0x38]         ;1935
0000fc  2604              MOVS     r6,#4                 ;1937
0000fe  4630              MOV      r0,r6                 ;1939
000100  e796              B        |L12.48|
                  |L12.258|
000102  6820              LDR      r0,[r4,#0]            ;1941
000104  6b40              LDR      r0,[r0,#0x34]         ;1941
000106  f0000002          AND      r0,r0,#2              ;1941
00010a  b128              CBZ      r0,|L12.280|
00010c  2002              MOVS     r0,#2                 ;1943
00010e  6821              LDR      r1,[r4,#0]            ;1943
000110  6388              STR      r0,[r1,#0x38]         ;1943
000112  2602              MOVS     r6,#2                 ;1945
000114  4630              MOV      r0,r6                 ;1947
000116  e78b              B        |L12.48|
                  |L12.280|
000118  6820              LDR      r0,[r4,#0]            ;1949
00011a  6b40              LDR      r0,[r0,#0x34]         ;1949
00011c  f0000020          AND      r0,r0,#0x20           ;1949
000120  b130              CBZ      r0,|L12.304|
000122  2020              MOVS     r0,#0x20              ;1951
000124  6821              LDR      r1,[r4,#0]            ;1951
000126  6388              STR      r0,[r1,#0x38]         ;1951
000128  2606              MOVS     r6,#6                 ;1953
00012a  4630              MOV      r0,r6                 ;1955
00012c  e780              B        |L12.48|
                  |L12.302|
00012e  e026              B        |L12.382|
                  |L12.304|
000130  6820              LDR      r0,[r4,#0]            ;1958
000132  6b40              LDR      r0,[r0,#0x34]         ;1958
000134  f4007000          AND      r0,r0,#0x200          ;1958
000138  b130              CBZ      r0,|L12.328|
00013a  f44f7000          MOV      r0,#0x200             ;1960
00013e  6821              LDR      r1,[r4,#0]            ;1960
000140  6388              STR      r0,[r1,#0x38]         ;1960
000142  2607              MOVS     r6,#7                 ;1962
000144  4630              MOV      r0,r6                 ;1964
000146  e773              B        |L12.48|
                  |L12.328|
000148  f04f35ff          MOV      r5,#0xffffffff        ;1972
00014c  e005              B        |L12.346|
                  |L12.334|
00014e  6820              LDR      r0,[r4,#0]            ;1976
000150  f7fffffe          BL       SDIO_ReadFIFO
000154  6038              STR      r0,[r7,#0]            ;1976
000156  1d3f              ADDS     r7,r7,#4              ;1977
000158  1e6d              SUBS     r5,r5,#1              ;1978
                  |L12.346|
00015a  6820              LDR      r0,[r4,#0]            ;1974
00015c  6b40              LDR      r0,[r0,#0x34]         ;1974
00015e  f4001000          AND      r0,r0,#0x200000       ;1974
000162  b108              CBZ      r0,|L12.360|
000164  2d00              CMP      r5,#0                 ;1974
000166  d1f2              BNE      |L12.334|
                  |L12.360|
000168  f24050ff          MOV      r0,#0x5ff             ;1982
00016c  6821              LDR      r1,[r4,#0]            ;1982
00016e  6388              STR      r0,[r1,#0x38]         ;1982
000170  f89d0019          LDRB     r0,[sp,#0x19]         ;1985
000174  f0000002          AND      r0,r0,#2              ;1985
000178  2802              CMP      r0,#2                 ;1985
00017a  d000              BEQ      |L12.382|
00017c  2627              MOVS     r6,#0x27              ;1987
                  |L12.382|
00017e  4630              MOV      r0,r6                 ;1991
000180  e756              B        |L12.48|
;;;1993   
                          ENDP

000182  0000              DCW      0x0000
                  |L12.388|
                          DCD      0x80ffff01

                          AREA ||i.HAL_SD_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_SD_IRQHandler PROC
;;;1364     */
;;;1365   void HAL_SD_IRQHandler(SD_HandleTypeDef *hsd)
000000  b510              PUSH     {r4,lr}
;;;1366   {  
000002  4604              MOV      r4,r0
;;;1367     /* Check for SDIO interrupt flags */
;;;1368     if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_IT_DATAEND))
000004  6820              LDR      r0,[r4,#0]
000006  6b40              LDR      r0,[r0,#0x34]
000008  f4007080          AND      r0,r0,#0x100
00000c  b158              CBZ      r0,|L13.38|
;;;1369     {
;;;1370       __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_IT_DATAEND);  
00000e  f44f7080          MOV      r0,#0x100
000012  6821              LDR      r1,[r4,#0]
000014  6388              STR      r0,[r1,#0x38]
;;;1371         
;;;1372       /* SD transfer is complete */
;;;1373       hsd->SdTransferCplt = 1;
000016  2001              MOVS     r0,#1
000018  64a0              STR      r0,[r4,#0x48]
;;;1374   
;;;1375       /* No transfer error */ 
;;;1376       hsd->SdTransferErr  = SD_OK;
00001a  2000              MOVS     r0,#0
00001c  64e0              STR      r0,[r4,#0x4c]
;;;1377   
;;;1378       HAL_SD_XferCpltCallback(hsd);  
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       HAL_SD_XferCpltCallback
000024  e044              B        |L13.176|
                  |L13.38|
;;;1379     }  
;;;1380     else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_IT_DCRCFAIL))
000026  6820              LDR      r0,[r4,#0]
000028  6b40              LDR      r0,[r0,#0x34]
00002a  f0000002          AND      r0,r0,#2
00002e  b138              CBZ      r0,|L13.64|
;;;1381     {
;;;1382       __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DCRCFAIL);
000030  2002              MOVS     r0,#2
000032  6821              LDR      r1,[r4,#0]
000034  6388              STR      r0,[r1,#0x38]
;;;1383       
;;;1384       hsd->SdTransferErr = SD_DATA_CRC_FAIL;
000036  64e0              STR      r0,[r4,#0x4c]
;;;1385       
;;;1386       HAL_SD_XferErrorCallback(hsd);
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       HAL_SD_XferErrorCallback
00003e  e037              B        |L13.176|
                  |L13.64|
;;;1387       
;;;1388     }
;;;1389     else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_IT_DTIMEOUT))
000040  6820              LDR      r0,[r4,#0]
000042  6b40              LDR      r0,[r0,#0x34]
000044  f0000008          AND      r0,r0,#8
000048  b140              CBZ      r0,|L13.92|
;;;1390     {
;;;1391       __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DTIMEOUT);
00004a  2008              MOVS     r0,#8
00004c  6821              LDR      r1,[r4,#0]
00004e  6388              STR      r0,[r1,#0x38]
;;;1392       
;;;1393       hsd->SdTransferErr = SD_DATA_TIMEOUT;
000050  2004              MOVS     r0,#4
000052  64e0              STR      r0,[r4,#0x4c]
;;;1394       
;;;1395       HAL_SD_XferErrorCallback(hsd);
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       HAL_SD_XferErrorCallback
00005a  e029              B        |L13.176|
                  |L13.92|
;;;1396     }
;;;1397     else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_IT_RXOVERR))
00005c  6820              LDR      r0,[r4,#0]
00005e  6b40              LDR      r0,[r0,#0x34]
000060  f0000020          AND      r0,r0,#0x20
000064  b140              CBZ      r0,|L13.120|
;;;1398     {
;;;1399       __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_RXOVERR);
000066  2020              MOVS     r0,#0x20
000068  6821              LDR      r1,[r4,#0]
00006a  6388              STR      r0,[r1,#0x38]
;;;1400       
;;;1401       hsd->SdTransferErr = SD_RX_OVERRUN;
00006c  2006              MOVS     r0,#6
00006e  64e0              STR      r0,[r4,#0x4c]
;;;1402       
;;;1403       HAL_SD_XferErrorCallback(hsd);
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       HAL_SD_XferErrorCallback
000076  e01b              B        |L13.176|
                  |L13.120|
;;;1404     }
;;;1405     else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_IT_TXUNDERR))
000078  6820              LDR      r0,[r4,#0]
00007a  6b40              LDR      r0,[r0,#0x34]
00007c  f0000010          AND      r0,r0,#0x10
000080  b140              CBZ      r0,|L13.148|
;;;1406     {
;;;1407       __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_TXUNDERR);
000082  2010              MOVS     r0,#0x10
000084  6821              LDR      r1,[r4,#0]
000086  6388              STR      r0,[r1,#0x38]
;;;1408       
;;;1409       hsd->SdTransferErr = SD_TX_UNDERRUN;
000088  2005              MOVS     r0,#5
00008a  64e0              STR      r0,[r4,#0x4c]
;;;1410       
;;;1411       HAL_SD_XferErrorCallback(hsd);
00008c  4620              MOV      r0,r4
00008e  f7fffffe          BL       HAL_SD_XferErrorCallback
000092  e00d              B        |L13.176|
                  |L13.148|
;;;1412     }
;;;1413   #ifdef SDIO_STA_STBITERR
;;;1414     else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_IT_STBITERR))
000094  6820              LDR      r0,[r4,#0]
000096  6b40              LDR      r0,[r0,#0x34]
000098  f4007000          AND      r0,r0,#0x200
00009c  b140              CBZ      r0,|L13.176|
;;;1415     {
;;;1416       __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_STBITERR);
00009e  f44f7000          MOV      r0,#0x200
0000a2  6821              LDR      r1,[r4,#0]
0000a4  6388              STR      r0,[r1,#0x38]
;;;1417       
;;;1418       hsd->SdTransferErr = SD_START_BIT_ERR;
0000a6  2007              MOVS     r0,#7
0000a8  64e0              STR      r0,[r4,#0x4c]
;;;1419       
;;;1420       HAL_SD_XferErrorCallback(hsd);
0000aa  4620              MOV      r0,r4
0000ac  f7fffffe          BL       HAL_SD_XferErrorCallback
                  |L13.176|
;;;1421     }
;;;1422   #endif /* SDIO_STA_STBITERR */
;;;1423     else
;;;1424     {
;;;1425       /* No error flag set */
;;;1426     }
;;;1427   
;;;1428     /* Disable all SDIO peripheral interrupt sources */
;;;1429   #ifdef SDIO_STA_STBITERR
;;;1430     __HAL_SD_SDIO_DISABLE_IT(hsd, SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_DATAEND  |\
0000b0  6820              LDR      r0,[r4,#0]
0000b2  6bc0              LDR      r0,[r0,#0x3c]
0000b4  f24c313a          MOV      r1,#0xc33a
0000b8  4388              BICS     r0,r0,r1
0000ba  6821              LDR      r1,[r4,#0]
0000bc  63c8              STR      r0,[r1,#0x3c]
;;;1431                                   SDIO_IT_TXFIFOHE | SDIO_IT_RXFIFOHF | SDIO_IT_TXUNDERR |\
;;;1432                                   SDIO_IT_RXOVERR  | SDIO_IT_STBITERR);
;;;1433   #else /* SDIO_STA_STBITERR not defined */
;;;1434     __HAL_SD_SDIO_DISABLE_IT(hsd, SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_DATAEND  |\
;;;1435                                   SDIO_IT_TXFIFOHE | SDIO_IT_RXFIFOHF | SDIO_IT_TXUNDERR |\
;;;1436                                   SDIO_IT_RXOVERR);
;;;1437   #endif /* SDIO_STA_STBITERR */
;;;1438   }
0000be  bd10              POP      {r4,pc}
;;;1439   
                          ENDP


                          AREA ||i.HAL_SD_Init||, CODE, READONLY, ALIGN=1

                  HAL_SD_Init PROC
;;;340      */
;;;341    HAL_SD_ErrorTypedef HAL_SD_Init(SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypedef *SDCardInfo)
000000  b530              PUSH     {r4,r5,lr}
;;;342    { 
000002  b08b              SUB      sp,sp,#0x2c
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;343      __IO HAL_SD_ErrorTypedef errorstate = SD_OK;
000008  2000              MOVS     r0,#0
00000a  900a              STR      r0,[sp,#0x28]
;;;344      SD_InitTypeDef tmpinit;
;;;345      
;;;346      /* Allocate lock resource and initialize it */
;;;347      hsd->Lock = HAL_UNLOCKED;
00000c  7720              STRB     r0,[r4,#0x1c]
;;;348      /* Initialize the low level hardware (MSP) */
;;;349      HAL_SD_MspInit(hsd);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       HAL_SD_MspInit
;;;350      
;;;351      /* Default SDIO peripheral configuration for SD card initialization */
;;;352      tmpinit.ClockEdge           = SDIO_CLOCK_EDGE_RISING;
000014  2000              MOVS     r0,#0
000016  9004              STR      r0,[sp,#0x10]
;;;353      tmpinit.ClockBypass         = SDIO_CLOCK_BYPASS_DISABLE;
000018  9005              STR      r0,[sp,#0x14]
;;;354      tmpinit.ClockPowerSave      = SDIO_CLOCK_POWER_SAVE_DISABLE;
00001a  9006              STR      r0,[sp,#0x18]
;;;355      tmpinit.BusWide             = SDIO_BUS_WIDE_1B;
00001c  9007              STR      r0,[sp,#0x1c]
;;;356      tmpinit.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
00001e  9008              STR      r0,[sp,#0x20]
;;;357      tmpinit.ClockDiv            = SDIO_INIT_CLK_DIV;
000020  2076              MOVS     r0,#0x76
000022  9009              STR      r0,[sp,#0x24]
;;;358      
;;;359      /* Initialize SDIO peripheral interface with default configuration */
;;;360      SDIO_Init(hsd->Instance, tmpinit);
000024  a807              ADD      r0,sp,#0x1c
000026  c807              LDM      r0,{r0-r2}
000028  e88d0007          STM      sp,{r0-r2}
00002c  6820              LDR      r0,[r4,#0]
00002e  a904              ADD      r1,sp,#0x10
000030  c90e              LDM      r1,{r1-r3}
000032  f7fffffe          BL       SDIO_Init
;;;361      
;;;362      /* Identify card operating voltage */
;;;363      errorstate = SD_PowerON(hsd); 
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       SD_PowerON
00003c  900a              STR      r0,[sp,#0x28]
;;;364      
;;;365      if(errorstate != SD_OK)     
00003e  f89d0028          LDRB     r0,[sp,#0x28]
000042  b118              CBZ      r0,|L14.76|
;;;366      {
;;;367        return errorstate;
000044  f89d0028          LDRB     r0,[sp,#0x28]
                  |L14.72|
;;;368      }
;;;369      
;;;370      /* Initialize the present SDIO card(s) and put them in idle state */
;;;371      errorstate = SD_Initialize_Cards(hsd);
;;;372      
;;;373      if (errorstate != SD_OK)
;;;374      {
;;;375        return errorstate;
;;;376      }
;;;377      
;;;378      /* Read CSD/CID MSD registers */
;;;379      errorstate = HAL_SD_Get_CardInfo(hsd, SDCardInfo);
;;;380      
;;;381      if (errorstate == SD_OK)
;;;382      {
;;;383        /* Select the Card */
;;;384        errorstate = SD_Select_Deselect(hsd, (uint32_t)(((uint32_t)SDCardInfo->RCA) << 16));
;;;385      }
;;;386      
;;;387      /* Configure SDIO peripheral interface */
;;;388      SDIO_Init(hsd->Instance, hsd->Init);   
;;;389      
;;;390      return errorstate;
;;;391    }
000048  b00b              ADD      sp,sp,#0x2c
00004a  bd30              POP      {r4,r5,pc}
                  |L14.76|
00004c  4620              MOV      r0,r4                 ;371
00004e  f7fffffe          BL       SD_Initialize_Cards
000052  900a              STR      r0,[sp,#0x28]         ;371
000054  f89d0028          LDRB     r0,[sp,#0x28]         ;373
000058  b110              CBZ      r0,|L14.96|
00005a  f89d0028          LDRB     r0,[sp,#0x28]         ;375
00005e  e7f3              B        |L14.72|
                  |L14.96|
000060  4629              MOV      r1,r5                 ;379
000062  4620              MOV      r0,r4                 ;379
000064  f7fffffe          BL       HAL_SD_Get_CardInfo
000068  900a              STR      r0,[sp,#0x28]         ;379
00006a  f89d0028          LDRB     r0,[sp,#0x28]         ;381
00006e  b940              CBNZ     r0,|L14.130|
000070  f8b50054          LDRH     r0,[r5,#0x54]         ;384
000074  0401              LSLS     r1,r0,#16             ;384
000076  460a              MOV      r2,r1                 ;384
000078  2300              MOVS     r3,#0                 ;384
00007a  4620              MOV      r0,r4                 ;384
00007c  f7fffffe          BL       SD_Select_Deselect
000080  900a              STR      r0,[sp,#0x28]         ;384
                  |L14.130|
000082  e9d41204          LDRD     r1,r2,[r4,#0x10]      ;388
000086  69a0              LDR      r0,[r4,#0x18]         ;388
000088  e9cd1200          STRD     r1,r2,[sp,#0]         ;388
00008c  9002              STR      r0,[sp,#8]            ;388
00008e  e894000f          LDM      r4,{r0-r3}            ;388
000092  f7fffffe          BL       SDIO_Init
000096  f89d0028          LDRB     r0,[sp,#0x28]         ;390
00009a  e7d5              B        |L14.72|
;;;392    
                          ENDP


                          AREA ||i.HAL_SD_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_SD_MspDeInit PROC
;;;429      */
;;;430    __weak void HAL_SD_MspDeInit(SD_HandleTypeDef *hsd)
000000  4770              BX       lr
;;;431    {
;;;432      /* Prevent unused argument(s) compilation warning */
;;;433      UNUSED(hsd);
;;;434      /* NOTE : This function Should not be modified, when the callback is needed,
;;;435                the HAL_SD_MspDeInit could be implemented in the user file
;;;436       */
;;;437    }
;;;438    
                          ENDP


                          AREA ||i.HAL_SD_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_SD_MspInit PROC
;;;415      */
;;;416    __weak void HAL_SD_MspInit(SD_HandleTypeDef *hsd)
000000  4770              BX       lr
;;;417    {
;;;418      /* Prevent unused argument(s) compilation warning */
;;;419      UNUSED(hsd);
;;;420      /* NOTE : This function Should not be modified, when the callback is needed,
;;;421                the HAL_SD_MspInit could be implemented in the user file
;;;422       */
;;;423    }
;;;424    
                          ENDP


                          AREA ||i.HAL_SD_ReadBlocks||, CODE, READONLY, ALIGN=1

                  HAL_SD_ReadBlocks PROC
;;;468      */
;;;469    HAL_SD_ErrorTypedef HAL_SD_ReadBlocks(SD_HandleTypeDef *hsd, uint32_t *pReadBuffer, uint64_t ReadAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;470    {
000004  b08c              SUB      sp,sp,#0x30
000006  4604              MOV      r4,r0
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  e9ddb91a          LDRD     r11,r9,[sp,#0x68]
;;;471      SDIO_CmdInitTypeDef  sdio_cmdinitstructure;
;;;472      SDIO_DataInitTypeDef sdio_datainitstructure;
;;;473      HAL_SD_ErrorTypedef errorstate = SD_OK;
000010  f04f0a00          MOV      r10,#0
;;;474      uint32_t count = 0, *tempbuff = (uint32_t *)pReadBuffer;
000014  2500              MOVS     r5,#0
000016  9e0d              LDR      r6,[sp,#0x34]
;;;475      
;;;476      /* Initialize data control register */
;;;477      hsd->Instance->DCTRL = 0;
000018  2000              MOVS     r0,#0
00001a  6821              LDR      r1,[r4,#0]
00001c  62c8              STR      r0,[r1,#0x2c]
;;;478      
;;;479      if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
00001e  6a20              LDR      r0,[r4,#0x20]
000020  2802              CMP      r0,#2
000022  d109              BNE      |L17.56|
;;;480      {
;;;481        BlockSize = 512;
000024  f44f7b00          MOV      r11,#0x200
;;;482        ReadAddr /= 512;
000028  0202              LSLS     r2,r0,#8
00002a  2300              MOVS     r3,#0
00002c  4638              MOV      r0,r7
00002e  4641              MOV      r1,r8
000030  f7fffffe          BL       __aeabi_uldivmod
000034  4607              MOV      r7,r0
000036  4688              MOV      r8,r1
                  |L17.56|
;;;483      }
;;;484      
;;;485      /* Set Block Size for Card */ 
;;;486      sdio_cmdinitstructure.Argument         = (uint32_t) BlockSize;
000038  f8cdb01c          STR      r11,[sp,#0x1c]
;;;487      sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
00003c  2010              MOVS     r0,#0x10
00003e  9008              STR      r0,[sp,#0x20]
;;;488      sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
000040  2040              MOVS     r0,#0x40
000042  9009              STR      r0,[sp,#0x24]
;;;489      sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
000044  2000              MOVS     r0,#0
000046  900a              STR      r0,[sp,#0x28]
;;;490      sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
000048  f44f6080          MOV      r0,#0x400
00004c  900b              STR      r0,[sp,#0x2c]
;;;491      SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
00004e  a907              ADD      r1,sp,#0x1c
000050  6820              LDR      r0,[r4,#0]
000052  f7fffffe          BL       SDIO_SendCommand
;;;492      
;;;493      /* Check for error conditions */
;;;494      errorstate = SD_CmdResp1Error(hsd, SD_CMD_SET_BLOCKLEN);
000056  2110              MOVS     r1,#0x10
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       SD_CmdResp1Error
00005e  4682              MOV      r10,r0
;;;495      
;;;496      if (errorstate != SD_OK)
000060  f1ba0f00          CMP      r10,#0
000064  d003              BEQ      |L17.110|
;;;497      {
;;;498        return errorstate;
000066  4650              MOV      r0,r10
                  |L17.104|
;;;499      }
;;;500      
;;;501      /* Configure the SD DPSM (Data Path State Machine) */
;;;502      sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
;;;503      sdio_datainitstructure.DataLength    = NumberOfBlocks * BlockSize;
;;;504      sdio_datainitstructure.DataBlockSize = DATA_BLOCK_SIZE;
;;;505      sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
;;;506      sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
;;;507      sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
;;;508      SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
;;;509      
;;;510      if(NumberOfBlocks > 1)
;;;511      {
;;;512        /* Send CMD18 READ_MULT_BLOCK with argument data address */
;;;513        sdio_cmdinitstructure.CmdIndex = SD_CMD_READ_MULT_BLOCK;
;;;514      }
;;;515      else
;;;516      {
;;;517        /* Send CMD17 READ_SINGLE_BLOCK */
;;;518        sdio_cmdinitstructure.CmdIndex = SD_CMD_READ_SINGLE_BLOCK;    
;;;519      }
;;;520      
;;;521      sdio_cmdinitstructure.Argument         = (uint32_t)ReadAddr;
;;;522      SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
;;;523      
;;;524      /* Read block(s) in polling mode */
;;;525      if(NumberOfBlocks > 1)
;;;526      {
;;;527        /* Check for error conditions */
;;;528        errorstate = SD_CmdResp1Error(hsd, SD_CMD_READ_MULT_BLOCK);
;;;529        
;;;530        if (errorstate != SD_OK)
;;;531        {
;;;532          return errorstate;
;;;533        }
;;;534        
;;;535        /* Poll on SDIO flags */
;;;536    #ifdef SDIO_STA_STBITERR
;;;537        while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DATAEND | SDIO_FLAG_STBITERR))
;;;538    #else /* SDIO_STA_STBITERR not defined */
;;;539        while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DATAEND))
;;;540    #endif /* SDIO_STA_STBITERR */
;;;541        {
;;;542          if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXFIFOHF))
;;;543          {
;;;544            /* Read data from SDIO Rx FIFO */
;;;545            for (count = 0; count < 8; count++)
;;;546            {
;;;547              *(tempbuff + count) = SDIO_ReadFIFO(hsd->Instance);
;;;548            }
;;;549            
;;;550            tempbuff += 8;
;;;551          }
;;;552        }      
;;;553      }
;;;554      else
;;;555      {
;;;556        /* Check for error conditions */
;;;557        errorstate = SD_CmdResp1Error(hsd, SD_CMD_READ_SINGLE_BLOCK); 
;;;558        
;;;559        if (errorstate != SD_OK)
;;;560        {
;;;561          return errorstate;
;;;562        }    
;;;563        
;;;564        /* In case of single block transfer, no need of stop transfer at all */
;;;565    #ifdef SDIO_STA_STBITERR
;;;566        while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND | SDIO_FLAG_STBITERR))
;;;567    #else /* SDIO_STA_STBITERR not defined */
;;;568        while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND))      
;;;569    #endif /* SDIO_STA_STBITERR */
;;;570        {
;;;571          if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXFIFOHF))
;;;572          {
;;;573            /* Read data from SDIO Rx FIFO */
;;;574            for (count = 0; count < 8; count++)
;;;575            {
;;;576              *(tempbuff + count) = SDIO_ReadFIFO(hsd->Instance);
;;;577            }
;;;578            
;;;579            tempbuff += 8;
;;;580          }
;;;581        }
;;;582      }
;;;583      
;;;584      /* Send stop transmission command in case of multiblock read */
;;;585      if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DATAEND) && (NumberOfBlocks > 1))
;;;586      {    
;;;587        if ((hsd->CardType == STD_CAPACITY_SD_CARD_V1_1) ||\
;;;588          (hsd->CardType == STD_CAPACITY_SD_CARD_V2_0) ||\
;;;589            (hsd->CardType == HIGH_CAPACITY_SD_CARD))
;;;590        {
;;;591          /* Send stop transmission command */
;;;592          errorstate = HAL_SD_StopTransfer(hsd);
;;;593        }
;;;594      }
;;;595      
;;;596      /* Get error state */
;;;597      if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DTIMEOUT))
;;;598      {
;;;599        __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DTIMEOUT);
;;;600        
;;;601        errorstate = SD_DATA_TIMEOUT;
;;;602        
;;;603        return errorstate;
;;;604      }
;;;605      else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DCRCFAIL))
;;;606      {
;;;607        __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DCRCFAIL);
;;;608        
;;;609        errorstate = SD_DATA_CRC_FAIL;
;;;610        
;;;611        return errorstate;
;;;612      }
;;;613      else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR))
;;;614      {
;;;615        __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_RXOVERR);
;;;616        
;;;617        errorstate = SD_RX_OVERRUN;
;;;618        
;;;619        return errorstate;
;;;620      }
;;;621    #ifdef SDIO_STA_STBITERR
;;;622      else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_STBITERR))
;;;623      {
;;;624        __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_STBITERR);
;;;625        
;;;626        errorstate = SD_START_BIT_ERR;
;;;627        
;;;628        return errorstate;
;;;629      }
;;;630    #endif /* SDIO_STA_STBITERR */ 
;;;631      else
;;;632      {
;;;633        /* No error flag set */
;;;634      }
;;;635      
;;;636      count = SD_DATATIMEOUT;
;;;637      
;;;638      /* Empty FIFO if there is still any data */
;;;639      while ((__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXDAVL)) && (count > 0))
;;;640      {
;;;641        *tempbuff = SDIO_ReadFIFO(hsd->Instance);
;;;642        tempbuff++;
;;;643        count--;
;;;644      }
;;;645      
;;;646      /* Clear all the static flags */
;;;647      __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;648      
;;;649      return errorstate;
;;;650    }
000068  b010              ADD      sp,sp,#0x40
00006a  e8bd9ff0          POP      {r4-r12,pc}
                  |L17.110|
00006e  f04f30ff          MOV      r0,#0xffffffff        ;502
000072  9001              STR      r0,[sp,#4]            ;502
000074  fb09f00b          MUL      r0,r9,r11             ;503
000078  9002              STR      r0,[sp,#8]            ;503
00007a  2090              MOVS     r0,#0x90              ;504
00007c  9003              STR      r0,[sp,#0xc]          ;504
00007e  2002              MOVS     r0,#2                 ;505
000080  9004              STR      r0,[sp,#0x10]         ;505
000082  2000              MOVS     r0,#0                 ;506
000084  9005              STR      r0,[sp,#0x14]         ;506
000086  2001              MOVS     r0,#1                 ;507
000088  9006              STR      r0,[sp,#0x18]         ;507
00008a  a901              ADD      r1,sp,#4              ;508
00008c  6820              LDR      r0,[r4,#0]            ;508
00008e  f7fffffe          BL       SDIO_DataConfig
000092  f1b90f01          CMP      r9,#1                 ;510
000096  d902              BLS      |L17.158|
000098  2012              MOVS     r0,#0x12              ;513
00009a  9008              STR      r0,[sp,#0x20]         ;513
00009c  e001              B        |L17.162|
                  |L17.158|
00009e  2011              MOVS     r0,#0x11              ;518
0000a0  9008              STR      r0,[sp,#0x20]         ;518
                  |L17.162|
0000a2  9707              STR      r7,[sp,#0x1c]         ;521
0000a4  a907              ADD      r1,sp,#0x1c           ;522
0000a6  6820              LDR      r0,[r4,#0]            ;522
0000a8  f7fffffe          BL       SDIO_SendCommand
0000ac  f1b90f01          CMP      r9,#1                 ;525
0000b0  d922              BLS      |L17.248|
0000b2  2112              MOVS     r1,#0x12              ;528
0000b4  4620              MOV      r0,r4                 ;528
0000b6  f7fffffe          BL       SD_CmdResp1Error
0000ba  4682              MOV      r10,r0                ;528
0000bc  f1ba0f00          CMP      r10,#0                ;530
0000c0  d001              BEQ      |L17.198|
0000c2  4650              MOV      r0,r10                ;532
0000c4  e7d0              B        |L17.104|
                  |L17.198|
0000c6  e00f              B        |L17.232|
                  |L17.200|
0000c8  6820              LDR      r0,[r4,#0]            ;542
0000ca  6b40              LDR      r0,[r0,#0x34]         ;542
0000cc  f4004000          AND      r0,r0,#0x8000         ;542
0000d0  b150              CBZ      r0,|L17.232|
0000d2  2500              MOVS     r5,#0                 ;545
0000d4  e005              B        |L17.226|
                  |L17.214|
0000d6  6820              LDR      r0,[r4,#0]            ;547
0000d8  f7fffffe          BL       SDIO_ReadFIFO
0000dc  f8460025          STR      r0,[r6,r5,LSL #2]     ;547
0000e0  1c6d              ADDS     r5,r5,#1              ;545
                  |L17.226|
0000e2  2d08              CMP      r5,#8                 ;545
0000e4  d3f7              BCC      |L17.214|
0000e6  3620              ADDS     r6,r6,#0x20           ;550
                  |L17.232|
0000e8  6820              LDR      r0,[r4,#0]            ;537
0000ea  6b40              LDR      r0,[r0,#0x34]         ;537
0000ec  f240312a          MOV      r1,#0x32a             ;537
0000f0  4008              ANDS     r0,r0,r1              ;537
0000f2  2800              CMP      r0,#0                 ;537
0000f4  d0e8              BEQ      |L17.200|
0000f6  e021              B        |L17.316|
                  |L17.248|
0000f8  2111              MOVS     r1,#0x11              ;557
0000fa  4620              MOV      r0,r4                 ;557
0000fc  f7fffffe          BL       SD_CmdResp1Error
000100  4682              MOV      r10,r0                ;557
000102  f1ba0f00          CMP      r10,#0                ;559
000106  d001              BEQ      |L17.268|
000108  4650              MOV      r0,r10                ;561
00010a  e7ad              B        |L17.104|
                  |L17.268|
00010c  e00f              B        |L17.302|
                  |L17.270|
00010e  6820              LDR      r0,[r4,#0]            ;571
000110  6b40              LDR      r0,[r0,#0x34]         ;571
000112  f4004000          AND      r0,r0,#0x8000         ;571
000116  b150              CBZ      r0,|L17.302|
000118  2500              MOVS     r5,#0                 ;574
00011a  e005              B        |L17.296|
                  |L17.284|
00011c  6820              LDR      r0,[r4,#0]            ;576
00011e  f7fffffe          BL       SDIO_ReadFIFO
000122  f8460025          STR      r0,[r6,r5,LSL #2]     ;576
000126  1c6d              ADDS     r5,r5,#1              ;574
                  |L17.296|
000128  2d08              CMP      r5,#8                 ;574
00012a  d3f7              BCC      |L17.284|
00012c  3620              ADDS     r6,r6,#0x20           ;579
                  |L17.302|
00012e  6820              LDR      r0,[r4,#0]            ;566
000130  6b40              LDR      r0,[r0,#0x34]         ;566
000132  f240612a          MOV      r1,#0x62a             ;566
000136  4008              ANDS     r0,r0,r1              ;566
000138  2800              CMP      r0,#0                 ;566
00013a  d0e8              BEQ      |L17.270|
                  |L17.316|
00013c  6820              LDR      r0,[r4,#0]            ;585
00013e  6b40              LDR      r0,[r0,#0x34]         ;585
000140  f4007080          AND      r0,r0,#0x100          ;585
000144  b170              CBZ      r0,|L17.356|
000146  f1b90f01          CMP      r9,#1                 ;585
00014a  d90b              BLS      |L17.356|
00014c  6a20              LDR      r0,[r4,#0x20]         ;587
00014e  b128              CBZ      r0,|L17.348|
000150  6a20              LDR      r0,[r4,#0x20]         ;588
000152  2801              CMP      r0,#1                 ;588
000154  d002              BEQ      |L17.348|
000156  6a20              LDR      r0,[r4,#0x20]         ;589
000158  2802              CMP      r0,#2                 ;589
00015a  d103              BNE      |L17.356|
                  |L17.348|
00015c  4620              MOV      r0,r4                 ;592
00015e  f7fffffe          BL       HAL_SD_StopTransfer
000162  4682              MOV      r10,r0                ;592
                  |L17.356|
000164  6820              LDR      r0,[r4,#0]            ;597
000166  6b40              LDR      r0,[r0,#0x34]         ;597
000168  f0000008          AND      r0,r0,#8              ;597
00016c  b130              CBZ      r0,|L17.380|
00016e  2008              MOVS     r0,#8                 ;599
000170  6821              LDR      r1,[r4,#0]            ;599
000172  6388              STR      r0,[r1,#0x38]         ;599
000174  f04f0a04          MOV      r10,#4                ;601
000178  4650              MOV      r0,r10                ;603
00017a  e775              B        |L17.104|
                  |L17.380|
00017c  6820              LDR      r0,[r4,#0]            ;605
00017e  6b40              LDR      r0,[r0,#0x34]         ;605
000180  f0000002          AND      r0,r0,#2              ;605
000184  b128              CBZ      r0,|L17.402|
000186  2002              MOVS     r0,#2                 ;607
000188  6821              LDR      r1,[r4,#0]            ;607
00018a  6388              STR      r0,[r1,#0x38]         ;607
00018c  4682              MOV      r10,r0                ;609
00018e  4650              MOV      r0,r10                ;611
000190  e76a              B        |L17.104|
                  |L17.402|
000192  6820              LDR      r0,[r4,#0]            ;613
000194  6b40              LDR      r0,[r0,#0x34]         ;613
000196  f0000020          AND      r0,r0,#0x20           ;613
00019a  b130              CBZ      r0,|L17.426|
00019c  2020              MOVS     r0,#0x20              ;615
00019e  6821              LDR      r1,[r4,#0]            ;615
0001a0  6388              STR      r0,[r1,#0x38]         ;615
0001a2  f04f0a06          MOV      r10,#6                ;617
0001a6  4650              MOV      r0,r10                ;619
0001a8  e75e              B        |L17.104|
                  |L17.426|
0001aa  6820              LDR      r0,[r4,#0]            ;622
0001ac  6b40              LDR      r0,[r0,#0x34]         ;622
0001ae  f4007000          AND      r0,r0,#0x200          ;622
0001b2  b138              CBZ      r0,|L17.452|
0001b4  f44f7000          MOV      r0,#0x200             ;624
0001b8  6821              LDR      r1,[r4,#0]            ;624
0001ba  6388              STR      r0,[r1,#0x38]         ;624
0001bc  f04f0a07          MOV      r10,#7                ;626
0001c0  4650              MOV      r0,r10                ;628
0001c2  e751              B        |L17.104|
                  |L17.452|
0001c4  f04f35ff          MOV      r5,#0xffffffff        ;636
0001c8  e005              B        |L17.470|
                  |L17.458|
0001ca  6820              LDR      r0,[r4,#0]            ;641
0001cc  f7fffffe          BL       SDIO_ReadFIFO
0001d0  6030              STR      r0,[r6,#0]            ;641
0001d2  1d36              ADDS     r6,r6,#4              ;642
0001d4  1e6d              SUBS     r5,r5,#1              ;643
                  |L17.470|
0001d6  6820              LDR      r0,[r4,#0]            ;639
0001d8  6b40              LDR      r0,[r0,#0x34]         ;639
0001da  f4001000          AND      r0,r0,#0x200000       ;639
0001de  b108              CBZ      r0,|L17.484|
0001e0  2d00              CMP      r5,#0                 ;639
0001e2  d1f2              BNE      |L17.458|
                  |L17.484|
0001e4  f24050ff          MOV      r0,#0x5ff             ;647
0001e8  6821              LDR      r1,[r4,#0]            ;647
0001ea  6388              STR      r0,[r1,#0x38]         ;647
0001ec  4650              MOV      r0,r10                ;649
0001ee  e73b              B        |L17.104|
;;;651    
                          ENDP


                          AREA ||i.HAL_SD_ReadBlocks_DMA||, CODE, READONLY, ALIGN=2

                  HAL_SD_ReadBlocks_DMA PROC
;;;890      */
;;;891    HAL_SD_ErrorTypedef HAL_SD_ReadBlocks_DMA(SD_HandleTypeDef *hsd, uint32_t *pReadBuffer, uint64_t ReadAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;892    {
000004  b08c              SUB      sp,sp,#0x30
000006  4604              MOV      r4,r0
000008  468a              MOV      r10,r1
00000a  4616              MOV      r6,r2
00000c  461f              MOV      r7,r3
00000e  e9dd8514          LDRD     r8,r5,[sp,#0x50]
;;;893      SDIO_CmdInitTypeDef sdio_cmdinitstructure;
;;;894      SDIO_DataInitTypeDef sdio_datainitstructure;
;;;895      HAL_SD_ErrorTypedef errorstate = SD_OK;
000012  f04f0900          MOV      r9,#0
;;;896      
;;;897      /* Initialize data control register */
;;;898      hsd->Instance->DCTRL = 0;
000016  2000              MOVS     r0,#0
000018  6821              LDR      r1,[r4,#0]
00001a  62c8              STR      r0,[r1,#0x2c]
;;;899      
;;;900      /* Initialize handle flags */
;;;901      hsd->SdTransferCplt  = 0;
00001c  64a0              STR      r0,[r4,#0x48]
;;;902      hsd->DmaTransferCplt = 0;
00001e  6520              STR      r0,[r4,#0x50]
;;;903      hsd->SdTransferErr   = SD_OK; 
000020  64e0              STR      r0,[r4,#0x4c]
;;;904      
;;;905      /* Initialize SD Read operation */
;;;906      if(NumberOfBlocks > 1)
000022  2d01              CMP      r5,#1
000024  d902              BLS      |L18.44|
;;;907      {
;;;908        hsd->SdOperation = SD_READ_MULTIPLE_BLOCK;
000026  2001              MOVS     r0,#1
000028  6560              STR      r0,[r4,#0x54]
00002a  e001              B        |L18.48|
                  |L18.44|
;;;909      }
;;;910      else
;;;911      {
;;;912        hsd->SdOperation = SD_READ_SINGLE_BLOCK;
00002c  2000              MOVS     r0,#0
00002e  6560              STR      r0,[r4,#0x54]
                  |L18.48|
;;;913      }
;;;914      
;;;915      /* Enable transfer interrupts */
;;;916    #ifdef SDIO_STA_STBITERR
;;;917      __HAL_SD_SDIO_ENABLE_IT(hsd, (SDIO_IT_DCRCFAIL |\
000030  6820              LDR      r0,[r4,#0]
000032  6bc0              LDR      r0,[r0,#0x3c]
000034  f240312a          MOV      r1,#0x32a
000038  4308              ORRS     r0,r0,r1
00003a  6821              LDR      r1,[r4,#0]
00003c  63c8              STR      r0,[r1,#0x3c]
;;;918                                    SDIO_IT_DTIMEOUT |\
;;;919                                    SDIO_IT_DATAEND  |\
;;;920                                    SDIO_IT_RXOVERR  |\
;;;921                                    SDIO_IT_STBITERR));
;;;922    #else /* SDIO_STA_STBITERR not defined */
;;;923      __HAL_SD_SDIO_ENABLE_IT(hsd, (SDIO_IT_DCRCFAIL |\
;;;924                                    SDIO_IT_DTIMEOUT |\
;;;925                                    SDIO_IT_DATAEND  |\
;;;926                                    SDIO_IT_RXOVERR));
;;;927    #endif /* SDIO_STA_STBITERR */
;;;928      
;;;929      /* Enable SDIO DMA transfer */
;;;930      __HAL_SD_SDIO_DMA_ENABLE();
00003e  2001              MOVS     r0,#1
000040  4934              LDR      r1,|L18.276|
000042  6008              STR      r0,[r1,#0]
;;;931      
;;;932      /* Configure DMA user callbacks */
;;;933      hsd->hdmarx->XferCpltCallback  = SD_DMA_RxCplt;
000044  4834              LDR      r0,|L18.280|
000046  6da1              LDR      r1,[r4,#0x58]
000048  63c8              STR      r0,[r1,#0x3c]
;;;934      hsd->hdmarx->XferErrorCallback = SD_DMA_RxError;
00004a  4834              LDR      r0,|L18.284|
00004c  6da1              LDR      r1,[r4,#0x58]
00004e  6488              STR      r0,[r1,#0x48]
;;;935      
;;;936      /* Enable the DMA Stream */
;;;937      HAL_DMA_Start_IT(hsd->hdmarx, (uint32_t)&hsd->Instance->FIFO, (uint32_t)pReadBuffer, (uint32_t)(BlockSize * NumberOfBlocks)/4);
000050  fb08f205          MUL      r2,r8,r5
000054  0893              LSRS     r3,r2,#2
000056  6822              LDR      r2,[r4,#0]
000058  f1020180          ADD      r1,r2,#0x80
00005c  4652              MOV      r2,r10
00005e  6da0              LDR      r0,[r4,#0x58]
000060  f7fffffe          BL       HAL_DMA_Start_IT
;;;938      
;;;939      if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
000064  6a20              LDR      r0,[r4,#0x20]
000066  2802              CMP      r0,#2
000068  d109              BNE      |L18.126|
;;;940      {
;;;941        BlockSize = 512;
00006a  f44f7800          MOV      r8,#0x200
;;;942        ReadAddr /= 512;
00006e  0202              LSLS     r2,r0,#8
000070  2300              MOVS     r3,#0
000072  4630              MOV      r0,r6
000074  4639              MOV      r1,r7
000076  f7fffffe          BL       __aeabi_uldivmod
00007a  4606              MOV      r6,r0
00007c  460f              MOV      r7,r1
                  |L18.126|
;;;943      }
;;;944      
;;;945      /* Set Block Size for Card */ 
;;;946      sdio_cmdinitstructure.Argument         = (uint32_t)BlockSize;
00007e  f8cd801c          STR      r8,[sp,#0x1c]
;;;947      sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
000082  2010              MOVS     r0,#0x10
000084  9008              STR      r0,[sp,#0x20]
;;;948      sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
000086  2040              MOVS     r0,#0x40
000088  9009              STR      r0,[sp,#0x24]
;;;949      sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
00008a  2000              MOVS     r0,#0
00008c  900a              STR      r0,[sp,#0x28]
;;;950      sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
00008e  f44f6080          MOV      r0,#0x400
000092  900b              STR      r0,[sp,#0x2c]
;;;951      SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
000094  a907              ADD      r1,sp,#0x1c
000096  6820              LDR      r0,[r4,#0]
000098  f7fffffe          BL       SDIO_SendCommand
;;;952      
;;;953      /* Check for error conditions */
;;;954      errorstate = SD_CmdResp1Error(hsd, SD_CMD_SET_BLOCKLEN);
00009c  2110              MOVS     r1,#0x10
00009e  4620              MOV      r0,r4
0000a0  f7fffffe          BL       SD_CmdResp1Error
0000a4  4681              MOV      r9,r0
;;;955      
;;;956      if (errorstate != SD_OK)
0000a6  f1b90f00          CMP      r9,#0
0000aa  d003              BEQ      |L18.180|
;;;957      {
;;;958        return errorstate;
0000ac  4648              MOV      r0,r9
                  |L18.174|
;;;959      }
;;;960      
;;;961      /* Configure the SD DPSM (Data Path State Machine) */ 
;;;962      sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
;;;963      sdio_datainitstructure.DataLength    = BlockSize * NumberOfBlocks;
;;;964      sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
;;;965      sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
;;;966      sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
;;;967      sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
;;;968      SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
;;;969      
;;;970      /* Check number of blocks command */
;;;971      if(NumberOfBlocks > 1)
;;;972      {
;;;973        /* Send CMD18 READ_MULT_BLOCK with argument data address */
;;;974        sdio_cmdinitstructure.CmdIndex = SD_CMD_READ_MULT_BLOCK;
;;;975      }
;;;976      else
;;;977      {
;;;978        /* Send CMD17 READ_SINGLE_BLOCK */
;;;979        sdio_cmdinitstructure.CmdIndex = SD_CMD_READ_SINGLE_BLOCK;
;;;980      }
;;;981      
;;;982      sdio_cmdinitstructure.Argument = (uint32_t)ReadAddr;
;;;983      SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
;;;984      
;;;985      /* Check for error conditions */
;;;986      if(NumberOfBlocks > 1)
;;;987      {
;;;988        errorstate = SD_CmdResp1Error(hsd, SD_CMD_READ_MULT_BLOCK);
;;;989      }
;;;990      else
;;;991      {
;;;992        errorstate = SD_CmdResp1Error(hsd, SD_CMD_READ_SINGLE_BLOCK);
;;;993      }
;;;994      
;;;995      /* Update the SD transfer error in SD handle */
;;;996      hsd->SdTransferErr = errorstate;
;;;997      
;;;998      return errorstate;
;;;999    }
0000ae  b00c              ADD      sp,sp,#0x30
0000b0  e8bd87f0          POP      {r4-r10,pc}
                  |L18.180|
0000b4  f04f30ff          MOV      r0,#0xffffffff        ;962
0000b8  9001              STR      r0,[sp,#4]            ;962
0000ba  fb08f005          MUL      r0,r8,r5              ;963
0000be  9002              STR      r0,[sp,#8]            ;963
0000c0  2090              MOVS     r0,#0x90              ;964
0000c2  9003              STR      r0,[sp,#0xc]          ;964
0000c4  2002              MOVS     r0,#2                 ;965
0000c6  9004              STR      r0,[sp,#0x10]         ;965
0000c8  2000              MOVS     r0,#0                 ;966
0000ca  9005              STR      r0,[sp,#0x14]         ;966
0000cc  2001              MOVS     r0,#1                 ;967
0000ce  9006              STR      r0,[sp,#0x18]         ;967
0000d0  a901              ADD      r1,sp,#4              ;968
0000d2  6820              LDR      r0,[r4,#0]            ;968
0000d4  f7fffffe          BL       SDIO_DataConfig
0000d8  2d01              CMP      r5,#1                 ;971
0000da  d902              BLS      |L18.226|
0000dc  2012              MOVS     r0,#0x12              ;974
0000de  9008              STR      r0,[sp,#0x20]         ;974
0000e0  e001              B        |L18.230|
                  |L18.226|
0000e2  2011              MOVS     r0,#0x11              ;979
0000e4  9008              STR      r0,[sp,#0x20]         ;979
                  |L18.230|
0000e6  9607              STR      r6,[sp,#0x1c]         ;982
0000e8  a907              ADD      r1,sp,#0x1c           ;983
0000ea  6820              LDR      r0,[r4,#0]            ;983
0000ec  f7fffffe          BL       SDIO_SendCommand
0000f0  2d01              CMP      r5,#1                 ;986
0000f2  d905              BLS      |L18.256|
0000f4  2112              MOVS     r1,#0x12              ;988
0000f6  4620              MOV      r0,r4                 ;988
0000f8  f7fffffe          BL       SD_CmdResp1Error
0000fc  4681              MOV      r9,r0                 ;988
0000fe  e004              B        |L18.266|
                  |L18.256|
000100  2111              MOVS     r1,#0x11              ;992
000102  4620              MOV      r0,r4                 ;992
000104  f7fffffe          BL       SD_CmdResp1Error
000108  4681              MOV      r9,r0                 ;992
                  |L18.266|
00010a  f8c4904c          STR      r9,[r4,#0x4c]         ;996
00010e  4648              MOV      r0,r9                 ;998
000110  e7cd              B        |L18.174|
;;;1000   
                          ENDP

000112  0000              DCW      0x0000
                  |L18.276|
                          DCD      0x4225858c
                  |L18.280|
                          DCD      SD_DMA_RxCplt
                  |L18.284|
                          DCD      SD_DMA_RxError

                          AREA ||i.HAL_SD_SendSDStatus||, CODE, READONLY, ALIGN=1

                  HAL_SD_SendSDStatus PROC
;;;2019     */
;;;2020   HAL_SD_ErrorTypedef HAL_SD_SendSDStatus(SD_HandleTypeDef *hsd, uint32_t *pSDstatus)
000000  b5f0              PUSH     {r4-r7,lr}
;;;2021   {
000002  b08b              SUB      sp,sp,#0x2c
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;2022     SDIO_CmdInitTypeDef  sdio_cmdinitstructure;
;;;2023     SDIO_DataInitTypeDef sdio_datainitstructure;
;;;2024     HAL_SD_ErrorTypedef errorstate = SD_OK;
000008  2700              MOVS     r7,#0
;;;2025     uint32_t count = 0;
00000a  2600              MOVS     r6,#0
;;;2026     
;;;2027     /* Check SD response */
;;;2028     if ((SDIO_GetResponse(SDIO_RESP1) & SD_CARD_LOCKED) == SD_CARD_LOCKED)
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       SDIO_GetResponse
000012  f0007000          AND      r0,r0,#0x2000000
000016  f1b07f00          CMP      r0,#0x2000000
00001a  d103              BNE      |L19.36|
;;;2029     {
;;;2030       errorstate = SD_LOCK_UNLOCK_FAILED;
00001c  270e              MOVS     r7,#0xe
;;;2031       
;;;2032       return errorstate;
00001e  4638              MOV      r0,r7
                  |L19.32|
;;;2033     }
;;;2034     
;;;2035     /* Set block size for card if it is not equal to current block size for card */
;;;2036     sdio_cmdinitstructure.Argument         = 64;
;;;2037     sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
;;;2038     sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
;;;2039     sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
;;;2040     sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
;;;2041     SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
;;;2042     
;;;2043     /* Check for error conditions */
;;;2044     errorstate = SD_CmdResp1Error(hsd, SD_CMD_SET_BLOCKLEN);
;;;2045     
;;;2046     if (errorstate != SD_OK)
;;;2047     {
;;;2048       return errorstate;
;;;2049     }
;;;2050     
;;;2051     /* Send CMD55 */
;;;2052     sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16);
;;;2053     sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
;;;2054     SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
;;;2055     
;;;2056     /* Check for error conditions */
;;;2057     errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_CMD);
;;;2058     
;;;2059     if (errorstate != SD_OK)
;;;2060     {
;;;2061       return errorstate;
;;;2062     }
;;;2063     
;;;2064     /* Configure the SD DPSM (Data Path State Machine) */ 
;;;2065     sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
;;;2066     sdio_datainitstructure.DataLength    = 64;
;;;2067     sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_64B;
;;;2068     sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
;;;2069     sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
;;;2070     sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
;;;2071     SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
;;;2072     
;;;2073     /* Send ACMD13 (SD_APP_STATUS)  with argument as card's RCA */
;;;2074     sdio_cmdinitstructure.Argument         = 0;
;;;2075     sdio_cmdinitstructure.CmdIndex         = SD_CMD_SD_APP_STATUS;
;;;2076     SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
;;;2077     
;;;2078     /* Check for error conditions */
;;;2079     errorstate = SD_CmdResp1Error(hsd, SD_CMD_SD_APP_STATUS);
;;;2080     
;;;2081     if (errorstate != SD_OK)
;;;2082     {
;;;2083       return errorstate;
;;;2084     }
;;;2085     
;;;2086     /* Get status data */
;;;2087   #ifdef SDIO_STA_STBITERR 
;;;2088     while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND | SDIO_FLAG_STBITERR))
;;;2089   #else /* SDIO_STA_STBITERR not defined */
;;;2090     while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND))    
;;;2091   #endif /* SDIO_STA_STBITERR */
;;;2092     {
;;;2093       if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXFIFOHF))
;;;2094       {
;;;2095         for (count = 0; count < 8; count++)
;;;2096         {
;;;2097           *(pSDstatus + count) = SDIO_ReadFIFO(hsd->Instance);
;;;2098         }
;;;2099         
;;;2100         pSDstatus += 8;
;;;2101       }
;;;2102     }
;;;2103     
;;;2104     if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DTIMEOUT))
;;;2105     {
;;;2106       __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DTIMEOUT);
;;;2107       
;;;2108       errorstate = SD_DATA_TIMEOUT;
;;;2109       
;;;2110       return errorstate;
;;;2111     }
;;;2112     else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DCRCFAIL))
;;;2113     {
;;;2114       __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DCRCFAIL);
;;;2115       
;;;2116       errorstate = SD_DATA_CRC_FAIL;
;;;2117       
;;;2118       return errorstate;
;;;2119     }
;;;2120     else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR))
;;;2121     {
;;;2122       __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_RXOVERR);
;;;2123       
;;;2124       errorstate = SD_RX_OVERRUN;
;;;2125       
;;;2126       return errorstate;
;;;2127     }
;;;2128   #ifdef SDIO_STA_STBITERR
;;;2129     else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_STBITERR))
;;;2130     {
;;;2131       __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_STBITERR);
;;;2132       
;;;2133       errorstate = SD_START_BIT_ERR;
;;;2134       
;;;2135       return errorstate;
;;;2136     }
;;;2137   #endif /* SDIO_STA_STBITERR */
;;;2138     else
;;;2139     {
;;;2140       /* No error flag set */
;;;2141     }  
;;;2142     
;;;2143     count = SD_DATATIMEOUT;
;;;2144     while ((__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXDAVL)) && (count > 0))
;;;2145     {
;;;2146       *pSDstatus = SDIO_ReadFIFO(hsd->Instance);
;;;2147       pSDstatus++;
;;;2148       count--;
;;;2149     }
;;;2150     
;;;2151     /* Clear all the static status flags*/
;;;2152     __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;2153     
;;;2154     return errorstate;
;;;2155   }
000020  b00b              ADD      sp,sp,#0x2c
000022  bdf0              POP      {r4-r7,pc}
                  |L19.36|
000024  2040              MOVS     r0,#0x40              ;2036
000026  9006              STR      r0,[sp,#0x18]         ;2036
000028  2010              MOVS     r0,#0x10              ;2037
00002a  9007              STR      r0,[sp,#0x1c]         ;2037
00002c  2040              MOVS     r0,#0x40              ;2038
00002e  9008              STR      r0,[sp,#0x20]         ;2038
000030  2000              MOVS     r0,#0                 ;2039
000032  9009              STR      r0,[sp,#0x24]         ;2039
000034  f44f6080          MOV      r0,#0x400             ;2040
000038  900a              STR      r0,[sp,#0x28]         ;2040
00003a  a906              ADD      r1,sp,#0x18           ;2041
00003c  6820              LDR      r0,[r4,#0]            ;2041
00003e  f7fffffe          BL       SDIO_SendCommand
000042  2110              MOVS     r1,#0x10              ;2044
000044  4620              MOV      r0,r4                 ;2044
000046  f7fffffe          BL       SD_CmdResp1Error
00004a  4607              MOV      r7,r0                 ;2044
00004c  b10f              CBZ      r7,|L19.82|
00004e  4638              MOV      r0,r7                 ;2048
000050  e7e6              B        |L19.32|
                  |L19.82|
000052  8ca0              LDRH     r0,[r4,#0x24]         ;2052
000054  0400              LSLS     r0,r0,#16             ;2052
000056  9006              STR      r0,[sp,#0x18]         ;2052
000058  2037              MOVS     r0,#0x37              ;2053
00005a  9007              STR      r0,[sp,#0x1c]         ;2053
00005c  a906              ADD      r1,sp,#0x18           ;2054
00005e  6820              LDR      r0,[r4,#0]            ;2054
000060  f7fffffe          BL       SDIO_SendCommand
000064  2137              MOVS     r1,#0x37              ;2057
000066  4620              MOV      r0,r4                 ;2057
000068  f7fffffe          BL       SD_CmdResp1Error
00006c  4607              MOV      r7,r0                 ;2057
00006e  b10f              CBZ      r7,|L19.116|
000070  4638              MOV      r0,r7                 ;2061
000072  e7d5              B        |L19.32|
                  |L19.116|
000074  f04f30ff          MOV      r0,#0xffffffff        ;2065
000078  9000              STR      r0,[sp,#0]            ;2065
00007a  2040              MOVS     r0,#0x40              ;2066
00007c  9001              STR      r0,[sp,#4]            ;2066
00007e  2060              MOVS     r0,#0x60              ;2067
000080  9002              STR      r0,[sp,#8]            ;2067
000082  2002              MOVS     r0,#2                 ;2068
000084  9003              STR      r0,[sp,#0xc]          ;2068
000086  2000              MOVS     r0,#0                 ;2069
000088  9004              STR      r0,[sp,#0x10]         ;2069
00008a  2001              MOVS     r0,#1                 ;2070
00008c  9005              STR      r0,[sp,#0x14]         ;2070
00008e  4669              MOV      r1,sp                 ;2071
000090  6820              LDR      r0,[r4,#0]            ;2071
000092  f7fffffe          BL       SDIO_DataConfig
000096  2000              MOVS     r0,#0                 ;2074
000098  9006              STR      r0,[sp,#0x18]         ;2074
00009a  200d              MOVS     r0,#0xd               ;2075
00009c  9007              STR      r0,[sp,#0x1c]         ;2075
00009e  a906              ADD      r1,sp,#0x18           ;2076
0000a0  6820              LDR      r0,[r4,#0]            ;2076
0000a2  f7fffffe          BL       SDIO_SendCommand
0000a6  210d              MOVS     r1,#0xd               ;2079
0000a8  4620              MOV      r0,r4                 ;2079
0000aa  f7fffffe          BL       SD_CmdResp1Error
0000ae  4607              MOV      r7,r0                 ;2079
0000b0  b10f              CBZ      r7,|L19.182|
0000b2  4638              MOV      r0,r7                 ;2083
0000b4  e7b4              B        |L19.32|
                  |L19.182|
0000b6  e00f              B        |L19.216|
                  |L19.184|
0000b8  6820              LDR      r0,[r4,#0]            ;2093
0000ba  6b40              LDR      r0,[r0,#0x34]         ;2093
0000bc  f4004000          AND      r0,r0,#0x8000         ;2093
0000c0  b150              CBZ      r0,|L19.216|
0000c2  2600              MOVS     r6,#0                 ;2095
0000c4  e005              B        |L19.210|
                  |L19.198|
0000c6  6820              LDR      r0,[r4,#0]            ;2097
0000c8  f7fffffe          BL       SDIO_ReadFIFO
0000cc  f8450026          STR      r0,[r5,r6,LSL #2]     ;2097
0000d0  1c76              ADDS     r6,r6,#1              ;2095
                  |L19.210|
0000d2  2e08              CMP      r6,#8                 ;2095
0000d4  d3f7              BCC      |L19.198|
0000d6  3520              ADDS     r5,r5,#0x20           ;2100
                  |L19.216|
0000d8  6820              LDR      r0,[r4,#0]            ;2088
0000da  6b40              LDR      r0,[r0,#0x34]         ;2088
0000dc  f240612a          MOV      r1,#0x62a             ;2088
0000e0  4008              ANDS     r0,r0,r1              ;2088
0000e2  2800              CMP      r0,#0                 ;2088
0000e4  d0e8              BEQ      |L19.184|
0000e6  6820              LDR      r0,[r4,#0]            ;2104
0000e8  6b40              LDR      r0,[r0,#0x34]         ;2104
0000ea  f0000008          AND      r0,r0,#8              ;2104
0000ee  b128              CBZ      r0,|L19.252|
0000f0  2008              MOVS     r0,#8                 ;2106
0000f2  6821              LDR      r1,[r4,#0]            ;2106
0000f4  6388              STR      r0,[r1,#0x38]         ;2106
0000f6  2704              MOVS     r7,#4                 ;2108
0000f8  4638              MOV      r0,r7                 ;2110
0000fa  e791              B        |L19.32|
                  |L19.252|
0000fc  6820              LDR      r0,[r4,#0]            ;2112
0000fe  6b40              LDR      r0,[r0,#0x34]         ;2112
000100  f0000002          AND      r0,r0,#2              ;2112
000104  b128              CBZ      r0,|L19.274|
000106  2002              MOVS     r0,#2                 ;2114
000108  6821              LDR      r1,[r4,#0]            ;2114
00010a  6388              STR      r0,[r1,#0x38]         ;2114
00010c  2702              MOVS     r7,#2                 ;2116
00010e  4638              MOV      r0,r7                 ;2118
000110  e786              B        |L19.32|
                  |L19.274|
000112  6820              LDR      r0,[r4,#0]            ;2120
000114  6b40              LDR      r0,[r0,#0x34]         ;2120
000116  f0000020          AND      r0,r0,#0x20           ;2120
00011a  b128              CBZ      r0,|L19.296|
00011c  2020              MOVS     r0,#0x20              ;2122
00011e  6821              LDR      r1,[r4,#0]            ;2122
000120  6388              STR      r0,[r1,#0x38]         ;2122
000122  2706              MOVS     r7,#6                 ;2124
000124  4638              MOV      r0,r7                 ;2126
000126  e77b              B        |L19.32|
                  |L19.296|
000128  6820              LDR      r0,[r4,#0]            ;2129
00012a  6b40              LDR      r0,[r0,#0x34]         ;2129
00012c  f4007000          AND      r0,r0,#0x200          ;2129
000130  b130              CBZ      r0,|L19.320|
000132  f44f7000          MOV      r0,#0x200             ;2131
000136  6821              LDR      r1,[r4,#0]            ;2131
000138  6388              STR      r0,[r1,#0x38]         ;2131
00013a  2707              MOVS     r7,#7                 ;2133
00013c  4638              MOV      r0,r7                 ;2135
00013e  e76f              B        |L19.32|
                  |L19.320|
000140  f04f36ff          MOV      r6,#0xffffffff        ;2143
000144  e005              B        |L19.338|
                  |L19.326|
000146  6820              LDR      r0,[r4,#0]            ;2146
000148  f7fffffe          BL       SDIO_ReadFIFO
00014c  6028              STR      r0,[r5,#0]            ;2146
00014e  1d2d              ADDS     r5,r5,#4              ;2147
000150  1e76              SUBS     r6,r6,#1              ;2148
                  |L19.338|
000152  6820              LDR      r0,[r4,#0]            ;2144
000154  6b40              LDR      r0,[r0,#0x34]         ;2144
000156  f4001000          AND      r0,r0,#0x200000       ;2144
00015a  b108              CBZ      r0,|L19.352|
00015c  2e00              CMP      r6,#0                 ;2144
00015e  d1f2              BNE      |L19.326|
                  |L19.352|
000160  f24050ff          MOV      r0,#0x5ff             ;2152
000164  6821              LDR      r1,[r4,#0]            ;2152
000166  6388              STR      r0,[r1,#0x38]         ;2152
000168  4638              MOV      r0,r7                 ;2154
00016a  e759              B        |L19.32|
;;;2156   
                          ENDP


                          AREA ||i.HAL_SD_StopTransfer||, CODE, READONLY, ALIGN=1

                  HAL_SD_StopTransfer PROC
;;;1824     */
;;;1825   HAL_SD_ErrorTypedef HAL_SD_StopTransfer(SD_HandleTypeDef *hsd)
000000  b530              PUSH     {r4,r5,lr}
;;;1826   {
000002  b085              SUB      sp,sp,#0x14
000004  4604              MOV      r4,r0
;;;1827     SDIO_CmdInitTypeDef sdio_cmdinitstructure;
;;;1828     HAL_SD_ErrorTypedef errorstate = SD_OK;
000006  2500              MOVS     r5,#0
;;;1829     
;;;1830     /* Send CMD12 STOP_TRANSMISSION  */
;;;1831     sdio_cmdinitstructure.Argument         = 0;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;1832     sdio_cmdinitstructure.CmdIndex         = SD_CMD_STOP_TRANSMISSION;
00000c  200c              MOVS     r0,#0xc
00000e  9001              STR      r0,[sp,#4]
;;;1833     sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
000010  2040              MOVS     r0,#0x40
000012  9002              STR      r0,[sp,#8]
;;;1834     sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
000014  2000              MOVS     r0,#0
000016  9003              STR      r0,[sp,#0xc]
;;;1835     sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
000018  f44f6080          MOV      r0,#0x400
00001c  9004              STR      r0,[sp,#0x10]
;;;1836     SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
00001e  4669              MOV      r1,sp
000020  6820              LDR      r0,[r4,#0]
000022  f7fffffe          BL       SDIO_SendCommand
;;;1837     
;;;1838     /* Check for error conditions */
;;;1839     errorstate = SD_CmdResp1Error(hsd, SD_CMD_STOP_TRANSMISSION);
000026  210c              MOVS     r1,#0xc
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       SD_CmdResp1Error
00002e  4605              MOV      r5,r0
;;;1840     
;;;1841     return errorstate;
000030  4628              MOV      r0,r5
;;;1842   }
000032  b005              ADD      sp,sp,#0x14
000034  bd30              POP      {r4,r5,pc}
;;;1843   
                          ENDP


                          AREA ||i.HAL_SD_WideBusOperation_Config||, CODE, READONLY, ALIGN=1

                  HAL_SD_WideBusOperation_Config PROC
;;;1770     */
;;;1771   HAL_SD_ErrorTypedef HAL_SD_WideBusOperation_Config(SD_HandleTypeDef *hsd, uint32_t WideMode)
000000  b570              PUSH     {r4-r6,lr}
;;;1772   {
000002  b08a              SUB      sp,sp,#0x28
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;1773     HAL_SD_ErrorTypedef errorstate = SD_OK;
000008  2600              MOVS     r6,#0
;;;1774     SDIO_InitTypeDef tmpinit;
;;;1775     
;;;1776     /* MMC Card does not support this feature */
;;;1777     if (hsd->CardType == MULTIMEDIA_CARD)
00000a  6a20              LDR      r0,[r4,#0x20]
00000c  2803              CMP      r0,#3
00000e  d103              BNE      |L21.24|
;;;1778     {
;;;1779       errorstate = SD_UNSUPPORTED_FEATURE;
000010  2627              MOVS     r6,#0x27
;;;1780       
;;;1781       return errorstate;
000012  4630              MOV      r0,r6
                  |L21.20|
;;;1782     }
;;;1783     else if ((hsd->CardType == STD_CAPACITY_SD_CARD_V1_1) || (hsd->CardType == STD_CAPACITY_SD_CARD_V2_0) ||\
;;;1784       (hsd->CardType == HIGH_CAPACITY_SD_CARD))
;;;1785     {
;;;1786       if (WideMode == SDIO_BUS_WIDE_8B)
;;;1787       {
;;;1788         errorstate = SD_UNSUPPORTED_FEATURE;
;;;1789       }
;;;1790       else if (WideMode == SDIO_BUS_WIDE_4B)
;;;1791       {
;;;1792         errorstate = SD_WideBus_Enable(hsd);
;;;1793       }
;;;1794       else if (WideMode == SDIO_BUS_WIDE_1B)
;;;1795       {
;;;1796         errorstate = SD_WideBus_Disable(hsd);
;;;1797       }
;;;1798       else
;;;1799       {
;;;1800         /* WideMode is not a valid argument*/
;;;1801         errorstate = SD_INVALID_PARAMETER;
;;;1802       }
;;;1803         
;;;1804       if (errorstate == SD_OK)
;;;1805       {
;;;1806         /* Configure the SDIO peripheral */
;;;1807         tmpinit.ClockEdge           = hsd->Init.ClockEdge;
;;;1808         tmpinit.ClockBypass         = hsd->Init.ClockBypass;
;;;1809         tmpinit.ClockPowerSave      = hsd->Init.ClockPowerSave;
;;;1810         tmpinit.BusWide             = WideMode;
;;;1811         tmpinit.HardwareFlowControl = hsd->Init.HardwareFlowControl;
;;;1812         tmpinit.ClockDiv            = hsd->Init.ClockDiv;
;;;1813         SDIO_Init(hsd->Instance, tmpinit);
;;;1814       }
;;;1815     }
;;;1816     
;;;1817     return errorstate;
;;;1818   }
000014  b00a              ADD      sp,sp,#0x28
000016  bd70              POP      {r4-r6,pc}
                  |L21.24|
000018  6a20              LDR      r0,[r4,#0x20]         ;1783
00001a  b128              CBZ      r0,|L21.40|
00001c  6a20              LDR      r0,[r4,#0x20]         ;1783
00001e  2801              CMP      r0,#1                 ;1783
000020  d002              BEQ      |L21.40|
000022  6a20              LDR      r0,[r4,#0x20]         ;1784
000024  2802              CMP      r0,#2                 ;1784
000026  d128              BNE      |L21.122|
                  |L21.40|
000028  f5b55f80          CMP      r5,#0x1000            ;1786
00002c  d101              BNE      |L21.50|
00002e  2627              MOVS     r6,#0x27              ;1788
000030  e00e              B        |L21.80|
                  |L21.50|
000032  f5b56f00          CMP      r5,#0x800             ;1790
000036  d104              BNE      |L21.66|
000038  4620              MOV      r0,r4                 ;1792
00003a  f7fffffe          BL       SD_WideBus_Enable
00003e  4606              MOV      r6,r0                 ;1792
000040  e006              B        |L21.80|
                  |L21.66|
000042  b925              CBNZ     r5,|L21.78|
000044  4620              MOV      r0,r4                 ;1796
000046  f7fffffe          BL       SD_WideBus_Disable
00004a  4606              MOV      r6,r0                 ;1796
00004c  e000              B        |L21.80|
                  |L21.78|
00004e  2626              MOVS     r6,#0x26              ;1801
                  |L21.80|
000050  b99e              CBNZ     r6,|L21.122|
000052  6860              LDR      r0,[r4,#4]            ;1807
000054  9004              STR      r0,[sp,#0x10]         ;1807
000056  68a0              LDR      r0,[r4,#8]            ;1808
000058  9005              STR      r0,[sp,#0x14]         ;1808
00005a  68e0              LDR      r0,[r4,#0xc]          ;1809
00005c  9006              STR      r0,[sp,#0x18]         ;1809
00005e  9507              STR      r5,[sp,#0x1c]         ;1810
000060  6960              LDR      r0,[r4,#0x14]         ;1811
000062  9008              STR      r0,[sp,#0x20]         ;1811
000064  69a0              LDR      r0,[r4,#0x18]         ;1812
000066  9009              STR      r0,[sp,#0x24]         ;1812
000068  a807              ADD      r0,sp,#0x1c           ;1813
00006a  c807              LDM      r0,{r0-r2}            ;1813
00006c  e88d0007          STM      sp,{r0-r2}            ;1813
000070  6820              LDR      r0,[r4,#0]            ;1813
000072  a904              ADD      r1,sp,#0x10           ;1813
000074  c90e              LDM      r1,{r1-r3}            ;1813
000076  f7fffffe          BL       SDIO_Init
                  |L21.122|
00007a  4630              MOV      r0,r6                 ;1817
00007c  e7ca              B        |L21.20|
;;;1819   
                          ENDP


                          AREA ||i.HAL_SD_WriteBlocks||, CODE, READONLY, ALIGN=1

                  HAL_SD_WriteBlocks PROC
;;;662      */
;;;663    HAL_SD_ErrorTypedef HAL_SD_WriteBlocks(SD_HandleTypeDef *hsd, uint32_t *pWriteBuffer, uint64_t WriteAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;664    {
000004  b08e              SUB      sp,sp,#0x38
000006  4604              MOV      r4,r0
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  f8ddb074          LDR      r11,[sp,#0x74]
;;;665      SDIO_CmdInitTypeDef sdio_cmdinitstructure;
;;;666      SDIO_DataInitTypeDef sdio_datainitstructure;
;;;667      HAL_SD_ErrorTypedef errorstate = SD_OK;
000010  2000              MOVS     r0,#0
000012  9002              STR      r0,[sp,#8]
;;;668      uint32_t totalnumberofbytes = 0, bytestransferred = 0, count = 0, restwords = 0;
000014  4681              MOV      r9,r0
000016  2500              MOVS     r5,#0
000018  2600              MOVS     r6,#0
00001a  9001              STR      r0,[sp,#4]
;;;669      uint32_t *tempbuff = (uint32_t *)pWriteBuffer;
00001c  f8dda03c          LDR      r10,[sp,#0x3c]
;;;670      uint8_t cardstate  = 0;
000020  9000              STR      r0,[sp,#0]
;;;671      
;;;672      /* Initialize data control register */
;;;673      hsd->Instance->DCTRL = 0;
000022  6821              LDR      r1,[r4,#0]
000024  62c8              STR      r0,[r1,#0x2c]
;;;674      
;;;675      if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
000026  6a20              LDR      r0,[r4,#0x20]
000028  2802              CMP      r0,#2
00002a  d109              BNE      |L22.64|
;;;676      {
;;;677        BlockSize = 512;
00002c  0200              LSLS     r0,r0,#8
00002e  901c              STR      r0,[sp,#0x70]
;;;678        WriteAddr /= 512;
000030  4602              MOV      r2,r0
000032  2300              MOVS     r3,#0
000034  4638              MOV      r0,r7
000036  4641              MOV      r1,r8
000038  f7fffffe          BL       __aeabi_uldivmod
00003c  4607              MOV      r7,r0
00003e  4688              MOV      r8,r1
                  |L22.64|
;;;679      }
;;;680      
;;;681      /* Set Block Size for Card */ 
;;;682      sdio_cmdinitstructure.Argument         = (uint32_t)BlockSize;
000040  981c              LDR      r0,[sp,#0x70]
000042  9009              STR      r0,[sp,#0x24]
;;;683      sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
000044  2010              MOVS     r0,#0x10
000046  900a              STR      r0,[sp,#0x28]
;;;684      sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
000048  2040              MOVS     r0,#0x40
00004a  900b              STR      r0,[sp,#0x2c]
;;;685      sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
00004c  2000              MOVS     r0,#0
00004e  900c              STR      r0,[sp,#0x30]
;;;686      sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
000050  f44f6080          MOV      r0,#0x400
000054  900d              STR      r0,[sp,#0x34]
;;;687      SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
000056  a909              ADD      r1,sp,#0x24
000058  6820              LDR      r0,[r4,#0]
00005a  f7fffffe          BL       SDIO_SendCommand
;;;688      
;;;689      /* Check for error conditions */
;;;690      errorstate = SD_CmdResp1Error(hsd, SD_CMD_SET_BLOCKLEN);
00005e  2110              MOVS     r1,#0x10
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       SD_CmdResp1Error
000066  9002              STR      r0,[sp,#8]
;;;691      
;;;692      if (errorstate != SD_OK)
000068  9802              LDR      r0,[sp,#8]
00006a  b118              CBZ      r0,|L22.116|
;;;693      {
;;;694        return errorstate;
00006c  9802              LDR      r0,[sp,#8]
                  |L22.110|
;;;695      }
;;;696      
;;;697      if(NumberOfBlocks > 1)
;;;698      {
;;;699        /* Send CMD25 WRITE_MULT_BLOCK with argument data address */
;;;700        sdio_cmdinitstructure.CmdIndex = SD_CMD_WRITE_MULT_BLOCK;
;;;701      }
;;;702      else
;;;703      {
;;;704        /* Send CMD24 WRITE_SINGLE_BLOCK */
;;;705        sdio_cmdinitstructure.CmdIndex = SD_CMD_WRITE_SINGLE_BLOCK;
;;;706      }
;;;707      
;;;708      sdio_cmdinitstructure.Argument         = (uint32_t)WriteAddr;
;;;709      SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
;;;710      
;;;711      /* Check for error conditions */
;;;712      if(NumberOfBlocks > 1)
;;;713      {
;;;714        errorstate = SD_CmdResp1Error(hsd, SD_CMD_WRITE_MULT_BLOCK);
;;;715      }
;;;716      else
;;;717      {
;;;718        errorstate = SD_CmdResp1Error(hsd, SD_CMD_WRITE_SINGLE_BLOCK);
;;;719      }  
;;;720      
;;;721      if (errorstate != SD_OK)
;;;722      {
;;;723        return errorstate;
;;;724      }
;;;725      
;;;726      /* Set total number of bytes to write */
;;;727      totalnumberofbytes = NumberOfBlocks * BlockSize;
;;;728      
;;;729      /* Configure the SD DPSM (Data Path State Machine) */ 
;;;730      sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
;;;731      sdio_datainitstructure.DataLength    = NumberOfBlocks * BlockSize;
;;;732      sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
;;;733      sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_CARD;
;;;734      sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
;;;735      sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
;;;736      SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
;;;737      
;;;738      /* Write block(s) in polling mode */
;;;739      if(NumberOfBlocks > 1)
;;;740      {
;;;741    #ifdef SDIO_STA_STBITERR
;;;742        while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DATAEND | SDIO_FLAG_STBITERR))
;;;743    #else /* SDIO_STA_STBITERR not defined */
;;;744        while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DATAEND))
;;;745    #endif /* SDIO_STA_STBITERR */     
;;;746        {
;;;747          if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXFIFOHE))
;;;748          {
;;;749            if ((totalnumberofbytes - bytestransferred) < 32)
;;;750            {
;;;751              restwords = ((totalnumberofbytes - bytestransferred) % 4 == 0) ? ((totalnumberofbytes - bytestransferred) / 4) : (( totalnumberofbytes -  bytestransferred) / 4 + 1);
;;;752              
;;;753              /* Write data to SDIO Tx FIFO */
;;;754              for (count = 0; count < restwords; count++)
;;;755              {
;;;756                SDIO_WriteFIFO(hsd->Instance, tempbuff);
;;;757                tempbuff++;
;;;758                bytestransferred += 4;
;;;759              }
;;;760            }
;;;761            else
;;;762            {
;;;763              /* Write data to SDIO Tx FIFO */
;;;764              for (count = 0; count < 8; count++)
;;;765              {
;;;766                SDIO_WriteFIFO(hsd->Instance, (tempbuff + count));
;;;767              }
;;;768              
;;;769              tempbuff += 8;
;;;770              bytestransferred += 32;
;;;771            }
;;;772          }
;;;773        }   
;;;774      }
;;;775      else
;;;776      {
;;;777        /* In case of single data block transfer no need of stop command at all */
;;;778    #ifdef SDIO_STA_STBITERR
;;;779        while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND | SDIO_FLAG_STBITERR))
;;;780    #else /* SDIO_STA_STBITERR not defined */
;;;781        while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND))
;;;782    #endif /* SDIO_STA_STBITERR */
;;;783        {
;;;784          if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXFIFOHE))
;;;785          {
;;;786            if ((totalnumberofbytes - bytestransferred) < 32)
;;;787            {
;;;788              restwords = ((totalnumberofbytes - bytestransferred) % 4 == 0) ? ((totalnumberofbytes - bytestransferred) / 4) : (( totalnumberofbytes -  bytestransferred) / 4 + 1);
;;;789              
;;;790              /* Write data to SDIO Tx FIFO */
;;;791              for (count = 0; count < restwords; count++)
;;;792              {
;;;793                SDIO_WriteFIFO(hsd->Instance, tempbuff);
;;;794                tempbuff++; 
;;;795                bytestransferred += 4;
;;;796              }
;;;797            }
;;;798            else
;;;799            {
;;;800              /* Write data to SDIO Tx FIFO */
;;;801              for (count = 0; count < 8; count++)
;;;802              {
;;;803                SDIO_WriteFIFO(hsd->Instance, (tempbuff + count));
;;;804              }
;;;805              
;;;806              tempbuff += 8;
;;;807              bytestransferred += 32;
;;;808            }
;;;809          }
;;;810        }  
;;;811      }
;;;812      
;;;813      /* Send stop transmission command in case of multiblock write */
;;;814      if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DATAEND) && (NumberOfBlocks > 1))
;;;815      {    
;;;816        if ((hsd->CardType == STD_CAPACITY_SD_CARD_V1_1) || (hsd->CardType == STD_CAPACITY_SD_CARD_V2_0) ||\
;;;817          (hsd->CardType == HIGH_CAPACITY_SD_CARD))
;;;818        {
;;;819          /* Send stop transmission command */
;;;820          errorstate = HAL_SD_StopTransfer(hsd);
;;;821        }
;;;822      }
;;;823      
;;;824      /* Get error state */
;;;825      if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DTIMEOUT))
;;;826      {
;;;827        __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DTIMEOUT);
;;;828        
;;;829        errorstate = SD_DATA_TIMEOUT;
;;;830        
;;;831        return errorstate;
;;;832      }
;;;833      else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DCRCFAIL))
;;;834      {
;;;835        __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DCRCFAIL);
;;;836        
;;;837        errorstate = SD_DATA_CRC_FAIL;
;;;838        
;;;839        return errorstate;
;;;840      }
;;;841      else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR))
;;;842      {
;;;843        __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_TXUNDERR);
;;;844        
;;;845        errorstate = SD_TX_UNDERRUN;
;;;846        
;;;847        return errorstate;
;;;848      }
;;;849    #ifdef SDIO_STA_STBITERR
;;;850      else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_STBITERR))
;;;851      {
;;;852        __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_STBITERR);
;;;853        
;;;854        errorstate = SD_START_BIT_ERR;
;;;855        
;;;856        return errorstate;
;;;857      }
;;;858    #endif /* SDIO_STA_STBITERR */
;;;859      else
;;;860      {
;;;861        /* No error flag set */
;;;862      }
;;;863      
;;;864      /* Clear all the static flags */
;;;865      __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;866      
;;;867      /* Wait till the card is in programming state */
;;;868      errorstate = SD_IsCardProgramming(hsd, &cardstate);
;;;869      
;;;870      while ((errorstate == SD_OK) && ((cardstate == SD_CARD_PROGRAMMING) || (cardstate == SD_CARD_RECEIVING)))
;;;871      {
;;;872        errorstate = SD_IsCardProgramming(hsd, &cardstate);
;;;873      }
;;;874      
;;;875      return errorstate;
;;;876    }
00006e  b012              ADD      sp,sp,#0x48
000070  e8bd9ff0          POP      {r4-r12,pc}
                  |L22.116|
000074  f1bb0f01          CMP      r11,#1                ;697
000078  d902              BLS      |L22.128|
00007a  2019              MOVS     r0,#0x19              ;700
00007c  900a              STR      r0,[sp,#0x28]         ;700
00007e  e001              B        |L22.132|
                  |L22.128|
000080  2018              MOVS     r0,#0x18              ;705
000082  900a              STR      r0,[sp,#0x28]         ;705
                  |L22.132|
000084  9709              STR      r7,[sp,#0x24]         ;708
000086  a909              ADD      r1,sp,#0x24           ;709
000088  6820              LDR      r0,[r4,#0]            ;709
00008a  f7fffffe          BL       SDIO_SendCommand
00008e  f1bb0f01          CMP      r11,#1                ;712
000092  d905              BLS      |L22.160|
000094  2119              MOVS     r1,#0x19              ;714
000096  4620              MOV      r0,r4                 ;714
000098  f7fffffe          BL       SD_CmdResp1Error
00009c  9002              STR      r0,[sp,#8]            ;714
00009e  e004              B        |L22.170|
                  |L22.160|
0000a0  2118              MOVS     r1,#0x18              ;718
0000a2  4620              MOV      r0,r4                 ;718
0000a4  f7fffffe          BL       SD_CmdResp1Error
0000a8  9002              STR      r0,[sp,#8]            ;718
                  |L22.170|
0000aa  9802              LDR      r0,[sp,#8]            ;721
0000ac  b108              CBZ      r0,|L22.178|
0000ae  9802              LDR      r0,[sp,#8]            ;723
0000b0  e7dd              B        |L22.110|
                  |L22.178|
0000b2  981c              LDR      r0,[sp,#0x70]         ;727
0000b4  fb0bf900          MUL      r9,r11,r0             ;727
0000b8  f04f30ff          MOV      r0,#0xffffffff        ;730
0000bc  9003              STR      r0,[sp,#0xc]          ;730
0000be  981c              LDR      r0,[sp,#0x70]         ;731
0000c0  fb0bf000          MUL      r0,r11,r0             ;731
0000c4  9004              STR      r0,[sp,#0x10]         ;731
0000c6  2090              MOVS     r0,#0x90              ;732
0000c8  9005              STR      r0,[sp,#0x14]         ;732
0000ca  2000              MOVS     r0,#0                 ;733
0000cc  9006              STR      r0,[sp,#0x18]         ;733
0000ce  9007              STR      r0,[sp,#0x1c]         ;734
0000d0  2001              MOVS     r0,#1                 ;735
0000d2  9008              STR      r0,[sp,#0x20]         ;735
0000d4  a903              ADD      r1,sp,#0xc            ;736
0000d6  6820              LDR      r0,[r4,#0]            ;736
0000d8  f7fffffe          BL       SDIO_DataConfig
0000dc  f1bb0f01          CMP      r11,#1                ;739
0000e0  d93a              BLS      |L22.344|
0000e2  e031              B        |L22.328|
                  |L22.228|
0000e4  6820              LDR      r0,[r4,#0]            ;747
0000e6  6b40              LDR      r0,[r0,#0x34]         ;747
0000e8  f4004080          AND      r0,r0,#0x4000         ;747
0000ec  b360              CBZ      r0,|L22.328|
0000ee  eba90005          SUB      r0,r9,r5              ;749
0000f2  2820              CMP      r0,#0x20              ;749
0000f4  d21b              BCS      |L22.302|
0000f6  eba90005          SUB      r0,r9,r5              ;751
0000fa  f0000003          AND      r0,r0,#3              ;751
0000fe  b918              CBNZ     r0,|L22.264|
000100  eba90005          SUB      r0,r9,r5              ;751
000104  0880              LSRS     r0,r0,#2              ;751
000106  e003              B        |L22.272|
                  |L22.264|
000108  eba90005          SUB      r0,r9,r5              ;751
00010c  0880              LSRS     r0,r0,#2              ;751
00010e  1c40              ADDS     r0,r0,#1              ;751
                  |L22.272|
000110  9001              STR      r0,[sp,#4]            ;751
000112  2600              MOVS     r6,#0                 ;754
000114  e007              B        |L22.294|
                  |L22.278|
000116  4651              MOV      r1,r10                ;756
000118  6820              LDR      r0,[r4,#0]            ;756
00011a  f7fffffe          BL       SDIO_WriteFIFO
00011e  f10a0a04          ADD      r10,r10,#4            ;757
000122  1d2d              ADDS     r5,r5,#4              ;758
000124  1c76              ADDS     r6,r6,#1              ;754
                  |L22.294|
000126  9801              LDR      r0,[sp,#4]            ;754
000128  4286              CMP      r6,r0                 ;754
00012a  d20d              BCS      |L22.328|
00012c  e7f3              B        |L22.278|
                  |L22.302|
00012e  2600              MOVS     r6,#0                 ;764
000130  e005              B        |L22.318|
                  |L22.306|
000132  eb0a0186          ADD      r1,r10,r6,LSL #2      ;766
000136  6820              LDR      r0,[r4,#0]            ;766
000138  f7fffffe          BL       SDIO_WriteFIFO
00013c  1c76              ADDS     r6,r6,#1              ;764
                  |L22.318|
00013e  2e08              CMP      r6,#8                 ;764
000140  d3f7              BCC      |L22.306|
000142  f10a0a20          ADD      r10,r10,#0x20         ;769
000146  3520              ADDS     r5,r5,#0x20           ;770
                  |L22.328|
000148  6820              LDR      r0,[r4,#0]            ;742
00014a  6b40              LDR      r0,[r0,#0x34]         ;742
00014c  f240311a          MOV      r1,#0x31a             ;742
000150  4008              ANDS     r0,r0,r1              ;742
000152  2800              CMP      r0,#0                 ;742
000154  d0c6              BEQ      |L22.228|
000156  e039              B        |L22.460|
                  |L22.344|
000158  e031              B        |L22.446|
                  |L22.346|
00015a  6820              LDR      r0,[r4,#0]            ;784
00015c  6b40              LDR      r0,[r0,#0x34]         ;784
00015e  f4004080          AND      r0,r0,#0x4000         ;784
000162  b360              CBZ      r0,|L22.446|
000164  eba90005          SUB      r0,r9,r5              ;786
000168  2820              CMP      r0,#0x20              ;786
00016a  d21b              BCS      |L22.420|
00016c  eba90005          SUB      r0,r9,r5              ;788
000170  f0000003          AND      r0,r0,#3              ;788
000174  b918              CBNZ     r0,|L22.382|
000176  eba90005          SUB      r0,r9,r5              ;788
00017a  0880              LSRS     r0,r0,#2              ;788
00017c  e003              B        |L22.390|
                  |L22.382|
00017e  eba90005          SUB      r0,r9,r5              ;788
000182  0880              LSRS     r0,r0,#2              ;788
000184  1c40              ADDS     r0,r0,#1              ;788
                  |L22.390|
000186  9001              STR      r0,[sp,#4]            ;788
000188  2600              MOVS     r6,#0                 ;791
00018a  e007              B        |L22.412|
                  |L22.396|
00018c  4651              MOV      r1,r10                ;793
00018e  6820              LDR      r0,[r4,#0]            ;793
000190  f7fffffe          BL       SDIO_WriteFIFO
000194  f10a0a04          ADD      r10,r10,#4            ;794
000198  1d2d              ADDS     r5,r5,#4              ;795
00019a  1c76              ADDS     r6,r6,#1              ;791
                  |L22.412|
00019c  9801              LDR      r0,[sp,#4]            ;791
00019e  4286              CMP      r6,r0                 ;791
0001a0  d20d              BCS      |L22.446|
0001a2  e7f3              B        |L22.396|
                  |L22.420|
0001a4  2600              MOVS     r6,#0                 ;801
0001a6  e005              B        |L22.436|
                  |L22.424|
0001a8  eb0a0186          ADD      r1,r10,r6,LSL #2      ;803
0001ac  6820              LDR      r0,[r4,#0]            ;803
0001ae  f7fffffe          BL       SDIO_WriteFIFO
0001b2  1c76              ADDS     r6,r6,#1              ;801
                  |L22.436|
0001b4  2e08              CMP      r6,#8                 ;801
0001b6  d3f7              BCC      |L22.424|
0001b8  f10a0a20          ADD      r10,r10,#0x20         ;806
0001bc  3520              ADDS     r5,r5,#0x20           ;807
                  |L22.446|
0001be  6820              LDR      r0,[r4,#0]            ;779
0001c0  6b40              LDR      r0,[r0,#0x34]         ;779
0001c2  f240611a          MOV      r1,#0x61a             ;779
0001c6  4008              ANDS     r0,r0,r1              ;779
0001c8  2800              CMP      r0,#0                 ;779
0001ca  d0c6              BEQ      |L22.346|
                  |L22.460|
0001cc  6820              LDR      r0,[r4,#0]            ;814
0001ce  6b40              LDR      r0,[r0,#0x34]         ;814
0001d0  f4007080          AND      r0,r0,#0x100          ;814
0001d4  b170              CBZ      r0,|L22.500|
0001d6  f1bb0f01          CMP      r11,#1                ;814
0001da  d90b              BLS      |L22.500|
0001dc  6a20              LDR      r0,[r4,#0x20]         ;816
0001de  b128              CBZ      r0,|L22.492|
0001e0  6a20              LDR      r0,[r4,#0x20]         ;816
0001e2  2801              CMP      r0,#1                 ;816
0001e4  d002              BEQ      |L22.492|
0001e6  6a20              LDR      r0,[r4,#0x20]         ;817
0001e8  2802              CMP      r0,#2                 ;817
0001ea  d103              BNE      |L22.500|
                  |L22.492|
0001ec  4620              MOV      r0,r4                 ;820
0001ee  f7fffffe          BL       HAL_SD_StopTransfer
0001f2  9002              STR      r0,[sp,#8]            ;820
                  |L22.500|
0001f4  6820              LDR      r0,[r4,#0]            ;825
0001f6  6b40              LDR      r0,[r0,#0x34]         ;825
0001f8  f0000008          AND      r0,r0,#8              ;825
0001fc  b130              CBZ      r0,|L22.524|
0001fe  2008              MOVS     r0,#8                 ;827
000200  6821              LDR      r1,[r4,#0]            ;827
000202  6388              STR      r0,[r1,#0x38]         ;827
000204  2004              MOVS     r0,#4                 ;829
000206  9002              STR      r0,[sp,#8]            ;829
000208  9802              LDR      r0,[sp,#8]            ;831
00020a  e730              B        |L22.110|
                  |L22.524|
00020c  6820              LDR      r0,[r4,#0]            ;833
00020e  6b40              LDR      r0,[r0,#0x34]         ;833
000210  f0000002          AND      r0,r0,#2              ;833
000214  b128              CBZ      r0,|L22.546|
000216  2002              MOVS     r0,#2                 ;835
000218  6821              LDR      r1,[r4,#0]            ;835
00021a  6388              STR      r0,[r1,#0x38]         ;835
00021c  9002              STR      r0,[sp,#8]            ;837
00021e  9802              LDR      r0,[sp,#8]            ;839
000220  e725              B        |L22.110|
                  |L22.546|
000222  6820              LDR      r0,[r4,#0]            ;841
000224  6b40              LDR      r0,[r0,#0x34]         ;841
000226  f0000010          AND      r0,r0,#0x10           ;841
00022a  b130              CBZ      r0,|L22.570|
00022c  2010              MOVS     r0,#0x10              ;843
00022e  6821              LDR      r1,[r4,#0]            ;843
000230  6388              STR      r0,[r1,#0x38]         ;843
000232  2005              MOVS     r0,#5                 ;845
000234  9002              STR      r0,[sp,#8]            ;845
000236  9802              LDR      r0,[sp,#8]            ;847
000238  e719              B        |L22.110|
                  |L22.570|
00023a  6820              LDR      r0,[r4,#0]            ;850
00023c  6b40              LDR      r0,[r0,#0x34]         ;850
00023e  f4007000          AND      r0,r0,#0x200          ;850
000242  b138              CBZ      r0,|L22.596|
000244  f44f7000          MOV      r0,#0x200             ;852
000248  6821              LDR      r1,[r4,#0]            ;852
00024a  6388              STR      r0,[r1,#0x38]         ;852
00024c  2007              MOVS     r0,#7                 ;854
00024e  9002              STR      r0,[sp,#8]            ;854
000250  9802              LDR      r0,[sp,#8]            ;856
000252  e70c              B        |L22.110|
                  |L22.596|
000254  f24050ff          MOV      r0,#0x5ff             ;865
000258  6821              LDR      r1,[r4,#0]            ;865
00025a  6388              STR      r0,[r1,#0x38]         ;865
00025c  4669              MOV      r1,sp                 ;868
00025e  4620              MOV      r0,r4                 ;868
000260  f7fffffe          BL       SD_IsCardProgramming
000264  9002              STR      r0,[sp,#8]            ;868
000266  e004              B        |L22.626|
                  |L22.616|
000268  4669              MOV      r1,sp                 ;872
00026a  4620              MOV      r0,r4                 ;872
00026c  f7fffffe          BL       SD_IsCardProgramming
000270  9002              STR      r0,[sp,#8]            ;872
                  |L22.626|
000272  9802              LDR      r0,[sp,#8]            ;870
000274  b938              CBNZ     r0,|L22.646|
000276  f89d0000          LDRB     r0,[sp,#0]            ;870
00027a  2807              CMP      r0,#7                 ;870
00027c  d0f4              BEQ      |L22.616|
00027e  f89d0000          LDRB     r0,[sp,#0]            ;870
000282  2806              CMP      r0,#6                 ;870
000284  d0f0              BEQ      |L22.616|
                  |L22.646|
000286  9802              LDR      r0,[sp,#8]            ;875
000288  e6f1              B        |L22.110|
;;;877    
                          ENDP


                          AREA ||i.HAL_SD_WriteBlocks_DMA||, CODE, READONLY, ALIGN=2

                  HAL_SD_WriteBlocks_DMA PROC
;;;1014     */
;;;1015   HAL_SD_ErrorTypedef HAL_SD_WriteBlocks_DMA(SD_HandleTypeDef *hsd, uint32_t *pWriteBuffer, uint64_t WriteAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1016   {
000004  b08c              SUB      sp,sp,#0x30
000006  4604              MOV      r4,r0
000008  468a              MOV      r10,r1
00000a  4617              MOV      r7,r2
00000c  4698              MOV      r8,r3
00000e  e9dd9514          LDRD     r9,r5,[sp,#0x50]
;;;1017     SDIO_CmdInitTypeDef sdio_cmdinitstructure;
;;;1018     SDIO_DataInitTypeDef sdio_datainitstructure;
;;;1019     HAL_SD_ErrorTypedef errorstate = SD_OK;
000012  2600              MOVS     r6,#0
;;;1020     
;;;1021     /* Initialize data control register */
;;;1022     hsd->Instance->DCTRL = 0;
000014  2000              MOVS     r0,#0
000016  6821              LDR      r1,[r4,#0]
000018  62c8              STR      r0,[r1,#0x2c]
;;;1023     
;;;1024     /* Initialize handle flags */
;;;1025     hsd->SdTransferCplt  = 0;
00001a  64a0              STR      r0,[r4,#0x48]
;;;1026     hsd->DmaTransferCplt = 0;
00001c  6520              STR      r0,[r4,#0x50]
;;;1027     hsd->SdTransferErr   = SD_OK;
00001e  64e0              STR      r0,[r4,#0x4c]
;;;1028     
;;;1029     /* Initialize SD Write operation */
;;;1030     if(NumberOfBlocks > 1)
000020  2d01              CMP      r5,#1
000022  d902              BLS      |L23.42|
;;;1031     {
;;;1032       hsd->SdOperation = SD_WRITE_MULTIPLE_BLOCK;
000024  2003              MOVS     r0,#3
000026  6560              STR      r0,[r4,#0x54]
000028  e001              B        |L23.46|
                  |L23.42|
;;;1033     }
;;;1034     else
;;;1035     {
;;;1036       hsd->SdOperation = SD_WRITE_SINGLE_BLOCK;
00002a  2002              MOVS     r0,#2
00002c  6560              STR      r0,[r4,#0x54]
                  |L23.46|
;;;1037     }  
;;;1038     
;;;1039     /* Enable transfer interrupts */
;;;1040   #ifdef SDIO_STA_STBITERR
;;;1041     __HAL_SD_SDIO_ENABLE_IT(hsd, (SDIO_IT_DCRCFAIL |\
00002e  6820              LDR      r0,[r4,#0]
000030  6bc0              LDR      r0,[r0,#0x3c]
000032  f240311a          MOV      r1,#0x31a
000036  4308              ORRS     r0,r0,r1
000038  6821              LDR      r1,[r4,#0]
00003a  63c8              STR      r0,[r1,#0x3c]
;;;1042                                   SDIO_IT_DTIMEOUT |\
;;;1043                                   SDIO_IT_DATAEND  |\
;;;1044                                   SDIO_IT_TXUNDERR |\
;;;1045                                   SDIO_IT_STBITERR));
;;;1046   #else /* SDIO_STA_STBITERR not defined */
;;;1047     __HAL_SD_SDIO_ENABLE_IT(hsd, (SDIO_IT_DCRCFAIL |\
;;;1048                                   SDIO_IT_DTIMEOUT |\
;;;1049                                   SDIO_IT_DATAEND  |\
;;;1050                                   SDIO_IT_TXUNDERR));
;;;1051   #endif /* SDIO_STA_STBITERR */
;;;1052     
;;;1053     /* Configure DMA user callbacks */
;;;1054     hsd->hdmatx->XferCpltCallback  = SD_DMA_TxCplt;
00003c  4834              LDR      r0,|L23.272|
00003e  6de1              LDR      r1,[r4,#0x5c]
000040  63c8              STR      r0,[r1,#0x3c]
;;;1055     hsd->hdmatx->XferErrorCallback = SD_DMA_TxError;
000042  4834              LDR      r0,|L23.276|
000044  6de1              LDR      r1,[r4,#0x5c]
000046  6488              STR      r0,[r1,#0x48]
;;;1056     
;;;1057     /* Enable the DMA Stream */
;;;1058     HAL_DMA_Start_IT(hsd->hdmatx, (uint32_t)pWriteBuffer, (uint32_t)&hsd->Instance->FIFO, (uint32_t)(BlockSize * NumberOfBlocks)/4);
000048  fb09f105          MUL      r1,r9,r5
00004c  088b              LSRS     r3,r1,#2
00004e  6821              LDR      r1,[r4,#0]
000050  f1010280          ADD      r2,r1,#0x80
000054  4651              MOV      r1,r10
000056  6de0              LDR      r0,[r4,#0x5c]
000058  f7fffffe          BL       HAL_DMA_Start_IT
;;;1059   
;;;1060     /* Enable SDIO DMA transfer */
;;;1061     __HAL_SD_SDIO_DMA_ENABLE();
00005c  2001              MOVS     r0,#1
00005e  492e              LDR      r1,|L23.280|
000060  6008              STR      r0,[r1,#0]
;;;1062     
;;;1063     if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
000062  6a20              LDR      r0,[r4,#0x20]
000064  2802              CMP      r0,#2
000066  d109              BNE      |L23.124|
;;;1064     {
;;;1065       BlockSize = 512;
000068  f44f7900          MOV      r9,#0x200
;;;1066       WriteAddr /= 512;
00006c  0202              LSLS     r2,r0,#8
00006e  2300              MOVS     r3,#0
000070  4638              MOV      r0,r7
000072  4641              MOV      r1,r8
000074  f7fffffe          BL       __aeabi_uldivmod
000078  4607              MOV      r7,r0
00007a  4688              MOV      r8,r1
                  |L23.124|
;;;1067     }
;;;1068   
;;;1069     /* Set Block Size for Card */ 
;;;1070     sdio_cmdinitstructure.Argument         = (uint32_t)BlockSize;
00007c  f8cd901c          STR      r9,[sp,#0x1c]
;;;1071     sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
000080  2010              MOVS     r0,#0x10
000082  9008              STR      r0,[sp,#0x20]
;;;1072     sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
000084  2040              MOVS     r0,#0x40
000086  9009              STR      r0,[sp,#0x24]
;;;1073     sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
000088  2000              MOVS     r0,#0
00008a  900a              STR      r0,[sp,#0x28]
;;;1074     sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
00008c  f44f6080          MOV      r0,#0x400
000090  900b              STR      r0,[sp,#0x2c]
;;;1075     SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
000092  a907              ADD      r1,sp,#0x1c
000094  6820              LDR      r0,[r4,#0]
000096  f7fffffe          BL       SDIO_SendCommand
;;;1076   
;;;1077     /* Check for error conditions */
;;;1078     errorstate = SD_CmdResp1Error(hsd, SD_CMD_SET_BLOCKLEN);
00009a  2110              MOVS     r1,#0x10
00009c  4620              MOV      r0,r4
00009e  f7fffffe          BL       SD_CmdResp1Error
0000a2  4606              MOV      r6,r0
;;;1079   
;;;1080     if (errorstate != SD_OK)
0000a4  b11e              CBZ      r6,|L23.174|
;;;1081     {
;;;1082       return errorstate;
0000a6  4630              MOV      r0,r6
                  |L23.168|
;;;1083     }
;;;1084     
;;;1085     /* Check number of blocks command */
;;;1086     if(NumberOfBlocks <= 1)
;;;1087     {
;;;1088       /* Send CMD24 WRITE_SINGLE_BLOCK */
;;;1089       sdio_cmdinitstructure.CmdIndex = SD_CMD_WRITE_SINGLE_BLOCK;
;;;1090     }
;;;1091     else
;;;1092     {
;;;1093       /* Send CMD25 WRITE_MULT_BLOCK with argument data address */
;;;1094       sdio_cmdinitstructure.CmdIndex = SD_CMD_WRITE_MULT_BLOCK;
;;;1095     }
;;;1096     
;;;1097     sdio_cmdinitstructure.Argument         = (uint32_t)WriteAddr;
;;;1098     SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
;;;1099   
;;;1100     /* Check for error conditions */
;;;1101     if(NumberOfBlocks > 1)
;;;1102     {
;;;1103       errorstate = SD_CmdResp1Error(hsd, SD_CMD_WRITE_MULT_BLOCK);
;;;1104     }
;;;1105     else
;;;1106     {
;;;1107       errorstate = SD_CmdResp1Error(hsd, SD_CMD_WRITE_SINGLE_BLOCK);
;;;1108     }
;;;1109     
;;;1110     if (errorstate != SD_OK)
;;;1111     {
;;;1112       return errorstate;
;;;1113     }
;;;1114     
;;;1115     /* Configure the SD DPSM (Data Path State Machine) */ 
;;;1116     sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
;;;1117     sdio_datainitstructure.DataLength    = BlockSize * NumberOfBlocks;
;;;1118     sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
;;;1119     sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_CARD;
;;;1120     sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
;;;1121     sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
;;;1122     SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
;;;1123     
;;;1124     hsd->SdTransferErr = errorstate;
;;;1125     
;;;1126     return errorstate;
;;;1127   }
0000a8  b00c              ADD      sp,sp,#0x30
0000aa  e8bd87f0          POP      {r4-r10,pc}
                  |L23.174|
0000ae  2d01              CMP      r5,#1                 ;1086
0000b0  d802              BHI      |L23.184|
0000b2  2018              MOVS     r0,#0x18              ;1089
0000b4  9008              STR      r0,[sp,#0x20]         ;1089
0000b6  e001              B        |L23.188|
                  |L23.184|
0000b8  2019              MOVS     r0,#0x19              ;1094
0000ba  9008              STR      r0,[sp,#0x20]         ;1094
                  |L23.188|
0000bc  9707              STR      r7,[sp,#0x1c]         ;1097
0000be  a907              ADD      r1,sp,#0x1c           ;1098
0000c0  6820              LDR      r0,[r4,#0]            ;1098
0000c2  f7fffffe          BL       SDIO_SendCommand
0000c6  2d01              CMP      r5,#1                 ;1101
0000c8  d905              BLS      |L23.214|
0000ca  2119              MOVS     r1,#0x19              ;1103
0000cc  4620              MOV      r0,r4                 ;1103
0000ce  f7fffffe          BL       SD_CmdResp1Error
0000d2  4606              MOV      r6,r0                 ;1103
0000d4  e004              B        |L23.224|
                  |L23.214|
0000d6  2118              MOVS     r1,#0x18              ;1107
0000d8  4620              MOV      r0,r4                 ;1107
0000da  f7fffffe          BL       SD_CmdResp1Error
0000de  4606              MOV      r6,r0                 ;1107
                  |L23.224|
0000e0  b10e              CBZ      r6,|L23.230|
0000e2  4630              MOV      r0,r6                 ;1112
0000e4  e7e0              B        |L23.168|
                  |L23.230|
0000e6  f04f30ff          MOV      r0,#0xffffffff        ;1116
0000ea  9001              STR      r0,[sp,#4]            ;1116
0000ec  fb09f005          MUL      r0,r9,r5              ;1117
0000f0  9002              STR      r0,[sp,#8]            ;1117
0000f2  2090              MOVS     r0,#0x90              ;1118
0000f4  9003              STR      r0,[sp,#0xc]          ;1118
0000f6  2000              MOVS     r0,#0                 ;1119
0000f8  9004              STR      r0,[sp,#0x10]         ;1119
0000fa  9005              STR      r0,[sp,#0x14]         ;1120
0000fc  2001              MOVS     r0,#1                 ;1121
0000fe  9006              STR      r0,[sp,#0x18]         ;1121
000100  a901              ADD      r1,sp,#4              ;1122
000102  6820              LDR      r0,[r4,#0]            ;1122
000104  f7fffffe          BL       SDIO_DataConfig
000108  64e6              STR      r6,[r4,#0x4c]         ;1124
00010a  4630              MOV      r0,r6                 ;1126
00010c  e7cc              B        |L23.168|
;;;1128   
                          ENDP

00010e  0000              DCW      0x0000
                  |L23.272|
                          DCD      SD_DMA_TxCplt
                  |L23.276|
                          DCD      SD_DMA_TxError
                  |L23.280|
                          DCD      0x4225858c

                          AREA ||i.HAL_SD_XferCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SD_XferCpltCallback PROC
;;;1445     */
;;;1446   __weak void HAL_SD_XferCpltCallback(SD_HandleTypeDef *hsd)
000000  4770              BX       lr
;;;1447   {
;;;1448     /* Prevent unused argument(s) compilation warning */
;;;1449     UNUSED(hsd);
;;;1450     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1451               the HAL_SD_XferCpltCallback could be implemented in the user file
;;;1452      */ 
;;;1453   }
;;;1454   
                          ENDP


                          AREA ||i.HAL_SD_XferErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_SD_XferErrorCallback PROC
;;;1459     */
;;;1460   __weak void HAL_SD_XferErrorCallback(SD_HandleTypeDef *hsd)
000000  4770              BX       lr
;;;1461   {
;;;1462     /* Prevent unused argument(s) compilation warning */
;;;1463     UNUSED(hsd);
;;;1464     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1465               the HAL_SD_XferErrorCallback could be implemented in the user file
;;;1466      */ 
;;;1467   }
;;;1468   
                          ENDP


                          AREA ||i.SD_CmdError||, CODE, READONLY, ALIGN=1

                  SD_CmdError PROC
;;;2697     */
;;;2698   static HAL_SD_ErrorTypedef SD_CmdError(SD_HandleTypeDef *hsd)
000000  b530              PUSH     {r4,r5,lr}
;;;2699   {
000002  4601              MOV      r1,r0
;;;2700     HAL_SD_ErrorTypedef errorstate = SD_OK;
000004  2000              MOVS     r0,#0
;;;2701     uint32_t timeout, tmp;
;;;2702     
;;;2703     timeout = SDIO_CMD0TIMEOUT;
000006  f44f3280          MOV      r2,#0x10000
;;;2704     
;;;2705     tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CMDSENT);
00000a  680c              LDR      r4,[r1,#0]
00000c  6b64              LDR      r4,[r4,#0x34]
00000e  f3c413c0          UBFX     r3,r4,#7,#1
;;;2706       
;;;2707     while((timeout > 0) && (!tmp))
000012  e004              B        |L26.30|
                  |L26.20|
;;;2708     {
;;;2709       tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CMDSENT);
000014  680c              LDR      r4,[r1,#0]
000016  6b64              LDR      r4,[r4,#0x34]
000018  f3c413c0          UBFX     r3,r4,#7,#1
;;;2710       timeout--;
00001c  1e52              SUBS     r2,r2,#1
                  |L26.30|
00001e  b10a              CBZ      r2,|L26.36|
000020  2b00              CMP      r3,#0                 ;2707
000022  d0f7              BEQ      |L26.20|
                  |L26.36|
;;;2711     }
;;;2712     
;;;2713     if(timeout == 0)
000024  b90a              CBNZ     r2,|L26.42|
;;;2714     {
;;;2715       errorstate = SD_CMD_RSP_TIMEOUT;
000026  2003              MOVS     r0,#3
                  |L26.40|
;;;2716       return errorstate;
;;;2717     }
;;;2718     
;;;2719     /* Clear all the static flags */
;;;2720     __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;2721     
;;;2722     return errorstate;
;;;2723   }
000028  bd30              POP      {r4,r5,pc}
                  |L26.42|
00002a  f24054ff          MOV      r4,#0x5ff             ;2720
00002e  680d              LDR      r5,[r1,#0]            ;2720
000030  63ac              STR      r4,[r5,#0x38]         ;2720
000032  bf00              NOP                            ;2722
000034  e7f8              B        |L26.40|
;;;2724   
                          ENDP


                          AREA ||i.SD_CmdResp1Error||, CODE, READONLY, ALIGN=2

                  SD_CmdResp1Error PROC
;;;2773     */
;;;2774   static HAL_SD_ErrorTypedef SD_CmdResp1Error(SD_HandleTypeDef *hsd, uint8_t SD_CMD)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2775   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;2776     HAL_SD_ErrorTypedef errorstate = SD_OK;
000008  2700              MOVS     r7,#0
;;;2777     uint32_t response_r1;
;;;2778     
;;;2779     while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))
00000a  bf00              NOP      
                  |L27.12|
00000c  6828              LDR      r0,[r5,#0]
00000e  6b40              LDR      r0,[r0,#0x34]
000010  f0000045          AND      r0,r0,#0x45
000014  2800              CMP      r0,#0
000016  d0f9              BEQ      |L27.12|
;;;2780     {
;;;2781     }
;;;2782     
;;;2783     if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT))
000018  6828              LDR      r0,[r5,#0]
00001a  6b40              LDR      r0,[r0,#0x34]
00001c  f0000004          AND      r0,r0,#4
000020  b130              CBZ      r0,|L27.48|
;;;2784     {
;;;2785       errorstate = SD_CMD_RSP_TIMEOUT;
000022  2703              MOVS     r7,#3
;;;2786       
;;;2787       __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
000024  2004              MOVS     r0,#4
000026  6829              LDR      r1,[r5,#0]
000028  6388              STR      r0,[r1,#0x38]
;;;2788       
;;;2789       return errorstate;
00002a  4638              MOV      r0,r7
                  |L27.44|
;;;2790     }
;;;2791     else if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL))
;;;2792     {
;;;2793       errorstate = SD_CMD_CRC_FAIL;
;;;2794       
;;;2795       __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CCRCFAIL);
;;;2796       
;;;2797       return errorstate;
;;;2798     }
;;;2799     
;;;2800     /* Check response received is of desired command */
;;;2801     if(SDIO_GetCommandResponse(hsd->Instance) != SD_CMD)
;;;2802     {
;;;2803       errorstate = SD_ILLEGAL_CMD;
;;;2804       
;;;2805       return errorstate;
;;;2806     }
;;;2807     
;;;2808     /* Clear all the static flags */
;;;2809     __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;2810     
;;;2811     /* We have received response, retrieve it for analysis  */
;;;2812     response_r1 = SDIO_GetResponse(SDIO_RESP1);
;;;2813     
;;;2814     if((response_r1 & SD_OCR_ERRORBITS) == SD_ALLZERO)
;;;2815     {
;;;2816       return errorstate;
;;;2817     }
;;;2818     
;;;2819     if((response_r1 & SD_OCR_ADDR_OUT_OF_RANGE) == SD_OCR_ADDR_OUT_OF_RANGE)
;;;2820     {
;;;2821       return(SD_ADDR_OUT_OF_RANGE);
;;;2822     }
;;;2823     
;;;2824     if((response_r1 & SD_OCR_ADDR_MISALIGNED) == SD_OCR_ADDR_MISALIGNED)
;;;2825     {
;;;2826       return(SD_ADDR_MISALIGNED);
;;;2827     }
;;;2828     
;;;2829     if((response_r1 & SD_OCR_BLOCK_LEN_ERR) == SD_OCR_BLOCK_LEN_ERR)
;;;2830     {
;;;2831       return(SD_BLOCK_LEN_ERR);
;;;2832     }
;;;2833     
;;;2834     if((response_r1 & SD_OCR_ERASE_SEQ_ERR) == SD_OCR_ERASE_SEQ_ERR)
;;;2835     {
;;;2836       return(SD_ERASE_SEQ_ERR);
;;;2837     }
;;;2838     
;;;2839     if((response_r1 & SD_OCR_BAD_ERASE_PARAM) == SD_OCR_BAD_ERASE_PARAM)
;;;2840     {
;;;2841       return(SD_BAD_ERASE_PARAM);
;;;2842     }
;;;2843     
;;;2844     if((response_r1 & SD_OCR_WRITE_PROT_VIOLATION) == SD_OCR_WRITE_PROT_VIOLATION)
;;;2845     {
;;;2846       return(SD_WRITE_PROT_VIOLATION);
;;;2847     }
;;;2848     
;;;2849     if((response_r1 & SD_OCR_LOCK_UNLOCK_FAILED) == SD_OCR_LOCK_UNLOCK_FAILED)
;;;2850     {
;;;2851       return(SD_LOCK_UNLOCK_FAILED);
;;;2852     }
;;;2853     
;;;2854     if((response_r1 & SD_OCR_COM_CRC_FAILED) == SD_OCR_COM_CRC_FAILED)
;;;2855     {
;;;2856       return(SD_COM_CRC_FAILED);
;;;2857     }
;;;2858     
;;;2859     if((response_r1 & SD_OCR_ILLEGAL_CMD) == SD_OCR_ILLEGAL_CMD)
;;;2860     {
;;;2861       return(SD_ILLEGAL_CMD);
;;;2862     }
;;;2863     
;;;2864     if((response_r1 & SD_OCR_CARD_ECC_FAILED) == SD_OCR_CARD_ECC_FAILED)
;;;2865     {
;;;2866       return(SD_CARD_ECC_FAILED);
;;;2867     }
;;;2868     
;;;2869     if((response_r1 & SD_OCR_CC_ERROR) == SD_OCR_CC_ERROR)
;;;2870     {
;;;2871       return(SD_CC_ERROR);
;;;2872     }
;;;2873     
;;;2874     if((response_r1 & SD_OCR_GENERAL_UNKNOWN_ERROR) == SD_OCR_GENERAL_UNKNOWN_ERROR)
;;;2875     {
;;;2876       return(SD_GENERAL_UNKNOWN_ERROR);
;;;2877     }
;;;2878     
;;;2879     if((response_r1 & SD_OCR_STREAM_READ_UNDERRUN) == SD_OCR_STREAM_READ_UNDERRUN)
;;;2880     {
;;;2881       return(SD_STREAM_READ_UNDERRUN);
;;;2882     }
;;;2883     
;;;2884     if((response_r1 & SD_OCR_STREAM_WRITE_OVERRUN) == SD_OCR_STREAM_WRITE_OVERRUN)
;;;2885     {
;;;2886       return(SD_STREAM_WRITE_OVERRUN);
;;;2887     }
;;;2888     
;;;2889     if((response_r1 & SD_OCR_CID_CSD_OVERWRITE) == SD_OCR_CID_CSD_OVERWRITE)
;;;2890     {
;;;2891       return(SD_CID_CSD_OVERWRITE);
;;;2892     }
;;;2893     
;;;2894     if((response_r1 & SD_OCR_WP_ERASE_SKIP) == SD_OCR_WP_ERASE_SKIP)
;;;2895     {
;;;2896       return(SD_WP_ERASE_SKIP);
;;;2897     }
;;;2898     
;;;2899     if((response_r1 & SD_OCR_CARD_ECC_DISABLED) == SD_OCR_CARD_ECC_DISABLED)
;;;2900     {
;;;2901       return(SD_CARD_ECC_DISABLED);
;;;2902     }
;;;2903     
;;;2904     if((response_r1 & SD_OCR_ERASE_RESET) == SD_OCR_ERASE_RESET)
;;;2905     {
;;;2906       return(SD_ERASE_RESET);
;;;2907     }
;;;2908     
;;;2909     if((response_r1 & SD_OCR_AKE_SEQ_ERROR) == SD_OCR_AKE_SEQ_ERROR)
;;;2910     {
;;;2911       return(SD_AKE_SEQ_ERROR);
;;;2912     }
;;;2913     
;;;2914     return errorstate;
;;;2915   }
00002c  e8bd81f0          POP      {r4-r8,pc}
                  |L27.48|
000030  6828              LDR      r0,[r5,#0]            ;2791
000032  6b40              LDR      r0,[r0,#0x34]         ;2791
000034  f0000001          AND      r0,r0,#1              ;2791
000038  b128              CBZ      r0,|L27.70|
00003a  2701              MOVS     r7,#1                 ;2793
00003c  2001              MOVS     r0,#1                 ;2795
00003e  6829              LDR      r1,[r5,#0]            ;2795
000040  6388              STR      r0,[r1,#0x38]         ;2795
000042  4638              MOV      r0,r7                 ;2797
000044  e7f2              B        |L27.44|
                  |L27.70|
000046  6828              LDR      r0,[r5,#0]            ;2801
000048  f7fffffe          BL       SDIO_GetCommandResponse
00004c  42b0              CMP      r0,r6                 ;2801
00004e  d002              BEQ      |L27.86|
000050  2710              MOVS     r7,#0x10              ;2803
000052  4638              MOV      r0,r7                 ;2805
000054  e7ea              B        |L27.44|
                  |L27.86|
000056  f24050ff          MOV      r0,#0x5ff             ;2809
00005a  6829              LDR      r1,[r5,#0]            ;2809
00005c  6388              STR      r0,[r1,#0x38]         ;2809
00005e  2000              MOVS     r0,#0                 ;2812
000060  f7fffffe          BL       SDIO_GetResponse
000064  4604              MOV      r4,r0                 ;2812
000066  4845              LDR      r0,|L27.380|
000068  4020              ANDS     r0,r0,r4              ;2814
00006a  b908              CBNZ     r0,|L27.112|
00006c  4638              MOV      r0,r7                 ;2816
00006e  e7dd              B        |L27.44|
                  |L27.112|
000070  f0044000          AND      r0,r4,#0x80000000     ;2819
000074  f1b04f00          CMP      r0,#0x80000000        ;2819
000078  d101              BNE      |L27.126|
00007a  201c              MOVS     r0,#0x1c              ;2821
00007c  e7d6              B        |L27.44|
                  |L27.126|
00007e  f0044080          AND      r0,r4,#0x40000000     ;2824
000082  f1b04f80          CMP      r0,#0x40000000        ;2824
000086  d101              BNE      |L27.140|
000088  2009              MOVS     r0,#9                 ;2826
00008a  e7cf              B        |L27.44|
                  |L27.140|
00008c  f0045000          AND      r0,r4,#0x20000000     ;2829
000090  f1b05f00          CMP      r0,#0x20000000        ;2829
000094  d101              BNE      |L27.154|
000096  200a              MOVS     r0,#0xa               ;2831
000098  e7c8              B        |L27.44|
                  |L27.154|
00009a  f0045080          AND      r0,r4,#0x10000000     ;2834
00009e  f1b05f80          CMP      r0,#0x10000000        ;2834
0000a2  d101              BNE      |L27.168|
0000a4  200b              MOVS     r0,#0xb               ;2836
0000a6  e7c1              B        |L27.44|
                  |L27.168|
0000a8  f0046000          AND      r0,r4,#0x8000000      ;2839
0000ac  f1b06f00          CMP      r0,#0x8000000         ;2839
0000b0  d101              BNE      |L27.182|
0000b2  200c              MOVS     r0,#0xc               ;2841
0000b4  e7ba              B        |L27.44|
                  |L27.182|
0000b6  f0046080          AND      r0,r4,#0x4000000      ;2844
0000ba  f1b06f80          CMP      r0,#0x4000000         ;2844
0000be  d101              BNE      |L27.196|
0000c0  200d              MOVS     r0,#0xd               ;2846
0000c2  e7b3              B        |L27.44|
                  |L27.196|
0000c4  f0047080          AND      r0,r4,#0x1000000      ;2849
0000c8  f1b07f80          CMP      r0,#0x1000000         ;2849
0000cc  d101              BNE      |L27.210|
0000ce  200e              MOVS     r0,#0xe               ;2851
0000d0  e7ac              B        |L27.44|
                  |L27.210|
0000d2  f4040000          AND      r0,r4,#0x800000       ;2854
0000d6  f5b00f00          CMP      r0,#0x800000          ;2854
0000da  d101              BNE      |L27.224|
0000dc  200f              MOVS     r0,#0xf               ;2856
0000de  e7a5              B        |L27.44|
                  |L27.224|
0000e0  f4040080          AND      r0,r4,#0x400000       ;2859
0000e4  f5b00f80          CMP      r0,#0x400000          ;2859
0000e8  d101              BNE      |L27.238|
0000ea  2010              MOVS     r0,#0x10              ;2861
0000ec  e79e              B        |L27.44|
                  |L27.238|
0000ee  f4041000          AND      r0,r4,#0x200000       ;2864
0000f2  f5b01f00          CMP      r0,#0x200000          ;2864
0000f6  d101              BNE      |L27.252|
0000f8  2011              MOVS     r0,#0x11              ;2866
0000fa  e797              B        |L27.44|
                  |L27.252|
0000fc  f4041080          AND      r0,r4,#0x100000       ;2869
000100  f5b01f80          CMP      r0,#0x100000          ;2869
000104  d101              BNE      |L27.266|
000106  2012              MOVS     r0,#0x12              ;2871
000108  e790              B        |L27.44|
                  |L27.266|
00010a  f4042000          AND      r0,r4,#0x80000        ;2874
00010e  f5b02f00          CMP      r0,#0x80000           ;2874
000112  d101              BNE      |L27.280|
000114  2013              MOVS     r0,#0x13              ;2876
000116  e789              B        |L27.44|
                  |L27.280|
000118  f4042080          AND      r0,r4,#0x40000        ;2879
00011c  f5b02f80          CMP      r0,#0x40000           ;2879
000120  d101              BNE      |L27.294|
000122  2014              MOVS     r0,#0x14              ;2881
000124  e782              B        |L27.44|
                  |L27.294|
000126  f4043000          AND      r0,r4,#0x20000        ;2884
00012a  f5b03f00          CMP      r0,#0x20000           ;2884
00012e  d101              BNE      |L27.308|
000130  2015              MOVS     r0,#0x15              ;2886
000132  e77b              B        |L27.44|
                  |L27.308|
000134  f4043080          AND      r0,r4,#0x10000        ;2889
000138  f5b03f80          CMP      r0,#0x10000           ;2889
00013c  d101              BNE      |L27.322|
00013e  2016              MOVS     r0,#0x16              ;2891
000140  e774              B        |L27.44|
                  |L27.322|
000142  f4044000          AND      r0,r4,#0x8000         ;2894
000146  f5b04f00          CMP      r0,#0x8000            ;2894
00014a  d101              BNE      |L27.336|
00014c  2017              MOVS     r0,#0x17              ;2896
00014e  e76d              B        |L27.44|
                  |L27.336|
000150  f4044080          AND      r0,r4,#0x4000         ;2899
000154  f5b04f80          CMP      r0,#0x4000            ;2899
000158  d101              BNE      |L27.350|
00015a  2018              MOVS     r0,#0x18              ;2901
00015c  e766              B        |L27.44|
                  |L27.350|
00015e  f4045000          AND      r0,r4,#0x2000         ;2904
000162  f5b05f00          CMP      r0,#0x2000            ;2904
000166  d101              BNE      |L27.364|
000168  2019              MOVS     r0,#0x19              ;2906
00016a  e75f              B        |L27.44|
                  |L27.364|
00016c  f0040008          AND      r0,r4,#8              ;2909
000170  2808              CMP      r0,#8                 ;2909
000172  d101              BNE      |L27.376|
000174  201a              MOVS     r0,#0x1a              ;2911
000176  e759              B        |L27.44|
                  |L27.376|
000178  4638              MOV      r0,r7                 ;2914
00017a  e757              B        |L27.44|
;;;2916   
                          ENDP

                  |L27.380|
                          DCD      0xfdffe008

                          AREA ||i.SD_CmdResp2Error||, CODE, READONLY, ALIGN=1

                  SD_CmdResp2Error PROC
;;;2949     */
;;;2950   static HAL_SD_ErrorTypedef SD_CmdResp2Error(SD_HandleTypeDef *hsd)
000000  4601              MOV      r1,r0
;;;2951   {
;;;2952     HAL_SD_ErrorTypedef errorstate = SD_OK;
000002  2000              MOVS     r0,#0
;;;2953     
;;;2954     while (!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))
000004  bf00              NOP      
                  |L28.6|
000006  680a              LDR      r2,[r1,#0]
000008  6b52              LDR      r2,[r2,#0x34]
00000a  f0020245          AND      r2,r2,#0x45
00000e  2a00              CMP      r2,#0
000010  d0f9              BEQ      |L28.6|
;;;2955     {
;;;2956     }
;;;2957       
;;;2958     if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT))
000012  680a              LDR      r2,[r1,#0]
000014  6b52              LDR      r2,[r2,#0x34]
000016  f0020204          AND      r2,r2,#4
00001a  b122              CBZ      r2,|L28.38|
;;;2959     {
;;;2960       errorstate = SD_CMD_RSP_TIMEOUT;
00001c  2003              MOVS     r0,#3
;;;2961       
;;;2962       __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
00001e  2204              MOVS     r2,#4
000020  680b              LDR      r3,[r1,#0]
000022  639a              STR      r2,[r3,#0x38]
                  |L28.36|
;;;2963       
;;;2964       return errorstate;
;;;2965     }
;;;2966     else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL))
;;;2967     {
;;;2968       errorstate = SD_CMD_CRC_FAIL;
;;;2969       
;;;2970       __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CCRCFAIL);
;;;2971       
;;;2972       return errorstate;
;;;2973     }
;;;2974     else
;;;2975     {
;;;2976       /* No error flag set */
;;;2977     }
;;;2978     
;;;2979     /* Clear all the static flags */
;;;2980     __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;2981     
;;;2982     return errorstate;
;;;2983   }
000024  4770              BX       lr
                  |L28.38|
000026  680a              LDR      r2,[r1,#0]            ;2966
000028  6b52              LDR      r2,[r2,#0x34]         ;2966
00002a  f0020201          AND      r2,r2,#1              ;2966
00002e  b122              CBZ      r2,|L28.58|
000030  2001              MOVS     r0,#1                 ;2968
000032  2201              MOVS     r2,#1                 ;2970
000034  680b              LDR      r3,[r1,#0]            ;2970
000036  639a              STR      r2,[r3,#0x38]         ;2970
000038  e7f4              B        |L28.36|
                  |L28.58|
00003a  f24052ff          MOV      r2,#0x5ff             ;2980
00003e  680b              LDR      r3,[r1,#0]            ;2980
000040  639a              STR      r2,[r3,#0x38]         ;2980
000042  bf00              NOP                            ;2982
000044  e7ee              B        |L28.36|
;;;2984   
                          ENDP


                          AREA ||i.SD_CmdResp3Error||, CODE, READONLY, ALIGN=1

                  SD_CmdResp3Error PROC
;;;2921     */
;;;2922   static HAL_SD_ErrorTypedef SD_CmdResp3Error(SD_HandleTypeDef *hsd)
000000  4601              MOV      r1,r0
;;;2923   {
;;;2924     HAL_SD_ErrorTypedef errorstate = SD_OK;
000002  2000              MOVS     r0,#0
;;;2925     
;;;2926     while (!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))
000004  bf00              NOP      
                  |L29.6|
000006  680a              LDR      r2,[r1,#0]
000008  6b52              LDR      r2,[r2,#0x34]
00000a  f0020245          AND      r2,r2,#0x45
00000e  2a00              CMP      r2,#0
000010  d0f9              BEQ      |L29.6|
;;;2927     {
;;;2928     }
;;;2929     
;;;2930     if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT))
000012  680a              LDR      r2,[r1,#0]
000014  6b52              LDR      r2,[r2,#0x34]
000016  f0020204          AND      r2,r2,#4
00001a  b122              CBZ      r2,|L29.38|
;;;2931     {
;;;2932       errorstate = SD_CMD_RSP_TIMEOUT;
00001c  2003              MOVS     r0,#3
;;;2933       
;;;2934       __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
00001e  2204              MOVS     r2,#4
000020  680b              LDR      r3,[r1,#0]
000022  639a              STR      r2,[r3,#0x38]
                  |L29.36|
;;;2935       
;;;2936       return errorstate;
;;;2937     }
;;;2938     
;;;2939     /* Clear all the static flags */
;;;2940     __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;2941     
;;;2942     return errorstate;
;;;2943   }
000024  4770              BX       lr
                  |L29.38|
000026  f24052ff          MOV      r2,#0x5ff             ;2940
00002a  680b              LDR      r3,[r1,#0]            ;2940
00002c  639a              STR      r2,[r3,#0x38]         ;2940
00002e  bf00              NOP                            ;2942
000030  e7f8              B        |L29.36|
;;;2944   
                          ENDP


                          AREA ||i.SD_CmdResp6Error||, CODE, READONLY, ALIGN=1

                  SD_CmdResp6Error PROC
;;;2992     */
;;;2993   static HAL_SD_ErrorTypedef SD_CmdResp6Error(SD_HandleTypeDef *hsd, uint8_t SD_CMD, uint16_t *pRCA)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2994   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;2995     HAL_SD_ErrorTypedef errorstate = SD_OK;
00000a  f04f0800          MOV      r8,#0
;;;2996     uint32_t response_r1;
;;;2997     
;;;2998     while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))
00000e  bf00              NOP      
                  |L30.16|
000010  6820              LDR      r0,[r4,#0]
000012  6b40              LDR      r0,[r0,#0x34]
000014  f0000045          AND      r0,r0,#0x45
000018  2800              CMP      r0,#0
00001a  d0f9              BEQ      |L30.16|
;;;2999     {
;;;3000     }
;;;3001     
;;;3002     if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT))
00001c  6820              LDR      r0,[r4,#0]
00001e  6b40              LDR      r0,[r0,#0x34]
000020  f0000004          AND      r0,r0,#4
000024  b138              CBZ      r0,|L30.54|
;;;3003     {
;;;3004       errorstate = SD_CMD_RSP_TIMEOUT;
000026  f04f0803          MOV      r8,#3
;;;3005       
;;;3006       __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
00002a  2004              MOVS     r0,#4
00002c  6821              LDR      r1,[r4,#0]
00002e  6388              STR      r0,[r1,#0x38]
;;;3007       
;;;3008       return errorstate;
000030  4640              MOV      r0,r8
                  |L30.50|
;;;3009     }
;;;3010     else if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL))
;;;3011     {
;;;3012       errorstate = SD_CMD_CRC_FAIL;
;;;3013       
;;;3014       __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CCRCFAIL);
;;;3015       
;;;3016       return errorstate;
;;;3017     }
;;;3018     else
;;;3019     {
;;;3020       /* No error flag set */
;;;3021     }
;;;3022     
;;;3023     /* Check response received is of desired command */
;;;3024     if(SDIO_GetCommandResponse(hsd->Instance) != SD_CMD)
;;;3025     {
;;;3026       errorstate = SD_ILLEGAL_CMD;
;;;3027       
;;;3028       return errorstate;
;;;3029     }
;;;3030     
;;;3031     /* Clear all the static flags */
;;;3032     __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;3033     
;;;3034     /* We have received response, retrieve it.  */
;;;3035     response_r1 = SDIO_GetResponse(SDIO_RESP1);
;;;3036     
;;;3037     if((response_r1 & (SD_R6_GENERAL_UNKNOWN_ERROR | SD_R6_ILLEGAL_CMD | SD_R6_COM_CRC_FAILED)) == SD_ALLZERO)
;;;3038     {
;;;3039       *pRCA = (uint16_t) (response_r1 >> 16);
;;;3040       
;;;3041       return errorstate;
;;;3042     }
;;;3043     
;;;3044     if((response_r1 & SD_R6_GENERAL_UNKNOWN_ERROR) == SD_R6_GENERAL_UNKNOWN_ERROR)
;;;3045     {
;;;3046       return(SD_GENERAL_UNKNOWN_ERROR);
;;;3047     }
;;;3048     
;;;3049     if((response_r1 & SD_R6_ILLEGAL_CMD) == SD_R6_ILLEGAL_CMD)
;;;3050     {
;;;3051       return(SD_ILLEGAL_CMD);
;;;3052     }
;;;3053     
;;;3054     if((response_r1 & SD_R6_COM_CRC_FAILED) == SD_R6_COM_CRC_FAILED)
;;;3055     {
;;;3056       return(SD_COM_CRC_FAILED);
;;;3057     }
;;;3058     
;;;3059     return errorstate;
;;;3060   }
000032  e8bd81f0          POP      {r4-r8,pc}
                  |L30.54|
000036  6820              LDR      r0,[r4,#0]            ;3010
000038  6b40              LDR      r0,[r0,#0x34]         ;3010
00003a  f0000001          AND      r0,r0,#1              ;3010
00003e  b130              CBZ      r0,|L30.78|
000040  f04f0801          MOV      r8,#1                 ;3012
000044  2001              MOVS     r0,#1                 ;3014
000046  6821              LDR      r1,[r4,#0]            ;3014
000048  6388              STR      r0,[r1,#0x38]         ;3014
00004a  4640              MOV      r0,r8                 ;3016
00004c  e7f1              B        |L30.50|
                  |L30.78|
00004e  6820              LDR      r0,[r4,#0]            ;3024
000050  f7fffffe          BL       SDIO_GetCommandResponse
000054  42b0              CMP      r0,r6                 ;3024
000056  d003              BEQ      |L30.96|
000058  f04f0810          MOV      r8,#0x10              ;3026
00005c  4640              MOV      r0,r8                 ;3028
00005e  e7e8              B        |L30.50|
                  |L30.96|
000060  f24050ff          MOV      r0,#0x5ff             ;3032
000064  6821              LDR      r1,[r4,#0]            ;3032
000066  6388              STR      r0,[r1,#0x38]         ;3032
000068  2000              MOVS     r0,#0                 ;3035
00006a  f7fffffe          BL       SDIO_GetResponse
00006e  4605              MOV      r5,r0                 ;3035
000070  f4054060          AND      r0,r5,#0xe000         ;3037
000074  b918              CBNZ     r0,|L30.126|
000076  0c28              LSRS     r0,r5,#16             ;3039
000078  8038              STRH     r0,[r7,#0]            ;3039
00007a  4640              MOV      r0,r8                 ;3041
00007c  e7d9              B        |L30.50|
                  |L30.126|
00007e  f4055000          AND      r0,r5,#0x2000         ;3044
000082  f5b05f00          CMP      r0,#0x2000            ;3044
000086  d101              BNE      |L30.140|
000088  2013              MOVS     r0,#0x13              ;3046
00008a  e7d2              B        |L30.50|
                  |L30.140|
00008c  f4054080          AND      r0,r5,#0x4000         ;3049
000090  f5b04f80          CMP      r0,#0x4000            ;3049
000094  d101              BNE      |L30.154|
000096  2010              MOVS     r0,#0x10              ;3051
000098  e7cb              B        |L30.50|
                  |L30.154|
00009a  f4054000          AND      r0,r5,#0x8000         ;3054
00009e  f5b04f00          CMP      r0,#0x8000            ;3054
0000a2  d101              BNE      |L30.168|
0000a4  200f              MOVS     r0,#0xf               ;3056
0000a6  e7c4              B        |L30.50|
                  |L30.168|
0000a8  4640              MOV      r0,r8                 ;3059
0000aa  e7c2              B        |L30.50|
;;;3061   
                          ENDP


                          AREA ||i.SD_CmdResp7Error||, CODE, READONLY, ALIGN=1

                  SD_CmdResp7Error PROC
;;;2729     */
;;;2730   static HAL_SD_ErrorTypedef SD_CmdResp7Error(SD_HandleTypeDef *hsd)
000000  b530              PUSH     {r4,r5,lr}
;;;2731   {
000002  4601              MOV      r1,r0
;;;2732     HAL_SD_ErrorTypedef errorstate = SD_ERROR;
000004  2029              MOVS     r0,#0x29
;;;2733     uint32_t timeout = SDIO_CMD0TIMEOUT, tmp;
000006  f44f3280          MOV      r2,#0x10000
;;;2734     
;;;2735     tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT); 
00000a  680c              LDR      r4,[r1,#0]
00000c  6b64              LDR      r4,[r4,#0x34]
00000e  f0040445          AND      r4,r4,#0x45
000012  b10c              CBZ      r4,|L31.24|
000014  2401              MOVS     r4,#1
000016  e000              B        |L31.26|
                  |L31.24|
000018  2400              MOVS     r4,#0
                  |L31.26|
00001a  4623              MOV      r3,r4
;;;2736     
;;;2737     while((!tmp) && (timeout > 0))
00001c  e009              B        |L31.50|
                  |L31.30|
;;;2738     {
;;;2739       tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT);
00001e  680c              LDR      r4,[r1,#0]
000020  6b64              LDR      r4,[r4,#0x34]
000022  f0040445          AND      r4,r4,#0x45
000026  b10c              CBZ      r4,|L31.44|
000028  2401              MOVS     r4,#1
00002a  e000              B        |L31.46|
                  |L31.44|
00002c  2400              MOVS     r4,#0
                  |L31.46|
00002e  4623              MOV      r3,r4
;;;2740       timeout--;
000030  1e52              SUBS     r2,r2,#1
                  |L31.50|
000032  b90b              CBNZ     r3,|L31.56|
000034  2a00              CMP      r2,#0                 ;2737
000036  d1f2              BNE      |L31.30|
                  |L31.56|
;;;2741     }
;;;2742     
;;;2743     tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT); 
000038  680c              LDR      r4,[r1,#0]
00003a  6b64              LDR      r4,[r4,#0x34]
00003c  f3c40380          UBFX     r3,r4,#2,#1
;;;2744     
;;;2745     if((timeout == 0) || tmp)
000040  b102              CBZ      r2,|L31.68|
000042  b123              CBZ      r3,|L31.78|
                  |L31.68|
;;;2746     {
;;;2747       /* Card is not V2.0 compliant or card does not support the set voltage range */
;;;2748       errorstate = SD_CMD_RSP_TIMEOUT;
000044  2003              MOVS     r0,#3
;;;2749       
;;;2750       __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
000046  2404              MOVS     r4,#4
000048  680d              LDR      r5,[r1,#0]
00004a  63ac              STR      r4,[r5,#0x38]
                  |L31.76|
;;;2751       
;;;2752       return errorstate;
;;;2753     }
;;;2754     
;;;2755     if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CMDREND))
;;;2756     {
;;;2757       /* Card is SD V2.0 compliant */
;;;2758       errorstate = SD_OK;
;;;2759       
;;;2760       __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CMDREND);
;;;2761       
;;;2762       return errorstate;
;;;2763     }
;;;2764     
;;;2765     return errorstate;
;;;2766   }
00004c  bd30              POP      {r4,r5,pc}
                  |L31.78|
00004e  680c              LDR      r4,[r1,#0]            ;2755
000050  6b64              LDR      r4,[r4,#0x34]         ;2755
000052  f0040440          AND      r4,r4,#0x40           ;2755
000056  b124              CBZ      r4,|L31.98|
000058  2000              MOVS     r0,#0                 ;2758
00005a  2440              MOVS     r4,#0x40              ;2760
00005c  680d              LDR      r5,[r1,#0]            ;2760
00005e  63ac              STR      r4,[r5,#0x38]         ;2760
000060  e7f4              B        |L31.76|
                  |L31.98|
000062  bf00              NOP                            ;2765
000064  e7f2              B        |L31.76|
;;;2767   
                          ENDP


                          AREA ||i.SD_DMA_RxCplt||, CODE, READONLY, ALIGN=1

                  SD_DMA_RxCplt PROC
;;;2285     */
;;;2286   static void SD_DMA_RxCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2287   {
000002  4605              MOV      r5,r0
;;;2288     SD_HandleTypeDef *hsd = (SD_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;2289     
;;;2290     /* DMA transfer is complete */
;;;2291     hsd->DmaTransferCplt = 1;
000006  2001              MOVS     r0,#1
000008  6520              STR      r0,[r4,#0x50]
;;;2292     
;;;2293     /* Wait until SD transfer is complete */
;;;2294     while(hsd->SdTransferCplt == 0)
00000a  bf00              NOP      
                  |L32.12|
00000c  6ca0              LDR      r0,[r4,#0x48]
00000e  2800              CMP      r0,#0
000010  d0fc              BEQ      |L32.12|
;;;2295     {
;;;2296     }
;;;2297     
;;;2298     /* Disable the DMA channel */
;;;2299     HAL_DMA_Abort(hdma);
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       HAL_DMA_Abort
;;;2300   
;;;2301     /* Transfer complete user callback */
;;;2302     HAL_SD_DMA_RxCpltCallback(hsd->hdmarx);   
000018  6da0              LDR      r0,[r4,#0x58]
00001a  f7fffffe          BL       HAL_SD_DMA_RxCpltCallback
;;;2303   }
00001e  bd70              POP      {r4-r6,pc}
;;;2304   
                          ENDP


                          AREA ||i.SD_DMA_RxError||, CODE, READONLY, ALIGN=1

                  SD_DMA_RxError PROC
;;;2310     */
;;;2311   static void SD_DMA_RxError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2312   {
000002  4604              MOV      r4,r0
;;;2313     SD_HandleTypeDef *hsd = (SD_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000004  6ba5              LDR      r5,[r4,#0x38]
;;;2314     
;;;2315     /* Transfer complete user callback */
;;;2316     HAL_SD_DMA_RxErrorCallback(hsd->hdmarx);
000006  6da8              LDR      r0,[r5,#0x58]
000008  f7fffffe          BL       HAL_SD_DMA_RxErrorCallback
;;;2317   }
00000c  bd70              POP      {r4-r6,pc}
;;;2318   
                          ENDP


                          AREA ||i.SD_DMA_TxCplt||, CODE, READONLY, ALIGN=1

                  SD_DMA_TxCplt PROC
;;;2324     */
;;;2325   static void SD_DMA_TxCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2326   {
000002  4605              MOV      r5,r0
;;;2327     SD_HandleTypeDef *hsd = (SD_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;2328     
;;;2329     /* DMA transfer is complete */
;;;2330     hsd->DmaTransferCplt = 1;
000006  2001              MOVS     r0,#1
000008  6520              STR      r0,[r4,#0x50]
;;;2331     
;;;2332     /* Wait until SD transfer is complete */
;;;2333     while(hsd->SdTransferCplt == 0)
00000a  bf00              NOP      
                  |L34.12|
00000c  6ca0              LDR      r0,[r4,#0x48]
00000e  2800              CMP      r0,#0
000010  d0fc              BEQ      |L34.12|
;;;2334     {
;;;2335     }
;;;2336    
;;;2337     /* Disable the DMA channel */
;;;2338     HAL_DMA_Abort(hdma);
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       HAL_DMA_Abort
;;;2339   
;;;2340     /* Transfer complete user callback */
;;;2341     HAL_SD_DMA_TxCpltCallback(hsd->hdmatx);  
000018  6de0              LDR      r0,[r4,#0x5c]
00001a  f7fffffe          BL       HAL_SD_DMA_TxCpltCallback
;;;2342   }
00001e  bd70              POP      {r4-r6,pc}
;;;2343   
                          ENDP


                          AREA ||i.SD_DMA_TxError||, CODE, READONLY, ALIGN=1

                  SD_DMA_TxError PROC
;;;2349     */
;;;2350   static void SD_DMA_TxError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2351   {
000002  4604              MOV      r4,r0
;;;2352     SD_HandleTypeDef *hsd = ( SD_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6ba5              LDR      r5,[r4,#0x38]
;;;2353     
;;;2354     /* Transfer complete user callback */
;;;2355     HAL_SD_DMA_TxErrorCallback(hsd->hdmatx);
000006  6de8              LDR      r0,[r5,#0x5c]
000008  f7fffffe          BL       HAL_SD_DMA_TxErrorCallback
;;;2356   }
00000c  bd70              POP      {r4-r6,pc}
;;;2357   
                          ENDP


                          AREA ||i.SD_FindSCR||, CODE, READONLY, ALIGN=1

                  SD_FindSCR PROC
;;;3206     */
;;;3207   static HAL_SD_ErrorTypedef SD_FindSCR(SD_HandleTypeDef *hsd, uint32_t *pSCR)
000000  b5f0              PUSH     {r4-r7,lr}
;;;3208   {
000002  b08d              SUB      sp,sp,#0x34
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;3209     SDIO_CmdInitTypeDef  sdio_cmdinitstructure;
;;;3210     SDIO_DataInitTypeDef sdio_datainitstructure;
;;;3211     HAL_SD_ErrorTypedef errorstate = SD_OK;
000008  2500              MOVS     r5,#0
;;;3212     uint32_t index = 0;
00000a  2700              MOVS     r7,#0
;;;3213     uint32_t tempscr[2] = {0, 0};
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
000010  9001              STR      r0,[sp,#4]
;;;3214     
;;;3215     /* Set Block Size To 8 Bytes */
;;;3216     /* Send CMD55 APP_CMD with argument as card's RCA */
;;;3217     sdio_cmdinitstructure.Argument         = (uint32_t)8;
000012  2008              MOVS     r0,#8
000014  9008              STR      r0,[sp,#0x20]
;;;3218     sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
000016  2010              MOVS     r0,#0x10
000018  9009              STR      r0,[sp,#0x24]
;;;3219     sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
00001a  2040              MOVS     r0,#0x40
00001c  900a              STR      r0,[sp,#0x28]
;;;3220     sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
00001e  2000              MOVS     r0,#0
000020  900b              STR      r0,[sp,#0x2c]
;;;3221     sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
000022  f44f6080          MOV      r0,#0x400
000026  900c              STR      r0,[sp,#0x30]
;;;3222     SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
000028  a908              ADD      r1,sp,#0x20
00002a  6820              LDR      r0,[r4,#0]
00002c  f7fffffe          BL       SDIO_SendCommand
;;;3223     
;;;3224     /* Check for error conditions */
;;;3225     errorstate = SD_CmdResp1Error(hsd, SD_CMD_SET_BLOCKLEN);
000030  2110              MOVS     r1,#0x10
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       SD_CmdResp1Error
000038  4605              MOV      r5,r0
;;;3226     
;;;3227     if(errorstate != SD_OK)
00003a  b115              CBZ      r5,|L36.66|
;;;3228     {
;;;3229       return errorstate;
00003c  4628              MOV      r0,r5
                  |L36.62|
;;;3230     }
;;;3231     
;;;3232     /* Send CMD55 APP_CMD with argument as card's RCA */
;;;3233     sdio_cmdinitstructure.Argument         = (uint32_t)((hsd->RCA) << 16);
;;;3234     sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
;;;3235     SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
;;;3236     
;;;3237     /* Check for error conditions */
;;;3238     errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_CMD);
;;;3239     
;;;3240     if(errorstate != SD_OK)
;;;3241     {
;;;3242       return errorstate;
;;;3243     }
;;;3244     sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
;;;3245     sdio_datainitstructure.DataLength    = 8;
;;;3246     sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_8B;
;;;3247     sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
;;;3248     sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
;;;3249     sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
;;;3250     SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
;;;3251     
;;;3252     /* Send ACMD51 SD_APP_SEND_SCR with argument as 0 */
;;;3253     sdio_cmdinitstructure.Argument         = 0;
;;;3254     sdio_cmdinitstructure.CmdIndex         = SD_CMD_SD_APP_SEND_SCR;
;;;3255     SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
;;;3256     
;;;3257     /* Check for error conditions */
;;;3258     errorstate = SD_CmdResp1Error(hsd, SD_CMD_SD_APP_SEND_SCR);
;;;3259     
;;;3260     if(errorstate != SD_OK)
;;;3261     {
;;;3262       return errorstate;
;;;3263     }
;;;3264   #ifdef SDIO_STA_STBITERR  
;;;3265     while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND | SDIO_FLAG_STBITERR))
;;;3266   #else /* SDIO_STA_STBITERR not defined */
;;;3267     while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND))
;;;3268   #endif /* SDIO_STA_STBITERR */
;;;3269     {
;;;3270       if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXDAVL))
;;;3271       {
;;;3272         *(tempscr + index) = SDIO_ReadFIFO(hsd->Instance);
;;;3273         index++;
;;;3274       }
;;;3275     }
;;;3276     
;;;3277     if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DTIMEOUT))
;;;3278     {
;;;3279       __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DTIMEOUT);
;;;3280       
;;;3281       errorstate = SD_DATA_TIMEOUT;
;;;3282       
;;;3283       return errorstate;
;;;3284     }
;;;3285     else if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DCRCFAIL))
;;;3286     {
;;;3287       __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DCRCFAIL);
;;;3288       
;;;3289       errorstate = SD_DATA_CRC_FAIL;
;;;3290       
;;;3291       return errorstate;
;;;3292     }
;;;3293     else if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR))
;;;3294     {
;;;3295       __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_RXOVERR);
;;;3296       
;;;3297       errorstate = SD_RX_OVERRUN;
;;;3298       
;;;3299       return errorstate;
;;;3300     }
;;;3301   #ifdef SDIO_STA_STBITERR
;;;3302     else if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_STBITERR))
;;;3303     {
;;;3304       __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_STBITERR);
;;;3305       
;;;3306       errorstate = SD_START_BIT_ERR;
;;;3307       
;;;3308       return errorstate;
;;;3309     }
;;;3310   #endif /* SDIO_STA_STBITERR */
;;;3311     else
;;;3312     {
;;;3313       /* No error flag set */
;;;3314     }
;;;3315     
;;;3316     /* Clear all the static flags */
;;;3317     __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;3318     
;;;3319     *(pSCR + 1) = ((tempscr[0] & SD_0TO7BITS) << 24)  | ((tempscr[0] & SD_8TO15BITS) << 8) |\
;;;3320       ((tempscr[0] & SD_16TO23BITS) >> 8) | ((tempscr[0] & SD_24TO31BITS) >> 24);
;;;3321     
;;;3322     *(pSCR) = ((tempscr[1] & SD_0TO7BITS) << 24)  | ((tempscr[1] & SD_8TO15BITS) << 8) |\
;;;3323       ((tempscr[1] & SD_16TO23BITS) >> 8) | ((tempscr[1] & SD_24TO31BITS) >> 24);
;;;3324     
;;;3325     return errorstate;
;;;3326   }
00003e  b00d              ADD      sp,sp,#0x34
000040  bdf0              POP      {r4-r7,pc}
                  |L36.66|
000042  8ca0              LDRH     r0,[r4,#0x24]         ;3233
000044  0400              LSLS     r0,r0,#16             ;3233
000046  9008              STR      r0,[sp,#0x20]         ;3233
000048  2037              MOVS     r0,#0x37              ;3234
00004a  9009              STR      r0,[sp,#0x24]         ;3234
00004c  a908              ADD      r1,sp,#0x20           ;3235
00004e  6820              LDR      r0,[r4,#0]            ;3235
000050  f7fffffe          BL       SDIO_SendCommand
000054  2137              MOVS     r1,#0x37              ;3238
000056  4620              MOV      r0,r4                 ;3238
000058  f7fffffe          BL       SD_CmdResp1Error
00005c  4605              MOV      r5,r0                 ;3238
00005e  b10d              CBZ      r5,|L36.100|
000060  4628              MOV      r0,r5                 ;3242
000062  e7ec              B        |L36.62|
                  |L36.100|
000064  f04f30ff          MOV      r0,#0xffffffff        ;3244
000068  9002              STR      r0,[sp,#8]            ;3244
00006a  2008              MOVS     r0,#8                 ;3245
00006c  9003              STR      r0,[sp,#0xc]          ;3245
00006e  2030              MOVS     r0,#0x30              ;3246
000070  9004              STR      r0,[sp,#0x10]         ;3246
000072  2002              MOVS     r0,#2                 ;3247
000074  9005              STR      r0,[sp,#0x14]         ;3247
000076  2000              MOVS     r0,#0                 ;3248
000078  9006              STR      r0,[sp,#0x18]         ;3248
00007a  2001              MOVS     r0,#1                 ;3249
00007c  9007              STR      r0,[sp,#0x1c]         ;3249
00007e  a902              ADD      r1,sp,#8              ;3250
000080  6820              LDR      r0,[r4,#0]            ;3250
000082  f7fffffe          BL       SDIO_DataConfig
000086  2000              MOVS     r0,#0                 ;3253
000088  9008              STR      r0,[sp,#0x20]         ;3253
00008a  2033              MOVS     r0,#0x33              ;3254
00008c  9009              STR      r0,[sp,#0x24]         ;3254
00008e  a908              ADD      r1,sp,#0x20           ;3255
000090  6820              LDR      r0,[r4,#0]            ;3255
000092  f7fffffe          BL       SDIO_SendCommand
000096  2133              MOVS     r1,#0x33              ;3258
000098  4620              MOV      r0,r4                 ;3258
00009a  f7fffffe          BL       SD_CmdResp1Error
00009e  4605              MOV      r5,r0                 ;3258
0000a0  b10d              CBZ      r5,|L36.166|
0000a2  4628              MOV      r0,r5                 ;3262
0000a4  e7cb              B        |L36.62|
                  |L36.166|
0000a6  e00a              B        |L36.190|
                  |L36.168|
0000a8  6820              LDR      r0,[r4,#0]            ;3270
0000aa  6b40              LDR      r0,[r0,#0x34]         ;3270
0000ac  f4001000          AND      r0,r0,#0x200000       ;3270
0000b0  b128              CBZ      r0,|L36.190|
0000b2  6820              LDR      r0,[r4,#0]            ;3272
0000b4  f7fffffe          BL       SDIO_ReadFIFO
0000b8  f84d0027          STR      r0,[sp,r7,LSL #2]     ;3272
0000bc  1c7f              ADDS     r7,r7,#1              ;3273
                  |L36.190|
0000be  6820              LDR      r0,[r4,#0]            ;3265
0000c0  6b40              LDR      r0,[r0,#0x34]         ;3265
0000c2  f240612a          MOV      r1,#0x62a             ;3265
0000c6  4008              ANDS     r0,r0,r1              ;3265
0000c8  2800              CMP      r0,#0                 ;3265
0000ca  d0ed              BEQ      |L36.168|
0000cc  6820              LDR      r0,[r4,#0]            ;3277
0000ce  6b40              LDR      r0,[r0,#0x34]         ;3277
0000d0  f0000008          AND      r0,r0,#8              ;3277
0000d4  b128              CBZ      r0,|L36.226|
0000d6  2008              MOVS     r0,#8                 ;3279
0000d8  6821              LDR      r1,[r4,#0]            ;3279
0000da  6388              STR      r0,[r1,#0x38]         ;3279
0000dc  2504              MOVS     r5,#4                 ;3281
0000de  4628              MOV      r0,r5                 ;3283
0000e0  e7ad              B        |L36.62|
                  |L36.226|
0000e2  6820              LDR      r0,[r4,#0]            ;3285
0000e4  6b40              LDR      r0,[r0,#0x34]         ;3285
0000e6  f0000002          AND      r0,r0,#2              ;3285
0000ea  b128              CBZ      r0,|L36.248|
0000ec  2002              MOVS     r0,#2                 ;3287
0000ee  6821              LDR      r1,[r4,#0]            ;3287
0000f0  6388              STR      r0,[r1,#0x38]         ;3287
0000f2  2502              MOVS     r5,#2                 ;3289
0000f4  4628              MOV      r0,r5                 ;3291
0000f6  e7a2              B        |L36.62|
                  |L36.248|
0000f8  6820              LDR      r0,[r4,#0]            ;3293
0000fa  6b40              LDR      r0,[r0,#0x34]         ;3293
0000fc  f0000020          AND      r0,r0,#0x20           ;3293
000100  b128              CBZ      r0,|L36.270|
000102  2020              MOVS     r0,#0x20              ;3295
000104  6821              LDR      r1,[r4,#0]            ;3295
000106  6388              STR      r0,[r1,#0x38]         ;3295
000108  2506              MOVS     r5,#6                 ;3297
00010a  4628              MOV      r0,r5                 ;3299
00010c  e797              B        |L36.62|
                  |L36.270|
00010e  6820              LDR      r0,[r4,#0]            ;3302
000110  6b40              LDR      r0,[r0,#0x34]         ;3302
000112  f4007000          AND      r0,r0,#0x200          ;3302
000116  b130              CBZ      r0,|L36.294|
000118  f44f7000          MOV      r0,#0x200             ;3304
00011c  6821              LDR      r1,[r4,#0]            ;3304
00011e  6388              STR      r0,[r1,#0x38]         ;3304
000120  2507              MOVS     r5,#7                 ;3306
000122  4628              MOV      r0,r5                 ;3308
000124  e78b              B        |L36.62|
                  |L36.294|
000126  f24050ff          MOV      r0,#0x5ff             ;3317
00012a  6821              LDR      r1,[r4,#0]            ;3317
00012c  6388              STR      r0,[r1,#0x38]         ;3317
00012e  9800              LDR      r0,[sp,#0]            ;3319
000130  0600              LSLS     r0,r0,#24             ;3319
000132  9900              LDR      r1,[sp,#0]            ;3319
000134  f401417f          AND      r1,r1,#0xff00         ;3319
000138  ea402001          ORR      r0,r0,r1,LSL #8       ;3319
00013c  9900              LDR      r1,[sp,#0]            ;3319
00013e  f401017f          AND      r1,r1,#0xff0000       ;3319
000142  ea402011          ORR      r0,r0,r1,LSR #8       ;3319
000146  9900              LDR      r1,[sp,#0]            ;3319
000148  ea406011          ORR      r0,r0,r1,LSR #24      ;3319
00014c  6070              STR      r0,[r6,#4]            ;3319
00014e  9801              LDR      r0,[sp,#4]            ;3322
000150  0600              LSLS     r0,r0,#24             ;3322
000152  9901              LDR      r1,[sp,#4]            ;3322
000154  f401417f          AND      r1,r1,#0xff00         ;3322
000158  ea402001          ORR      r0,r0,r1,LSL #8       ;3322
00015c  9901              LDR      r1,[sp,#4]            ;3322
00015e  f401017f          AND      r1,r1,#0xff0000       ;3322
000162  ea402011          ORR      r0,r0,r1,LSR #8       ;3322
000166  9901              LDR      r1,[sp,#4]            ;3322
000168  ea406011          ORR      r0,r0,r1,LSR #24      ;3322
00016c  6030              STR      r0,[r6,#0]            ;3322
00016e  4628              MOV      r0,r5                 ;3325
000170  e765              B        |L36.62|
;;;3327   
                          ENDP


                          AREA ||i.SD_GetState||, CODE, READONLY, ALIGN=1

                  SD_GetState PROC
;;;2362     */
;;;2363   static HAL_SD_CardStateTypedef SD_GetState(SD_HandleTypeDef *hsd)
000000  b538              PUSH     {r3-r5,lr}
;;;2364   {
000002  4604              MOV      r4,r0
;;;2365     uint32_t resp1 = 0;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;2366     
;;;2367     if (SD_SendStatus(hsd, &resp1) != SD_OK)
000008  4669              MOV      r1,sp
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       SD_SendStatus
000010  b108              CBZ      r0,|L37.22|
;;;2368     {
;;;2369       return SD_CARD_ERROR;
000012  20ff              MOVS     r0,#0xff
                  |L37.20|
;;;2370     }
;;;2371     else
;;;2372     {
;;;2373       return (HAL_SD_CardStateTypedef)((resp1 >> 9) & 0x0F);
;;;2374     }
;;;2375   }
000014  bd38              POP      {r3-r5,pc}
                  |L37.22|
000016  9800              LDR      r0,[sp,#0]            ;2373
000018  f3c02043          UBFX     r0,r0,#9,#4           ;2373
00001c  e7fa              B        |L37.20|
;;;2376   
                          ENDP


                          AREA ||i.SD_Initialize_Cards||, CODE, READONLY, ALIGN=1

                  SD_Initialize_Cards PROC
;;;2382     */
;;;2383   static HAL_SD_ErrorTypedef SD_Initialize_Cards(SD_HandleTypeDef *hsd)
000000  b530              PUSH     {r4,r5,lr}
;;;2384   {
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
;;;2385     SDIO_CmdInitTypeDef sdio_cmdinitstructure; 
;;;2386     HAL_SD_ErrorTypedef errorstate = SD_OK;
000006  2500              MOVS     r5,#0
;;;2387     uint16_t sd_rca = 1;
000008  2001              MOVS     r0,#1
00000a  9001              STR      r0,[sp,#4]
;;;2388     
;;;2389     if(SDIO_GetPowerState(hsd->Instance) == 0) /* Power off */
00000c  6820              LDR      r0,[r4,#0]
00000e  f7fffffe          BL       SDIO_GetPowerState
000012  b918              CBNZ     r0,|L38.28|
;;;2390     {
;;;2391       errorstate = SD_REQUEST_NOT_APPLICABLE;
000014  2525              MOVS     r5,#0x25
;;;2392       
;;;2393       return errorstate;
000016  4628              MOV      r0,r5
                  |L38.24|
;;;2394     }
;;;2395     
;;;2396     if(hsd->CardType != SECURE_DIGITAL_IO_CARD)
;;;2397     {
;;;2398       /* Send CMD2 ALL_SEND_CID */
;;;2399       sdio_cmdinitstructure.Argument         = 0;
;;;2400       sdio_cmdinitstructure.CmdIndex         = SD_CMD_ALL_SEND_CID;
;;;2401       sdio_cmdinitstructure.Response         = SDIO_RESPONSE_LONG;
;;;2402       sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
;;;2403       sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
;;;2404       SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
;;;2405       
;;;2406       /* Check for error conditions */
;;;2407       errorstate = SD_CmdResp2Error(hsd);
;;;2408       
;;;2409       if(errorstate != SD_OK)
;;;2410       {
;;;2411         return errorstate;
;;;2412       }
;;;2413       
;;;2414       /* Get Card identification number data */
;;;2415       hsd->CID[0] = SDIO_GetResponse(SDIO_RESP1);
;;;2416       hsd->CID[1] = SDIO_GetResponse(SDIO_RESP2);
;;;2417       hsd->CID[2] = SDIO_GetResponse(SDIO_RESP3);
;;;2418       hsd->CID[3] = SDIO_GetResponse(SDIO_RESP4);
;;;2419     }
;;;2420     
;;;2421     if((hsd->CardType == STD_CAPACITY_SD_CARD_V1_1)    || (hsd->CardType == STD_CAPACITY_SD_CARD_V2_0) ||\
;;;2422        (hsd->CardType == SECURE_DIGITAL_IO_COMBO_CARD) || (hsd->CardType == HIGH_CAPACITY_SD_CARD))
;;;2423     {
;;;2424       /* Send CMD3 SET_REL_ADDR with argument 0 */
;;;2425       /* SD Card publishes its RCA. */
;;;2426       sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_REL_ADDR;
;;;2427       sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
;;;2428       SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
;;;2429       
;;;2430       /* Check for error conditions */
;;;2431       errorstate = SD_CmdResp6Error(hsd, SD_CMD_SET_REL_ADDR, &sd_rca);
;;;2432       
;;;2433       if(errorstate != SD_OK)
;;;2434       {
;;;2435         return errorstate;
;;;2436       }
;;;2437     }
;;;2438     
;;;2439     if (hsd->CardType != SECURE_DIGITAL_IO_CARD)
;;;2440     {
;;;2441       /* Get the SD card RCA */
;;;2442       hsd->RCA = sd_rca;
;;;2443       
;;;2444       /* Send CMD9 SEND_CSD with argument as card's RCA */
;;;2445       sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16);
;;;2446       sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_CSD;
;;;2447       sdio_cmdinitstructure.Response         = SDIO_RESPONSE_LONG;
;;;2448       SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
;;;2449       
;;;2450       /* Check for error conditions */
;;;2451       errorstate = SD_CmdResp2Error(hsd);
;;;2452       
;;;2453       if(errorstate != SD_OK)
;;;2454       {
;;;2455         return errorstate;
;;;2456       }
;;;2457       
;;;2458       /* Get Card Specific Data */
;;;2459       hsd->CSD[0] = SDIO_GetResponse(SDIO_RESP1);
;;;2460       hsd->CSD[1] = SDIO_GetResponse(SDIO_RESP2);
;;;2461       hsd->CSD[2] = SDIO_GetResponse(SDIO_RESP3);
;;;2462       hsd->CSD[3] = SDIO_GetResponse(SDIO_RESP4);
;;;2463     }
;;;2464     
;;;2465     /* All cards are initialized */
;;;2466     return errorstate;
;;;2467   }
000018  b007              ADD      sp,sp,#0x1c
00001a  bd30              POP      {r4,r5,pc}
                  |L38.28|
00001c  6a20              LDR      r0,[r4,#0x20]         ;2396
00001e  2804              CMP      r0,#4                 ;2396
000020  d025              BEQ      |L38.110|
000022  2000              MOVS     r0,#0                 ;2399
000024  9002              STR      r0,[sp,#8]            ;2399
000026  2002              MOVS     r0,#2                 ;2400
000028  9003              STR      r0,[sp,#0xc]          ;2400
00002a  20c0              MOVS     r0,#0xc0              ;2401
00002c  9004              STR      r0,[sp,#0x10]         ;2401
00002e  2000              MOVS     r0,#0                 ;2402
000030  9005              STR      r0,[sp,#0x14]         ;2402
000032  f44f6080          MOV      r0,#0x400             ;2403
000036  9006              STR      r0,[sp,#0x18]         ;2403
000038  a902              ADD      r1,sp,#8              ;2404
00003a  6820              LDR      r0,[r4,#0]            ;2404
00003c  f7fffffe          BL       SDIO_SendCommand
000040  4620              MOV      r0,r4                 ;2407
000042  f7fffffe          BL       SD_CmdResp2Error
000046  4605              MOV      r5,r0                 ;2407
000048  b10d              CBZ      r5,|L38.78|
00004a  4628              MOV      r0,r5                 ;2411
00004c  e7e4              B        |L38.24|
                  |L38.78|
00004e  2000              MOVS     r0,#0                 ;2415
000050  f7fffffe          BL       SDIO_GetResponse
000054  63a0              STR      r0,[r4,#0x38]         ;2415
000056  2004              MOVS     r0,#4                 ;2416
000058  f7fffffe          BL       SDIO_GetResponse
00005c  63e0              STR      r0,[r4,#0x3c]         ;2416
00005e  2008              MOVS     r0,#8                 ;2417
000060  f7fffffe          BL       SDIO_GetResponse
000064  6420              STR      r0,[r4,#0x40]         ;2417
000066  200c              MOVS     r0,#0xc               ;2418
000068  f7fffffe          BL       SDIO_GetResponse
00006c  6460              STR      r0,[r4,#0x44]         ;2418
                  |L38.110|
00006e  6a20              LDR      r0,[r4,#0x20]         ;2421
000070  b140              CBZ      r0,|L38.132|
000072  6a20              LDR      r0,[r4,#0x20]         ;2421
000074  2801              CMP      r0,#1                 ;2421
000076  d005              BEQ      |L38.132|
000078  6a20              LDR      r0,[r4,#0x20]         ;2422
00007a  2806              CMP      r0,#6                 ;2422
00007c  d002              BEQ      |L38.132|
00007e  6a20              LDR      r0,[r4,#0x20]         ;2422
000080  2802              CMP      r0,#2                 ;2422
000082  d110              BNE      |L38.166|
                  |L38.132|
000084  2003              MOVS     r0,#3                 ;2426
000086  9003              STR      r0,[sp,#0xc]          ;2426
000088  2040              MOVS     r0,#0x40              ;2427
00008a  9004              STR      r0,[sp,#0x10]         ;2427
00008c  a902              ADD      r1,sp,#8              ;2428
00008e  6820              LDR      r0,[r4,#0]            ;2428
000090  f7fffffe          BL       SDIO_SendCommand
000094  aa01              ADD      r2,sp,#4              ;2431
000096  2103              MOVS     r1,#3                 ;2431
000098  4620              MOV      r0,r4                 ;2431
00009a  f7fffffe          BL       SD_CmdResp6Error
00009e  4605              MOV      r5,r0                 ;2431
0000a0  b10d              CBZ      r5,|L38.166|
0000a2  4628              MOV      r0,r5                 ;2435
0000a4  e7b8              B        |L38.24|
                  |L38.166|
0000a6  6a20              LDR      r0,[r4,#0x20]         ;2439
0000a8  2804              CMP      r0,#4                 ;2439
0000aa  d024              BEQ      |L38.246|
0000ac  f8bd0004          LDRH     r0,[sp,#4]            ;2442
0000b0  6260              STR      r0,[r4,#0x24]         ;2442
0000b2  8ca0              LDRH     r0,[r4,#0x24]         ;2445
0000b4  0400              LSLS     r0,r0,#16             ;2445
0000b6  9002              STR      r0,[sp,#8]            ;2445
0000b8  2009              MOVS     r0,#9                 ;2446
0000ba  9003              STR      r0,[sp,#0xc]          ;2446
0000bc  20c0              MOVS     r0,#0xc0              ;2447
0000be  9004              STR      r0,[sp,#0x10]         ;2447
0000c0  a902              ADD      r1,sp,#8              ;2448
0000c2  6820              LDR      r0,[r4,#0]            ;2448
0000c4  f7fffffe          BL       SDIO_SendCommand
0000c8  4620              MOV      r0,r4                 ;2451
0000ca  f7fffffe          BL       SD_CmdResp2Error
0000ce  4605              MOV      r5,r0                 ;2451
0000d0  b10d              CBZ      r5,|L38.214|
0000d2  4628              MOV      r0,r5                 ;2455
0000d4  e7a0              B        |L38.24|
                  |L38.214|
0000d6  2000              MOVS     r0,#0                 ;2459
0000d8  f7fffffe          BL       SDIO_GetResponse
0000dc  62a0              STR      r0,[r4,#0x28]         ;2459
0000de  2004              MOVS     r0,#4                 ;2460
0000e0  f7fffffe          BL       SDIO_GetResponse
0000e4  62e0              STR      r0,[r4,#0x2c]         ;2460
0000e6  2008              MOVS     r0,#8                 ;2461
0000e8  f7fffffe          BL       SDIO_GetResponse
0000ec  6320              STR      r0,[r4,#0x30]         ;2461
0000ee  200c              MOVS     r0,#0xc               ;2462
0000f0  f7fffffe          BL       SDIO_GetResponse
0000f4  6360              STR      r0,[r4,#0x34]         ;2462
                  |L38.246|
0000f6  4628              MOV      r0,r5                 ;2466
0000f8  e78e              B        |L38.24|
;;;2468   
                          ENDP


                          AREA ||i.SD_IsCardProgramming||, CODE, READONLY, ALIGN=2

                  SD_IsCardProgramming PROC
;;;3333     */
;;;3334   static HAL_SD_ErrorTypedef SD_IsCardProgramming(SD_HandleTypeDef *hsd, uint8_t *pStatus)
000000  b570              PUSH     {r4-r6,lr}
;;;3335   {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;3336     SDIO_CmdInitTypeDef sdio_cmdinitstructure;
;;;3337     HAL_SD_ErrorTypedef errorstate = SD_OK;
000008  2600              MOVS     r6,#0
;;;3338     __IO uint32_t responseR1 = 0;
00000a  2000              MOVS     r0,#0
00000c  9000              STR      r0,[sp,#0]
;;;3339     
;;;3340     sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16);
00000e  8ca0              LDRH     r0,[r4,#0x24]
000010  0400              LSLS     r0,r0,#16
000012  9001              STR      r0,[sp,#4]
;;;3341     sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
000014  200d              MOVS     r0,#0xd
000016  9002              STR      r0,[sp,#8]
;;;3342     sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
000018  2040              MOVS     r0,#0x40
00001a  9003              STR      r0,[sp,#0xc]
;;;3343     sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
00001c  2000              MOVS     r0,#0
00001e  9004              STR      r0,[sp,#0x10]
;;;3344     sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
000020  f44f6080          MOV      r0,#0x400
000024  9005              STR      r0,[sp,#0x14]
;;;3345     SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
000026  a901              ADD      r1,sp,#4
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       SDIO_SendCommand
;;;3346     
;;;3347     while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))
00002e  bf00              NOP      
                  |L39.48|
000030  6820              LDR      r0,[r4,#0]
000032  6b40              LDR      r0,[r0,#0x34]
000034  f0000045          AND      r0,r0,#0x45
000038  2800              CMP      r0,#0
00003a  d0f9              BEQ      |L39.48|
;;;3348     {
;;;3349     }
;;;3350     
;;;3351     if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT))
00003c  6820              LDR      r0,[r4,#0]
00003e  6b40              LDR      r0,[r0,#0x34]
000040  f0000004          AND      r0,r0,#4
000044  b130              CBZ      r0,|L39.84|
;;;3352     {
;;;3353       errorstate = SD_CMD_RSP_TIMEOUT;
000046  2603              MOVS     r6,#3
;;;3354       
;;;3355       __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
000048  2004              MOVS     r0,#4
00004a  6821              LDR      r1,[r4,#0]
00004c  6388              STR      r0,[r1,#0x38]
;;;3356       
;;;3357       return errorstate;
00004e  4630              MOV      r0,r6
                  |L39.80|
;;;3358     }
;;;3359     else if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL))
;;;3360     {
;;;3361       errorstate = SD_CMD_CRC_FAIL;
;;;3362       
;;;3363       __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CCRCFAIL);
;;;3364       
;;;3365       return errorstate;
;;;3366     }
;;;3367     else
;;;3368     {
;;;3369       /* No error flag set */
;;;3370     }
;;;3371     
;;;3372     /* Check response received is of desired command */
;;;3373     if((uint32_t)SDIO_GetCommandResponse(hsd->Instance) != SD_CMD_SEND_STATUS)
;;;3374     {
;;;3375       errorstate = SD_ILLEGAL_CMD;
;;;3376       
;;;3377       return errorstate;
;;;3378     }
;;;3379     
;;;3380     /* Clear all the static flags */
;;;3381     __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;3382     
;;;3383     
;;;3384     /* We have received response, retrieve it for analysis */
;;;3385     responseR1 = SDIO_GetResponse(SDIO_RESP1);
;;;3386     
;;;3387     /* Find out card status */
;;;3388     *pStatus = (uint8_t)((responseR1 >> 9) & 0x0000000F);
;;;3389     
;;;3390     if((responseR1 & SD_OCR_ERRORBITS) == SD_ALLZERO)
;;;3391     {
;;;3392       return errorstate;
;;;3393     }
;;;3394     
;;;3395     if((responseR1 & SD_OCR_ADDR_OUT_OF_RANGE) == SD_OCR_ADDR_OUT_OF_RANGE)
;;;3396     {
;;;3397       return(SD_ADDR_OUT_OF_RANGE);
;;;3398     }
;;;3399     
;;;3400     if((responseR1 & SD_OCR_ADDR_MISALIGNED) == SD_OCR_ADDR_MISALIGNED)
;;;3401     {
;;;3402       return(SD_ADDR_MISALIGNED);
;;;3403     }
;;;3404     
;;;3405     if((responseR1 & SD_OCR_BLOCK_LEN_ERR) == SD_OCR_BLOCK_LEN_ERR)
;;;3406     {
;;;3407       return(SD_BLOCK_LEN_ERR);
;;;3408     }
;;;3409     
;;;3410     if((responseR1 & SD_OCR_ERASE_SEQ_ERR) == SD_OCR_ERASE_SEQ_ERR)
;;;3411     {
;;;3412       return(SD_ERASE_SEQ_ERR);
;;;3413     }
;;;3414     
;;;3415     if((responseR1 & SD_OCR_BAD_ERASE_PARAM) == SD_OCR_BAD_ERASE_PARAM)
;;;3416     {
;;;3417       return(SD_BAD_ERASE_PARAM);
;;;3418     }
;;;3419     
;;;3420     if((responseR1 & SD_OCR_WRITE_PROT_VIOLATION) == SD_OCR_WRITE_PROT_VIOLATION)
;;;3421     {
;;;3422       return(SD_WRITE_PROT_VIOLATION);
;;;3423     }
;;;3424     
;;;3425     if((responseR1 & SD_OCR_LOCK_UNLOCK_FAILED) == SD_OCR_LOCK_UNLOCK_FAILED)
;;;3426     {
;;;3427       return(SD_LOCK_UNLOCK_FAILED);
;;;3428     }
;;;3429     
;;;3430     if((responseR1 & SD_OCR_COM_CRC_FAILED) == SD_OCR_COM_CRC_FAILED)
;;;3431     {
;;;3432       return(SD_COM_CRC_FAILED);
;;;3433     }
;;;3434     
;;;3435     if((responseR1 & SD_OCR_ILLEGAL_CMD) == SD_OCR_ILLEGAL_CMD)
;;;3436     {
;;;3437       return(SD_ILLEGAL_CMD);
;;;3438     }
;;;3439     
;;;3440     if((responseR1 & SD_OCR_CARD_ECC_FAILED) == SD_OCR_CARD_ECC_FAILED)
;;;3441     {
;;;3442       return(SD_CARD_ECC_FAILED);
;;;3443     }
;;;3444     
;;;3445     if((responseR1 & SD_OCR_CC_ERROR) == SD_OCR_CC_ERROR)
;;;3446     {
;;;3447       return(SD_CC_ERROR);
;;;3448     }
;;;3449     
;;;3450     if((responseR1 & SD_OCR_GENERAL_UNKNOWN_ERROR) == SD_OCR_GENERAL_UNKNOWN_ERROR)
;;;3451     {
;;;3452       return(SD_GENERAL_UNKNOWN_ERROR);
;;;3453     }
;;;3454     
;;;3455     if((responseR1 & SD_OCR_STREAM_READ_UNDERRUN) == SD_OCR_STREAM_READ_UNDERRUN)
;;;3456     {
;;;3457       return(SD_STREAM_READ_UNDERRUN);
;;;3458     }
;;;3459     
;;;3460     if((responseR1 & SD_OCR_STREAM_WRITE_OVERRUN) == SD_OCR_STREAM_WRITE_OVERRUN)
;;;3461     {
;;;3462       return(SD_STREAM_WRITE_OVERRUN);
;;;3463     }
;;;3464     
;;;3465     if((responseR1 & SD_OCR_CID_CSD_OVERWRITE) == SD_OCR_CID_CSD_OVERWRITE)
;;;3466     {
;;;3467       return(SD_CID_CSD_OVERWRITE);
;;;3468     }
;;;3469     
;;;3470     if((responseR1 & SD_OCR_WP_ERASE_SKIP) == SD_OCR_WP_ERASE_SKIP)
;;;3471     {
;;;3472       return(SD_WP_ERASE_SKIP);
;;;3473     }
;;;3474     
;;;3475     if((responseR1 & SD_OCR_CARD_ECC_DISABLED) == SD_OCR_CARD_ECC_DISABLED)
;;;3476     {
;;;3477       return(SD_CARD_ECC_DISABLED);
;;;3478     }
;;;3479     
;;;3480     if((responseR1 & SD_OCR_ERASE_RESET) == SD_OCR_ERASE_RESET)
;;;3481     {
;;;3482       return(SD_ERASE_RESET);
;;;3483     }
;;;3484     
;;;3485     if((responseR1 & SD_OCR_AKE_SEQ_ERROR) == SD_OCR_AKE_SEQ_ERROR)
;;;3486     {
;;;3487       return(SD_AKE_SEQ_ERROR);
;;;3488     }
;;;3489     
;;;3490     return errorstate;
;;;3491   }   
000050  b006              ADD      sp,sp,#0x18
000052  bd70              POP      {r4-r6,pc}
                  |L39.84|
000054  6820              LDR      r0,[r4,#0]            ;3359
000056  6b40              LDR      r0,[r0,#0x34]         ;3359
000058  f0000001          AND      r0,r0,#1              ;3359
00005c  b128              CBZ      r0,|L39.106|
00005e  2601              MOVS     r6,#1                 ;3361
000060  2001              MOVS     r0,#1                 ;3363
000062  6821              LDR      r1,[r4,#0]            ;3363
000064  6388              STR      r0,[r1,#0x38]         ;3363
000066  4630              MOV      r0,r6                 ;3365
000068  e7f2              B        |L39.80|
                  |L39.106|
00006a  6820              LDR      r0,[r4,#0]            ;3373
00006c  f7fffffe          BL       SDIO_GetCommandResponse
000070  280d              CMP      r0,#0xd               ;3373
000072  d002              BEQ      |L39.122|
000074  2610              MOVS     r6,#0x10              ;3375
000076  4630              MOV      r0,r6                 ;3377
000078  e7ea              B        |L39.80|
                  |L39.122|
00007a  f24050ff          MOV      r0,#0x5ff             ;3381
00007e  6821              LDR      r1,[r4,#0]            ;3381
000080  6388              STR      r0,[r1,#0x38]         ;3381
000082  2000              MOVS     r0,#0                 ;3385
000084  f7fffffe          BL       SDIO_GetResponse
000088  9000              STR      r0,[sp,#0]            ;3385
00008a  9800              LDR      r0,[sp,#0]            ;3388
00008c  f3c02043          UBFX     r0,r0,#9,#4           ;3388
000090  7028              STRB     r0,[r5,#0]            ;3388
000092  494f              LDR      r1,|L39.464|
000094  9800              LDR      r0,[sp,#0]            ;3390
000096  4008              ANDS     r0,r0,r1              ;3390
000098  b908              CBNZ     r0,|L39.158|
00009a  4630              MOV      r0,r6                 ;3392
00009c  e7d8              B        |L39.80|
                  |L39.158|
00009e  9800              LDR      r0,[sp,#0]            ;3395
0000a0  f0004000          AND      r0,r0,#0x80000000     ;3395
0000a4  f1b04f00          CMP      r0,#0x80000000        ;3395
0000a8  d101              BNE      |L39.174|
0000aa  201c              MOVS     r0,#0x1c              ;3397
0000ac  e7d0              B        |L39.80|
                  |L39.174|
0000ae  9800              LDR      r0,[sp,#0]            ;3400
0000b0  f0004080          AND      r0,r0,#0x40000000     ;3400
0000b4  f1b04f80          CMP      r0,#0x40000000        ;3400
0000b8  d101              BNE      |L39.190|
0000ba  2009              MOVS     r0,#9                 ;3402
0000bc  e7c8              B        |L39.80|
                  |L39.190|
0000be  9800              LDR      r0,[sp,#0]            ;3405
0000c0  f0005000          AND      r0,r0,#0x20000000     ;3405
0000c4  f1b05f00          CMP      r0,#0x20000000        ;3405
0000c8  d101              BNE      |L39.206|
0000ca  200a              MOVS     r0,#0xa               ;3407
0000cc  e7c0              B        |L39.80|
                  |L39.206|
0000ce  9800              LDR      r0,[sp,#0]            ;3410
0000d0  f0005080          AND      r0,r0,#0x10000000     ;3410
0000d4  f1b05f80          CMP      r0,#0x10000000        ;3410
0000d8  d101              BNE      |L39.222|
0000da  200b              MOVS     r0,#0xb               ;3412
0000dc  e7b8              B        |L39.80|
                  |L39.222|
0000de  9800              LDR      r0,[sp,#0]            ;3415
0000e0  f0006000          AND      r0,r0,#0x8000000      ;3415
0000e4  f1b06f00          CMP      r0,#0x8000000         ;3415
0000e8  d101              BNE      |L39.238|
0000ea  200c              MOVS     r0,#0xc               ;3417
0000ec  e7b0              B        |L39.80|
                  |L39.238|
0000ee  9800              LDR      r0,[sp,#0]            ;3420
0000f0  f0006080          AND      r0,r0,#0x4000000      ;3420
0000f4  f1b06f80          CMP      r0,#0x4000000         ;3420
0000f8  d101              BNE      |L39.254|
0000fa  200d              MOVS     r0,#0xd               ;3422
0000fc  e7a8              B        |L39.80|
                  |L39.254|
0000fe  9800              LDR      r0,[sp,#0]            ;3425
000100  f0007080          AND      r0,r0,#0x1000000      ;3425
000104  f1b07f80          CMP      r0,#0x1000000         ;3425
000108  d101              BNE      |L39.270|
00010a  200e              MOVS     r0,#0xe               ;3427
00010c  e7a0              B        |L39.80|
                  |L39.270|
00010e  9800              LDR      r0,[sp,#0]            ;3430
000110  f4000000          AND      r0,r0,#0x800000       ;3430
000114  f5b00f00          CMP      r0,#0x800000          ;3430
000118  d101              BNE      |L39.286|
00011a  200f              MOVS     r0,#0xf               ;3432
00011c  e798              B        |L39.80|
                  |L39.286|
00011e  9800              LDR      r0,[sp,#0]            ;3435
000120  f4000080          AND      r0,r0,#0x400000       ;3435
000124  f5b00f80          CMP      r0,#0x400000          ;3435
000128  d101              BNE      |L39.302|
00012a  2010              MOVS     r0,#0x10              ;3437
00012c  e790              B        |L39.80|
                  |L39.302|
00012e  9800              LDR      r0,[sp,#0]            ;3440
000130  f4001000          AND      r0,r0,#0x200000       ;3440
000134  f5b01f00          CMP      r0,#0x200000          ;3440
000138  d101              BNE      |L39.318|
00013a  2011              MOVS     r0,#0x11              ;3442
00013c  e788              B        |L39.80|
                  |L39.318|
00013e  9800              LDR      r0,[sp,#0]            ;3445
000140  f4001080          AND      r0,r0,#0x100000       ;3445
000144  f5b01f80          CMP      r0,#0x100000          ;3445
000148  d101              BNE      |L39.334|
00014a  2012              MOVS     r0,#0x12              ;3447
00014c  e780              B        |L39.80|
                  |L39.334|
00014e  9800              LDR      r0,[sp,#0]            ;3450
000150  f4002000          AND      r0,r0,#0x80000        ;3450
000154  f5b02f00          CMP      r0,#0x80000           ;3450
000158  d101              BNE      |L39.350|
00015a  2013              MOVS     r0,#0x13              ;3452
00015c  e778              B        |L39.80|
                  |L39.350|
00015e  9800              LDR      r0,[sp,#0]            ;3455
000160  f4002080          AND      r0,r0,#0x40000        ;3455
000164  f5b02f80          CMP      r0,#0x40000           ;3455
000168  d101              BNE      |L39.366|
00016a  2014              MOVS     r0,#0x14              ;3457
00016c  e770              B        |L39.80|
                  |L39.366|
00016e  9800              LDR      r0,[sp,#0]            ;3460
000170  f4003000          AND      r0,r0,#0x20000        ;3460
000174  f5b03f00          CMP      r0,#0x20000           ;3460
000178  d101              BNE      |L39.382|
00017a  2015              MOVS     r0,#0x15              ;3462
00017c  e768              B        |L39.80|
                  |L39.382|
00017e  9800              LDR      r0,[sp,#0]            ;3465
000180  f4003080          AND      r0,r0,#0x10000        ;3465
000184  f5b03f80          CMP      r0,#0x10000           ;3465
000188  d101              BNE      |L39.398|
00018a  2016              MOVS     r0,#0x16              ;3467
00018c  e760              B        |L39.80|
                  |L39.398|
00018e  9800              LDR      r0,[sp,#0]            ;3470
000190  f4004000          AND      r0,r0,#0x8000         ;3470
000194  f5b04f00          CMP      r0,#0x8000            ;3470
000198  d101              BNE      |L39.414|
00019a  2017              MOVS     r0,#0x17              ;3472
00019c  e758              B        |L39.80|
                  |L39.414|
00019e  9800              LDR      r0,[sp,#0]            ;3475
0001a0  f4004080          AND      r0,r0,#0x4000         ;3475
0001a4  f5b04f80          CMP      r0,#0x4000            ;3475
0001a8  d101              BNE      |L39.430|
0001aa  2018              MOVS     r0,#0x18              ;3477
0001ac  e750              B        |L39.80|
                  |L39.430|
0001ae  9800              LDR      r0,[sp,#0]            ;3480
0001b0  f4005000          AND      r0,r0,#0x2000         ;3480
0001b4  f5b05f00          CMP      r0,#0x2000            ;3480
0001b8  d101              BNE      |L39.446|
0001ba  2019              MOVS     r0,#0x19              ;3482
0001bc  e748              B        |L39.80|
                  |L39.446|
0001be  9800              LDR      r0,[sp,#0]            ;3485
0001c0  f0000008          AND      r0,r0,#8              ;3485
0001c4  2808              CMP      r0,#8                 ;3485
0001c6  d101              BNE      |L39.460|
0001c8  201a              MOVS     r0,#0x1a              ;3487
0001ca  e741              B        |L39.80|
                  |L39.460|
0001cc  4630              MOV      r0,r6                 ;3490
0001ce  e73f              B        |L39.80|
;;;3492   
                          ENDP

                  |L39.464|
                          DCD      0xfdffe008

                          AREA ||i.SD_PowerOFF||, CODE, READONLY, ALIGN=1

                  SD_PowerOFF PROC
;;;2641     */
;;;2642   static HAL_SD_ErrorTypedef SD_PowerOFF(SD_HandleTypeDef *hsd)
000000  b570              PUSH     {r4-r6,lr}
;;;2643   {
000002  4604              MOV      r4,r0
;;;2644     HAL_SD_ErrorTypedef errorstate = SD_OK;
000004  2500              MOVS     r5,#0
;;;2645     
;;;2646     /* Set Power State to OFF */
;;;2647     SDIO_PowerState_OFF(hsd->Instance);
000006  6820              LDR      r0,[r4,#0]
000008  f7fffffe          BL       SDIO_PowerState_OFF
;;;2648     
;;;2649     return errorstate;
00000c  4628              MOV      r0,r5
;;;2650   }
00000e  bd70              POP      {r4-r6,pc}
;;;2651   
                          ENDP


                          AREA ||i.SD_PowerON||, CODE, READONLY, ALIGN=2

                  SD_PowerON PROC
;;;2500     */
;;;2501   static HAL_SD_ErrorTypedef SD_PowerON(SD_HandleTypeDef *hsd)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2502   {
000004  b086              SUB      sp,sp,#0x18
000006  4604              MOV      r4,r0
;;;2503     SDIO_CmdInitTypeDef sdio_cmdinitstructure; 
;;;2504     __IO HAL_SD_ErrorTypedef errorstate = SD_OK; 
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;2505     uint32_t response = 0, count = 0, validvoltage = 0;
00000c  2600              MOVS     r6,#0
00000e  2500              MOVS     r5,#0
000010  2700              MOVS     r7,#0
;;;2506     uint32_t sdtype = SD_STD_CAPACITY;
000012  4680              MOV      r8,r0
;;;2507     
;;;2508     /* Power ON Sequence -------------------------------------------------------*/
;;;2509     /* Disable SDIO Clock */
;;;2510     __HAL_SD_SDIO_DISABLE(); 
000014  4951              LDR      r1,|L41.348|
000016  6008              STR      r0,[r1,#0]
;;;2511     
;;;2512     /* Set Power State to ON */
;;;2513     SDIO_PowerState_ON(hsd->Instance);
000018  6820              LDR      r0,[r4,#0]
00001a  f7fffffe          BL       SDIO_PowerState_ON
;;;2514     
;;;2515     /* 1ms: required power up waiting time before starting the SD initialization 
;;;2516        sequence */
;;;2517     Delayms(1);
00001e  2001              MOVS     r0,#1
000020  f7fffffe          BL       Delayms
;;;2518     
;;;2519     /* Enable SDIO Clock */
;;;2520     __HAL_SD_SDIO_ENABLE();
000024  2001              MOVS     r0,#1
000026  494d              LDR      r1,|L41.348|
000028  39a0              SUBS     r1,r1,#0xa0
00002a  f8c100a0          STR      r0,[r1,#0xa0]
;;;2521     
;;;2522     /* CMD0: GO_IDLE_STATE -----------------------------------------------------*/
;;;2523     /* No CMD response required */
;;;2524     sdio_cmdinitstructure.Argument         = 0;
00002e  2000              MOVS     r0,#0
000030  9001              STR      r0,[sp,#4]
;;;2525     sdio_cmdinitstructure.CmdIndex         = SD_CMD_GO_IDLE_STATE;
000032  9002              STR      r0,[sp,#8]
;;;2526     sdio_cmdinitstructure.Response         = SDIO_RESPONSE_NO;
000034  9003              STR      r0,[sp,#0xc]
;;;2527     sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
000036  9004              STR      r0,[sp,#0x10]
;;;2528     sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
000038  f44f6080          MOV      r0,#0x400
00003c  9005              STR      r0,[sp,#0x14]
;;;2529     SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
00003e  a901              ADD      r1,sp,#4
000040  6820              LDR      r0,[r4,#0]
000042  f7fffffe          BL       SDIO_SendCommand
;;;2530     
;;;2531     /* Check for error conditions */
;;;2532     errorstate = SD_CmdError(hsd);
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       SD_CmdError
00004c  9000              STR      r0,[sp,#0]
;;;2533     
;;;2534     if(errorstate != SD_OK)
00004e  f89d0000          LDRB     r0,[sp,#0]
000052  b120              CBZ      r0,|L41.94|
;;;2535     {
;;;2536       /* CMD Response Timeout (wait for CMDSENT flag) */
;;;2537       return errorstate;
000054  f89d0000          LDRB     r0,[sp,#0]
                  |L41.88|
;;;2538     }
;;;2539     
;;;2540     /* CMD8: SEND_IF_COND ------------------------------------------------------*/
;;;2541     /* Send CMD8 to verify SD card interface operating condition */
;;;2542     /* Argument: - [31:12]: Reserved (shall be set to '0')
;;;2543     - [11:8]: Supply Voltage (VHS) 0x1 (Range: 2.7-3.6 V)
;;;2544     - [7:0]: Check Pattern (recommended 0xAA) */
;;;2545     /* CMD Response: R7 */
;;;2546     sdio_cmdinitstructure.Argument         = SD_CHECK_PATTERN;
;;;2547     sdio_cmdinitstructure.CmdIndex         = SD_SDIO_SEND_IF_COND;
;;;2548     sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
;;;2549     SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
;;;2550     
;;;2551     /* Check for error conditions */ 
;;;2552     errorstate = SD_CmdResp7Error(hsd);
;;;2553     
;;;2554     if (errorstate == SD_OK)
;;;2555     {
;;;2556       /* SD Card 2.0 */
;;;2557       hsd->CardType = STD_CAPACITY_SD_CARD_V2_0; 
;;;2558       sdtype        = SD_HIGH_CAPACITY;
;;;2559     }
;;;2560     
;;;2561     /* Send CMD55 */
;;;2562     sdio_cmdinitstructure.Argument         = 0;
;;;2563     sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
;;;2564     SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
;;;2565     
;;;2566     /* Check for error conditions */
;;;2567     errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_CMD);
;;;2568     
;;;2569     /* If errorstate is Command Timeout, it is a MMC card */
;;;2570     /* If errorstate is SD_OK it is a SD card: SD card 2.0 (voltage range mismatch)
;;;2571        or SD card 1.x */
;;;2572     if(errorstate == SD_OK)
;;;2573     {
;;;2574       /* SD CARD */
;;;2575       /* Send ACMD41 SD_APP_OP_COND with Argument 0x80100000 */
;;;2576       while((!validvoltage) && (count < SD_MAX_VOLT_TRIAL))
;;;2577       {
;;;2578         
;;;2579         /* SEND CMD55 APP_CMD with RCA as 0 */
;;;2580         sdio_cmdinitstructure.Argument         = 0;
;;;2581         sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
;;;2582         sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
;;;2583         sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
;;;2584         sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
;;;2585         SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
;;;2586         
;;;2587         /* Check for error conditions */
;;;2588         errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_CMD);
;;;2589         
;;;2590         if(errorstate != SD_OK)
;;;2591         {
;;;2592           return errorstate;
;;;2593         }
;;;2594         
;;;2595         /* Send CMD41 */
;;;2596         sdio_cmdinitstructure.Argument         = SD_VOLTAGE_WINDOW_SD | sdtype;
;;;2597         sdio_cmdinitstructure.CmdIndex         = SD_CMD_SD_APP_OP_COND;
;;;2598         sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
;;;2599         sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
;;;2600         sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
;;;2601         SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
;;;2602         
;;;2603         /* Check for error conditions */
;;;2604         errorstate = SD_CmdResp3Error(hsd);
;;;2605         
;;;2606         if(errorstate != SD_OK)
;;;2607         {
;;;2608           return errorstate;
;;;2609         }
;;;2610         
;;;2611         /* Get command response */
;;;2612         response = SDIO_GetResponse(SDIO_RESP1);
;;;2613         
;;;2614         /* Get operating voltage*/
;;;2615         validvoltage = (((response >> 31) == 1) ? 1 : 0);
;;;2616         
;;;2617         count++;
;;;2618       }
;;;2619       
;;;2620       if(count >= SD_MAX_VOLT_TRIAL)
;;;2621       {
;;;2622         errorstate = SD_INVALID_VOLTRANGE;
;;;2623         
;;;2624         return errorstate;
;;;2625       }
;;;2626       
;;;2627       if((response & SD_HIGH_CAPACITY) == SD_HIGH_CAPACITY) /* (response &= SD_HIGH_CAPACITY) */
;;;2628       {
;;;2629         hsd->CardType = HIGH_CAPACITY_SD_CARD;
;;;2630       }
;;;2631       
;;;2632     } /* else MMC Card */
;;;2633     
;;;2634     return errorstate;
;;;2635   }
000058  b006              ADD      sp,sp,#0x18
00005a  e8bd81f0          POP      {r4-r8,pc}
                  |L41.94|
00005e  f44f70d5          MOV      r0,#0x1aa             ;2546
000062  9001              STR      r0,[sp,#4]            ;2546
000064  2008              MOVS     r0,#8                 ;2547
000066  9002              STR      r0,[sp,#8]            ;2547
000068  2040              MOVS     r0,#0x40              ;2548
00006a  9003              STR      r0,[sp,#0xc]          ;2548
00006c  a901              ADD      r1,sp,#4              ;2549
00006e  6820              LDR      r0,[r4,#0]            ;2549
000070  f7fffffe          BL       SDIO_SendCommand
000074  4620              MOV      r0,r4                 ;2552
000076  f7fffffe          BL       SD_CmdResp7Error
00007a  9000              STR      r0,[sp,#0]            ;2552
00007c  f89d0000          LDRB     r0,[sp,#0]            ;2554
000080  b918              CBNZ     r0,|L41.138|
000082  2001              MOVS     r0,#1                 ;2557
000084  6220              STR      r0,[r4,#0x20]         ;2557
000086  f04f4880          MOV      r8,#0x40000000        ;2558
                  |L41.138|
00008a  2000              MOVS     r0,#0                 ;2562
00008c  9001              STR      r0,[sp,#4]            ;2562
00008e  2037              MOVS     r0,#0x37              ;2563
000090  9002              STR      r0,[sp,#8]            ;2563
000092  a901              ADD      r1,sp,#4              ;2564
000094  6820              LDR      r0,[r4,#0]            ;2564
000096  f7fffffe          BL       SDIO_SendCommand
00009a  2137              MOVS     r1,#0x37              ;2567
00009c  4620              MOV      r0,r4                 ;2567
00009e  f7fffffe          BL       SD_CmdResp1Error
0000a2  9000              STR      r0,[sp,#0]            ;2567
0000a4  f89d0000          LDRB     r0,[sp,#0]            ;2572
0000a8  2800              CMP      r0,#0                 ;2572
0000aa  d154              BNE      |L41.342|
0000ac  e03e              B        |L41.300|
                  |L41.174|
0000ae  2000              MOVS     r0,#0                 ;2580
0000b0  9001              STR      r0,[sp,#4]            ;2580
0000b2  2037              MOVS     r0,#0x37              ;2581
0000b4  9002              STR      r0,[sp,#8]            ;2581
0000b6  2040              MOVS     r0,#0x40              ;2582
0000b8  9003              STR      r0,[sp,#0xc]          ;2582
0000ba  2000              MOVS     r0,#0                 ;2583
0000bc  9004              STR      r0,[sp,#0x10]         ;2583
0000be  f44f6080          MOV      r0,#0x400             ;2584
0000c2  9005              STR      r0,[sp,#0x14]         ;2584
0000c4  a901              ADD      r1,sp,#4              ;2585
0000c6  6820              LDR      r0,[r4,#0]            ;2585
0000c8  f7fffffe          BL       SDIO_SendCommand
0000cc  2137              MOVS     r1,#0x37              ;2588
0000ce  4620              MOV      r0,r4                 ;2588
0000d0  f7fffffe          BL       SD_CmdResp1Error
0000d4  9000              STR      r0,[sp,#0]            ;2588
0000d6  f89d0000          LDRB     r0,[sp,#0]            ;2590
0000da  b110              CBZ      r0,|L41.226|
0000dc  f89d0000          LDRB     r0,[sp,#0]            ;2592
0000e0  e7ba              B        |L41.88|
                  |L41.226|
0000e2  481f              LDR      r0,|L41.352|
0000e4  ea480000          ORR      r0,r8,r0              ;2596
0000e8  9001              STR      r0,[sp,#4]            ;2596
0000ea  2029              MOVS     r0,#0x29              ;2597
0000ec  9002              STR      r0,[sp,#8]            ;2597
0000ee  2040              MOVS     r0,#0x40              ;2598
0000f0  9003              STR      r0,[sp,#0xc]          ;2598
0000f2  2000              MOVS     r0,#0                 ;2599
0000f4  9004              STR      r0,[sp,#0x10]         ;2599
0000f6  f44f6080          MOV      r0,#0x400             ;2600
0000fa  9005              STR      r0,[sp,#0x14]         ;2600
0000fc  a901              ADD      r1,sp,#4              ;2601
0000fe  6820              LDR      r0,[r4,#0]            ;2601
000100  f7fffffe          BL       SDIO_SendCommand
000104  4620              MOV      r0,r4                 ;2604
000106  f7fffffe          BL       SD_CmdResp3Error
00010a  9000              STR      r0,[sp,#0]            ;2604
00010c  f89d0000          LDRB     r0,[sp,#0]            ;2606
000110  b110              CBZ      r0,|L41.280|
000112  f89d0000          LDRB     r0,[sp,#0]            ;2608
000116  e79f              B        |L41.88|
                  |L41.280|
000118  2000              MOVS     r0,#0                 ;2612
00011a  f7fffffe          BL       SDIO_GetResponse
00011e  4606              MOV      r6,r0                 ;2612
000120  2001              MOVS     r0,#1                 ;2615
000122  ea8070d6          EOR      r0,r0,r6,LSR #31      ;2615
000126  f0800701          EOR      r7,r0,#1              ;2615
00012a  1c6d              ADDS     r5,r5,#1              ;2617
                  |L41.300|
00012c  b91f              CBNZ     r7,|L41.310|
00012e  f64f70ff          MOV      r0,#0xffff            ;2576
000132  4285              CMP      r5,r0                 ;2576
000134  d3bb              BCC      |L41.174|
                  |L41.310|
000136  f64f70ff          MOV      r0,#0xffff            ;2620
00013a  4285              CMP      r5,r0                 ;2620
00013c  d304              BCC      |L41.328|
00013e  201b              MOVS     r0,#0x1b              ;2622
000140  9000              STR      r0,[sp,#0]            ;2622
000142  f89d0000          LDRB     r0,[sp,#0]            ;2624
000146  e787              B        |L41.88|
                  |L41.328|
000148  f0064080          AND      r0,r6,#0x40000000     ;2627
00014c  f1b04f80          CMP      r0,#0x40000000        ;2627
000150  d101              BNE      |L41.342|
000152  2002              MOVS     r0,#2                 ;2629
000154  6220              STR      r0,[r4,#0x20]         ;2629
                  |L41.342|
000156  f89d0000          LDRB     r0,[sp,#0]            ;2634
00015a  e77d              B        |L41.88|
;;;2636   
                          ENDP

                  |L41.348|
                          DCD      0x422580a0
                  |L41.352|
                          DCD      0x80100000

                          AREA ||i.SD_Select_Deselect||, CODE, READONLY, ALIGN=1

                  SD_Select_Deselect PROC
;;;2474     */
;;;2475   static HAL_SD_ErrorTypedef SD_Select_Deselect(SD_HandleTypeDef *hsd, uint64_t addr)
000000  b5f0              PUSH     {r4-r7,lr}
;;;2476   {
000002  b085              SUB      sp,sp,#0x14
000004  4606              MOV      r6,r0
000006  4614              MOV      r4,r2
000008  461d              MOV      r5,r3
;;;2477     SDIO_CmdInitTypeDef sdio_cmdinitstructure;
;;;2478     HAL_SD_ErrorTypedef errorstate = SD_OK;
00000a  2700              MOVS     r7,#0
;;;2479     
;;;2480     /* Send CMD7 SDIO_SEL_DESEL_CARD */
;;;2481     sdio_cmdinitstructure.Argument         = (uint32_t)addr;
00000c  9400              STR      r4,[sp,#0]
;;;2482     sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEL_DESEL_CARD;
00000e  2007              MOVS     r0,#7
000010  9001              STR      r0,[sp,#4]
;;;2483     sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
000012  2040              MOVS     r0,#0x40
000014  9002              STR      r0,[sp,#8]
;;;2484     sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
000016  2000              MOVS     r0,#0
000018  9003              STR      r0,[sp,#0xc]
;;;2485     sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
00001a  f44f6080          MOV      r0,#0x400
00001e  9004              STR      r0,[sp,#0x10]
;;;2486     SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
000020  4669              MOV      r1,sp
000022  6830              LDR      r0,[r6,#0]
000024  f7fffffe          BL       SDIO_SendCommand
;;;2487     
;;;2488     /* Check for error conditions */
;;;2489     errorstate = SD_CmdResp1Error(hsd, SD_CMD_SEL_DESEL_CARD);
000028  2107              MOVS     r1,#7
00002a  4630              MOV      r0,r6
00002c  f7fffffe          BL       SD_CmdResp1Error
000030  4607              MOV      r7,r0
;;;2490     
;;;2491     return errorstate;
000032  4638              MOV      r0,r7
;;;2492   }
000034  b005              ADD      sp,sp,#0x14
000036  bdf0              POP      {r4-r7,pc}
;;;2493   
                          ENDP


                          AREA ||i.SD_SendStatus||, CODE, READONLY, ALIGN=1

                  SD_SendStatus PROC
;;;2658     */
;;;2659   static HAL_SD_ErrorTypedef SD_SendStatus(SD_HandleTypeDef *hsd, uint32_t *pCardStatus)
000000  b570              PUSH     {r4-r6,lr}
;;;2660   {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;2661     SDIO_CmdInitTypeDef sdio_cmdinitstructure;
;;;2662     HAL_SD_ErrorTypedef errorstate = SD_OK;
000008  2600              MOVS     r6,#0
;;;2663     
;;;2664     if(pCardStatus == NULL)
00000a  b91d              CBNZ     r5,|L43.20|
;;;2665     {
;;;2666       errorstate = SD_INVALID_PARAMETER;
00000c  2626              MOVS     r6,#0x26
;;;2667       
;;;2668       return errorstate;
00000e  4630              MOV      r0,r6
                  |L43.16|
;;;2669     }
;;;2670     
;;;2671     /* Send Status command */
;;;2672     sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16);
;;;2673     sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
;;;2674     sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
;;;2675     sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
;;;2676     sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
;;;2677     SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
;;;2678     
;;;2679     /* Check for error conditions */
;;;2680     errorstate = SD_CmdResp1Error(hsd, SD_CMD_SEND_STATUS);
;;;2681     
;;;2682     if(errorstate != SD_OK)
;;;2683     {
;;;2684       return errorstate;
;;;2685     }
;;;2686     
;;;2687     /* Get SD card status */
;;;2688     *pCardStatus = SDIO_GetResponse(SDIO_RESP1);
;;;2689     
;;;2690     return errorstate;
;;;2691   }
000010  b006              ADD      sp,sp,#0x18
000012  bd70              POP      {r4-r6,pc}
                  |L43.20|
000014  8ca0              LDRH     r0,[r4,#0x24]         ;2672
000016  0400              LSLS     r0,r0,#16             ;2672
000018  9001              STR      r0,[sp,#4]            ;2672
00001a  200d              MOVS     r0,#0xd               ;2673
00001c  9002              STR      r0,[sp,#8]            ;2673
00001e  2040              MOVS     r0,#0x40              ;2674
000020  9003              STR      r0,[sp,#0xc]          ;2674
000022  2000              MOVS     r0,#0                 ;2675
000024  9004              STR      r0,[sp,#0x10]         ;2675
000026  f44f6080          MOV      r0,#0x400             ;2676
00002a  9005              STR      r0,[sp,#0x14]         ;2676
00002c  a901              ADD      r1,sp,#4              ;2677
00002e  6820              LDR      r0,[r4,#0]            ;2677
000030  f7fffffe          BL       SDIO_SendCommand
000034  210d              MOVS     r1,#0xd               ;2680
000036  4620              MOV      r0,r4                 ;2680
000038  f7fffffe          BL       SD_CmdResp1Error
00003c  4606              MOV      r6,r0                 ;2680
00003e  b10e              CBZ      r6,|L43.68|
000040  4630              MOV      r0,r6                 ;2684
000042  e7e5              B        |L43.16|
                  |L43.68|
000044  2000              MOVS     r0,#0                 ;2688
000046  f7fffffe          BL       SDIO_GetResponse
00004a  6028              STR      r0,[r5,#0]            ;2688
00004c  4630              MOV      r0,r6                 ;2690
00004e  e7df              B        |L43.16|
;;;2692   
                          ENDP


                          AREA ||i.SD_WideBus_Disable||, CODE, READONLY, ALIGN=1

                  SD_WideBus_Disable PROC
;;;3135     */
;;;3136   static HAL_SD_ErrorTypedef SD_WideBus_Disable(SD_HandleTypeDef *hsd)
000000  b530              PUSH     {r4,r5,lr}
;;;3137   {
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
;;;3138     SDIO_CmdInitTypeDef sdio_cmdinitstructure;
;;;3139     HAL_SD_ErrorTypedef errorstate = SD_OK;
000006  2500              MOVS     r5,#0
;;;3140     
;;;3141     uint32_t scr[2] = {0, 0};
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
00000c  9001              STR      r0,[sp,#4]
;;;3142     
;;;3143     if((SDIO_GetResponse(SDIO_RESP1) & SD_CARD_LOCKED) == SD_CARD_LOCKED)
00000e  f7fffffe          BL       SDIO_GetResponse
000012  f0007000          AND      r0,r0,#0x2000000
000016  f1b07f00          CMP      r0,#0x2000000
00001a  d103              BNE      |L44.36|
;;;3144     {
;;;3145       errorstate = SD_LOCK_UNLOCK_FAILED;
00001c  250e              MOVS     r5,#0xe
;;;3146       
;;;3147       return errorstate;
00001e  4628              MOV      r0,r5
                  |L44.32|
;;;3148     }
;;;3149     
;;;3150     /* Get SCR Register */
;;;3151     errorstate = SD_FindSCR(hsd, scr);
;;;3152     
;;;3153     if(errorstate != SD_OK)
;;;3154     {
;;;3155       return errorstate;
;;;3156     }
;;;3157     
;;;3158     /* If requested card supports 1 bit mode operation */
;;;3159     if((scr[1] & SD_SINGLE_BUS_SUPPORT) != SD_ALLZERO)
;;;3160     {
;;;3161       /* Send CMD55 APP_CMD with argument as card's RCA */
;;;3162       sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16);
;;;3163       sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
;;;3164       sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
;;;3165       sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
;;;3166       sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
;;;3167       SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
;;;3168       
;;;3169       /* Check for error conditions */
;;;3170       errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_CMD);
;;;3171       
;;;3172       if(errorstate != SD_OK)
;;;3173       {
;;;3174         return errorstate;
;;;3175       }
;;;3176       
;;;3177       /* Send ACMD6 APP_CMD with argument as 0 for single bus mode */
;;;3178       sdio_cmdinitstructure.Argument         = 0;
;;;3179       sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_SD_SET_BUSWIDTH;
;;;3180       SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
;;;3181       
;;;3182       /* Check for error conditions */
;;;3183       errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_SD_SET_BUSWIDTH);
;;;3184       
;;;3185       if(errorstate != SD_OK)
;;;3186       {
;;;3187         return errorstate;
;;;3188       }
;;;3189       
;;;3190       return errorstate;
;;;3191     }
;;;3192     else
;;;3193     {
;;;3194       errorstate = SD_REQUEST_NOT_APPLICABLE;
;;;3195       
;;;3196       return errorstate;
;;;3197     }
;;;3198   }
000020  b007              ADD      sp,sp,#0x1c
000022  bd30              POP      {r4,r5,pc}
                  |L44.36|
000024  4669              MOV      r1,sp                 ;3151
000026  4620              MOV      r0,r4                 ;3151
000028  f7fffffe          BL       SD_FindSCR
00002c  4605              MOV      r5,r0                 ;3151
00002e  b10d              CBZ      r5,|L44.52|
000030  4628              MOV      r0,r5                 ;3155
000032  e7f5              B        |L44.32|
                  |L44.52|
000034  9801              LDR      r0,[sp,#4]            ;3159
000036  f4003080          AND      r0,r0,#0x10000        ;3159
00003a  b348              CBZ      r0,|L44.144|
00003c  8ca0              LDRH     r0,[r4,#0x24]         ;3162
00003e  0400              LSLS     r0,r0,#16             ;3162
000040  9002              STR      r0,[sp,#8]            ;3162
000042  2037              MOVS     r0,#0x37              ;3163
000044  9003              STR      r0,[sp,#0xc]          ;3163
000046  2040              MOVS     r0,#0x40              ;3164
000048  9004              STR      r0,[sp,#0x10]         ;3164
00004a  2000              MOVS     r0,#0                 ;3165
00004c  9005              STR      r0,[sp,#0x14]         ;3165
00004e  f44f6080          MOV      r0,#0x400             ;3166
000052  9006              STR      r0,[sp,#0x18]         ;3166
000054  a902              ADD      r1,sp,#8              ;3167
000056  6820              LDR      r0,[r4,#0]            ;3167
000058  f7fffffe          BL       SDIO_SendCommand
00005c  2137              MOVS     r1,#0x37              ;3170
00005e  4620              MOV      r0,r4                 ;3170
000060  f7fffffe          BL       SD_CmdResp1Error
000064  4605              MOV      r5,r0                 ;3170
000066  b10d              CBZ      r5,|L44.108|
000068  4628              MOV      r0,r5                 ;3174
00006a  e7d9              B        |L44.32|
                  |L44.108|
00006c  2000              MOVS     r0,#0                 ;3178
00006e  9002              STR      r0,[sp,#8]            ;3178
000070  2006              MOVS     r0,#6                 ;3179
000072  9003              STR      r0,[sp,#0xc]          ;3179
000074  a902              ADD      r1,sp,#8              ;3180
000076  6820              LDR      r0,[r4,#0]            ;3180
000078  f7fffffe          BL       SDIO_SendCommand
00007c  2106              MOVS     r1,#6                 ;3183
00007e  4620              MOV      r0,r4                 ;3183
000080  f7fffffe          BL       SD_CmdResp1Error
000084  4605              MOV      r5,r0                 ;3183
000086  b10d              CBZ      r5,|L44.140|
000088  4628              MOV      r0,r5                 ;3187
00008a  e7c9              B        |L44.32|
                  |L44.140|
00008c  4628              MOV      r0,r5                 ;3190
00008e  e7c7              B        |L44.32|
                  |L44.144|
000090  2525              MOVS     r5,#0x25              ;3194
000092  4628              MOV      r0,r5                 ;3196
000094  e7c4              B        |L44.32|
;;;3199     
                          ENDP


                          AREA ||i.SD_WideBus_Enable||, CODE, READONLY, ALIGN=1

                  SD_WideBus_Enable PROC
;;;3066     */
;;;3067   static HAL_SD_ErrorTypedef SD_WideBus_Enable(SD_HandleTypeDef *hsd)
000000  b530              PUSH     {r4,r5,lr}
;;;3068   {
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
;;;3069     SDIO_CmdInitTypeDef sdio_cmdinitstructure;
;;;3070     HAL_SD_ErrorTypedef errorstate = SD_OK;
000006  2500              MOVS     r5,#0
;;;3071     
;;;3072     uint32_t scr[2] = {0, 0};
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
00000c  9001              STR      r0,[sp,#4]
;;;3073     
;;;3074     if((SDIO_GetResponse(SDIO_RESP1) & SD_CARD_LOCKED) == SD_CARD_LOCKED)
00000e  f7fffffe          BL       SDIO_GetResponse
000012  f0007000          AND      r0,r0,#0x2000000
000016  f1b07f00          CMP      r0,#0x2000000
00001a  d103              BNE      |L45.36|
;;;3075     {
;;;3076       errorstate = SD_LOCK_UNLOCK_FAILED;
00001c  250e              MOVS     r5,#0xe
;;;3077       
;;;3078       return errorstate;
00001e  4628              MOV      r0,r5
                  |L45.32|
;;;3079     }
;;;3080     
;;;3081     /* Get SCR Register */
;;;3082     errorstate = SD_FindSCR(hsd, scr);
;;;3083     
;;;3084     if(errorstate != SD_OK)
;;;3085     {
;;;3086       return errorstate;
;;;3087     }
;;;3088     
;;;3089     /* If requested card supports wide bus operation */
;;;3090     if((scr[1] & SD_WIDE_BUS_SUPPORT) != SD_ALLZERO)
;;;3091     {
;;;3092       /* Send CMD55 APP_CMD with argument as card's RCA.*/
;;;3093       sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16);
;;;3094       sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
;;;3095       sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
;;;3096       sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
;;;3097       sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
;;;3098       SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
;;;3099       
;;;3100       /* Check for error conditions */
;;;3101       errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_CMD);
;;;3102       
;;;3103       if(errorstate != SD_OK)
;;;3104       {
;;;3105         return errorstate;
;;;3106       }
;;;3107       
;;;3108       /* Send ACMD6 APP_CMD with argument as 2 for wide bus mode */
;;;3109       sdio_cmdinitstructure.Argument         = 2;
;;;3110       sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_SD_SET_BUSWIDTH;
;;;3111       SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
;;;3112       
;;;3113       /* Check for error conditions */
;;;3114       errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_SD_SET_BUSWIDTH);
;;;3115       
;;;3116       if(errorstate != SD_OK)
;;;3117       {
;;;3118         return errorstate;
;;;3119       }
;;;3120       
;;;3121       return errorstate;
;;;3122     }
;;;3123     else
;;;3124     {
;;;3125       errorstate = SD_REQUEST_NOT_APPLICABLE;
;;;3126       
;;;3127       return errorstate;
;;;3128     }
;;;3129   }   
000020  b007              ADD      sp,sp,#0x1c
000022  bd30              POP      {r4,r5,pc}
                  |L45.36|
000024  4669              MOV      r1,sp                 ;3082
000026  4620              MOV      r0,r4                 ;3082
000028  f7fffffe          BL       SD_FindSCR
00002c  4605              MOV      r5,r0                 ;3082
00002e  b10d              CBZ      r5,|L45.52|
000030  4628              MOV      r0,r5                 ;3086
000032  e7f5              B        |L45.32|
                  |L45.52|
000034  9801              LDR      r0,[sp,#4]            ;3090
000036  f4002080          AND      r0,r0,#0x40000        ;3090
00003a  b348              CBZ      r0,|L45.144|
00003c  8ca0              LDRH     r0,[r4,#0x24]         ;3093
00003e  0400              LSLS     r0,r0,#16             ;3093
000040  9002              STR      r0,[sp,#8]            ;3093
000042  2037              MOVS     r0,#0x37              ;3094
000044  9003              STR      r0,[sp,#0xc]          ;3094
000046  2040              MOVS     r0,#0x40              ;3095
000048  9004              STR      r0,[sp,#0x10]         ;3095
00004a  2000              MOVS     r0,#0                 ;3096
00004c  9005              STR      r0,[sp,#0x14]         ;3096
00004e  f44f6080          MOV      r0,#0x400             ;3097
000052  9006              STR      r0,[sp,#0x18]         ;3097
000054  a902              ADD      r1,sp,#8              ;3098
000056  6820              LDR      r0,[r4,#0]            ;3098
000058  f7fffffe          BL       SDIO_SendCommand
00005c  2137              MOVS     r1,#0x37              ;3101
00005e  4620              MOV      r0,r4                 ;3101
000060  f7fffffe          BL       SD_CmdResp1Error
000064  4605              MOV      r5,r0                 ;3101
000066  b10d              CBZ      r5,|L45.108|
000068  4628              MOV      r0,r5                 ;3105
00006a  e7d9              B        |L45.32|
                  |L45.108|
00006c  2002              MOVS     r0,#2                 ;3109
00006e  9002              STR      r0,[sp,#8]            ;3109
000070  2006              MOVS     r0,#6                 ;3110
000072  9003              STR      r0,[sp,#0xc]          ;3110
000074  a902              ADD      r1,sp,#8              ;3111
000076  6820              LDR      r0,[r4,#0]            ;3111
000078  f7fffffe          BL       SDIO_SendCommand
00007c  2106              MOVS     r1,#6                 ;3114
00007e  4620              MOV      r0,r4                 ;3114
000080  f7fffffe          BL       SD_CmdResp1Error
000084  4605              MOV      r5,r0                 ;3114
000086  b10d              CBZ      r5,|L45.140|
000088  4628              MOV      r0,r5                 ;3118
00008a  e7c9              B        |L45.32|
                  |L45.140|
00008c  4628              MOV      r0,r5                 ;3121
00008e  e7c7              B        |L45.32|
                  |L45.144|
000090  2525              MOVS     r5,#0x25              ;3125
000092  4628              MOV      r0,r5                 ;3127
000094  e7c4              B        |L45.32|
;;;3130   
                          ENDP


;*** Start embedded assembler ***

#line 1 "HALLIB\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_sd.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f4xx_hal_sd_c_b96143bd____REV16|
#line 388 ".\\CORE\\cmsis_armcc.h"
|__asm___18_stm32f4xx_hal_sd_c_b96143bd____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f4xx_hal_sd_c_b96143bd____REVSH|
#line 402
|__asm___18_stm32f4xx_hal_sd_c_b96143bd____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f4xx_hal_sd_c_b96143bd____RRX|
#line 587
|__asm___18_stm32f4xx_hal_sd_c_b96143bd____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
