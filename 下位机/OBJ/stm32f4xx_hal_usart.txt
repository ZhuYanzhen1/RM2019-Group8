; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\stm32f4xx_hal_usart.o --asm_dir=.\OBJ\ --list_dir=.\OBJ\ --depend=.\obj\stm32f4xx_hal_usart.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I.\CORE -I.\USER -I.\HALLIB\STM32F4xx_HAL_Driver\Inc -I.\SYSTEM -I.\Hardware -I.\App -I.\DSP_LIB\Include -I.\FreeRTOS -I.\MPU9250\DMP -I.\MPU9250 -I.\RTE\_Project -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=526 -DSTM32F427xx -DSTM32F4 -DUSE_HAL_DRIVER -DSTM32F427xx -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=.\obj\stm32f4xx_hal_usart.crf HALLIB\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_usart.c]
                          THUMB

                          AREA ||i.HAL_USART_DMAPause||, CODE, READONLY, ALIGN=1

                  HAL_USART_DMAPause PROC
;;;1051     */
;;;1052   HAL_StatusTypeDef HAL_USART_DMAPause(USART_HandleTypeDef *husart)
000000  4601              MOV      r1,r0
;;;1053   {
;;;1054     /* Process Locked */
;;;1055     __HAL_LOCK(husart);
000002  bf00              NOP      
000004  f891003c          LDRB     r0,[r1,#0x3c]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L1.16|
00000c  2002              MOVS     r0,#2
                  |L1.14|
;;;1056     
;;;1057     /* Disable the USART DMA Tx request */
;;;1058     husart->Instance->CR3 &= (uint32_t)(~USART_CR3_DMAT);
;;;1059     
;;;1060     /* Process Unlocked */
;;;1061     __HAL_UNLOCK(husart);
;;;1062     
;;;1063     return HAL_OK; 
;;;1064   }
00000e  4770              BX       lr
                  |L1.16|
000010  2001              MOVS     r0,#1                 ;1055
000012  f881003c          STRB     r0,[r1,#0x3c]         ;1055
000016  bf00              NOP                            ;1055
000018  6808              LDR      r0,[r1,#0]            ;1058
00001a  6940              LDR      r0,[r0,#0x14]         ;1058
00001c  f0200080          BIC      r0,r0,#0x80           ;1058
000020  680a              LDR      r2,[r1,#0]            ;1058
000022  6150              STR      r0,[r2,#0x14]         ;1058
000024  bf00              NOP                            ;1061
000026  2000              MOVS     r0,#0                 ;1061
000028  f881003c          STRB     r0,[r1,#0x3c]         ;1061
00002c  bf00              NOP                            ;1061
00002e  bf00              NOP                            ;1063
000030  e7ed              B        |L1.14|
;;;1065   
                          ENDP


                          AREA ||i.HAL_USART_DMAResume||, CODE, READONLY, ALIGN=1

                  HAL_USART_DMAResume PROC
;;;1071     */
;;;1072   HAL_StatusTypeDef HAL_USART_DMAResume(USART_HandleTypeDef *husart)
000000  4601              MOV      r1,r0
;;;1073   {
;;;1074     /* Process Locked */
;;;1075     __HAL_LOCK(husart);
000002  bf00              NOP      
000004  f891003c          LDRB     r0,[r1,#0x3c]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L2.16|
00000c  2002              MOVS     r0,#2
                  |L2.14|
;;;1076     
;;;1077     /* Enable the USART DMA Tx request */
;;;1078     husart->Instance->CR3 |= USART_CR3_DMAT;
;;;1079     
;;;1080     /* Process Unlocked */
;;;1081     __HAL_UNLOCK(husart);
;;;1082     
;;;1083     return HAL_OK;
;;;1084   }
00000e  4770              BX       lr
                  |L2.16|
000010  2001              MOVS     r0,#1                 ;1075
000012  f881003c          STRB     r0,[r1,#0x3c]         ;1075
000016  bf00              NOP                            ;1075
000018  6808              LDR      r0,[r1,#0]            ;1078
00001a  6940              LDR      r0,[r0,#0x14]         ;1078
00001c  f0400080          ORR      r0,r0,#0x80           ;1078
000020  680a              LDR      r2,[r1,#0]            ;1078
000022  6150              STR      r0,[r2,#0x14]         ;1078
000024  bf00              NOP                            ;1081
000026  2000              MOVS     r0,#0                 ;1081
000028  f881003c          STRB     r0,[r1,#0x3c]         ;1081
00002c  bf00              NOP                            ;1081
00002e  bf00              NOP                            ;1083
000030  e7ed              B        |L2.14|
;;;1085   
                          ENDP


                          AREA ||i.HAL_USART_DMAStop||, CODE, READONLY, ALIGN=1

                  HAL_USART_DMAStop PROC
;;;1091     */
;;;1092   HAL_StatusTypeDef HAL_USART_DMAStop(USART_HandleTypeDef *husart)
000000  b510              PUSH     {r4,lr}
;;;1093   {
000002  4604              MOV      r4,r0
;;;1094     /* The Lock is not implemented on this API to allow the user application
;;;1095        to call the HAL USART API under callbacks HAL_USART_TxCpltCallback() / HAL_USART_RxCpltCallback():
;;;1096        when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
;;;1097        and the correspond call back is executed HAL_USART_TxCpltCallback() / HAL_USART_RxCpltCallback()
;;;1098        */
;;;1099   
;;;1100     /* Abort the USART DMA Tx Stream */
;;;1101     if(husart->hdmatx != NULL)
000004  6b60              LDR      r0,[r4,#0x34]
000006  b110              CBZ      r0,|L3.14|
;;;1102     {
;;;1103       HAL_DMA_Abort(husart->hdmatx);
000008  6b60              LDR      r0,[r4,#0x34]
00000a  f7fffffe          BL       HAL_DMA_Abort
                  |L3.14|
;;;1104     }
;;;1105     /* Abort the USART DMA Rx Stream */
;;;1106     if(husart->hdmarx != NULL)
00000e  6ba0              LDR      r0,[r4,#0x38]
000010  b110              CBZ      r0,|L3.24|
;;;1107     {  
;;;1108       HAL_DMA_Abort(husart->hdmarx);
000012  6ba0              LDR      r0,[r4,#0x38]
000014  f7fffffe          BL       HAL_DMA_Abort
                  |L3.24|
;;;1109     }
;;;1110     
;;;1111     /* Disable the USART Tx/Rx DMA requests */
;;;1112     husart->Instance->CR3 &= ~USART_CR3_DMAT;
000018  6820              LDR      r0,[r4,#0]
00001a  6940              LDR      r0,[r0,#0x14]
00001c  f0200080          BIC      r0,r0,#0x80
000020  6821              LDR      r1,[r4,#0]
000022  6148              STR      r0,[r1,#0x14]
;;;1113     husart->Instance->CR3 &= ~USART_CR3_DMAR;
000024  6820              LDR      r0,[r4,#0]
000026  6940              LDR      r0,[r0,#0x14]
000028  f0200040          BIC      r0,r0,#0x40
00002c  6821              LDR      r1,[r4,#0]
00002e  6148              STR      r0,[r1,#0x14]
;;;1114     
;;;1115     husart->State = HAL_USART_STATE_READY;
000030  2001              MOVS     r0,#1
000032  f884003d          STRB     r0,[r4,#0x3d]
;;;1116   
;;;1117     return HAL_OK;
000036  2000              MOVS     r0,#0
;;;1118   }
000038  bd10              POP      {r4,pc}
;;;1119   
                          ENDP


                          AREA ||i.HAL_USART_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_USART_DeInit PROC
;;;267      */
;;;268    HAL_StatusTypeDef HAL_USART_DeInit(USART_HandleTypeDef *husart)
000000  b510              PUSH     {r4,lr}
;;;269    {
000002  4604              MOV      r4,r0
;;;270       /* Check the USART handle allocation */
;;;271      if(husart == NULL)
000004  b90c              CBNZ     r4,|L4.10|
;;;272      {
;;;273        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L4.8|
;;;274      }
;;;275    
;;;276      /* Check the parameters */
;;;277      assert_param(IS_USART_INSTANCE(husart->Instance));
;;;278    
;;;279      husart->State = HAL_USART_STATE_BUSY;
;;;280    
;;;281      /* Disable the Peripheral */
;;;282      __HAL_USART_DISABLE(husart);
;;;283    
;;;284      /* DeInit the low level hardware */
;;;285      HAL_USART_MspDeInit(husart);
;;;286    
;;;287      husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;288      husart->State = HAL_USART_STATE_RESET;
;;;289    
;;;290      /* Release Lock */
;;;291      __HAL_UNLOCK(husart);
;;;292    
;;;293      return HAL_OK;
;;;294    }
000008  bd10              POP      {r4,pc}
                  |L4.10|
00000a  2002              MOVS     r0,#2                 ;279
00000c  f884003d          STRB     r0,[r4,#0x3d]         ;279
000010  6820              LDR      r0,[r4,#0]            ;282
000012  68c0              LDR      r0,[r0,#0xc]          ;282
000014  f4205000          BIC      r0,r0,#0x2000         ;282
000018  6821              LDR      r1,[r4,#0]            ;282
00001a  60c8              STR      r0,[r1,#0xc]          ;282
00001c  4620              MOV      r0,r4                 ;285
00001e  f7fffffe          BL       HAL_USART_MspDeInit
000022  2000              MOVS     r0,#0                 ;287
000024  6420              STR      r0,[r4,#0x40]         ;287
000026  f884003d          STRB     r0,[r4,#0x3d]         ;288
00002a  bf00              NOP                            ;291
00002c  f884003c          STRB     r0,[r4,#0x3c]         ;291
000030  bf00              NOP                            ;291
000032  bf00              NOP                            ;293
000034  e7e8              B        |L4.8|
;;;295    
                          ENDP


                          AREA ||i.HAL_USART_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_ErrorCallback PROC
;;;1293     */
;;;1294    __weak void HAL_USART_ErrorCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1295   {
;;;1296     /* Prevent unused argument(s) compilation warning */
;;;1297     UNUSED(husart); 
;;;1298     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1299              the HAL_USART_ErrorCallback could be implemented in the user file
;;;1300      */ 
;;;1301   }
;;;1302   
                          ENDP


                          AREA ||i.HAL_USART_GetError||, CODE, READONLY, ALIGN=1

                  HAL_USART_GetError PROC
;;;1342     */
;;;1343   uint32_t HAL_USART_GetError(USART_HandleTypeDef *husart)
000000  4601              MOV      r1,r0
;;;1344   {
;;;1345     return husart->ErrorCode;
000002  6c08              LDR      r0,[r1,#0x40]
;;;1346   }
000004  4770              BX       lr
;;;1347   
                          ENDP


                          AREA ||i.HAL_USART_GetState||, CODE, READONLY, ALIGN=1

                  HAL_USART_GetState PROC
;;;1331     */
;;;1332   HAL_USART_StateTypeDef HAL_USART_GetState(USART_HandleTypeDef *husart)
000000  4601              MOV      r1,r0
;;;1333   {
;;;1334     return husart->State;
000002  f891003d          LDRB     r0,[r1,#0x3d]
;;;1335   }
000006  4770              BX       lr
;;;1336   
                          ENDP


                          AREA ||i.HAL_USART_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_USART_IRQHandler PROC
;;;1125     */
;;;1126   void HAL_USART_IRQHandler(USART_HandleTypeDef *husart)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1127   {
000002  4604              MOV      r4,r0
;;;1128     uint32_t tmp1 = 0, tmp2 = 0;
000004  2500              MOVS     r5,#0
000006  2600              MOVS     r6,#0
;;;1129     
;;;1130     tmp1 = __HAL_USART_GET_FLAG(husart, USART_FLAG_PE);
000008  6820              LDR      r0,[r4,#0]
00000a  6800              LDR      r0,[r0,#0]
00000c  f0000501          AND      r5,r0,#1
;;;1131     tmp2 = __HAL_USART_GET_IT_SOURCE(husart, USART_IT_PE);
000010  6820              LDR      r0,[r4,#0]
000012  68c0              LDR      r0,[r0,#0xc]
000014  f4007680          AND      r6,r0,#0x100
;;;1132     /* USART parity error interrupt occurred -----------------------------------*/
;;;1133     if((tmp1 != RESET) && (tmp2 != RESET))
000018  b17d              CBZ      r5,|L8.58|
00001a  b176              CBZ      r6,|L8.58|
;;;1134     {
;;;1135       __HAL_USART_CLEAR_PEFLAG(husart);
00001c  bf00              NOP      
00001e  2000              MOVS     r0,#0
000020  9000              STR      r0,[sp,#0]
000022  6820              LDR      r0,[r4,#0]
000024  6800              LDR      r0,[r0,#0]
000026  9000              STR      r0,[sp,#0]
000028  6820              LDR      r0,[r4,#0]
00002a  6840              LDR      r0,[r0,#4]
00002c  9000              STR      r0,[sp,#0]
00002e  bf00              NOP      
000030  bf00              NOP      
;;;1136       husart->ErrorCode |= HAL_USART_ERROR_PE;
000032  6c20              LDR      r0,[r4,#0x40]
000034  f0400001          ORR      r0,r0,#1
000038  6420              STR      r0,[r4,#0x40]
                  |L8.58|
;;;1137     }
;;;1138   
;;;1139     tmp1 = __HAL_USART_GET_FLAG(husart, USART_FLAG_FE);
00003a  6820              LDR      r0,[r4,#0]
00003c  6800              LDR      r0,[r0,#0]
00003e  f3c00540          UBFX     r5,r0,#1,#1
;;;1140     tmp2 = __HAL_USART_GET_IT_SOURCE(husart, USART_IT_ERR);
000042  6820              LDR      r0,[r4,#0]
000044  6940              LDR      r0,[r0,#0x14]
000046  f0000601          AND      r6,r0,#1
;;;1141     /* USART frame error interrupt occurred ------------------------------------*/
;;;1142     if((tmp1 != RESET) && (tmp2 != RESET))
00004a  b17d              CBZ      r5,|L8.108|
00004c  b176              CBZ      r6,|L8.108|
;;;1143     {
;;;1144       __HAL_USART_CLEAR_FEFLAG(husart);
00004e  bf00              NOP      
000050  2000              MOVS     r0,#0
000052  9000              STR      r0,[sp,#0]
000054  6820              LDR      r0,[r4,#0]
000056  6800              LDR      r0,[r0,#0]
000058  9000              STR      r0,[sp,#0]
00005a  6820              LDR      r0,[r4,#0]
00005c  6840              LDR      r0,[r0,#4]
00005e  9000              STR      r0,[sp,#0]
000060  bf00              NOP      
000062  bf00              NOP      
;;;1145       husart->ErrorCode |= HAL_USART_ERROR_FE;
000064  6c20              LDR      r0,[r4,#0x40]
000066  f0400004          ORR      r0,r0,#4
00006a  6420              STR      r0,[r4,#0x40]
                  |L8.108|
;;;1146     }
;;;1147   
;;;1148     tmp1 = __HAL_USART_GET_FLAG(husart, USART_FLAG_NE);
00006c  6820              LDR      r0,[r4,#0]
00006e  6800              LDR      r0,[r0,#0]
000070  f3c00580          UBFX     r5,r0,#2,#1
;;;1149     tmp2 = __HAL_USART_GET_IT_SOURCE(husart, USART_IT_ERR);
000074  6820              LDR      r0,[r4,#0]
000076  6940              LDR      r0,[r0,#0x14]
000078  f0000601          AND      r6,r0,#1
;;;1150     /* USART noise error interrupt occurred ------------------------------------*/
;;;1151     if((tmp1 != RESET) && (tmp2 != RESET))
00007c  b17d              CBZ      r5,|L8.158|
00007e  b176              CBZ      r6,|L8.158|
;;;1152     {
;;;1153       __HAL_USART_CLEAR_NEFLAG(husart);
000080  bf00              NOP      
000082  2000              MOVS     r0,#0
000084  9000              STR      r0,[sp,#0]
000086  6820              LDR      r0,[r4,#0]
000088  6800              LDR      r0,[r0,#0]
00008a  9000              STR      r0,[sp,#0]
00008c  6820              LDR      r0,[r4,#0]
00008e  6840              LDR      r0,[r0,#4]
000090  9000              STR      r0,[sp,#0]
000092  bf00              NOP      
000094  bf00              NOP      
;;;1154       husart->ErrorCode |= HAL_USART_ERROR_NE;
000096  6c20              LDR      r0,[r4,#0x40]
000098  f0400002          ORR      r0,r0,#2
00009c  6420              STR      r0,[r4,#0x40]
                  |L8.158|
;;;1155     }
;;;1156   
;;;1157     tmp1 = __HAL_USART_GET_FLAG(husart, USART_FLAG_ORE);
00009e  6820              LDR      r0,[r4,#0]
0000a0  6800              LDR      r0,[r0,#0]
0000a2  f3c005c0          UBFX     r5,r0,#3,#1
;;;1158     tmp2 = __HAL_USART_GET_IT_SOURCE(husart, USART_IT_ERR);
0000a6  6820              LDR      r0,[r4,#0]
0000a8  6940              LDR      r0,[r0,#0x14]
0000aa  f0000601          AND      r6,r0,#1
;;;1159     /* USART Over-Run interrupt occurred ---------------------------------------*/
;;;1160     if((tmp1 != RESET) && (tmp2 != RESET))
0000ae  b17d              CBZ      r5,|L8.208|
0000b0  b176              CBZ      r6,|L8.208|
;;;1161     {
;;;1162       __HAL_USART_CLEAR_OREFLAG(husart);
0000b2  bf00              NOP      
0000b4  2000              MOVS     r0,#0
0000b6  9000              STR      r0,[sp,#0]
0000b8  6820              LDR      r0,[r4,#0]
0000ba  6800              LDR      r0,[r0,#0]
0000bc  9000              STR      r0,[sp,#0]
0000be  6820              LDR      r0,[r4,#0]
0000c0  6840              LDR      r0,[r0,#4]
0000c2  9000              STR      r0,[sp,#0]
0000c4  bf00              NOP      
0000c6  bf00              NOP      
;;;1163       husart->ErrorCode |= HAL_USART_ERROR_ORE;
0000c8  6c20              LDR      r0,[r4,#0x40]
0000ca  f0400008          ORR      r0,r0,#8
0000ce  6420              STR      r0,[r4,#0x40]
                  |L8.208|
;;;1164     }
;;;1165   
;;;1166     if(husart->ErrorCode != HAL_USART_ERROR_NONE)
0000d0  6c20              LDR      r0,[r4,#0x40]
0000d2  b128              CBZ      r0,|L8.224|
;;;1167     {
;;;1168       /* Set the USART state ready to be able to start again the process */
;;;1169       husart->State = HAL_USART_STATE_READY;
0000d4  2001              MOVS     r0,#1
0000d6  f884003d          STRB     r0,[r4,#0x3d]
;;;1170       
;;;1171       HAL_USART_ErrorCallback(husart);
0000da  4620              MOV      r0,r4
0000dc  f7fffffe          BL       HAL_USART_ErrorCallback
                  |L8.224|
;;;1172     }
;;;1173   
;;;1174     tmp1 = __HAL_USART_GET_FLAG(husart, USART_FLAG_RXNE);
0000e0  6820              LDR      r0,[r4,#0]
0000e2  6800              LDR      r0,[r0,#0]
0000e4  f3c01540          UBFX     r5,r0,#5,#1
;;;1175     tmp2 = __HAL_USART_GET_IT_SOURCE(husart, USART_IT_RXNE);
0000e8  6820              LDR      r0,[r4,#0]
0000ea  68c0              LDR      r0,[r0,#0xc]
0000ec  f0000620          AND      r6,r0,#0x20
;;;1176     /* USART in mode Receiver --------------------------------------------------*/
;;;1177     if((tmp1 != RESET) && (tmp2 != RESET))
0000f0  b15d              CBZ      r5,|L8.266|
0000f2  b156              CBZ      r6,|L8.266|
;;;1178     {
;;;1179       if(husart->State == HAL_USART_STATE_BUSY_RX)
0000f4  f894003d          LDRB     r0,[r4,#0x3d]
0000f8  2822              CMP      r0,#0x22
0000fa  d103              BNE      |L8.260|
;;;1180       {
;;;1181         USART_Receive_IT(husart);
0000fc  4620              MOV      r0,r4
0000fe  f7fffffe          BL       USART_Receive_IT
000102  e002              B        |L8.266|
                  |L8.260|
;;;1182       }
;;;1183       else
;;;1184       {
;;;1185         USART_TransmitReceive_IT(husart);
000104  4620              MOV      r0,r4
000106  f7fffffe          BL       USART_TransmitReceive_IT
                  |L8.266|
;;;1186       }
;;;1187     }
;;;1188   
;;;1189     tmp1 = __HAL_USART_GET_FLAG(husart, USART_FLAG_TXE);
00010a  6820              LDR      r0,[r4,#0]
00010c  6800              LDR      r0,[r0,#0]
00010e  f3c015c0          UBFX     r5,r0,#7,#1
;;;1190     tmp2 = __HAL_USART_GET_IT_SOURCE(husart, USART_IT_TXE);
000112  6820              LDR      r0,[r4,#0]
000114  68c0              LDR      r0,[r0,#0xc]
000116  f0000680          AND      r6,r0,#0x80
;;;1191     /* USART in mode Transmitter -----------------------------------------------*/
;;;1192     if((tmp1 != RESET) && (tmp2 != RESET))
00011a  b15d              CBZ      r5,|L8.308|
00011c  b156              CBZ      r6,|L8.308|
;;;1193     {
;;;1194       if(husart->State == HAL_USART_STATE_BUSY_TX)
00011e  f894003d          LDRB     r0,[r4,#0x3d]
000122  2812              CMP      r0,#0x12
000124  d103              BNE      |L8.302|
;;;1195       {
;;;1196         USART_Transmit_IT(husart);
000126  4620              MOV      r0,r4
000128  f7fffffe          BL       USART_Transmit_IT
00012c  e002              B        |L8.308|
                  |L8.302|
;;;1197       }
;;;1198       else
;;;1199       {
;;;1200         USART_TransmitReceive_IT(husart);
00012e  4620              MOV      r0,r4
000130  f7fffffe          BL       USART_TransmitReceive_IT
                  |L8.308|
;;;1201       }
;;;1202     }
;;;1203   
;;;1204     tmp1 = __HAL_USART_GET_FLAG(husart, USART_FLAG_TC);
000134  6820              LDR      r0,[r4,#0]
000136  6800              LDR      r0,[r0,#0]
000138  f3c01580          UBFX     r5,r0,#6,#1
;;;1205     tmp2 = __HAL_USART_GET_IT_SOURCE(husart, USART_IT_TC);
00013c  6820              LDR      r0,[r4,#0]
00013e  68c0              LDR      r0,[r0,#0xc]
000140  f0000640          AND      r6,r0,#0x40
;;;1206     /* USART in mode Transmitter (transmission end) ----------------------------*/
;;;1207     if((tmp1 != RESET) && (tmp2 != RESET))
000144  b11d              CBZ      r5,|L8.334|
000146  b116              CBZ      r6,|L8.334|
;;;1208     {
;;;1209       USART_EndTransmit_IT(husart);
000148  4620              MOV      r0,r4
00014a  f7fffffe          BL       USART_EndTransmit_IT
                  |L8.334|
;;;1210     }
;;;1211   }
00014e  bdf8              POP      {r3-r7,pc}
;;;1212   
                          ENDP


                          AREA ||i.HAL_USART_Init||, CODE, READONLY, ALIGN=1

                  HAL_USART_Init PROC
;;;221      */
;;;222    HAL_StatusTypeDef HAL_USART_Init(USART_HandleTypeDef *husart)
000000  b510              PUSH     {r4,lr}
;;;223    {
000002  4604              MOV      r4,r0
;;;224      /* Check the USART handle allocation */
;;;225      if(husart == NULL)
000004  b90c              CBNZ     r4,|L9.10|
;;;226      {
;;;227        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L9.8|
;;;228      }
;;;229    
;;;230      /* Check the parameters */
;;;231      assert_param(IS_USART_INSTANCE(husart->Instance));
;;;232    
;;;233      if(husart->State == HAL_USART_STATE_RESET)
;;;234      {
;;;235        /* Allocate lock resource and initialize it */
;;;236        husart->Lock = HAL_UNLOCKED;
;;;237        /* Init the low level hardware */
;;;238        HAL_USART_MspInit(husart);
;;;239      }
;;;240      
;;;241      husart->State = HAL_USART_STATE_BUSY;  
;;;242    
;;;243      /* Set the USART Communication parameters */
;;;244      USART_SetConfig(husart);
;;;245    
;;;246      /* In USART mode, the following bits must be kept cleared: 
;;;247         - LINEN bit in the USART_CR2 register
;;;248         - HDSEL, SCEN and IREN bits in the USART_CR3 register */
;;;249      husart->Instance->CR2 &= ~USART_CR2_LINEN;
;;;250      husart->Instance->CR3 &= ~(USART_CR3_IREN | USART_CR3_SCEN | USART_CR3_HDSEL);
;;;251    
;;;252      /* Enable the Peripheral */
;;;253      __HAL_USART_ENABLE(husart);
;;;254    
;;;255      /* Initialize the USART state */
;;;256      husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;257      husart->State= HAL_USART_STATE_READY;
;;;258    
;;;259      return HAL_OK;
;;;260    }
000008  bd10              POP      {r4,pc}
                  |L9.10|
00000a  f894003d          LDRB     r0,[r4,#0x3d]         ;233
00000e  b928              CBNZ     r0,|L9.28|
000010  2000              MOVS     r0,#0                 ;236
000012  f884003c          STRB     r0,[r4,#0x3c]         ;236
000016  4620              MOV      r0,r4                 ;238
000018  f7fffffe          BL       HAL_USART_MspInit
                  |L9.28|
00001c  2002              MOVS     r0,#2                 ;241
00001e  f884003d          STRB     r0,[r4,#0x3d]         ;241
000022  4620              MOV      r0,r4                 ;244
000024  f7fffffe          BL       USART_SetConfig
000028  6820              LDR      r0,[r4,#0]            ;249
00002a  6900              LDR      r0,[r0,#0x10]         ;249
00002c  f4204080          BIC      r0,r0,#0x4000         ;249
000030  6821              LDR      r1,[r4,#0]            ;249
000032  6108              STR      r0,[r1,#0x10]         ;249
000034  6820              LDR      r0,[r4,#0]            ;250
000036  6940              LDR      r0,[r0,#0x14]         ;250
000038  f020002a          BIC      r0,r0,#0x2a           ;250
00003c  6821              LDR      r1,[r4,#0]            ;250
00003e  6148              STR      r0,[r1,#0x14]         ;250
000040  6820              LDR      r0,[r4,#0]            ;253
000042  68c0              LDR      r0,[r0,#0xc]          ;253
000044  f4405000          ORR      r0,r0,#0x2000         ;253
000048  6821              LDR      r1,[r4,#0]            ;253
00004a  60c8              STR      r0,[r1,#0xc]          ;253
00004c  2000              MOVS     r0,#0                 ;256
00004e  6420              STR      r0,[r4,#0x40]         ;256
000050  2001              MOVS     r0,#1                 ;257
000052  f884003d          STRB     r0,[r4,#0x3d]         ;257
000056  2000              MOVS     r0,#0                 ;259
000058  e7d6              B        |L9.8|
;;;261    
                          ENDP


                          AREA ||i.HAL_USART_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_USART_MspDeInit PROC
;;;316      */
;;;317     __weak void HAL_USART_MspDeInit(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;318    {
;;;319      /* Prevent unused argument(s) compilation warning */
;;;320      UNUSED(husart);
;;;321      /* NOTE: This function Should not be modified, when the callback is needed,
;;;322               the HAL_USART_MspDeInit could be implemented in the user file
;;;323       */ 
;;;324    }
;;;325    
                          ENDP


                          AREA ||i.HAL_USART_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_USART_MspInit PROC
;;;301      */
;;;302     __weak void HAL_USART_MspInit(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;303    {
;;;304      /* Prevent unused argument(s) compilation warning */
;;;305      UNUSED(husart);
;;;306      /* NOTE: This function Should not be modified, when the callback is needed,
;;;307               the HAL_USART_MspInit could be implemented in the user file
;;;308       */ 
;;;309    }
;;;310    
                          ENDP


                          AREA ||i.HAL_USART_Receive||, CODE, READONLY, ALIGN=1

                  HAL_USART_Receive PROC
;;;476      */
;;;477    HAL_StatusTypeDef HAL_USART_Receive(USART_HandleTypeDef *husart, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;478    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  4698              MOV      r8,r3
;;;479      uint16_t* tmp;
;;;480    
;;;481      if(husart->State == HAL_USART_STATE_READY)
00000c  f894003d          LDRB     r0,[r4,#0x3d]
000010  2801              CMP      r0,#1
000012  d173              BNE      |L12.252|
;;;482      {
;;;483        if((pRxData == NULL) || (Size == 0)) 
000014  b105              CBZ      r5,|L12.24|
000016  b916              CBNZ     r6,|L12.30|
                  |L12.24|
;;;484        {
;;;485          return  HAL_ERROR;
000018  2001              MOVS     r0,#1
                  |L12.26|
;;;486        }
;;;487        /* Process Locked */
;;;488        __HAL_LOCK(husart);
;;;489    
;;;490        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;491        husart->State = HAL_USART_STATE_BUSY_RX;
;;;492    
;;;493        husart->RxXferSize = Size;
;;;494        husart->RxXferCount = Size;
;;;495        /* Check the remain data to be received */
;;;496        while(husart->RxXferCount > 0)
;;;497        {
;;;498          husart->RxXferCount--;
;;;499          if(husart->Init.WordLength == USART_WORDLENGTH_9B)
;;;500          {
;;;501            /* Wait until TXE flag is set to send dummy byte in order to generate the clock for the slave to send data */
;;;502            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, Timeout) != HAL_OK)
;;;503            { 
;;;504              return HAL_TIMEOUT;
;;;505            }
;;;506            /* Send dummy byte in order to generate clock */
;;;507            husart->Instance->DR = (DUMMY_DATA & (uint16_t)0x01FF);
;;;508            
;;;509            /* Wait for RXNE Flag */
;;;510            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_RXNE, RESET, Timeout) != HAL_OK)
;;;511            { 
;;;512              return HAL_TIMEOUT;
;;;513            }
;;;514            tmp = (uint16_t*) pRxData ;
;;;515            if(husart->Init.Parity == USART_PARITY_NONE)
;;;516            {
;;;517              *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x01FF);
;;;518              pRxData +=2;
;;;519            }
;;;520            else
;;;521            {
;;;522              *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x00FF);
;;;523              pRxData +=1;
;;;524            }
;;;525          }
;;;526          else
;;;527          {
;;;528            /* Wait until TXE flag is set to send dummy byte in order to generate the clock for the slave to send data */
;;;529            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, Timeout) != HAL_OK)
;;;530            { 
;;;531              return HAL_TIMEOUT;
;;;532            }
;;;533    
;;;534            /* Send Dummy Byte in order to generate clock */
;;;535            husart->Instance->DR = (DUMMY_DATA & (uint16_t)0x00FF);
;;;536    
;;;537            /* Wait until RXNE flag is set to receive the byte */
;;;538            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_RXNE, RESET, Timeout) != HAL_OK)
;;;539            {
;;;540              return HAL_TIMEOUT;
;;;541            }
;;;542            if(husart->Init.Parity == USART_PARITY_NONE)
;;;543            {
;;;544              /* Receive data */
;;;545              *pRxData++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x00FF);
;;;546            }
;;;547            else
;;;548            {
;;;549              /* Receive data */
;;;550              *pRxData++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x007F);
;;;551            }
;;;552            
;;;553          }
;;;554        }
;;;555    
;;;556        husart->State = HAL_USART_STATE_READY;
;;;557    
;;;558        /* Process Unlocked */
;;;559        __HAL_UNLOCK(husart);
;;;560    
;;;561        return HAL_OK;
;;;562      }
;;;563      else
;;;564      {
;;;565        return HAL_BUSY;
;;;566      }
;;;567    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L12.30|
00001e  bf00              NOP                            ;488
000020  f894003c          LDRB     r0,[r4,#0x3c]         ;488
000024  2801              CMP      r0,#1                 ;488
000026  d101              BNE      |L12.44|
000028  2002              MOVS     r0,#2                 ;488
00002a  e7f6              B        |L12.26|
                  |L12.44|
00002c  2001              MOVS     r0,#1                 ;488
00002e  f884003c          STRB     r0,[r4,#0x3c]         ;488
000032  bf00              NOP                            ;488
000034  2000              MOVS     r0,#0                 ;490
000036  6420              STR      r0,[r4,#0x40]         ;490
000038  2022              MOVS     r0,#0x22              ;491
00003a  f884003d          STRB     r0,[r4,#0x3d]         ;491
00003e  8626              STRH     r6,[r4,#0x30]         ;493
000040  8666              STRH     r6,[r4,#0x32]         ;494
000042  e04e              B        |L12.226|
                  |L12.68|
000044  8e60              LDRH     r0,[r4,#0x32]         ;498
000046  1e40              SUBS     r0,r0,#1              ;498
000048  8660              STRH     r0,[r4,#0x32]         ;498
00004a  68a0              LDR      r0,[r4,#8]            ;499
00004c  f5b05f80          CMP      r0,#0x1000            ;499
000050  d125              BNE      |L12.158|
000052  4643              MOV      r3,r8                 ;502
000054  2200              MOVS     r2,#0                 ;502
000056  2180              MOVS     r1,#0x80              ;502
000058  4620              MOV      r0,r4                 ;502
00005a  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
00005e  b108              CBZ      r0,|L12.100|
000060  2003              MOVS     r0,#3                 ;504
000062  e7da              B        |L12.26|
                  |L12.100|
000064  f24010ff          MOV      r0,#0x1ff             ;507
000068  6821              LDR      r1,[r4,#0]            ;507
00006a  6048              STR      r0,[r1,#4]            ;507
00006c  4643              MOV      r3,r8                 ;510
00006e  2200              MOVS     r2,#0                 ;510
000070  2120              MOVS     r1,#0x20              ;510
000072  4620              MOV      r0,r4                 ;510
000074  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
000078  b108              CBZ      r0,|L12.126|
00007a  2003              MOVS     r0,#3                 ;512
00007c  e7cd              B        |L12.26|
                  |L12.126|
00007e  462f              MOV      r7,r5                 ;514
000080  6920              LDR      r0,[r4,#0x10]         ;515
000082  b930              CBNZ     r0,|L12.146|
000084  6820              LDR      r0,[r4,#0]            ;517
000086  6840              LDR      r0,[r0,#4]            ;517
000088  f3c00008          UBFX     r0,r0,#0,#9           ;517
00008c  8038              STRH     r0,[r7,#0]            ;517
00008e  1cad              ADDS     r5,r5,#2              ;518
000090  e027              B        |L12.226|
                  |L12.146|
000092  6820              LDR      r0,[r4,#0]            ;522
000094  6840              LDR      r0,[r0,#4]            ;522
000096  b2c0              UXTB     r0,r0                 ;522
000098  8038              STRH     r0,[r7,#0]            ;522
00009a  1c6d              ADDS     r5,r5,#1              ;523
00009c  e021              B        |L12.226|
                  |L12.158|
00009e  4643              MOV      r3,r8                 ;529
0000a0  2200              MOVS     r2,#0                 ;529
0000a2  2180              MOVS     r1,#0x80              ;529
0000a4  4620              MOV      r0,r4                 ;529
0000a6  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
0000aa  b108              CBZ      r0,|L12.176|
0000ac  2003              MOVS     r0,#3                 ;531
0000ae  e7b4              B        |L12.26|
                  |L12.176|
0000b0  20ff              MOVS     r0,#0xff              ;535
0000b2  6821              LDR      r1,[r4,#0]            ;535
0000b4  6048              STR      r0,[r1,#4]            ;535
0000b6  4643              MOV      r3,r8                 ;538
0000b8  2200              MOVS     r2,#0                 ;538
0000ba  2120              MOVS     r1,#0x20              ;538
0000bc  4620              MOV      r0,r4                 ;538
0000be  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
0000c2  b108              CBZ      r0,|L12.200|
0000c4  2003              MOVS     r0,#3                 ;540
0000c6  e7a8              B        |L12.26|
                  |L12.200|
0000c8  6920              LDR      r0,[r4,#0x10]         ;542
0000ca  b920              CBNZ     r0,|L12.214|
0000cc  6820              LDR      r0,[r4,#0]            ;545
0000ce  6840              LDR      r0,[r0,#4]            ;545
0000d0  f8050b01          STRB     r0,[r5],#1            ;545
0000d4  e005              B        |L12.226|
                  |L12.214|
0000d6  6820              LDR      r0,[r4,#0]            ;550
0000d8  6840              LDR      r0,[r0,#4]            ;550
0000da  f000007f          AND      r0,r0,#0x7f           ;550
0000de  f8050b01          STRB     r0,[r5],#1            ;550
                  |L12.226|
0000e2  8e60              LDRH     r0,[r4,#0x32]         ;496
0000e4  2800              CMP      r0,#0                 ;496
0000e6  dcad              BGT      |L12.68|
0000e8  2001              MOVS     r0,#1                 ;556
0000ea  f884003d          STRB     r0,[r4,#0x3d]         ;556
0000ee  bf00              NOP                            ;559
0000f0  2000              MOVS     r0,#0                 ;559
0000f2  f884003c          STRB     r0,[r4,#0x3c]         ;559
0000f6  bf00              NOP                            ;559
0000f8  e78f              B        |L12.26|
0000fa  e7ff              B        |L12.252|
                  |L12.252|
0000fc  2002              MOVS     r0,#2                 ;565
0000fe  e78c              B        |L12.26|
;;;568    
                          ENDP


                          AREA ||i.HAL_USART_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_USART_Receive_DMA PROC
;;;900      */
;;;901    HAL_StatusTypeDef HAL_USART_Receive_DMA(USART_HandleTypeDef *husart, uint8_t *pRxData, uint16_t Size)
000000  b577              PUSH     {r0-r2,r4-r6,lr}
;;;902    {
000002  b081              SUB      sp,sp,#4
000004  4604              MOV      r4,r0
000006  4615              MOV      r5,r2
;;;903      uint32_t *tmp;
;;;904      
;;;905      if(husart->State == HAL_USART_STATE_READY)
000008  f894003d          LDRB     r0,[r4,#0x3d]
00000c  2801              CMP      r0,#1
00000e  d150              BNE      |L13.178|
;;;906      {
;;;907        if((pRxData == NULL) || (Size == 0)) 
000010  9802              LDR      r0,[sp,#8]
000012  b100              CBZ      r0,|L13.22|
000014  b915              CBNZ     r5,|L13.28|
                  |L13.22|
;;;908        {
;;;909          return HAL_ERROR;
000016  2001              MOVS     r0,#1
                  |L13.24|
;;;910        }
;;;911    
;;;912        /* Process Locked */
;;;913        __HAL_LOCK(husart);
;;;914    
;;;915        husart->pRxBuffPtr = pRxData;
;;;916        husart->RxXferSize = Size;
;;;917        husart->pTxBuffPtr = pRxData;
;;;918        husart->TxXferSize = Size;
;;;919    
;;;920        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;921        husart->State = HAL_USART_STATE_BUSY_RX;
;;;922    
;;;923        /* Set the USART DMA Rx transfer complete callback */
;;;924        husart->hdmarx->XferCpltCallback = USART_DMAReceiveCplt;
;;;925    
;;;926        /* Set the USART DMA Half transfer complete callback */
;;;927        husart->hdmarx->XferHalfCpltCallback = USART_DMARxHalfCplt;
;;;928    
;;;929        /* Set the USART DMA Rx transfer error callback */
;;;930        husart->hdmarx->XferErrorCallback = USART_DMAError;
;;;931    
;;;932        /* Enable the USART receive DMA Stream */
;;;933        tmp = (uint32_t*)&pRxData;
;;;934        HAL_DMA_Start_IT(husart->hdmarx, (uint32_t)&husart->Instance->DR, *(uint32_t*)tmp, Size);
;;;935    
;;;936        /* Enable the USART transmit DMA Stream: the transmit stream is used in order
;;;937           to generate in the non-blocking mode the clock to the slave device, 
;;;938           this mode isn't a simplex receive mode but a full-duplex receive one */
;;;939        HAL_DMA_Start_IT(husart->hdmatx, *(uint32_t*)tmp, (uint32_t)&husart->Instance->DR, Size);
;;;940    
;;;941        /* Clear the Overrun flag just before enabling the DMA Rx request: mandatory for the second transfer
;;;942           when using the USART in circular mode */
;;;943        __HAL_USART_CLEAR_OREFLAG(husart);
;;;944        
;;;945        /* Enable the DMA transfer for the receiver request by setting the DMAR bit 
;;;946           in the USART CR3 register */
;;;947        husart->Instance->CR3 |= USART_CR3_DMAR;
;;;948    
;;;949        /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;950           in the USART CR3 register */
;;;951        husart->Instance->CR3 |= USART_CR3_DMAT;
;;;952    
;;;953        /* Process Unlocked */
;;;954        __HAL_UNLOCK(husart);
;;;955    
;;;956        return HAL_OK;
;;;957      }
;;;958      else
;;;959      {
;;;960        return HAL_BUSY;
;;;961      }
;;;962    }
000018  b004              ADD      sp,sp,#0x10
00001a  bd70              POP      {r4-r6,pc}
                  |L13.28|
00001c  bf00              NOP                            ;913
00001e  f894003c          LDRB     r0,[r4,#0x3c]         ;913
000022  2801              CMP      r0,#1                 ;913
000024  d101              BNE      |L13.42|
000026  2002              MOVS     r0,#2                 ;913
000028  e7f6              B        |L13.24|
                  |L13.42|
00002a  2001              MOVS     r0,#1                 ;913
00002c  f884003c          STRB     r0,[r4,#0x3c]         ;913
000030  bf00              NOP                            ;913
000032  9802              LDR      r0,[sp,#8]            ;915
000034  62e0              STR      r0,[r4,#0x2c]         ;915
000036  8625              STRH     r5,[r4,#0x30]         ;916
000038  9802              LDR      r0,[sp,#8]            ;917
00003a  6260              STR      r0,[r4,#0x24]         ;917
00003c  8525              STRH     r5,[r4,#0x28]         ;918
00003e  2000              MOVS     r0,#0                 ;920
000040  6420              STR      r0,[r4,#0x40]         ;920
000042  2022              MOVS     r0,#0x22              ;921
000044  f884003d          STRB     r0,[r4,#0x3d]         ;921
000048  481b              LDR      r0,|L13.184|
00004a  6ba1              LDR      r1,[r4,#0x38]         ;924
00004c  63c8              STR      r0,[r1,#0x3c]         ;924
00004e  481b              LDR      r0,|L13.188|
000050  6ba1              LDR      r1,[r4,#0x38]         ;927
000052  6408              STR      r0,[r1,#0x40]         ;927
000054  481a              LDR      r0,|L13.192|
000056  6ba1              LDR      r1,[r4,#0x38]         ;930
000058  6488              STR      r0,[r1,#0x48]         ;930
00005a  ae02              ADD      r6,sp,#8              ;933
00005c  6832              LDR      r2,[r6,#0]            ;934
00005e  6823              LDR      r3,[r4,#0]            ;934
000060  1d19              ADDS     r1,r3,#4              ;934
000062  462b              MOV      r3,r5                 ;934
000064  6ba0              LDR      r0,[r4,#0x38]         ;934
000066  f7fffffe          BL       HAL_DMA_Start_IT
00006a  6823              LDR      r3,[r4,#0]            ;939
00006c  1d1a              ADDS     r2,r3,#4              ;939
00006e  6831              LDR      r1,[r6,#0]            ;939
000070  462b              MOV      r3,r5                 ;939
000072  6b60              LDR      r0,[r4,#0x34]         ;939
000074  f7fffffe          BL       HAL_DMA_Start_IT
000078  bf00              NOP                            ;943
00007a  2000              MOVS     r0,#0                 ;943
00007c  9000              STR      r0,[sp,#0]            ;943
00007e  6820              LDR      r0,[r4,#0]            ;943
000080  6800              LDR      r0,[r0,#0]            ;943
000082  9000              STR      r0,[sp,#0]            ;943
000084  6820              LDR      r0,[r4,#0]            ;943
000086  6840              LDR      r0,[r0,#4]            ;943
000088  9000              STR      r0,[sp,#0]            ;943
00008a  bf00              NOP                            ;943
00008c  bf00              NOP                            ;943
00008e  6820              LDR      r0,[r4,#0]            ;947
000090  6940              LDR      r0,[r0,#0x14]         ;947
000092  f0400040          ORR      r0,r0,#0x40           ;947
000096  6821              LDR      r1,[r4,#0]            ;947
000098  6148              STR      r0,[r1,#0x14]         ;947
00009a  6820              LDR      r0,[r4,#0]            ;951
00009c  6940              LDR      r0,[r0,#0x14]         ;951
00009e  f0400080          ORR      r0,r0,#0x80           ;951
0000a2  6821              LDR      r1,[r4,#0]            ;951
0000a4  6148              STR      r0,[r1,#0x14]         ;951
0000a6  bf00              NOP                            ;954
0000a8  2000              MOVS     r0,#0                 ;954
0000aa  f884003c          STRB     r0,[r4,#0x3c]         ;954
0000ae  bf00              NOP                            ;954
0000b0  e7b2              B        |L13.24|
                  |L13.178|
0000b2  2002              MOVS     r0,#2                 ;960
0000b4  e7b0              B        |L13.24|
;;;963    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L13.184|
                          DCD      USART_DMAReceiveCplt
                  |L13.188|
                          DCD      USART_DMARxHalfCplt
                  |L13.192|
                          DCD      USART_DMAError

                          AREA ||i.HAL_USART_Receive_IT||, CODE, READONLY, ALIGN=1

                  HAL_USART_Receive_IT PROC
;;;737      */
;;;738    HAL_StatusTypeDef HAL_USART_Receive_IT(USART_HandleTypeDef *husart, uint8_t *pRxData, uint16_t Size)
000000  b510              PUSH     {r4,lr}
;;;739    {
000002  4603              MOV      r3,r0
;;;740      if(husart->State == HAL_USART_STATE_READY)
000004  f893003d          LDRB     r0,[r3,#0x3d]
000008  2801              CMP      r0,#1
00000a  d133              BNE      |L14.116|
;;;741      {
;;;742        if((pRxData == NULL) || (Size == 0)) 
00000c  b101              CBZ      r1,|L14.16|
00000e  b90a              CBNZ     r2,|L14.20|
                  |L14.16|
;;;743        {
;;;744          return HAL_ERROR;
000010  2001              MOVS     r0,#1
                  |L14.18|
;;;745        }
;;;746        /* Process Locked */
;;;747        __HAL_LOCK(husart);
;;;748    
;;;749        husart->pRxBuffPtr = pRxData;
;;;750        husart->RxXferSize = Size;
;;;751        husart->RxXferCount = Size;
;;;752    
;;;753        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;754        husart->State = HAL_USART_STATE_BUSY_RX;
;;;755    
;;;756        /* Process Unlocked */
;;;757        __HAL_UNLOCK(husart);
;;;758    
;;;759        /* Enable the USART Data Register not empty Interrupt */
;;;760        __HAL_USART_ENABLE_IT(husart, USART_IT_RXNE); 
;;;761    
;;;762        /* Enable the USART Parity Error Interrupt */
;;;763        __HAL_USART_ENABLE_IT(husart, USART_IT_PE);
;;;764    
;;;765        /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;766        __HAL_USART_ENABLE_IT(husart, USART_IT_ERR);
;;;767    
;;;768        /* Send dummy byte in order to generate the clock for the slave to send data */
;;;769        husart->Instance->DR = (DUMMY_DATA & (uint16_t)0x01FF);    
;;;770    
;;;771        return HAL_OK;
;;;772      }
;;;773      else
;;;774      {
;;;775        return HAL_BUSY;
;;;776      }
;;;777    }
000012  bd10              POP      {r4,pc}
                  |L14.20|
000014  bf00              NOP                            ;747
000016  f893003c          LDRB     r0,[r3,#0x3c]         ;747
00001a  2801              CMP      r0,#1                 ;747
00001c  d101              BNE      |L14.34|
00001e  2002              MOVS     r0,#2                 ;747
000020  e7f7              B        |L14.18|
                  |L14.34|
000022  2001              MOVS     r0,#1                 ;747
000024  f883003c          STRB     r0,[r3,#0x3c]         ;747
000028  bf00              NOP                            ;747
00002a  62d9              STR      r1,[r3,#0x2c]         ;749
00002c  861a              STRH     r2,[r3,#0x30]         ;750
00002e  865a              STRH     r2,[r3,#0x32]         ;751
000030  2000              MOVS     r0,#0                 ;753
000032  6418              STR      r0,[r3,#0x40]         ;753
000034  2022              MOVS     r0,#0x22              ;754
000036  f883003d          STRB     r0,[r3,#0x3d]         ;754
00003a  bf00              NOP                            ;757
00003c  2000              MOVS     r0,#0                 ;757
00003e  f883003c          STRB     r0,[r3,#0x3c]         ;757
000042  bf00              NOP                            ;757
000044  6818              LDR      r0,[r3,#0]            ;760
000046  68c0              LDR      r0,[r0,#0xc]          ;760
000048  f0400020          ORR      r0,r0,#0x20           ;760
00004c  681c              LDR      r4,[r3,#0]            ;760
00004e  60e0              STR      r0,[r4,#0xc]          ;760
000050  6818              LDR      r0,[r3,#0]            ;763
000052  68c0              LDR      r0,[r0,#0xc]          ;763
000054  f4407080          ORR      r0,r0,#0x100          ;763
000058  681c              LDR      r4,[r3,#0]            ;763
00005a  60e0              STR      r0,[r4,#0xc]          ;763
00005c  6818              LDR      r0,[r3,#0]            ;766
00005e  6940              LDR      r0,[r0,#0x14]         ;766
000060  f0400001          ORR      r0,r0,#1              ;766
000064  681c              LDR      r4,[r3,#0]            ;766
000066  6160              STR      r0,[r4,#0x14]         ;766
000068  f24010ff          MOV      r0,#0x1ff             ;769
00006c  681c              LDR      r4,[r3,#0]            ;769
00006e  6060              STR      r0,[r4,#4]            ;769
000070  2000              MOVS     r0,#0                 ;771
000072  e7ce              B        |L14.18|
                  |L14.116|
000074  2002              MOVS     r0,#2                 ;775
000076  e7cc              B        |L14.18|
;;;778    
                          ENDP


                          AREA ||i.HAL_USART_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_RxCpltCallback PROC
;;;1248     */
;;;1249   __weak void HAL_USART_RxCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1250   {
;;;1251     /* Prevent unused argument(s) compilation warning */
;;;1252     UNUSED(husart);
;;;1253     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1254              the HAL_USART_TxCpltCallback could be implemented in the user file
;;;1255      */
;;;1256   }
;;;1257   
                          ENDP


                          AREA ||i.HAL_USART_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_RxHalfCpltCallback PROC
;;;1263     */
;;;1264   __weak void HAL_USART_RxHalfCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1265   {
;;;1266     /* Prevent unused argument(s) compilation warning */
;;;1267     UNUSED(husart);
;;;1268     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1269              the HAL_USART_TxCpltCallback could be implemented in the user file
;;;1270      */
;;;1271   }
;;;1272   
                          ENDP


                          AREA ||i.HAL_USART_Transmit||, CODE, READONLY, ALIGN=1

                  HAL_USART_Transmit PROC
;;;399      */
;;;400    HAL_StatusTypeDef HAL_USART_Transmit(USART_HandleTypeDef *husart, uint8_t *pTxData, uint16_t Size, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;401    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  4698              MOV      r8,r3
;;;402      uint16_t* tmp;
;;;403    
;;;404      if(husart->State == HAL_USART_STATE_READY)
00000c  f894003d          LDRB     r0,[r4,#0x3d]
000010  2801              CMP      r0,#1
000012  d155              BNE      |L17.192|
;;;405      {
;;;406        if((pTxData == NULL) || (Size == 0)) 
000014  b105              CBZ      r5,|L17.24|
000016  b916              CBNZ     r6,|L17.30|
                  |L17.24|
;;;407        {
;;;408          return  HAL_ERROR;
000018  2001              MOVS     r0,#1
                  |L17.26|
;;;409        }
;;;410    
;;;411        /* Process Locked */
;;;412        __HAL_LOCK(husart);
;;;413    
;;;414        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;415        husart->State = HAL_USART_STATE_BUSY_TX;
;;;416    
;;;417        husart->TxXferSize = Size;
;;;418        husart->TxXferCount = Size;
;;;419        while(husart->TxXferCount > 0)
;;;420        {
;;;421          husart->TxXferCount--;
;;;422          if(husart->Init.WordLength == USART_WORDLENGTH_9B)
;;;423          {
;;;424            /* Wait for TC flag in order to write data in DR */
;;;425            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, Timeout) != HAL_OK)
;;;426            {
;;;427              return HAL_TIMEOUT;
;;;428            }
;;;429            tmp = (uint16_t*) pTxData;
;;;430            husart->Instance->DR = (*tmp & (uint16_t)0x01FF);
;;;431            if(husart->Init.Parity == USART_PARITY_NONE)
;;;432            {
;;;433              pTxData += 2;
;;;434            }
;;;435            else
;;;436            {
;;;437              pTxData += 1;
;;;438            }
;;;439          }
;;;440          else
;;;441          {
;;;442            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, Timeout) != HAL_OK)
;;;443            {
;;;444              return HAL_TIMEOUT;
;;;445            }
;;;446            husart->Instance->DR = (*pTxData++ & (uint8_t)0xFF);
;;;447          }
;;;448        }
;;;449    
;;;450        if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TC, RESET, Timeout) != HAL_OK)
;;;451        { 
;;;452          return HAL_TIMEOUT;
;;;453        }
;;;454    
;;;455        husart->State = HAL_USART_STATE_READY;
;;;456    
;;;457        /* Process Unlocked */
;;;458        __HAL_UNLOCK(husart);
;;;459    
;;;460        return HAL_OK;
;;;461      }
;;;462      else
;;;463      {
;;;464        return HAL_BUSY;
;;;465      }
;;;466    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L17.30|
00001e  bf00              NOP                            ;412
000020  f894003c          LDRB     r0,[r4,#0x3c]         ;412
000024  2801              CMP      r0,#1                 ;412
000026  d101              BNE      |L17.44|
000028  2002              MOVS     r0,#2                 ;412
00002a  e7f6              B        |L17.26|
                  |L17.44|
00002c  2001              MOVS     r0,#1                 ;412
00002e  f884003c          STRB     r0,[r4,#0x3c]         ;412
000032  bf00              NOP                            ;412
000034  2000              MOVS     r0,#0                 ;414
000036  6420              STR      r0,[r4,#0x40]         ;414
000038  2012              MOVS     r0,#0x12              ;415
00003a  f884003d          STRB     r0,[r4,#0x3d]         ;415
00003e  8526              STRH     r6,[r4,#0x28]         ;417
000040  8566              STRH     r6,[r4,#0x2a]         ;418
000042  e028              B        |L17.150|
                  |L17.68|
000044  8d60              LDRH     r0,[r4,#0x2a]         ;421
000046  1e40              SUBS     r0,r0,#1              ;421
000048  8560              STRH     r0,[r4,#0x2a]         ;421
00004a  68a0              LDR      r0,[r4,#8]            ;422
00004c  f5b05f80          CMP      r0,#0x1000            ;422
000050  d114              BNE      |L17.124|
000052  4643              MOV      r3,r8                 ;425
000054  2200              MOVS     r2,#0                 ;425
000056  2180              MOVS     r1,#0x80              ;425
000058  4620              MOV      r0,r4                 ;425
00005a  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
00005e  b108              CBZ      r0,|L17.100|
000060  2003              MOVS     r0,#3                 ;427
000062  e7da              B        |L17.26|
                  |L17.100|
000064  462f              MOV      r7,r5                 ;429
000066  8838              LDRH     r0,[r7,#0]            ;430
000068  f3c00008          UBFX     r0,r0,#0,#9           ;430
00006c  6821              LDR      r1,[r4,#0]            ;430
00006e  6048              STR      r0,[r1,#4]            ;430
000070  6920              LDR      r0,[r4,#0x10]         ;431
000072  b908              CBNZ     r0,|L17.120|
000074  1cad              ADDS     r5,r5,#2              ;433
000076  e00e              B        |L17.150|
                  |L17.120|
000078  1c6d              ADDS     r5,r5,#1              ;437
00007a  e00c              B        |L17.150|
                  |L17.124|
00007c  4643              MOV      r3,r8                 ;442
00007e  2200              MOVS     r2,#0                 ;442
000080  2180              MOVS     r1,#0x80              ;442
000082  4620              MOV      r0,r4                 ;442
000084  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
000088  b108              CBZ      r0,|L17.142|
00008a  2003              MOVS     r0,#3                 ;444
00008c  e7c5              B        |L17.26|
                  |L17.142|
00008e  f8150b01          LDRB     r0,[r5],#1            ;446
000092  6821              LDR      r1,[r4,#0]            ;446
000094  6048              STR      r0,[r1,#4]            ;446
                  |L17.150|
000096  8d60              LDRH     r0,[r4,#0x2a]         ;419
000098  2800              CMP      r0,#0                 ;419
00009a  dcd3              BGT      |L17.68|
00009c  4643              MOV      r3,r8                 ;450
00009e  2200              MOVS     r2,#0                 ;450
0000a0  2140              MOVS     r1,#0x40              ;450
0000a2  4620              MOV      r0,r4                 ;450
0000a4  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
0000a8  b108              CBZ      r0,|L17.174|
0000aa  2003              MOVS     r0,#3                 ;452
0000ac  e7b5              B        |L17.26|
                  |L17.174|
0000ae  2001              MOVS     r0,#1                 ;455
0000b0  f884003d          STRB     r0,[r4,#0x3d]         ;455
0000b4  bf00              NOP                            ;458
0000b6  2000              MOVS     r0,#0                 ;458
0000b8  f884003c          STRB     r0,[r4,#0x3c]         ;458
0000bc  bf00              NOP                            ;458
0000be  e7ac              B        |L17.26|
                  |L17.192|
0000c0  2002              MOVS     r0,#2                 ;464
0000c2  e7aa              B        |L17.26|
;;;467    
                          ENDP


                          AREA ||i.HAL_USART_TransmitReceive||, CODE, READONLY, ALIGN=1

                  HAL_USART_TransmitReceive PROC
;;;578      */
;;;579    HAL_StatusTypeDef HAL_USART_TransmitReceive(USART_HandleTypeDef *husart, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;580    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
00000a  461f              MOV      r7,r3
00000c  f8dd9020          LDR      r9,[sp,#0x20]
;;;581      uint16_t* tmp;
;;;582    
;;;583      if(husart->State == HAL_USART_STATE_READY)
000010  f894003d          LDRB     r0,[r4,#0x3d]
000014  2801              CMP      r0,#1
000016  d171              BNE      |L18.252|
;;;584      {
;;;585        if((pTxData == NULL) || (pRxData == NULL) || (Size == 0)) 
000018  b10e              CBZ      r6,|L18.30|
00001a  b105              CBZ      r5,|L18.30|
00001c  b917              CBNZ     r7,|L18.36|
                  |L18.30|
;;;586        {
;;;587          return  HAL_ERROR;
00001e  2001              MOVS     r0,#1
                  |L18.32|
;;;588        }
;;;589        /* Process Locked */
;;;590        __HAL_LOCK(husart);
;;;591    
;;;592        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;593        husart->State = HAL_USART_STATE_BUSY_RX;
;;;594    
;;;595        husart->RxXferSize = Size;
;;;596        husart->TxXferSize = Size;
;;;597        husart->TxXferCount = Size;
;;;598        husart->RxXferCount = Size;
;;;599    
;;;600        /* Check the remain data to be received */
;;;601        while(husart->TxXferCount > 0)
;;;602        {
;;;603          husart->TxXferCount--;
;;;604          husart->RxXferCount--;
;;;605          if(husart->Init.WordLength == USART_WORDLENGTH_9B)
;;;606          {
;;;607            /* Wait for TC flag in order to write data in DR */
;;;608            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, Timeout) != HAL_OK)
;;;609            {
;;;610              return HAL_TIMEOUT;
;;;611            }
;;;612            tmp = (uint16_t*) pTxData;
;;;613            husart->Instance->DR = (*tmp & (uint16_t)0x01FF);
;;;614            if(husart->Init.Parity == USART_PARITY_NONE)
;;;615            {
;;;616              pTxData += 2;
;;;617            }
;;;618            else
;;;619            {
;;;620              pTxData += 1;
;;;621            }
;;;622            
;;;623            /* Wait for RXNE Flag */
;;;624            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_RXNE, RESET, Timeout) != HAL_OK)
;;;625            {
;;;626              return HAL_TIMEOUT;
;;;627            }
;;;628            tmp = (uint16_t*) pRxData ;
;;;629            if(husart->Init.Parity == USART_PARITY_NONE)
;;;630            {
;;;631              *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x01FF);
;;;632              pRxData += 2;
;;;633            }
;;;634            else
;;;635            {
;;;636              *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x00FF);
;;;637              pRxData += 1;
;;;638            }
;;;639          } 
;;;640          else
;;;641          {
;;;642            /* Wait for TC flag in order to write data in DR */
;;;643            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, Timeout) != HAL_OK)
;;;644            {
;;;645              return HAL_TIMEOUT;
;;;646            }
;;;647            husart->Instance->DR = (*pTxData++ & (uint8_t)0x00FF);
;;;648    
;;;649            /* Wait for RXNE Flag */
;;;650            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_RXNE, RESET, Timeout) != HAL_OK)
;;;651            {
;;;652              return HAL_TIMEOUT;
;;;653            }
;;;654            if(husart->Init.Parity == USART_PARITY_NONE)
;;;655            {
;;;656              /* Receive data */
;;;657              *pRxData++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x00FF);
;;;658            }
;;;659            else
;;;660            {
;;;661              /* Receive data */
;;;662              *pRxData++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x007F);
;;;663            }
;;;664          }
;;;665        }
;;;666    
;;;667        husart->State = HAL_USART_STATE_READY;
;;;668    
;;;669        /* Process Unlocked */
;;;670        __HAL_UNLOCK(husart);
;;;671    
;;;672        return HAL_OK;
;;;673      }
;;;674      else
;;;675      {
;;;676        return HAL_BUSY;
;;;677      }
;;;678    }
000020  e8bd87f0          POP      {r4-r10,pc}
                  |L18.36|
000024  bf00              NOP                            ;590
000026  f894003c          LDRB     r0,[r4,#0x3c]         ;590
00002a  2801              CMP      r0,#1                 ;590
00002c  d101              BNE      |L18.50|
00002e  2002              MOVS     r0,#2                 ;590
000030  e7f6              B        |L18.32|
                  |L18.50|
000032  2001              MOVS     r0,#1                 ;590
000034  f884003c          STRB     r0,[r4,#0x3c]         ;590
000038  bf00              NOP                            ;590
00003a  2000              MOVS     r0,#0                 ;592
00003c  6420              STR      r0,[r4,#0x40]         ;592
00003e  2022              MOVS     r0,#0x22              ;593
000040  f884003d          STRB     r0,[r4,#0x3d]         ;593
000044  8627              STRH     r7,[r4,#0x30]         ;595
000046  8527              STRH     r7,[r4,#0x28]         ;596
000048  8567              STRH     r7,[r4,#0x2a]         ;597
00004a  8667              STRH     r7,[r4,#0x32]         ;598
00004c  e05d              B        |L18.266|
                  |L18.78|
00004e  8d60              LDRH     r0,[r4,#0x2a]         ;603
000050  1e40              SUBS     r0,r0,#1              ;603
000052  8560              STRH     r0,[r4,#0x2a]         ;603
000054  8e60              LDRH     r0,[r4,#0x32]         ;604
000056  1e40              SUBS     r0,r0,#1              ;604
000058  8660              STRH     r0,[r4,#0x32]         ;604
00005a  68a0              LDR      r0,[r4,#8]            ;605
00005c  f5b05f80          CMP      r0,#0x1000            ;605
000060  d12f              BNE      |L18.194|
000062  464b              MOV      r3,r9                 ;608
000064  2200              MOVS     r2,#0                 ;608
000066  2180              MOVS     r1,#0x80              ;608
000068  4620              MOV      r0,r4                 ;608
00006a  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
00006e  b108              CBZ      r0,|L18.116|
000070  2003              MOVS     r0,#3                 ;610
000072  e7d5              B        |L18.32|
                  |L18.116|
000074  46b0              MOV      r8,r6                 ;612
000076  f8b80000          LDRH     r0,[r8,#0]            ;613
00007a  f3c00008          UBFX     r0,r0,#0,#9           ;613
00007e  6821              LDR      r1,[r4,#0]            ;613
000080  6048              STR      r0,[r1,#4]            ;613
000082  6920              LDR      r0,[r4,#0x10]         ;614
000084  b908              CBNZ     r0,|L18.138|
000086  1cb6              ADDS     r6,r6,#2              ;616
000088  e000              B        |L18.140|
                  |L18.138|
00008a  1c76              ADDS     r6,r6,#1              ;620
                  |L18.140|
00008c  464b              MOV      r3,r9                 ;624
00008e  2200              MOVS     r2,#0                 ;624
000090  2120              MOVS     r1,#0x20              ;624
000092  4620              MOV      r0,r4                 ;624
000094  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
000098  b108              CBZ      r0,|L18.158|
00009a  2003              MOVS     r0,#3                 ;626
00009c  e7c0              B        |L18.32|
                  |L18.158|
00009e  46a8              MOV      r8,r5                 ;628
0000a0  6920              LDR      r0,[r4,#0x10]         ;629
0000a2  b938              CBNZ     r0,|L18.180|
0000a4  6820              LDR      r0,[r4,#0]            ;631
0000a6  6840              LDR      r0,[r0,#4]            ;631
0000a8  f3c00008          UBFX     r0,r0,#0,#9           ;631
0000ac  f8a80000          STRH     r0,[r8,#0]            ;631
0000b0  1cad              ADDS     r5,r5,#2              ;632
0000b2  e02a              B        |L18.266|
                  |L18.180|
0000b4  6820              LDR      r0,[r4,#0]            ;636
0000b6  6840              LDR      r0,[r0,#4]            ;636
0000b8  b2c0              UXTB     r0,r0                 ;636
0000ba  f8a80000          STRH     r0,[r8,#0]            ;636
0000be  1c6d              ADDS     r5,r5,#1              ;637
0000c0  e023              B        |L18.266|
                  |L18.194|
0000c2  464b              MOV      r3,r9                 ;643
0000c4  2200              MOVS     r2,#0                 ;643
0000c6  2180              MOVS     r1,#0x80              ;643
0000c8  4620              MOV      r0,r4                 ;643
0000ca  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
0000ce  b108              CBZ      r0,|L18.212|
0000d0  2003              MOVS     r0,#3                 ;645
0000d2  e7a5              B        |L18.32|
                  |L18.212|
0000d4  f8160b01          LDRB     r0,[r6],#1            ;647
0000d8  6821              LDR      r1,[r4,#0]            ;647
0000da  6048              STR      r0,[r1,#4]            ;647
0000dc  464b              MOV      r3,r9                 ;650
0000de  2200              MOVS     r2,#0                 ;650
0000e0  2120              MOVS     r1,#0x20              ;650
0000e2  4620              MOV      r0,r4                 ;650
0000e4  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
0000e8  b108              CBZ      r0,|L18.238|
0000ea  2003              MOVS     r0,#3                 ;652
0000ec  e798              B        |L18.32|
                  |L18.238|
0000ee  6920              LDR      r0,[r4,#0x10]         ;654
0000f0  b928              CBNZ     r0,|L18.254|
0000f2  6820              LDR      r0,[r4,#0]            ;657
0000f4  6840              LDR      r0,[r0,#4]            ;657
0000f6  f8050b01          STRB     r0,[r5],#1            ;657
0000fa  e006              B        |L18.266|
                  |L18.252|
0000fc  e011              B        |L18.290|
                  |L18.254|
0000fe  6820              LDR      r0,[r4,#0]            ;662
000100  6840              LDR      r0,[r0,#4]            ;662
000102  f000007f          AND      r0,r0,#0x7f           ;662
000106  f8050b01          STRB     r0,[r5],#1            ;662
                  |L18.266|
00010a  8d60              LDRH     r0,[r4,#0x2a]         ;601
00010c  2800              CMP      r0,#0                 ;601
00010e  dc9e              BGT      |L18.78|
000110  2001              MOVS     r0,#1                 ;667
000112  f884003d          STRB     r0,[r4,#0x3d]         ;667
000116  bf00              NOP                            ;670
000118  2000              MOVS     r0,#0                 ;670
00011a  f884003c          STRB     r0,[r4,#0x3c]         ;670
00011e  bf00              NOP                            ;670
000120  e77e              B        |L18.32|
                  |L18.290|
000122  2002              MOVS     r0,#2                 ;676
000124  e77c              B        |L18.32|
;;;679    
                          ENDP


                          AREA ||i.HAL_USART_TransmitReceive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_USART_TransmitReceive_DMA PROC
;;;973      */
;;;974    HAL_StatusTypeDef HAL_USART_TransmitReceive_DMA(USART_HandleTypeDef *husart, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
000000  b57f              PUSH     {r0-r6,lr}
;;;975    {
000002  b082              SUB      sp,sp,#8
000004  4604              MOV      r4,r0
000006  461d              MOV      r5,r3
;;;976      uint32_t *tmp;
;;;977      
;;;978      if(husart->State == HAL_USART_STATE_READY)
000008  f894003d          LDRB     r0,[r4,#0x3d]
00000c  2801              CMP      r0,#1
00000e  d15f              BNE      |L19.208|
;;;979      {
;;;980        if((pTxData == NULL) || (pRxData == NULL) || (Size == 0)) 
000010  9803              LDR      r0,[sp,#0xc]
000012  b110              CBZ      r0,|L19.26|
000014  9804              LDR      r0,[sp,#0x10]
000016  b100              CBZ      r0,|L19.26|
000018  b915              CBNZ     r5,|L19.32|
                  |L19.26|
;;;981        {
;;;982          return HAL_ERROR;
00001a  2001              MOVS     r0,#1
                  |L19.28|
;;;983        }
;;;984        /* Process Locked */
;;;985        __HAL_LOCK(husart);
;;;986    
;;;987        husart->pRxBuffPtr = pRxData;
;;;988        husart->RxXferSize = Size;
;;;989        husart->pTxBuffPtr = pTxData;
;;;990        husart->TxXferSize = Size;
;;;991    
;;;992        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;993        husart->State = HAL_USART_STATE_BUSY_TX_RX;
;;;994    
;;;995        /* Set the USART DMA Rx transfer complete callback */
;;;996        husart->hdmarx->XferCpltCallback = USART_DMAReceiveCplt;
;;;997    
;;;998        /* Set the USART DMA Half transfer complete callback */
;;;999        husart->hdmarx->XferHalfCpltCallback = USART_DMARxHalfCplt;
;;;1000   
;;;1001       /* Set the USART DMA Tx transfer complete callback */
;;;1002       husart->hdmatx->XferCpltCallback = USART_DMATransmitCplt;
;;;1003   
;;;1004       /* Set the USART DMA Half transfer complete callback */
;;;1005       husart->hdmatx->XferHalfCpltCallback = USART_DMATxHalfCplt;
;;;1006   
;;;1007       /* Set the USART DMA Tx transfer error callback */
;;;1008       husart->hdmatx->XferErrorCallback = USART_DMAError;
;;;1009   
;;;1010       /* Set the USART DMA Rx transfer error callback */
;;;1011       husart->hdmarx->XferErrorCallback = USART_DMAError;
;;;1012   
;;;1013       /* Enable the USART receive DMA Stream */
;;;1014       tmp = (uint32_t*)&pRxData;
;;;1015       HAL_DMA_Start_IT(husart->hdmarx, (uint32_t)&husart->Instance->DR, *(uint32_t*)tmp, Size);
;;;1016   
;;;1017       /* Enable the USART transmit DMA Stream */
;;;1018       tmp = (uint32_t*)&pTxData;
;;;1019       HAL_DMA_Start_IT(husart->hdmatx, *(uint32_t*)tmp, (uint32_t)&husart->Instance->DR, Size);
;;;1020       
;;;1021       /* Clear the TC flag in the SR register by writing 0 to it */
;;;1022       __HAL_USART_CLEAR_FLAG(husart, USART_FLAG_TC);
;;;1023       
;;;1024       /* Clear the Overrun flag: mandatory for the second transfer in circular mode */
;;;1025       __HAL_USART_CLEAR_OREFLAG(husart);
;;;1026       
;;;1027       /* Enable the DMA transfer for the receiver request by setting the DMAR bit 
;;;1028          in the USART CR3 register */
;;;1029       husart->Instance->CR3 |= USART_CR3_DMAR;
;;;1030   
;;;1031       /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;1032          in the USART CR3 register */
;;;1033       husart->Instance->CR3 |= USART_CR3_DMAT;
;;;1034   
;;;1035       /* Process Unlocked */
;;;1036       __HAL_UNLOCK(husart);
;;;1037   
;;;1038       return HAL_OK;
;;;1039     }
;;;1040     else
;;;1041     {
;;;1042       return HAL_BUSY;
;;;1043     }
;;;1044   }
00001c  b006              ADD      sp,sp,#0x18
00001e  bd70              POP      {r4-r6,pc}
                  |L19.32|
000020  bf00              NOP                            ;985
000022  f894003c          LDRB     r0,[r4,#0x3c]         ;985
000026  2801              CMP      r0,#1                 ;985
000028  d101              BNE      |L19.46|
00002a  2002              MOVS     r0,#2                 ;985
00002c  e7f6              B        |L19.28|
                  |L19.46|
00002e  2001              MOVS     r0,#1                 ;985
000030  f884003c          STRB     r0,[r4,#0x3c]         ;985
000034  bf00              NOP                            ;985
000036  9804              LDR      r0,[sp,#0x10]         ;987
000038  62e0              STR      r0,[r4,#0x2c]         ;987
00003a  8625              STRH     r5,[r4,#0x30]         ;988
00003c  9803              LDR      r0,[sp,#0xc]          ;989
00003e  6260              STR      r0,[r4,#0x24]         ;989
000040  8525              STRH     r5,[r4,#0x28]         ;990
000042  2000              MOVS     r0,#0                 ;992
000044  6420              STR      r0,[r4,#0x40]         ;992
000046  2032              MOVS     r0,#0x32              ;993
000048  f884003d          STRB     r0,[r4,#0x3d]         ;993
00004c  4821              LDR      r0,|L19.212|
00004e  6ba1              LDR      r1,[r4,#0x38]         ;996
000050  63c8              STR      r0,[r1,#0x3c]         ;996
000052  4821              LDR      r0,|L19.216|
000054  6ba1              LDR      r1,[r4,#0x38]         ;999
000056  6408              STR      r0,[r1,#0x40]         ;999
000058  4820              LDR      r0,|L19.220|
00005a  6b61              LDR      r1,[r4,#0x34]         ;1002
00005c  63c8              STR      r0,[r1,#0x3c]         ;1002
00005e  4820              LDR      r0,|L19.224|
000060  6b61              LDR      r1,[r4,#0x34]         ;1005
000062  6408              STR      r0,[r1,#0x40]         ;1005
000064  481f              LDR      r0,|L19.228|
000066  6b61              LDR      r1,[r4,#0x34]         ;1008
000068  6488              STR      r0,[r1,#0x48]         ;1008
00006a  6ba1              LDR      r1,[r4,#0x38]         ;1011
00006c  6488              STR      r0,[r1,#0x48]         ;1011
00006e  ae04              ADD      r6,sp,#0x10           ;1014
000070  6832              LDR      r2,[r6,#0]            ;1015
000072  6823              LDR      r3,[r4,#0]            ;1015
000074  1d19              ADDS     r1,r3,#4              ;1015
000076  462b              MOV      r3,r5                 ;1015
000078  6ba0              LDR      r0,[r4,#0x38]         ;1015
00007a  f7fffffe          BL       HAL_DMA_Start_IT
00007e  ae03              ADD      r6,sp,#0xc            ;1018
000080  6823              LDR      r3,[r4,#0]            ;1019
000082  1d1a              ADDS     r2,r3,#4              ;1019
000084  6831              LDR      r1,[r6,#0]            ;1019
000086  462b              MOV      r3,r5                 ;1019
000088  6b60              LDR      r0,[r4,#0x34]         ;1019
00008a  f7fffffe          BL       HAL_DMA_Start_IT
00008e  f06f0040          MVN      r0,#0x40              ;1022
000092  6821              LDR      r1,[r4,#0]            ;1022
000094  6008              STR      r0,[r1,#0]            ;1022
000096  bf00              NOP                            ;1025
000098  2000              MOVS     r0,#0                 ;1025
00009a  9001              STR      r0,[sp,#4]            ;1025
00009c  6820              LDR      r0,[r4,#0]            ;1025
00009e  6800              LDR      r0,[r0,#0]            ;1025
0000a0  9001              STR      r0,[sp,#4]            ;1025
0000a2  6820              LDR      r0,[r4,#0]            ;1025
0000a4  6840              LDR      r0,[r0,#4]            ;1025
0000a6  9001              STR      r0,[sp,#4]            ;1025
0000a8  bf00              NOP                            ;1025
0000aa  bf00              NOP                            ;1025
0000ac  6820              LDR      r0,[r4,#0]            ;1029
0000ae  6940              LDR      r0,[r0,#0x14]         ;1029
0000b0  f0400040          ORR      r0,r0,#0x40           ;1029
0000b4  6821              LDR      r1,[r4,#0]            ;1029
0000b6  6148              STR      r0,[r1,#0x14]         ;1029
0000b8  6820              LDR      r0,[r4,#0]            ;1033
0000ba  6940              LDR      r0,[r0,#0x14]         ;1033
0000bc  f0400080          ORR      r0,r0,#0x80           ;1033
0000c0  6821              LDR      r1,[r4,#0]            ;1033
0000c2  6148              STR      r0,[r1,#0x14]         ;1033
0000c4  bf00              NOP                            ;1036
0000c6  2000              MOVS     r0,#0                 ;1036
0000c8  f884003c          STRB     r0,[r4,#0x3c]         ;1036
0000cc  bf00              NOP                            ;1036
0000ce  e7a5              B        |L19.28|
                  |L19.208|
0000d0  2002              MOVS     r0,#2                 ;1042
0000d2  e7a3              B        |L19.28|
;;;1045   
                          ENDP

                  |L19.212|
                          DCD      USART_DMAReceiveCplt
                  |L19.216|
                          DCD      USART_DMARxHalfCplt
                  |L19.220|
                          DCD      USART_DMATransmitCplt
                  |L19.224|
                          DCD      USART_DMATxHalfCplt
                  |L19.228|
                          DCD      USART_DMAError

                          AREA ||i.HAL_USART_TransmitReceive_IT||, CODE, READONLY, ALIGN=1

                  HAL_USART_TransmitReceive_IT PROC
;;;787      */
;;;788    HAL_StatusTypeDef HAL_USART_TransmitReceive_IT(USART_HandleTypeDef *husart, uint8_t *pTxData, uint8_t *pRxData,  uint16_t Size)
000000  b530              PUSH     {r4,r5,lr}
;;;789    {
000002  4604              MOV      r4,r0
;;;790      if(husart->State == HAL_USART_STATE_READY)
000004  f894003d          LDRB     r0,[r4,#0x3d]
000008  2801              CMP      r0,#1
00000a  d139              BNE      |L20.128|
;;;791      {
;;;792        if((pTxData == NULL) || (pRxData == NULL) || (Size == 0)) 
00000c  b109              CBZ      r1,|L20.18|
00000e  b102              CBZ      r2,|L20.18|
000010  b90b              CBNZ     r3,|L20.22|
                  |L20.18|
;;;793        {
;;;794          return HAL_ERROR;
000012  2001              MOVS     r0,#1
                  |L20.20|
;;;795        }
;;;796        /* Process Locked */
;;;797        __HAL_LOCK(husart);
;;;798    
;;;799        husart->pRxBuffPtr = pRxData;
;;;800        husart->RxXferSize = Size;
;;;801        husart->RxXferCount = Size;
;;;802        husart->pTxBuffPtr = pTxData;
;;;803        husart->TxXferSize = Size;
;;;804        husart->TxXferCount = Size;
;;;805    
;;;806        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;807        husart->State = HAL_USART_STATE_BUSY_TX_RX;
;;;808    
;;;809        /* Process Unlocked */
;;;810        __HAL_UNLOCK(husart);
;;;811        
;;;812        /* Enable the USART Data Register not empty Interrupt */
;;;813        __HAL_USART_ENABLE_IT(husart, USART_IT_RXNE); 
;;;814    
;;;815        /* Enable the USART Parity Error Interrupt */
;;;816        __HAL_USART_ENABLE_IT(husart, USART_IT_PE);
;;;817    
;;;818        /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;819        __HAL_USART_ENABLE_IT(husart, USART_IT_ERR);
;;;820    
;;;821        /* Enable the USART Transmit Data Register Empty Interrupt */
;;;822        __HAL_USART_ENABLE_IT(husart, USART_IT_TXE);
;;;823    
;;;824        return HAL_OK;
;;;825      }
;;;826      else
;;;827      {
;;;828        return HAL_BUSY; 
;;;829      }
;;;830    }
000014  bd30              POP      {r4,r5,pc}
                  |L20.22|
000016  bf00              NOP                            ;797
000018  f894003c          LDRB     r0,[r4,#0x3c]         ;797
00001c  2801              CMP      r0,#1                 ;797
00001e  d101              BNE      |L20.36|
000020  2002              MOVS     r0,#2                 ;797
000022  e7f7              B        |L20.20|
                  |L20.36|
000024  2001              MOVS     r0,#1                 ;797
000026  f884003c          STRB     r0,[r4,#0x3c]         ;797
00002a  bf00              NOP                            ;797
00002c  62e2              STR      r2,[r4,#0x2c]         ;799
00002e  8623              STRH     r3,[r4,#0x30]         ;800
000030  8663              STRH     r3,[r4,#0x32]         ;801
000032  6261              STR      r1,[r4,#0x24]         ;802
000034  8523              STRH     r3,[r4,#0x28]         ;803
000036  8563              STRH     r3,[r4,#0x2a]         ;804
000038  2000              MOVS     r0,#0                 ;806
00003a  6420              STR      r0,[r4,#0x40]         ;806
00003c  2032              MOVS     r0,#0x32              ;807
00003e  f884003d          STRB     r0,[r4,#0x3d]         ;807
000042  bf00              NOP                            ;810
000044  2000              MOVS     r0,#0                 ;810
000046  f884003c          STRB     r0,[r4,#0x3c]         ;810
00004a  bf00              NOP                            ;810
00004c  6820              LDR      r0,[r4,#0]            ;813
00004e  68c0              LDR      r0,[r0,#0xc]          ;813
000050  f0400020          ORR      r0,r0,#0x20           ;813
000054  6825              LDR      r5,[r4,#0]            ;813
000056  60e8              STR      r0,[r5,#0xc]          ;813
000058  6820              LDR      r0,[r4,#0]            ;816
00005a  68c0              LDR      r0,[r0,#0xc]          ;816
00005c  f4407080          ORR      r0,r0,#0x100          ;816
000060  6825              LDR      r5,[r4,#0]            ;816
000062  60e8              STR      r0,[r5,#0xc]          ;816
000064  6820              LDR      r0,[r4,#0]            ;819
000066  6940              LDR      r0,[r0,#0x14]         ;819
000068  f0400001          ORR      r0,r0,#1              ;819
00006c  6825              LDR      r5,[r4,#0]            ;819
00006e  6168              STR      r0,[r5,#0x14]         ;819
000070  6820              LDR      r0,[r4,#0]            ;822
000072  68c0              LDR      r0,[r0,#0xc]          ;822
000074  f0400080          ORR      r0,r0,#0x80           ;822
000078  6825              LDR      r5,[r4,#0]            ;822
00007a  60e8              STR      r0,[r5,#0xc]          ;822
00007c  2000              MOVS     r0,#0                 ;824
00007e  e7c9              B        |L20.20|
                  |L20.128|
000080  2002              MOVS     r0,#2                 ;828
000082  e7c7              B        |L20.20|
;;;831    
                          ENDP


                          AREA ||i.HAL_USART_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_USART_Transmit_DMA PROC
;;;839      */
;;;840    HAL_StatusTypeDef HAL_USART_Transmit_DMA(USART_HandleTypeDef *husart, uint8_t *pTxData, uint16_t Size)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;841    {
000002  4604              MOV      r4,r0
000004  4615              MOV      r5,r2
;;;842      uint32_t *tmp;
;;;843      
;;;844      if(husart->State == HAL_USART_STATE_READY)
000006  f894003d          LDRB     r0,[r4,#0x3d]
00000a  2801              CMP      r0,#1
00000c  d139              BNE      |L21.130|
;;;845      {
;;;846        if((pTxData == NULL) || (Size == 0)) 
00000e  9801              LDR      r0,[sp,#4]
000010  b100              CBZ      r0,|L21.20|
000012  b90d              CBNZ     r5,|L21.24|
                  |L21.20|
;;;847        {
;;;848          return HAL_ERROR;
000014  2001              MOVS     r0,#1
                  |L21.22|
;;;849        }
;;;850        /* Process Locked */
;;;851        __HAL_LOCK(husart);  
;;;852    
;;;853        husart->pTxBuffPtr = pTxData;
;;;854        husart->TxXferSize = Size;
;;;855        husart->TxXferCount = Size;
;;;856    
;;;857        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;858        husart->State = HAL_USART_STATE_BUSY_TX;
;;;859    
;;;860        /* Set the USART DMA transfer complete callback */
;;;861        husart->hdmatx->XferCpltCallback = USART_DMATransmitCplt;
;;;862    
;;;863        /* Set the USART DMA Half transfer complete callback */
;;;864        husart->hdmatx->XferHalfCpltCallback = USART_DMATxHalfCplt;
;;;865    
;;;866        /* Set the DMA error callback */
;;;867        husart->hdmatx->XferErrorCallback = USART_DMAError;
;;;868    
;;;869        /* Enable the USART transmit DMA Stream */
;;;870        tmp = (uint32_t*)&pTxData;
;;;871        HAL_DMA_Start_IT(husart->hdmatx, *(uint32_t*)tmp, (uint32_t)&husart->Instance->DR, Size);
;;;872    
;;;873        /* Clear the TC flag in the SR register by writing 0 to it */
;;;874        __HAL_USART_CLEAR_FLAG(husart, USART_FLAG_TC);
;;;875        
;;;876        /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;877           in the USART CR3 register */
;;;878        husart->Instance->CR3 |= USART_CR3_DMAT;
;;;879    
;;;880        /* Process Unlocked */
;;;881        __HAL_UNLOCK(husart);
;;;882    
;;;883        return HAL_OK;
;;;884      }
;;;885      else
;;;886      {
;;;887        return HAL_BUSY;
;;;888      }
;;;889    }
000016  bdfe              POP      {r1-r7,pc}
                  |L21.24|
000018  bf00              NOP                            ;851
00001a  f894003c          LDRB     r0,[r4,#0x3c]         ;851
00001e  2801              CMP      r0,#1                 ;851
000020  d101              BNE      |L21.38|
000022  2002              MOVS     r0,#2                 ;851
000024  e7f7              B        |L21.22|
                  |L21.38|
000026  2001              MOVS     r0,#1                 ;851
000028  f884003c          STRB     r0,[r4,#0x3c]         ;851
00002c  bf00              NOP                            ;851
00002e  9801              LDR      r0,[sp,#4]            ;853
000030  6260              STR      r0,[r4,#0x24]         ;853
000032  8525              STRH     r5,[r4,#0x28]         ;854
000034  8565              STRH     r5,[r4,#0x2a]         ;855
000036  2000              MOVS     r0,#0                 ;857
000038  6420              STR      r0,[r4,#0x40]         ;857
00003a  2012              MOVS     r0,#0x12              ;858
00003c  f884003d          STRB     r0,[r4,#0x3d]         ;858
000040  4811              LDR      r0,|L21.136|
000042  6b61              LDR      r1,[r4,#0x34]         ;861
000044  63c8              STR      r0,[r1,#0x3c]         ;861
000046  4811              LDR      r0,|L21.140|
000048  6b61              LDR      r1,[r4,#0x34]         ;864
00004a  6408              STR      r0,[r1,#0x40]         ;864
00004c  4810              LDR      r0,|L21.144|
00004e  6b61              LDR      r1,[r4,#0x34]         ;867
000050  6488              STR      r0,[r1,#0x48]         ;867
000052  ae01              ADD      r6,sp,#4              ;870
000054  6823              LDR      r3,[r4,#0]            ;871
000056  1d1a              ADDS     r2,r3,#4              ;871
000058  6831              LDR      r1,[r6,#0]            ;871
00005a  462b              MOV      r3,r5                 ;871
00005c  6b60              LDR      r0,[r4,#0x34]         ;871
00005e  f7fffffe          BL       HAL_DMA_Start_IT
000062  f06f0040          MVN      r0,#0x40              ;874
000066  6821              LDR      r1,[r4,#0]            ;874
000068  6008              STR      r0,[r1,#0]            ;874
00006a  6820              LDR      r0,[r4,#0]            ;878
00006c  6940              LDR      r0,[r0,#0x14]         ;878
00006e  f0400080          ORR      r0,r0,#0x80           ;878
000072  6821              LDR      r1,[r4,#0]            ;878
000074  6148              STR      r0,[r1,#0x14]         ;878
000076  bf00              NOP                            ;881
000078  2000              MOVS     r0,#0                 ;881
00007a  f884003c          STRB     r0,[r4,#0x3c]         ;881
00007e  bf00              NOP                            ;881
000080  e7c9              B        |L21.22|
                  |L21.130|
000082  2002              MOVS     r0,#2                 ;887
000084  e7c7              B        |L21.22|
;;;890    
                          ENDP

000086  0000              DCW      0x0000
                  |L21.136|
                          DCD      USART_DMATransmitCplt
                  |L21.140|
                          DCD      USART_DMATxHalfCplt
                  |L21.144|
                          DCD      USART_DMAError

                          AREA ||i.HAL_USART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  HAL_USART_Transmit_IT PROC
;;;688      */
;;;689    HAL_StatusTypeDef HAL_USART_Transmit_IT(USART_HandleTypeDef *husart, uint8_t *pTxData, uint16_t Size)
000000  b510              PUSH     {r4,lr}
;;;690    {
000002  4603              MOV      r3,r0
;;;691      if(husart->State == HAL_USART_STATE_READY)
000004  f893003d          LDRB     r0,[r3,#0x3d]
000008  2801              CMP      r0,#1
00000a  d123              BNE      |L22.84|
;;;692      {
;;;693        if((pTxData == NULL) || (Size == 0)) 
00000c  b101              CBZ      r1,|L22.16|
00000e  b90a              CBNZ     r2,|L22.20|
                  |L22.16|
;;;694        {
;;;695          return HAL_ERROR;
000010  2001              MOVS     r0,#1
                  |L22.18|
;;;696        }
;;;697    
;;;698        /* Process Locked */
;;;699        __HAL_LOCK(husart);
;;;700    
;;;701        husart->pTxBuffPtr = pTxData;
;;;702        husart->TxXferSize = Size;
;;;703        husart->TxXferCount = Size;
;;;704    
;;;705        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;706        husart->State = HAL_USART_STATE_BUSY_TX;
;;;707    
;;;708        /* The USART Error Interrupts: (Frame error, Noise error, Overrun error) 
;;;709           are not managed by the USART transmit process to avoid the overrun interrupt
;;;710           when the USART mode is configured for transmit and receive "USART_MODE_TX_RX"
;;;711           to benefit for the frame error and noise interrupts the USART mode should be
;;;712           configured only for transmit "USART_MODE_TX"
;;;713           The __HAL_USART_ENABLE_IT(husart, USART_IT_ERR) can be used to enable the Frame error,
;;;714           Noise error interrupt */
;;;715    
;;;716        /* Process Unlocked */
;;;717        __HAL_UNLOCK(husart);
;;;718    
;;;719        /* Enable the USART Transmit Data Register Empty Interrupt */
;;;720        __HAL_USART_ENABLE_IT(husart, USART_IT_TXE);
;;;721    
;;;722        return HAL_OK;
;;;723      }
;;;724      else
;;;725      {
;;;726        return HAL_BUSY;
;;;727      }
;;;728    }
000012  bd10              POP      {r4,pc}
                  |L22.20|
000014  bf00              NOP                            ;699
000016  f893003c          LDRB     r0,[r3,#0x3c]         ;699
00001a  2801              CMP      r0,#1                 ;699
00001c  d101              BNE      |L22.34|
00001e  2002              MOVS     r0,#2                 ;699
000020  e7f7              B        |L22.18|
                  |L22.34|
000022  2001              MOVS     r0,#1                 ;699
000024  f883003c          STRB     r0,[r3,#0x3c]         ;699
000028  bf00              NOP                            ;699
00002a  6259              STR      r1,[r3,#0x24]         ;701
00002c  851a              STRH     r2,[r3,#0x28]         ;702
00002e  855a              STRH     r2,[r3,#0x2a]         ;703
000030  2000              MOVS     r0,#0                 ;705
000032  6418              STR      r0,[r3,#0x40]         ;705
000034  2012              MOVS     r0,#0x12              ;706
000036  f883003d          STRB     r0,[r3,#0x3d]         ;706
00003a  bf00              NOP                            ;717
00003c  2000              MOVS     r0,#0                 ;717
00003e  f883003c          STRB     r0,[r3,#0x3c]         ;717
000042  bf00              NOP                            ;717
000044  6818              LDR      r0,[r3,#0]            ;720
000046  68c0              LDR      r0,[r0,#0xc]          ;720
000048  f0400080          ORR      r0,r0,#0x80           ;720
00004c  681c              LDR      r4,[r3,#0]            ;720
00004e  60e0              STR      r0,[r4,#0xc]          ;720
000050  2000              MOVS     r0,#0                 ;722
000052  e7de              B        |L22.18|
                  |L22.84|
000054  2002              MOVS     r0,#2                 ;726
000056  e7dc              B        |L22.18|
;;;729    
                          ENDP


                          AREA ||i.HAL_USART_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_TxCpltCallback PROC
;;;1218     */
;;;1219    __weak void HAL_USART_TxCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1220   {
;;;1221     /* Prevent unused argument(s) compilation warning */
;;;1222     UNUSED(husart);
;;;1223     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1224              the HAL_USART_TxCpltCallback could be implemented in the user file
;;;1225      */
;;;1226   }
;;;1227   
                          ENDP


                          AREA ||i.HAL_USART_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_TxHalfCpltCallback PROC
;;;1233     */
;;;1234    __weak void HAL_USART_TxHalfCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1235   {
;;;1236     /* Prevent unused argument(s) compilation warning */
;;;1237     UNUSED(husart);
;;;1238     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1239              the HAL_USART_TxCpltCallback could be implemented in the user file
;;;1240      */
;;;1241   }
;;;1242   
                          ENDP


                          AREA ||i.HAL_USART_TxRxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_TxRxCpltCallback PROC
;;;1278     */
;;;1279   __weak void HAL_USART_TxRxCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1280   {
;;;1281     /* Prevent unused argument(s) compilation warning */
;;;1282     UNUSED(husart);
;;;1283     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1284              the HAL_USART_TxCpltCallback could be implemented in the user file
;;;1285      */
;;;1286   }
;;;1287   
                          ENDP


                          AREA ||i.USART_DMAError||, CODE, READONLY, ALIGN=1

                  USART_DMAError PROC
;;;1463     */
;;;1464   static void USART_DMAError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1465   {
000002  4605              MOV      r5,r0
;;;1466     USART_HandleTypeDef* husart = ( USART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;1467   
;;;1468     husart->RxXferCount = 0;
000006  2000              MOVS     r0,#0
000008  8660              STRH     r0,[r4,#0x32]
;;;1469     husart->TxXferCount = 0;
00000a  8560              STRH     r0,[r4,#0x2a]
;;;1470     husart->ErrorCode |= HAL_USART_ERROR_DMA;
00000c  6c20              LDR      r0,[r4,#0x40]
00000e  f0400010          ORR      r0,r0,#0x10
000012  6420              STR      r0,[r4,#0x40]
;;;1471     husart->State= HAL_USART_STATE_READY;
000014  2001              MOVS     r0,#1
000016  f884003d          STRB     r0,[r4,#0x3d]
;;;1472     
;;;1473     HAL_USART_ErrorCallback(husart);
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       HAL_USART_ErrorCallback
;;;1474   }
000020  bd70              POP      {r4-r6,pc}
;;;1475   
                          ENDP


                          AREA ||i.USART_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  USART_DMAReceiveCplt PROC
;;;1402     */
;;;1403   static void USART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1404   {
000002  4605              MOV      r5,r0
;;;1405     USART_HandleTypeDef* husart = ( USART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;1406     /* DMA Normal mode */
;;;1407     if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
000006  6828              LDR      r0,[r5,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  f4007080          AND      r0,r0,#0x100
00000e  bb28              CBNZ     r0,|L27.92|
;;;1408     {
;;;1409       husart->RxXferCount = 0;
000010  2000              MOVS     r0,#0
000012  8660              STRH     r0,[r4,#0x32]
;;;1410       if(husart->State == HAL_USART_STATE_BUSY_RX)
000014  f894003d          LDRB     r0,[r4,#0x3d]
000018  2822              CMP      r0,#0x22
00001a  d10c              BNE      |L27.54|
;;;1411       {
;;;1412         /* Disable the DMA transfer for the Transmit/receiver requests by setting the DMAT/DMAR bit 
;;;1413            in the USART CR3 register */
;;;1414         husart->Instance->CR3 &= ~(USART_CR3_DMAR);
00001c  6820              LDR      r0,[r4,#0]
00001e  6940              LDR      r0,[r0,#0x14]
000020  f0200040          BIC      r0,r0,#0x40
000024  6821              LDR      r1,[r4,#0]
000026  6148              STR      r0,[r1,#0x14]
;;;1415   
;;;1416         husart->State= HAL_USART_STATE_READY;
000028  2001              MOVS     r0,#1
00002a  f884003d          STRB     r0,[r4,#0x3d]
;;;1417         HAL_USART_RxCpltCallback(husart);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       HAL_USART_RxCpltCallback
000034  e01d              B        |L27.114|
                  |L27.54|
;;;1418       }
;;;1419       /* The USART state is HAL_USART_STATE_BUSY_TX_RX */
;;;1420       else
;;;1421       {
;;;1422         /* Disable the DMA transfer for the Transmit/receiver requests by setting the DMAT/DMAR bit 
;;;1423            in the USART CR3 register */
;;;1424         husart->Instance->CR3 &= ~(USART_CR3_DMAR);
000036  6820              LDR      r0,[r4,#0]
000038  6940              LDR      r0,[r0,#0x14]
00003a  f0200040          BIC      r0,r0,#0x40
00003e  6821              LDR      r1,[r4,#0]
000040  6148              STR      r0,[r1,#0x14]
;;;1425         husart->Instance->CR3 &= ~(USART_CR3_DMAT);
000042  6820              LDR      r0,[r4,#0]
000044  6940              LDR      r0,[r0,#0x14]
000046  f0200080          BIC      r0,r0,#0x80
00004a  6821              LDR      r1,[r4,#0]
00004c  6148              STR      r0,[r1,#0x14]
;;;1426    
;;;1427         husart->State= HAL_USART_STATE_READY;
00004e  2001              MOVS     r0,#1
000050  f884003d          STRB     r0,[r4,#0x3d]
;;;1428         HAL_USART_TxRxCpltCallback(husart);
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       HAL_USART_TxRxCpltCallback
00005a  e00a              B        |L27.114|
                  |L27.92|
;;;1429       }
;;;1430     }
;;;1431     /* DMA circular mode */
;;;1432     else
;;;1433     {
;;;1434       if(husart->State == HAL_USART_STATE_BUSY_RX)
00005c  f894003d          LDRB     r0,[r4,#0x3d]
000060  2822              CMP      r0,#0x22
000062  d103              BNE      |L27.108|
;;;1435       {
;;;1436         HAL_USART_RxCpltCallback(husart);
000064  4620              MOV      r0,r4
000066  f7fffffe          BL       HAL_USART_RxCpltCallback
00006a  e002              B        |L27.114|
                  |L27.108|
;;;1437       }
;;;1438       /* The USART state is HAL_USART_STATE_BUSY_TX_RX */
;;;1439       else
;;;1440       {
;;;1441         HAL_USART_TxRxCpltCallback(husart);
00006c  4620              MOV      r0,r4
00006e  f7fffffe          BL       HAL_USART_TxRxCpltCallback
                  |L27.114|
;;;1442       }
;;;1443     }
;;;1444   }
000072  bd70              POP      {r4-r6,pc}
;;;1445   
                          ENDP


                          AREA ||i.USART_DMARxHalfCplt||, CODE, READONLY, ALIGN=1

                  USART_DMARxHalfCplt PROC
;;;1451     */
;;;1452   static void USART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1453   {
000002  4604              MOV      r4,r0
;;;1454     USART_HandleTypeDef* husart = (USART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000004  6ba5              LDR      r5,[r4,#0x38]
;;;1455   
;;;1456     HAL_USART_RxHalfCpltCallback(husart); 
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_USART_RxHalfCpltCallback
;;;1457   }
00000c  bd70              POP      {r4-r6,pc}
;;;1458   
                          ENDP


                          AREA ||i.USART_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  USART_DMATransmitCplt PROC
;;;1357     */
;;;1358   static void USART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1359   {
000002  4605              MOV      r5,r0
;;;1360     USART_HandleTypeDef* husart = ( USART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;1361     /* DMA Normal mode */
;;;1362     if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
000006  6828              LDR      r0,[r5,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  f4007080          AND      r0,r0,#0x100
00000e  b990              CBNZ     r0,|L29.54|
;;;1363     {
;;;1364       husart->TxXferCount = 0;
000010  2000              MOVS     r0,#0
000012  8560              STRH     r0,[r4,#0x2a]
;;;1365       if(husart->State == HAL_USART_STATE_BUSY_TX)
000014  f894003d          LDRB     r0,[r4,#0x3d]
000018  2812              CMP      r0,#0x12
00001a  d113              BNE      |L29.68|
;;;1366       {
;;;1367         /* Disable the DMA transfer for transmit request by resetting the DMAT bit
;;;1368            in the USART CR3 register */
;;;1369         CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
00001c  6820              LDR      r0,[r4,#0]
00001e  6940              LDR      r0,[r0,#0x14]
000020  f0200080          BIC      r0,r0,#0x80
000024  6821              LDR      r1,[r4,#0]
000026  6148              STR      r0,[r1,#0x14]
;;;1370         
;;;1371         /* Enable the USART Transmit Complete Interrupt */    
;;;1372         __HAL_USART_ENABLE_IT(husart, USART_IT_TC);
000028  6820              LDR      r0,[r4,#0]
00002a  68c0              LDR      r0,[r0,#0xc]
00002c  f0400040          ORR      r0,r0,#0x40
000030  6821              LDR      r1,[r4,#0]
000032  60c8              STR      r0,[r1,#0xc]
000034  e006              B        |L29.68|
                  |L29.54|
;;;1373       }
;;;1374     }
;;;1375     /* DMA Circular mode */
;;;1376     else
;;;1377     {
;;;1378       if(husart->State == HAL_USART_STATE_BUSY_TX)
000036  f894003d          LDRB     r0,[r4,#0x3d]
00003a  2812              CMP      r0,#0x12
00003c  d102              BNE      |L29.68|
;;;1379       {
;;;1380         HAL_USART_TxCpltCallback(husart);
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       HAL_USART_TxCpltCallback
                  |L29.68|
;;;1381       }
;;;1382     }
;;;1383   }
000044  bd70              POP      {r4-r6,pc}
;;;1384   
                          ENDP


                          AREA ||i.USART_DMATxHalfCplt||, CODE, READONLY, ALIGN=1

                  USART_DMATxHalfCplt PROC
;;;1390     */
;;;1391   static void USART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1392   {
000002  4604              MOV      r4,r0
;;;1393     USART_HandleTypeDef* husart = (USART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000004  6ba5              LDR      r5,[r4,#0x38]
;;;1394   
;;;1395     HAL_USART_TxHalfCpltCallback(husart);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_USART_TxHalfCpltCallback
;;;1396   }
00000c  bd70              POP      {r4-r6,pc}
;;;1397   
                          ENDP


                          AREA ||i.USART_EndTransmit_IT||, CODE, READONLY, ALIGN=1

                  USART_EndTransmit_IT PROC
;;;1599     */
;;;1600   static HAL_StatusTypeDef USART_EndTransmit_IT(USART_HandleTypeDef *husart)
000000  b510              PUSH     {r4,lr}
;;;1601   {
000002  4604              MOV      r4,r0
;;;1602     /* Disable the USART Transmit Complete Interrupt */    
;;;1603     __HAL_USART_DISABLE_IT(husart, USART_IT_TC);
000004  6820              LDR      r0,[r4,#0]
000006  68c0              LDR      r0,[r0,#0xc]
000008  f0200040          BIC      r0,r0,#0x40
00000c  6821              LDR      r1,[r4,#0]
00000e  60c8              STR      r0,[r1,#0xc]
;;;1604     
;;;1605     /* Disable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1606     __HAL_USART_DISABLE_IT(husart, USART_IT_ERR);
000010  6820              LDR      r0,[r4,#0]
000012  6940              LDR      r0,[r0,#0x14]
000014  f0200001          BIC      r0,r0,#1
000018  6821              LDR      r1,[r4,#0]
00001a  6148              STR      r0,[r1,#0x14]
;;;1607       
;;;1608     husart->State = HAL_USART_STATE_READY;
00001c  2001              MOVS     r0,#1
00001e  f884003d          STRB     r0,[r4,#0x3d]
;;;1609      
;;;1610     HAL_USART_TxCpltCallback(husart);
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       HAL_USART_TxCpltCallback
;;;1611     
;;;1612     return HAL_OK;
000028  2000              MOVS     r0,#0
;;;1613   }
00002a  bd10              POP      {r4,pc}
;;;1614   
                          ENDP


                          AREA ||i.USART_Receive_IT||, CODE, READONLY, ALIGN=1

                  USART_Receive_IT PROC
;;;1620     */
;;;1621   static HAL_StatusTypeDef USART_Receive_IT(USART_HandleTypeDef *husart)
000000  b570              PUSH     {r4-r6,lr}
;;;1622   {
000002  4604              MOV      r4,r0
;;;1623     uint16_t* tmp;
;;;1624     if(husart->State == HAL_USART_STATE_BUSY_RX)
000004  f894003d          LDRB     r0,[r4,#0x3d]
000008  2822              CMP      r0,#0x22
00000a  d158              BNE      |L32.190|
;;;1625     {
;;;1626       if(husart->Init.WordLength == USART_WORDLENGTH_9B)
00000c  68a0              LDR      r0,[r4,#8]
00000e  f5b05f80          CMP      r0,#0x1000
000012  d11c              BNE      |L32.78|
;;;1627       {
;;;1628         tmp = (uint16_t*) husart->pRxBuffPtr;
000014  6ae5              LDR      r5,[r4,#0x2c]
;;;1629         if(husart->Init.Parity == USART_PARITY_NONE)
000016  6920              LDR      r0,[r4,#0x10]
000018  b940              CBNZ     r0,|L32.44|
;;;1630         {
;;;1631           *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x01FF);
00001a  6820              LDR      r0,[r4,#0]
00001c  6840              LDR      r0,[r0,#4]
00001e  f3c00008          UBFX     r0,r0,#0,#9
000022  8028              STRH     r0,[r5,#0]
;;;1632           husart->pRxBuffPtr += 2;
000024  6ae0              LDR      r0,[r4,#0x2c]
000026  1c80              ADDS     r0,r0,#2
000028  62e0              STR      r0,[r4,#0x2c]
00002a  e006              B        |L32.58|
                  |L32.44|
;;;1633         }
;;;1634         else
;;;1635         {
;;;1636           *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x00FF);
00002c  6820              LDR      r0,[r4,#0]
00002e  6840              LDR      r0,[r0,#4]
000030  b2c0              UXTB     r0,r0
000032  8028              STRH     r0,[r5,#0]
;;;1637           husart->pRxBuffPtr += 1;
000034  6ae0              LDR      r0,[r4,#0x2c]
000036  1c40              ADDS     r0,r0,#1
000038  62e0              STR      r0,[r4,#0x2c]
                  |L32.58|
;;;1638         }
;;;1639         if(--husart->RxXferCount != 0x00) 
00003a  8e60              LDRH     r0,[r4,#0x32]
00003c  1e40              SUBS     r0,r0,#1
00003e  b280              UXTH     r0,r0
000040  8660              STRH     r0,[r4,#0x32]
000042  b1f0              CBZ      r0,|L32.130|
;;;1640         {
;;;1641           /* Send dummy byte in order to generate the clock for the slave to send the next data */
;;;1642           husart->Instance->DR = (DUMMY_DATA & (uint16_t)0x01FF); 
000044  f24010ff          MOV      r0,#0x1ff
000048  6821              LDR      r1,[r4,#0]
00004a  6048              STR      r0,[r1,#4]
00004c  e019              B        |L32.130|
                  |L32.78|
;;;1643         }
;;;1644       } 
;;;1645       else
;;;1646       {
;;;1647         if(husart->Init.Parity == USART_PARITY_NONE)
00004e  6920              LDR      r0,[r4,#0x10]
000050  b938              CBNZ     r0,|L32.98|
;;;1648         {
;;;1649           *husart->pRxBuffPtr++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x00FF);
000052  6820              LDR      r0,[r4,#0]
000054  6840              LDR      r0,[r0,#4]
000056  b2c1              UXTB     r1,r0
000058  6ae2              LDR      r2,[r4,#0x2c]
00005a  1c50              ADDS     r0,r2,#1
00005c  62e0              STR      r0,[r4,#0x2c]
00005e  7011              STRB     r1,[r2,#0]
000060  e007              B        |L32.114|
                  |L32.98|
;;;1650         }
;;;1651         else
;;;1652         {
;;;1653           *husart->pRxBuffPtr++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x007F);
000062  6820              LDR      r0,[r4,#0]
000064  6840              LDR      r0,[r0,#4]
000066  f000017f          AND      r1,r0,#0x7f
00006a  6ae2              LDR      r2,[r4,#0x2c]
00006c  1c50              ADDS     r0,r2,#1
00006e  62e0              STR      r0,[r4,#0x2c]
000070  7011              STRB     r1,[r2,#0]
                  |L32.114|
;;;1654         }
;;;1655   
;;;1656         if(--husart->RxXferCount != 0x00) 
000072  8e60              LDRH     r0,[r4,#0x32]
000074  1e40              SUBS     r0,r0,#1
000076  b280              UXTH     r0,r0
000078  8660              STRH     r0,[r4,#0x32]
00007a  b110              CBZ      r0,|L32.130|
;;;1657         {
;;;1658           /* Send dummy byte in order to generate the clock for the slave to send the next data */
;;;1659           husart->Instance->DR = (DUMMY_DATA & (uint16_t)0x00FF);  
00007c  20ff              MOVS     r0,#0xff
00007e  6821              LDR      r1,[r4,#0]
000080  6048              STR      r0,[r1,#4]
                  |L32.130|
;;;1660         }
;;;1661       }
;;;1662   
;;;1663       if(husart->RxXferCount == 0)
000082  8e60              LDRH     r0,[r4,#0x32]
000084  b9c8              CBNZ     r0,|L32.186|
;;;1664       {
;;;1665         /* Disable the USART RXNE Interrupt */
;;;1666         __HAL_USART_DISABLE_IT(husart, USART_IT_RXNE);
000086  6820              LDR      r0,[r4,#0]
000088  68c0              LDR      r0,[r0,#0xc]
00008a  f0200020          BIC      r0,r0,#0x20
00008e  6821              LDR      r1,[r4,#0]
000090  60c8              STR      r0,[r1,#0xc]
;;;1667   
;;;1668         /* Disable the USART Parity Error Interrupt */
;;;1669         __HAL_USART_DISABLE_IT(husart, USART_IT_PE);
000092  6820              LDR      r0,[r4,#0]
000094  68c0              LDR      r0,[r0,#0xc]
000096  f4207080          BIC      r0,r0,#0x100
00009a  6821              LDR      r1,[r4,#0]
00009c  60c8              STR      r0,[r1,#0xc]
;;;1670   
;;;1671         /* Disable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1672         __HAL_USART_DISABLE_IT(husart, USART_IT_ERR);
00009e  6820              LDR      r0,[r4,#0]
0000a0  6940              LDR      r0,[r0,#0x14]
0000a2  f0200001          BIC      r0,r0,#1
0000a6  6821              LDR      r1,[r4,#0]
0000a8  6148              STR      r0,[r1,#0x14]
;;;1673   
;;;1674         husart->State = HAL_USART_STATE_READY;
0000aa  2001              MOVS     r0,#1
0000ac  f884003d          STRB     r0,[r4,#0x3d]
;;;1675         HAL_USART_RxCpltCallback(husart);
0000b0  4620              MOV      r0,r4
0000b2  f7fffffe          BL       HAL_USART_RxCpltCallback
;;;1676         
;;;1677         return HAL_OK;
0000b6  2000              MOVS     r0,#0
                  |L32.184|
;;;1678       }
;;;1679       return HAL_OK;
;;;1680     }
;;;1681     else
;;;1682     {
;;;1683       return HAL_BUSY; 
;;;1684     }
;;;1685   }
0000b8  bd70              POP      {r4-r6,pc}
                  |L32.186|
0000ba  2000              MOVS     r0,#0                 ;1679
0000bc  e7fc              B        |L32.184|
                  |L32.190|
0000be  2002              MOVS     r0,#2                 ;1683
0000c0  e7fa              B        |L32.184|
;;;1686   
                          ENDP


                          AREA ||i.USART_SetConfig||, CODE, READONLY, ALIGN=2

                  USART_SetConfig PROC
;;;1794     */
;;;1795   static void USART_SetConfig(USART_HandleTypeDef *husart)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1796   {
000004  4604              MOV      r4,r0
;;;1797     uint32_t tmpreg = 0x00;
000006  2500              MOVS     r5,#0
;;;1798   
;;;1799     /* Check the parameters */
;;;1800     assert_param(IS_USART_INSTANCE(husart->Instance));
;;;1801     assert_param(IS_USART_POLARITY(husart->Init.CLKPolarity));
;;;1802     assert_param(IS_USART_PHASE(husart->Init.CLKPhase));
;;;1803     assert_param(IS_USART_LASTBIT(husart->Init.CLKLastBit));
;;;1804     assert_param(IS_USART_BAUDRATE(husart->Init.BaudRate));  
;;;1805     assert_param(IS_USART_WORD_LENGTH(husart->Init.WordLength));
;;;1806     assert_param(IS_USART_STOPBITS(husart->Init.StopBits));
;;;1807     assert_param(IS_USART_PARITY(husart->Init.Parity));
;;;1808     assert_param(IS_USART_MODE(husart->Init.Mode));
;;;1809   
;;;1810     /* The LBCL, CPOL and CPHA bits have to be selected when both the transmitter and the
;;;1811        receiver are disabled (TE=RE=0) to ensure that the clock pulses function correctly. */
;;;1812     husart->Instance->CR1 &= (uint32_t)~((uint32_t)(USART_CR1_TE | USART_CR1_RE));
000008  6820              LDR      r0,[r4,#0]
00000a  68c0              LDR      r0,[r0,#0xc]
00000c  f020000c          BIC      r0,r0,#0xc
000010  6821              LDR      r1,[r4,#0]
000012  60c8              STR      r0,[r1,#0xc]
;;;1813   
;;;1814     /*---------------------------- USART CR2 Configuration ---------------------*/
;;;1815     tmpreg = husart->Instance->CR2;
000014  6820              LDR      r0,[r4,#0]
000016  6905              LDR      r5,[r0,#0x10]
;;;1816     /* Clear CLKEN, CPOL, CPHA and LBCL bits */
;;;1817     tmpreg &= (uint32_t)~((uint32_t)(USART_CR2_CPHA | USART_CR2_CPOL | USART_CR2_CLKEN | USART_CR2_LBCL | USART_CR2_STOP));
000018  f425557c          BIC      r5,r5,#0x3f00
;;;1818     /* Configure the USART Clock, CPOL, CPHA and LastBit -----------------------*/
;;;1819     /* Set CPOL bit according to husart->Init.CLKPolarity value */
;;;1820     /* Set CPHA bit according to husart->Init.CLKPhase value */
;;;1821     /* Set LBCL bit according to husart->Init.CLKLastBit value */
;;;1822     /* Set Stop Bits: Set STOP[13:12] bits according to husart->Init.StopBits value */
;;;1823     tmpreg |= (uint32_t)(USART_CLOCK_ENABLE| husart->Init.CLKPolarity | 
00001c  69a0              LDR      r0,[r4,#0x18]
00001e  f4406000          ORR      r0,r0,#0x800
000022  69e1              LDR      r1,[r4,#0x1c]
000024  4308              ORRS     r0,r0,r1
000026  6a21              LDR      r1,[r4,#0x20]
000028  4308              ORRS     r0,r0,r1
00002a  68e1              LDR      r1,[r4,#0xc]
00002c  4308              ORRS     r0,r0,r1
00002e  4305              ORRS     r5,r5,r0
;;;1824                         husart->Init.CLKPhase| husart->Init.CLKLastBit | husart->Init.StopBits);
;;;1825     /* Write to USART CR2 */
;;;1826     husart->Instance->CR2 = (uint32_t)tmpreg;
000030  6820              LDR      r0,[r4,#0]
000032  6105              STR      r5,[r0,#0x10]
;;;1827   
;;;1828     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;1829     tmpreg = husart->Instance->CR1;
000034  6820              LDR      r0,[r4,#0]
000036  68c5              LDR      r5,[r0,#0xc]
;;;1830   
;;;1831     /* Clear M, PCE, PS, TE, RE and OVER8 bits */
;;;1832     tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | \
000038  f249600c          MOV      r0,#0x960c
00003c  4385              BICS     r5,r5,r0
;;;1833                                      USART_CR1_RE | USART_CR1_OVER8));
;;;1834   
;;;1835     /* Configure the USART Word Length, Parity and mode: 
;;;1836        Set the M bits according to husart->Init.WordLength value 
;;;1837        Set PCE and PS bits according to husart->Init.Parity value
;;;1838        Set TE and RE bits according to husart->Init.Mode value 
;;;1839        Force OVER8 bit to 1 in order to reach the max USART frequencies */
;;;1840     tmpreg |= (uint32_t)husart->Init.WordLength | husart->Init.Parity | husart->Init.Mode | USART_CR1_OVER8;
00003e  6921              LDR      r1,[r4,#0x10]
000040  68a0              LDR      r0,[r4,#8]
000042  4308              ORRS     r0,r0,r1
000044  6961              LDR      r1,[r4,#0x14]
000046  4308              ORRS     r0,r0,r1
000048  f4404000          ORR      r0,r0,#0x8000
00004c  4305              ORRS     r5,r5,r0
;;;1841   
;;;1842     /* Write to USART CR1 */
;;;1843     husart->Instance->CR1 = (uint32_t)tmpreg;
00004e  6820              LDR      r0,[r4,#0]
000050  60c5              STR      r5,[r0,#0xc]
;;;1844   
;;;1845     /*-------------------------- USART CR3 Configuration -----------------------*/  
;;;1846     /* Clear CTSE and RTSE bits */
;;;1847     husart->Instance->CR3 &= (uint32_t)~((uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE));
000052  6820              LDR      r0,[r4,#0]
000054  6940              LDR      r0,[r0,#0x14]
000056  f4207040          BIC      r0,r0,#0x300
00005a  6821              LDR      r1,[r4,#0]
00005c  6148              STR      r0,[r1,#0x14]
;;;1848   
;;;1849     /*-------------------------- USART BRR Configuration -----------------------*/
;;;1850     if((husart->Instance == USART1) || (husart->Instance == USART6))
00005e  4939              LDR      r1,|L33.324|
000060  6820              LDR      r0,[r4,#0]
000062  4288              CMP      r0,r1
000064  d003              BEQ      |L33.110|
000066  4938              LDR      r1,|L33.328|
000068  6820              LDR      r0,[r4,#0]
00006a  4288              CMP      r0,r1
00006c  d134              BNE      |L33.216|
                  |L33.110|
;;;1851     {
;;;1852       husart->Instance->BRR = USART_BRR(HAL_RCC_GetPCLK2Freq(), husart->Init.BaudRate);
00006e  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
000072  eb0001c0          ADD      r1,r0,r0,LSL #3
000076  eb011000          ADD      r0,r1,r0,LSL #4
00007a  6861              LDR      r1,[r4,#4]
00007c  0049              LSLS     r1,r1,#1
00007e  fbb0f0f1          UDIV     r0,r0,r1
000082  2164              MOVS     r1,#0x64
000084  fbb0f6f1          UDIV     r6,r0,r1
000088  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
00008c  eb0001c0          ADD      r1,r0,r0,LSL #3
000090  eb011000          ADD      r0,r1,r0,LSL #4
000094  6861              LDR      r1,[r4,#4]
000096  0049              LSLS     r1,r1,#1
000098  fbb0f7f1          UDIV     r7,r0,r1
00009c  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
0000a0  eb0001c0          ADD      r1,r0,r0,LSL #3
0000a4  eb011000          ADD      r0,r1,r0,LSL #4
0000a8  6861              LDR      r1,[r4,#4]
0000aa  0049              LSLS     r1,r1,#1
0000ac  fbb0f0f1          UDIV     r0,r0,r1
0000b0  2164              MOVS     r1,#0x64
0000b2  fbb0f0f1          UDIV     r0,r0,r1
0000b6  eb0001c0          ADD      r1,r0,r0,LSL #3
0000ba  eb011000          ADD      r0,r1,r0,LSL #4
0000be  eba70080          SUB      r0,r7,r0,LSL #2
0000c2  2132              MOVS     r1,#0x32
0000c4  eb011000          ADD      r0,r1,r0,LSL #4
0000c8  2164              MOVS     r1,#0x64
0000ca  fbb0f0f1          UDIV     r0,r0,r1
0000ce  f366101f          BFI      r0,r6,#4,#28
0000d2  6821              LDR      r1,[r4,#0]
0000d4  6088              STR      r0,[r1,#8]
0000d6  e033              B        |L33.320|
                  |L33.216|
;;;1853     }
;;;1854     else
;;;1855     {
;;;1856       husart->Instance->BRR = USART_BRR(HAL_RCC_GetPCLK1Freq(), husart->Init.BaudRate);
0000d8  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0000dc  eb0001c0          ADD      r1,r0,r0,LSL #3
0000e0  eb011000          ADD      r0,r1,r0,LSL #4
0000e4  6861              LDR      r1,[r4,#4]
0000e6  0049              LSLS     r1,r1,#1
0000e8  fbb0f0f1          UDIV     r0,r0,r1
0000ec  2164              MOVS     r1,#0x64
0000ee  fbb0f6f1          UDIV     r6,r0,r1
0000f2  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0000f6  eb0001c0          ADD      r1,r0,r0,LSL #3
0000fa  eb011000          ADD      r0,r1,r0,LSL #4
0000fe  6861              LDR      r1,[r4,#4]
000100  0049              LSLS     r1,r1,#1
000102  fbb0f7f1          UDIV     r7,r0,r1
000106  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
00010a  eb0001c0          ADD      r1,r0,r0,LSL #3
00010e  eb011000          ADD      r0,r1,r0,LSL #4
000112  6861              LDR      r1,[r4,#4]
000114  0049              LSLS     r1,r1,#1
000116  fbb0f0f1          UDIV     r0,r0,r1
00011a  2164              MOVS     r1,#0x64
00011c  fbb0f0f1          UDIV     r0,r0,r1
000120  eb0001c0          ADD      r1,r0,r0,LSL #3
000124  eb011000          ADD      r0,r1,r0,LSL #4
000128  eba70080          SUB      r0,r7,r0,LSL #2
00012c  2132              MOVS     r1,#0x32
00012e  eb011000          ADD      r0,r1,r0,LSL #4
000132  2164              MOVS     r1,#0x64
000134  fbb0f0f1          UDIV     r0,r0,r1
000138  f366101f          BFI      r0,r6,#4,#28
00013c  6821              LDR      r1,[r4,#0]
00013e  6088              STR      r0,[r1,#8]
                  |L33.320|
;;;1857     }
;;;1858   }
000140  e8bd81f0          POP      {r4-r8,pc}
;;;1859   
                          ENDP

                  |L33.324|
                          DCD      0x40011000
                  |L33.328|
                          DCD      0x40011400

                          AREA ||i.USART_TransmitReceive_IT||, CODE, READONLY, ALIGN=1

                  USART_TransmitReceive_IT PROC
;;;1692     */
;;;1693   static HAL_StatusTypeDef USART_TransmitReceive_IT(USART_HandleTypeDef *husart)
000000  b570              PUSH     {r4-r6,lr}
;;;1694   {
000002  4604              MOV      r4,r0
;;;1695     uint16_t* tmp;
;;;1696   
;;;1697     if(husart->State == HAL_USART_STATE_BUSY_TX_RX)
000004  f894003d          LDRB     r0,[r4,#0x3d]
000008  2832              CMP      r0,#0x32
00000a  d17e              BNE      |L34.266|
;;;1698     {
;;;1699       if(husart->TxXferCount != 0x00)
00000c  8d60              LDRH     r0,[r4,#0x2a]
00000e  b348              CBZ      r0,|L34.100|
;;;1700       {
;;;1701         if(__HAL_USART_GET_FLAG(husart, USART_FLAG_TXE) != RESET)
000010  6820              LDR      r0,[r4,#0]
000012  6800              LDR      r0,[r0,#0]
000014  f3c010c0          UBFX     r0,r0,#7,#1
000018  b320              CBZ      r0,|L34.100|
;;;1702         {
;;;1703           if(husart->Init.WordLength == USART_WORDLENGTH_9B)
00001a  68a0              LDR      r0,[r4,#8]
00001c  f5b05f80          CMP      r0,#0x1000
000020  d10f              BNE      |L34.66|
;;;1704           {
;;;1705             tmp = (uint16_t*) husart->pTxBuffPtr;
000022  6a65              LDR      r5,[r4,#0x24]
;;;1706             husart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
000024  8828              LDRH     r0,[r5,#0]
000026  f3c00008          UBFX     r0,r0,#0,#9
00002a  6821              LDR      r1,[r4,#0]
00002c  6048              STR      r0,[r1,#4]
;;;1707             if(husart->Init.Parity == USART_PARITY_NONE)
00002e  6920              LDR      r0,[r4,#0x10]
000030  b918              CBNZ     r0,|L34.58|
;;;1708             {
;;;1709               husart->pTxBuffPtr += 2;
000032  6a60              LDR      r0,[r4,#0x24]
000034  1c80              ADDS     r0,r0,#2
000036  6260              STR      r0,[r4,#0x24]
000038  e009              B        |L34.78|
                  |L34.58|
;;;1710             }
;;;1711             else
;;;1712             {
;;;1713               husart->pTxBuffPtr += 1;
00003a  6a60              LDR      r0,[r4,#0x24]
00003c  1c40              ADDS     r0,r0,#1
00003e  6260              STR      r0,[r4,#0x24]
000040  e005              B        |L34.78|
                  |L34.66|
;;;1714             }
;;;1715           } 
;;;1716           else
;;;1717           {
;;;1718             husart->Instance->DR = (uint8_t)(*husart->pTxBuffPtr++ & (uint8_t)0x00FF);
000042  6a61              LDR      r1,[r4,#0x24]
000044  1c48              ADDS     r0,r1,#1
000046  6260              STR      r0,[r4,#0x24]
000048  7808              LDRB     r0,[r1,#0]
00004a  6821              LDR      r1,[r4,#0]
00004c  6048              STR      r0,[r1,#4]
                  |L34.78|
;;;1719           }
;;;1720           husart->TxXferCount--;
00004e  8d60              LDRH     r0,[r4,#0x2a]
000050  1e40              SUBS     r0,r0,#1
000052  8560              STRH     r0,[r4,#0x2a]
;;;1721   
;;;1722           /* Check the latest data transmitted */
;;;1723           if(husart->TxXferCount == 0)
000054  8d60              LDRH     r0,[r4,#0x2a]
000056  b928              CBNZ     r0,|L34.100|
;;;1724           {
;;;1725              __HAL_USART_DISABLE_IT(husart, USART_IT_TXE);
000058  6820              LDR      r0,[r4,#0]
00005a  68c0              LDR      r0,[r0,#0xc]
00005c  f0200080          BIC      r0,r0,#0x80
000060  6821              LDR      r1,[r4,#0]
000062  60c8              STR      r0,[r1,#0xc]
                  |L34.100|
;;;1726           }
;;;1727         }
;;;1728       }
;;;1729   
;;;1730       if(husart->RxXferCount != 0x00)
000064  8e60              LDRH     r0,[r4,#0x32]
000066  b388              CBZ      r0,|L34.204|
;;;1731       {
;;;1732         if(__HAL_USART_GET_FLAG(husart, USART_FLAG_RXNE) != RESET)
000068  6820              LDR      r0,[r4,#0]
00006a  6800              LDR      r0,[r0,#0]
00006c  f3c01040          UBFX     r0,r0,#5,#1
000070  b360              CBZ      r0,|L34.204|
;;;1733         {
;;;1734           if(husart->Init.WordLength == USART_WORDLENGTH_9B)
000072  68a0              LDR      r0,[r4,#8]
000074  f5b05f80          CMP      r0,#0x1000
000078  d113              BNE      |L34.162|
;;;1735           {
;;;1736             tmp = (uint16_t*) husart->pRxBuffPtr;
00007a  6ae5              LDR      r5,[r4,#0x2c]
;;;1737             if(husart->Init.Parity == USART_PARITY_NONE)
00007c  6920              LDR      r0,[r4,#0x10]
00007e  b940              CBNZ     r0,|L34.146|
;;;1738             {
;;;1739               *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x01FF);
000080  6820              LDR      r0,[r4,#0]
000082  6840              LDR      r0,[r0,#4]
000084  f3c00008          UBFX     r0,r0,#0,#9
000088  8028              STRH     r0,[r5,#0]
;;;1740               husart->pRxBuffPtr += 2;
00008a  6ae0              LDR      r0,[r4,#0x2c]
00008c  1c80              ADDS     r0,r0,#2
00008e  62e0              STR      r0,[r4,#0x2c]
000090  e019              B        |L34.198|
                  |L34.146|
;;;1741             }
;;;1742             else
;;;1743             {
;;;1744               *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x00FF);
000092  6820              LDR      r0,[r4,#0]
000094  6840              LDR      r0,[r0,#4]
000096  b2c0              UXTB     r0,r0
000098  8028              STRH     r0,[r5,#0]
;;;1745               husart->pRxBuffPtr += 1;
00009a  6ae0              LDR      r0,[r4,#0x2c]
00009c  1c40              ADDS     r0,r0,#1
00009e  62e0              STR      r0,[r4,#0x2c]
0000a0  e011              B        |L34.198|
                  |L34.162|
;;;1746             }
;;;1747           } 
;;;1748           else
;;;1749           {
;;;1750             if(husart->Init.Parity == USART_PARITY_NONE)
0000a2  6920              LDR      r0,[r4,#0x10]
0000a4  b938              CBNZ     r0,|L34.182|
;;;1751             {
;;;1752               *husart->pRxBuffPtr++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x00FF);
0000a6  6820              LDR      r0,[r4,#0]
0000a8  6840              LDR      r0,[r0,#4]
0000aa  b2c1              UXTB     r1,r0
0000ac  6ae2              LDR      r2,[r4,#0x2c]
0000ae  1c50              ADDS     r0,r2,#1
0000b0  62e0              STR      r0,[r4,#0x2c]
0000b2  7011              STRB     r1,[r2,#0]
0000b4  e007              B        |L34.198|
                  |L34.182|
;;;1753             }
;;;1754             else
;;;1755             {
;;;1756               *husart->pRxBuffPtr++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x007F);
0000b6  6820              LDR      r0,[r4,#0]
0000b8  6840              LDR      r0,[r0,#4]
0000ba  f000017f          AND      r1,r0,#0x7f
0000be  6ae2              LDR      r2,[r4,#0x2c]
0000c0  1c50              ADDS     r0,r2,#1
0000c2  62e0              STR      r0,[r4,#0x2c]
0000c4  7011              STRB     r1,[r2,#0]
                  |L34.198|
;;;1757             }
;;;1758           }
;;;1759           husart->RxXferCount--;
0000c6  8e60              LDRH     r0,[r4,#0x32]
0000c8  1e40              SUBS     r0,r0,#1
0000ca  8660              STRH     r0,[r4,#0x32]
                  |L34.204|
;;;1760         }
;;;1761       }
;;;1762   
;;;1763       /* Check the latest data received */
;;;1764       if(husart->RxXferCount == 0)
0000cc  8e60              LDRH     r0,[r4,#0x32]
0000ce  b9d0              CBNZ     r0,|L34.262|
;;;1765       {
;;;1766         __HAL_USART_DISABLE_IT(husart, USART_IT_RXNE);
0000d0  6820              LDR      r0,[r4,#0]
0000d2  68c0              LDR      r0,[r0,#0xc]
0000d4  f0200020          BIC      r0,r0,#0x20
0000d8  6821              LDR      r1,[r4,#0]
0000da  60c8              STR      r0,[r1,#0xc]
;;;1767   
;;;1768         /* Disable the USART Parity Error Interrupt */
;;;1769         __HAL_USART_DISABLE_IT(husart, USART_IT_PE);
0000dc  6820              LDR      r0,[r4,#0]
0000de  68c0              LDR      r0,[r0,#0xc]
0000e0  f4207080          BIC      r0,r0,#0x100
0000e4  6821              LDR      r1,[r4,#0]
0000e6  60c8              STR      r0,[r1,#0xc]
;;;1770   
;;;1771         /* Disable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1772         __HAL_USART_DISABLE_IT(husart, USART_IT_ERR);
0000e8  6820              LDR      r0,[r4,#0]
0000ea  6940              LDR      r0,[r0,#0x14]
0000ec  f0200001          BIC      r0,r0,#1
0000f0  6821              LDR      r1,[r4,#0]
0000f2  6148              STR      r0,[r1,#0x14]
;;;1773         
;;;1774         husart->State = HAL_USART_STATE_READY;
0000f4  2001              MOVS     r0,#1
0000f6  f884003d          STRB     r0,[r4,#0x3d]
;;;1775   
;;;1776         HAL_USART_TxRxCpltCallback(husart);
0000fa  4620              MOV      r0,r4
0000fc  f7fffffe          BL       HAL_USART_TxRxCpltCallback
;;;1777   
;;;1778         return HAL_OK;
000100  2000              MOVS     r0,#0
                  |L34.258|
;;;1779       }
;;;1780   
;;;1781       return HAL_OK;
;;;1782     }
;;;1783     else
;;;1784     {
;;;1785       return HAL_BUSY; 
;;;1786     }
;;;1787   }
000102  bd70              POP      {r4-r6,pc}
000104  e001              B        |L34.266|
                  |L34.262|
000106  2000              MOVS     r0,#0                 ;1781
000108  e7fb              B        |L34.258|
                  |L34.266|
00010a  2002              MOVS     r0,#2                 ;1785
00010c  e7f9              B        |L34.258|
;;;1788   
                          ENDP


                          AREA ||i.USART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  USART_Transmit_IT PROC
;;;1553     */
;;;1554   static HAL_StatusTypeDef USART_Transmit_IT(USART_HandleTypeDef *husart)
000000  4601              MOV      r1,r0
;;;1555   {
;;;1556     uint16_t* tmp;
;;;1557    
;;;1558     if(husart->State == HAL_USART_STATE_BUSY_TX)
000002  f891003d          LDRB     r0,[r1,#0x3d]
000006  2812              CMP      r0,#0x12
000008  d12c              BNE      |L35.100|
;;;1559     {
;;;1560       if(husart->Init.WordLength == USART_WORDLENGTH_9B)
00000a  6888              LDR      r0,[r1,#8]
00000c  f5b05f80          CMP      r0,#0x1000
000010  d10f              BNE      |L35.50|
;;;1561       {
;;;1562         tmp = (uint16_t*) husart->pTxBuffPtr;
000012  6a4a              LDR      r2,[r1,#0x24]
;;;1563         husart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
000014  8810              LDRH     r0,[r2,#0]
000016  f3c00008          UBFX     r0,r0,#0,#9
00001a  680b              LDR      r3,[r1,#0]
00001c  6058              STR      r0,[r3,#4]
;;;1564         if(husart->Init.Parity == USART_PARITY_NONE)
00001e  6908              LDR      r0,[r1,#0x10]
000020  b918              CBNZ     r0,|L35.42|
;;;1565         {
;;;1566           husart->pTxBuffPtr += 2;
000022  6a48              LDR      r0,[r1,#0x24]
000024  1c80              ADDS     r0,r0,#2
000026  6248              STR      r0,[r1,#0x24]
000028  e009              B        |L35.62|
                  |L35.42|
;;;1567         }
;;;1568         else
;;;1569         {
;;;1570           husart->pTxBuffPtr += 1;
00002a  6a48              LDR      r0,[r1,#0x24]
00002c  1c40              ADDS     r0,r0,#1
00002e  6248              STR      r0,[r1,#0x24]
000030  e005              B        |L35.62|
                  |L35.50|
;;;1571         }
;;;1572       } 
;;;1573       else
;;;1574       { 
;;;1575         husart->Instance->DR = (uint8_t)(*husart->pTxBuffPtr++ & (uint8_t)0x00FF);
000032  6a4b              LDR      r3,[r1,#0x24]
000034  1c58              ADDS     r0,r3,#1
000036  6248              STR      r0,[r1,#0x24]
000038  7818              LDRB     r0,[r3,#0]
00003a  680b              LDR      r3,[r1,#0]
00003c  6058              STR      r0,[r3,#4]
                  |L35.62|
;;;1576       }
;;;1577       
;;;1578       if(--husart->TxXferCount == 0)
00003e  8d48              LDRH     r0,[r1,#0x2a]
000040  1e40              SUBS     r0,r0,#1
000042  b280              UXTH     r0,r0
000044  8548              STRH     r0,[r1,#0x2a]
000046  b958              CBNZ     r0,|L35.96|
;;;1579       {
;;;1580         /* Disable the USART Transmit data register empty Interrupt */
;;;1581         __HAL_USART_DISABLE_IT(husart, USART_IT_TXE);
000048  6808              LDR      r0,[r1,#0]
00004a  68c0              LDR      r0,[r0,#0xc]
00004c  f0200080          BIC      r0,r0,#0x80
000050  680b              LDR      r3,[r1,#0]
000052  60d8              STR      r0,[r3,#0xc]
;;;1582   
;;;1583         /* Enable the USART Transmit Complete Interrupt */    
;;;1584         __HAL_USART_ENABLE_IT(husart, USART_IT_TC);
000054  6808              LDR      r0,[r1,#0]
000056  68c0              LDR      r0,[r0,#0xc]
000058  f0400040          ORR      r0,r0,#0x40
00005c  680b              LDR      r3,[r1,#0]
00005e  60d8              STR      r0,[r3,#0xc]
                  |L35.96|
;;;1585       }
;;;1586       return HAL_OK;
000060  2000              MOVS     r0,#0
                  |L35.98|
;;;1587     }
;;;1588     else
;;;1589     {
;;;1590       return HAL_BUSY;
;;;1591     }
;;;1592   }
000062  4770              BX       lr
                  |L35.100|
000064  2002              MOVS     r0,#2                 ;1590
000066  e7fc              B        |L35.98|
;;;1593   
                          ENDP


                          AREA ||i.USART_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  USART_WaitOnFlagUntilTimeout PROC
;;;1484     */
;;;1485   static HAL_StatusTypeDef USART_WaitOnFlagUntilTimeout(USART_HandleTypeDef *husart, uint32_t Flag, FlagStatus Status, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1486   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;1487     uint32_t tickstart = 0;
00000c  f04f0800          MOV      r8,#0
;;;1488   
;;;1489     /* Get tick */ 
;;;1490     tickstart = HAL_GetTick();
000010  f7fffffe          BL       HAL_GetTick
000014  4680              MOV      r8,r0
;;;1491   
;;;1492     /* Wait until flag is set */
;;;1493     if(Status == RESET)
000016  bb9f              CBNZ     r7,|L36.128|
;;;1494     {
;;;1495       while(__HAL_USART_GET_FLAG(husart, Flag) == RESET)
000018  e02b              B        |L36.114|
                  |L36.26|
;;;1496       {
;;;1497         /* Check for the Timeout */
;;;1498         if(Timeout != HAL_MAX_DELAY)
00001a  1c68              ADDS     r0,r5,#1
00001c  b348              CBZ      r0,|L36.114|
;;;1499         {
;;;1500           if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
00001e  b12d              CBZ      r5,|L36.44|
000020  f7fffffe          BL       HAL_GetTick
000024  eba00008          SUB      r0,r0,r8
000028  42a8              CMP      r0,r5
00002a  d922              BLS      |L36.114|
                  |L36.44|
;;;1501           {
;;;1502             /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
;;;1503             __HAL_USART_DISABLE_IT(husart, USART_IT_TXE);
00002c  6820              LDR      r0,[r4,#0]
00002e  68c0              LDR      r0,[r0,#0xc]
000030  f0200080          BIC      r0,r0,#0x80
000034  6821              LDR      r1,[r4,#0]
000036  60c8              STR      r0,[r1,#0xc]
;;;1504             __HAL_USART_DISABLE_IT(husart, USART_IT_RXNE);
000038  6820              LDR      r0,[r4,#0]
00003a  68c0              LDR      r0,[r0,#0xc]
00003c  f0200020          BIC      r0,r0,#0x20
000040  6821              LDR      r1,[r4,#0]
000042  60c8              STR      r0,[r1,#0xc]
;;;1505             __HAL_USART_DISABLE_IT(husart, USART_IT_PE);
000044  6820              LDR      r0,[r4,#0]
000046  68c0              LDR      r0,[r0,#0xc]
000048  f4207080          BIC      r0,r0,#0x100
00004c  6821              LDR      r1,[r4,#0]
00004e  60c8              STR      r0,[r1,#0xc]
;;;1506             __HAL_USART_DISABLE_IT(husart, USART_IT_ERR);
000050  6820              LDR      r0,[r4,#0]
000052  6940              LDR      r0,[r0,#0x14]
000054  f0200001          BIC      r0,r0,#1
000058  6821              LDR      r1,[r4,#0]
00005a  6148              STR      r0,[r1,#0x14]
;;;1507   
;;;1508             husart->State= HAL_USART_STATE_READY;
00005c  2001              MOVS     r0,#1
00005e  f884003d          STRB     r0,[r4,#0x3d]
;;;1509   
;;;1510             /* Process Unlocked */
;;;1511             __HAL_UNLOCK(husart);
000062  bf00              NOP      
000064  2000              MOVS     r0,#0
000066  f884003c          STRB     r0,[r4,#0x3c]
00006a  bf00              NOP      
;;;1512   
;;;1513             return HAL_TIMEOUT;
00006c  2003              MOVS     r0,#3
                  |L36.110|
;;;1514           }
;;;1515         }
;;;1516       }
;;;1517     }
;;;1518     else
;;;1519     {
;;;1520       while(__HAL_USART_GET_FLAG(husart, Flag) != RESET)
;;;1521       {
;;;1522         /* Check for the Timeout */
;;;1523         if(Timeout != HAL_MAX_DELAY)
;;;1524         {
;;;1525           if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
;;;1526           {
;;;1527             /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
;;;1528             __HAL_USART_DISABLE_IT(husart, USART_IT_TXE);
;;;1529             __HAL_USART_DISABLE_IT(husart, USART_IT_RXNE);
;;;1530             __HAL_USART_DISABLE_IT(husart, USART_IT_PE);
;;;1531             __HAL_USART_DISABLE_IT(husart, USART_IT_ERR);
;;;1532   
;;;1533             husart->State= HAL_USART_STATE_READY;
;;;1534   
;;;1535             /* Process Unlocked */
;;;1536             __HAL_UNLOCK(husart);
;;;1537   
;;;1538             return HAL_TIMEOUT;
;;;1539           }
;;;1540         }
;;;1541       }
;;;1542     }
;;;1543     return HAL_OK;
;;;1544   }
00006e  e8bd81f0          POP      {r4-r8,pc}
                  |L36.114|
000072  6820              LDR      r0,[r4,#0]            ;1495
000074  6800              LDR      r0,[r0,#0]            ;1495
000076  4030              ANDS     r0,r0,r6              ;1495
000078  42b0              CMP      r0,r6                 ;1495
00007a  d102              BNE      |L36.130|
00007c  2001              MOVS     r0,#1                 ;1495
00007e  e001              B        |L36.132|
                  |L36.128|
000080  e003              B        |L36.138|
                  |L36.130|
000082  2000              MOVS     r0,#0                 ;1495
                  |L36.132|
000084  2800              CMP      r0,#0                 ;1495
000086  d0c8              BEQ      |L36.26|
000088  e035              B        |L36.246|
                  |L36.138|
00008a  e02a              B        |L36.226|
                  |L36.140|
00008c  1c68              ADDS     r0,r5,#1              ;1523
00008e  b340              CBZ      r0,|L36.226|
000090  b12d              CBZ      r5,|L36.158|
000092  f7fffffe          BL       HAL_GetTick
000096  eba00008          SUB      r0,r0,r8              ;1525
00009a  42a8              CMP      r0,r5                 ;1525
00009c  d921              BLS      |L36.226|
                  |L36.158|
00009e  6820              LDR      r0,[r4,#0]            ;1528
0000a0  68c0              LDR      r0,[r0,#0xc]          ;1528
0000a2  f0200080          BIC      r0,r0,#0x80           ;1528
0000a6  6821              LDR      r1,[r4,#0]            ;1528
0000a8  60c8              STR      r0,[r1,#0xc]          ;1528
0000aa  6820              LDR      r0,[r4,#0]            ;1529
0000ac  68c0              LDR      r0,[r0,#0xc]          ;1529
0000ae  f0200020          BIC      r0,r0,#0x20           ;1529
0000b2  6821              LDR      r1,[r4,#0]            ;1529
0000b4  60c8              STR      r0,[r1,#0xc]          ;1529
0000b6  6820              LDR      r0,[r4,#0]            ;1530
0000b8  68c0              LDR      r0,[r0,#0xc]          ;1530
0000ba  f4207080          BIC      r0,r0,#0x100          ;1530
0000be  6821              LDR      r1,[r4,#0]            ;1530
0000c0  60c8              STR      r0,[r1,#0xc]          ;1530
0000c2  6820              LDR      r0,[r4,#0]            ;1531
0000c4  6940              LDR      r0,[r0,#0x14]         ;1531
0000c6  f0200001          BIC      r0,r0,#1              ;1531
0000ca  6821              LDR      r1,[r4,#0]            ;1531
0000cc  6148              STR      r0,[r1,#0x14]         ;1531
0000ce  2001              MOVS     r0,#1                 ;1533
0000d0  f884003d          STRB     r0,[r4,#0x3d]         ;1533
0000d4  bf00              NOP                            ;1536
0000d6  2000              MOVS     r0,#0                 ;1536
0000d8  f884003c          STRB     r0,[r4,#0x3c]         ;1536
0000dc  bf00              NOP                            ;1536
0000de  2003              MOVS     r0,#3                 ;1538
0000e0  e7c5              B        |L36.110|
                  |L36.226|
0000e2  6820              LDR      r0,[r4,#0]            ;1520
0000e4  6800              LDR      r0,[r0,#0]            ;1520
0000e6  4030              ANDS     r0,r0,r6              ;1520
0000e8  42b0              CMP      r0,r6                 ;1520
0000ea  d101              BNE      |L36.240|
0000ec  2001              MOVS     r0,#1                 ;1520
0000ee  e000              B        |L36.242|
                  |L36.240|
0000f0  2000              MOVS     r0,#0                 ;1520
                  |L36.242|
0000f2  2800              CMP      r0,#0                 ;1520
0000f4  d1ca              BNE      |L36.140|
                  |L36.246|
0000f6  2000              MOVS     r0,#0                 ;1543
0000f8  e7b9              B        |L36.110|
;;;1545   
                          ENDP


;*** Start embedded assembler ***

#line 1 "HALLIB\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_usart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f4xx_hal_usart_c_32ae8742____REV16|
#line 388 ".\\CORE\\cmsis_armcc.h"
|__asm___21_stm32f4xx_hal_usart_c_32ae8742____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f4xx_hal_usart_c_32ae8742____REVSH|
#line 402
|__asm___21_stm32f4xx_hal_usart_c_32ae8742____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f4xx_hal_usart_c_32ae8742____RRX|
#line 587
|__asm___21_stm32f4xx_hal_usart_c_32ae8742____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
