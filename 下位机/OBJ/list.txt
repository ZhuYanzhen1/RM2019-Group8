; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\list.o --asm_dir=.\OBJ\ --list_dir=.\OBJ\ --depend=.\obj\list.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I.\CORE -I.\USER -I.\HALLIB\STM32F4xx_HAL_Driver\Inc -I.\SYSTEM -I.\Hardware -I.\App -I.\DSP_LIB\Include -I.\FreeRTOS -I.\MPU9250\DMP -I.\MPU9250 -I.\RTE\_Project -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=526 -DSTM32F427xx -DSTM32F4 -DUSE_HAL_DRIVER -DSTM32F427xx -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=.\obj\list.crf FreeRTOS\list.c]
                          THUMB

                          AREA ||i.uxListRemove||, CODE, READONLY, ALIGN=1

                  uxListRemove PROC
;;;169    
;;;170    UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
000000  4601              MOV      r1,r0
;;;171    {
;;;172    /* The list item knows which list it is in.  Obtain the list from the list
;;;173    item. */
;;;174    List_t * const pxList = pxItemToRemove->pxContainer;
000002  690a              LDR      r2,[r1,#0x10]
;;;175    
;;;176    	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
000004  e9d13001          LDRD     r3,r0,[r1,#4]
000008  6098              STR      r0,[r3,#8]
;;;177    	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
00000a  e9d10301          LDRD     r0,r3,[r1,#4]
00000e  6058              STR      r0,[r3,#4]
;;;178    
;;;179    	/* Only used during decision coverage testing. */
;;;180    	mtCOVERAGE_TEST_DELAY();
;;;181    
;;;182    	/* Make sure the index is left pointing to a valid item. */
;;;183    	if( pxList->pxIndex == pxItemToRemove )
000010  6850              LDR      r0,[r2,#4]
000012  4288              CMP      r0,r1
000014  d101              BNE      |L1.26|
;;;184    	{
;;;185    		pxList->pxIndex = pxItemToRemove->pxPrevious;
000016  6888              LDR      r0,[r1,#8]
000018  6050              STR      r0,[r2,#4]
                  |L1.26|
;;;186    	}
;;;187    	else
;;;188    	{
;;;189    		mtCOVERAGE_TEST_MARKER();
;;;190    	}
;;;191    
;;;192    	pxItemToRemove->pxContainer = NULL;
00001a  2000              MOVS     r0,#0
00001c  6108              STR      r0,[r1,#0x10]
;;;193    	( pxList->uxNumberOfItems )--;
00001e  6810              LDR      r0,[r2,#0]
000020  1e40              SUBS     r0,r0,#1
000022  6010              STR      r0,[r2,#0]
;;;194    
;;;195    	return pxList->uxNumberOfItems;
000024  6810              LDR      r0,[r2,#0]
;;;196    }
000026  4770              BX       lr
;;;197    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vListInitialise||, CODE, READONLY, ALIGN=1

                  vListInitialise PROC
;;;36     
;;;37     void vListInitialise( List_t * const pxList )
000000  f1000108          ADD      r1,r0,#8
;;;38     {
;;;39     	/* The list structure contains a list item which is used to mark the
;;;40     	end of the list.  To initialise the list the list end is inserted
;;;41     	as the only list entry. */
;;;42     	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
000004  6041              STR      r1,[r0,#4]
;;;43     
;;;44     	/* The list end value is the highest possible value in the list to
;;;45     	ensure it remains at the end of the list. */
;;;46     	pxList->xListEnd.xItemValue = portMAX_DELAY;
000006  f04f31ff          MOV      r1,#0xffffffff
00000a  6081              STR      r1,[r0,#8]
;;;47     
;;;48     	/* The list end next and previous pointers point to itself so we know
;;;49     	when the list is empty. */
;;;50     	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
00000c  f1000108          ADD      r1,r0,#8
000010  60c1              STR      r1,[r0,#0xc]
;;;51     	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
000012  6101              STR      r1,[r0,#0x10]
;;;52     
;;;53     	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
000014  2100              MOVS     r1,#0
000016  6001              STR      r1,[r0,#0]
;;;54     
;;;55     	/* Write known values into the list if
;;;56     	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
;;;57     	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
;;;58     	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
;;;59     }
000018  4770              BX       lr
;;;60     /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vListInitialiseItem||, CODE, READONLY, ALIGN=1

                  vListInitialiseItem PROC
;;;61     
;;;62     void vListInitialiseItem( ListItem_t * const pxItem )
000000  2100              MOVS     r1,#0
;;;63     {
;;;64     	/* Make sure the list item is not recorded as being on a list. */
;;;65     	pxItem->pxContainer = NULL;
000002  6101              STR      r1,[r0,#0x10]
;;;66     
;;;67     	/* Write known values into the list item if
;;;68     	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
;;;69     	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
;;;70     	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
;;;71     }
000004  4770              BX       lr
;;;72     /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vListInsert||, CODE, READONLY, ALIGN=1

                  vListInsert PROC
;;;102    
;;;103    void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
000000  b510              PUSH     {r4,lr}
;;;104    {
000002  4602              MOV      r2,r0
;;;105    ListItem_t *pxIterator;
;;;106    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
000004  680b              LDR      r3,[r1,#0]
;;;107    
;;;108    	/* Only effective when configASSERT() is also defined, these tests may catch
;;;109    	the list data structures being overwritten in memory.  They will not catch
;;;110    	data errors caused by incorrect configuration or use of FreeRTOS. */
;;;111    	listTEST_LIST_INTEGRITY( pxList );
;;;112    	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );
;;;113    
;;;114    	/* Insert the new list item into the list, sorted in xItemValue order.
;;;115    
;;;116    	If the list already contains a list item with the same item value then the
;;;117    	new list item should be placed after it.  This ensures that TCBs which are
;;;118    	stored in ready lists (all of which have the same xItemValue value) get a
;;;119    	share of the CPU.  However, if the xItemValue is the same as the back marker
;;;120    	the iteration loop below will not end.  Therefore the value is checked
;;;121    	first, and the algorithm slightly modified if necessary. */
;;;122    	if( xValueOfInsertion == portMAX_DELAY )
000006  1c5c              ADDS     r4,r3,#1
000008  b90c              CBNZ     r4,|L4.14|
;;;123    	{
;;;124    		pxIterator = pxList->xListEnd.pxPrevious;
00000a  6910              LDR      r0,[r2,#0x10]
00000c  e007              B        |L4.30|
                  |L4.14|
;;;125    	}
;;;126    	else
;;;127    	{
;;;128    		/* *** NOTE ***********************************************************
;;;129    		If you find your application is crashing here then likely causes are
;;;130    		listed below.  In addition see https://www.freertos.org/FAQHelp.html for
;;;131    		more tips, and ensure configASSERT() is defined!
;;;132    		https://www.freertos.org/a00110.html#configASSERT
;;;133    
;;;134    			1) Stack overflow -
;;;135    			   see https://www.freertos.org/Stacks-and-stack-overflow-checking.html
;;;136    			2) Incorrect interrupt priority assignment, especially on Cortex-M
;;;137    			   parts where numerically high priority values denote low actual
;;;138    			   interrupt priorities, which can seem counter intuitive.  See
;;;139    			   https://www.freertos.org/RTOS-Cortex-M3-M4.html and the definition
;;;140    			   of configMAX_SYSCALL_INTERRUPT_PRIORITY on
;;;141    			   https://www.freertos.org/a00110.html
;;;142    			3) Calling an API function from within a critical section or when
;;;143    			   the scheduler is suspended, or calling an API function that does
;;;144    			   not end in "FromISR" from an interrupt.
;;;145    			4) Using a queue or semaphore before it has been initialised or
;;;146    			   before the scheduler has been started (are interrupts firing
;;;147    			   before vTaskStartScheduler() has been called?).
;;;148    		**********************************************************************/
;;;149    
;;;150    		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
00000e  f1020008          ADD      r0,r2,#8
000012  e000              B        |L4.22|
                  |L4.20|
000014  6840              LDR      r0,[r0,#4]
                  |L4.22|
000016  6844              LDR      r4,[r0,#4]
000018  6824              LDR      r4,[r4,#0]
00001a  429c              CMP      r4,r3
00001c  d9fa              BLS      |L4.20|
                  |L4.30|
;;;151    		{
;;;152    			/* There is nothing to do here, just iterating to the wanted
;;;153    			insertion position. */
;;;154    		}
;;;155    	}
;;;156    
;;;157    	pxNewListItem->pxNext = pxIterator->pxNext;
00001e  6844              LDR      r4,[r0,#4]
000020  604c              STR      r4,[r1,#4]
;;;158    	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
000022  684c              LDR      r4,[r1,#4]
000024  60a1              STR      r1,[r4,#8]
;;;159    	pxNewListItem->pxPrevious = pxIterator;
000026  6088              STR      r0,[r1,#8]
;;;160    	pxIterator->pxNext = pxNewListItem;
000028  6041              STR      r1,[r0,#4]
;;;161    
;;;162    	/* Remember which list the item is in.  This allows fast removal of the
;;;163    	item later. */
;;;164    	pxNewListItem->pxContainer = pxList;
00002a  610a              STR      r2,[r1,#0x10]
;;;165    
;;;166    	( pxList->uxNumberOfItems )++;
00002c  6814              LDR      r4,[r2,#0]
00002e  1c64              ADDS     r4,r4,#1
000030  6014              STR      r4,[r2,#0]
;;;167    }
000032  bd10              POP      {r4,pc}
;;;168    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vListInsertEnd||, CODE, READONLY, ALIGN=1

                  vListInsertEnd PROC
;;;73     
;;;74     void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
000000  6842              LDR      r2,[r0,#4]
;;;75     {
;;;76     ListItem_t * const pxIndex = pxList->pxIndex;
;;;77     
;;;78     	/* Only effective when configASSERT() is also defined, these tests may catch
;;;79     	the list data structures being overwritten in memory.  They will not catch
;;;80     	data errors caused by incorrect configuration or use of FreeRTOS. */
;;;81     	listTEST_LIST_INTEGRITY( pxList );
;;;82     	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );
;;;83     
;;;84     	/* Insert a new list item into pxList, but rather than sort the list,
;;;85     	makes the new list item the last item to be removed by a call to
;;;86     	listGET_OWNER_OF_NEXT_ENTRY(). */
;;;87     	pxNewListItem->pxNext = pxIndex;
000002  604a              STR      r2,[r1,#4]
;;;88     	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
000004  6893              LDR      r3,[r2,#8]
000006  608b              STR      r3,[r1,#8]
;;;89     
;;;90     	/* Only used during decision coverage testing. */
;;;91     	mtCOVERAGE_TEST_DELAY();
;;;92     
;;;93     	pxIndex->pxPrevious->pxNext = pxNewListItem;
000008  6893              LDR      r3,[r2,#8]
00000a  6059              STR      r1,[r3,#4]
;;;94     	pxIndex->pxPrevious = pxNewListItem;
00000c  6091              STR      r1,[r2,#8]
;;;95     
;;;96     	/* Remember which list the item is in. */
;;;97     	pxNewListItem->pxContainer = pxList;
00000e  6108              STR      r0,[r1,#0x10]
;;;98     
;;;99     	( pxList->uxNumberOfItems )++;
000010  6803              LDR      r3,[r0,#0]
000012  1c5b              ADDS     r3,r3,#1
000014  6003              STR      r3,[r0,#0]
;;;100    }
000016  4770              BX       lr
;;;101    /*-----------------------------------------------------------*/
                          ENDP

