; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\stm32f4xx_hal_adc.o --asm_dir=.\OBJ\ --list_dir=.\OBJ\ --depend=.\obj\stm32f4xx_hal_adc.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I.\CORE -I.\USER -I.\HALLIB\STM32F4xx_HAL_Driver\Inc -I.\SYSTEM -I.\Hardware -I.\App -I.\DSP_LIB\Include -I.\FreeRTOS -I.\MPU9250\DMP -I.\MPU9250 -I.\RTE\_Project -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=526 -DSTM32F427xx -DSTM32F4 -DUSE_HAL_DRIVER -DSTM32F427xx -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=.\obj\stm32f4xx_hal_adc.crf HALLIB\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_adc.c]
                          THUMB

                          AREA ||i.ADC_DMAConvCplt||, CODE, READONLY, ALIGN=1

                  ADC_DMAConvCplt PROC
;;;1364     */
;;;1365   static void ADC_DMAConvCplt(DMA_HandleTypeDef *hdma)   
000000  b570              PUSH     {r4-r6,lr}
;;;1366   {
000002  4605              MOV      r5,r0
;;;1367     ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;1368       
;;;1369     /* Check if an injected conversion is ready */
;;;1370     if(hadc->State == HAL_ADC_STATE_EOC_INJ)
000006  f894003d          LDRB     r0,[r4,#0x3d]
00000a  2825              CMP      r0,#0x25
00000c  d103              BNE      |L1.22|
;;;1371     {
;;;1372       /* Change ADC state */
;;;1373       hadc->State = HAL_ADC_STATE_EOC_INJ_REG;  
00000e  2035              MOVS     r0,#0x35
000010  f884003d          STRB     r0,[r4,#0x3d]
000014  e002              B        |L1.28|
                  |L1.22|
;;;1374     }
;;;1375     else
;;;1376     {
;;;1377       /* Change ADC state */
;;;1378       hadc->State = HAL_ADC_STATE_EOC_REG;
000016  2015              MOVS     r0,#0x15
000018  f884003d          STRB     r0,[r4,#0x3d]
                  |L1.28|
;;;1379     }
;;;1380       
;;;1381     HAL_ADC_ConvCpltCallback(hadc); 
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       HAL_ADC_ConvCpltCallback
;;;1382   }
000022  bd70              POP      {r4-r6,pc}
;;;1383   
                          ENDP


                          AREA ||i.ADC_DMAError||, CODE, READONLY, ALIGN=1

                  ADC_DMAError PROC
;;;1402     */
;;;1403   static void ADC_DMAError(DMA_HandleTypeDef *hdma)   
000000  b570              PUSH     {r4-r6,lr}
;;;1404   {
000002  4605              MOV      r5,r0
;;;1405     ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;1406     hadc->State= HAL_ADC_STATE_ERROR;
000006  2004              MOVS     r0,#4
000008  f884003d          STRB     r0,[r4,#0x3d]
;;;1407     /* Set ADC error code to DMA error */
;;;1408     hadc->ErrorCode |= HAL_ADC_ERROR_DMA;
00000c  6c20              LDR      r0,[r4,#0x40]
00000e  f0400002          ORR      r0,r0,#2
000012  6420              STR      r0,[r4,#0x40]
;;;1409     HAL_ADC_ErrorCallback(hadc); 
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       HAL_ADC_ErrorCallback
;;;1410   }
00001a  bd70              POP      {r4-r6,pc}
;;;1411   
                          ENDP


                          AREA ||i.ADC_DMAHalfConvCplt||, CODE, READONLY, ALIGN=1

                  ADC_DMAHalfConvCplt PROC
;;;1389     */
;;;1390   static void ADC_DMAHalfConvCplt(DMA_HandleTypeDef *hdma)   
000000  b570              PUSH     {r4-r6,lr}
;;;1391   {
000002  4604              MOV      r4,r0
;;;1392     ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6ba5              LDR      r5,[r4,#0x38]
;;;1393     /* Conversion complete callback */
;;;1394     HAL_ADC_ConvHalfCpltCallback(hadc); 
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_ADC_ConvHalfCpltCallback
;;;1395   }
00000c  bd70              POP      {r4-r6,pc}
;;;1396   
                          ENDP


                          AREA ||i.ADC_Init||, CODE, READONLY, ALIGN=2

                  ADC_Init PROC
;;;1283     */
;;;1284   static void ADC_Init(ADC_HandleTypeDef* hadc)
000000  495a              LDR      r1,|L4.364|
;;;1285   {
;;;1286     /* Set ADC parameters */
;;;1287     /* Set the ADC clock prescaler */
;;;1288     ADC->CCR &= ~(ADC_CCR_ADCPRE);
000002  6809              LDR      r1,[r1,#0]
000004  f4213140          BIC      r1,r1,#0x30000
000008  4a59              LDR      r2,|L4.368|
00000a  f8c21304          STR      r1,[r2,#0x304]
;;;1289     ADC->CCR |=  hadc->Init.ClockPrescaler;
00000e  4611              MOV      r1,r2
000010  f8d11304          LDR      r1,[r1,#0x304]
000014  6842              LDR      r2,[r0,#4]
000016  4311              ORRS     r1,r1,r2
000018  4a54              LDR      r2,|L4.364|
00001a  6011              STR      r1,[r2,#0]
;;;1290     
;;;1291     /* Set ADC scan mode */
;;;1292     hadc->Instance->CR1 &= ~(ADC_CR1_SCAN);
00001c  6801              LDR      r1,[r0,#0]
00001e  6849              LDR      r1,[r1,#4]
000020  f4217180          BIC      r1,r1,#0x100
000024  6802              LDR      r2,[r0,#0]
000026  6051              STR      r1,[r2,#4]
;;;1293     hadc->Instance->CR1 |=  ADC_CR1_SCANCONV(hadc->Init.ScanConvMode);
000028  6801              LDR      r1,[r0,#0]
00002a  684a              LDR      r2,[r1,#4]
00002c  6901              LDR      r1,[r0,#0x10]
00002e  ea422101          ORR      r1,r2,r1,LSL #8
000032  6802              LDR      r2,[r0,#0]
000034  6051              STR      r1,[r2,#4]
;;;1294     
;;;1295     /* Set ADC resolution */
;;;1296     hadc->Instance->CR1 &= ~(ADC_CR1_RES);
000036  6801              LDR      r1,[r0,#0]
000038  6849              LDR      r1,[r1,#4]
00003a  f0217140          BIC      r1,r1,#0x3000000
00003e  6802              LDR      r2,[r0,#0]
000040  6051              STR      r1,[r2,#4]
;;;1297     hadc->Instance->CR1 |=  hadc->Init.Resolution;
000042  6801              LDR      r1,[r0,#0]
000044  6849              LDR      r1,[r1,#4]
000046  6882              LDR      r2,[r0,#8]
000048  4311              ORRS     r1,r1,r2
00004a  6802              LDR      r2,[r0,#0]
00004c  6051              STR      r1,[r2,#4]
;;;1298     
;;;1299     /* Set ADC data alignment */
;;;1300     hadc->Instance->CR2 &= ~(ADC_CR2_ALIGN);
00004e  6801              LDR      r1,[r0,#0]
000050  6889              LDR      r1,[r1,#8]
000052  f4216100          BIC      r1,r1,#0x800
000056  6802              LDR      r2,[r0,#0]
000058  6091              STR      r1,[r2,#8]
;;;1301     hadc->Instance->CR2 |= hadc->Init.DataAlign;
00005a  6801              LDR      r1,[r0,#0]
00005c  6889              LDR      r1,[r1,#8]
00005e  68c2              LDR      r2,[r0,#0xc]
000060  4311              ORRS     r1,r1,r2
000062  6802              LDR      r2,[r0,#0]
000064  6091              STR      r1,[r2,#8]
;;;1302     
;;;1303     /* Enable external trigger if trigger selection is different of software  */
;;;1304     /* start.                                                                 */
;;;1305     /* Note: This configuration keeps the hardware feature of parameter       */
;;;1306     /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
;;;1307     /*       software start.                                                  */
;;;1308     if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
000066  4a43              LDR      r2,|L4.372|
000068  6ac1              LDR      r1,[r0,#0x2c]
00006a  4291              CMP      r1,r2
00006c  d018              BEQ      |L4.160|
;;;1309     {
;;;1310       /* Select external trigger to start conversion */
;;;1311       hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
00006e  6801              LDR      r1,[r0,#0]
000070  6889              LDR      r1,[r1,#8]
000072  f0216170          BIC      r1,r1,#0xf000000
000076  6802              LDR      r2,[r0,#0]
000078  6091              STR      r1,[r2,#8]
;;;1312       hadc->Instance->CR2 |= hadc->Init.ExternalTrigConv;
00007a  6801              LDR      r1,[r0,#0]
00007c  6889              LDR      r1,[r1,#8]
00007e  6ac2              LDR      r2,[r0,#0x2c]
000080  4311              ORRS     r1,r1,r2
000082  6802              LDR      r2,[r0,#0]
000084  6091              STR      r1,[r2,#8]
;;;1313       
;;;1314       /* Select external trigger polarity */
;;;1315       hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
000086  6801              LDR      r1,[r0,#0]
000088  6889              LDR      r1,[r1,#8]
00008a  f0215140          BIC      r1,r1,#0x30000000
00008e  6802              LDR      r2,[r0,#0]
000090  6091              STR      r1,[r2,#8]
;;;1316       hadc->Instance->CR2 |= hadc->Init.ExternalTrigConvEdge;
000092  6801              LDR      r1,[r0,#0]
000094  6889              LDR      r1,[r1,#8]
000096  6b02              LDR      r2,[r0,#0x30]
000098  4311              ORRS     r1,r1,r2
00009a  6802              LDR      r2,[r0,#0]
00009c  6091              STR      r1,[r2,#8]
00009e  e00b              B        |L4.184|
                  |L4.160|
;;;1317     }
;;;1318     else
;;;1319     {
;;;1320       /* Reset the external trigger */
;;;1321       hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
0000a0  6801              LDR      r1,[r0,#0]
0000a2  6889              LDR      r1,[r1,#8]
0000a4  f0216170          BIC      r1,r1,#0xf000000
0000a8  6802              LDR      r2,[r0,#0]
0000aa  6091              STR      r1,[r2,#8]
;;;1322       hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
0000ac  6801              LDR      r1,[r0,#0]
0000ae  6889              LDR      r1,[r1,#8]
0000b0  f0215140          BIC      r1,r1,#0x30000000
0000b4  6802              LDR      r2,[r0,#0]
0000b6  6091              STR      r1,[r2,#8]
                  |L4.184|
;;;1323     }
;;;1324     
;;;1325     /* Enable or disable ADC continuous conversion mode */
;;;1326     hadc->Instance->CR2 &= ~(ADC_CR2_CONT);
0000b8  6801              LDR      r1,[r0,#0]
0000ba  6889              LDR      r1,[r1,#8]
0000bc  f0210102          BIC      r1,r1,#2
0000c0  6802              LDR      r2,[r0,#0]
0000c2  6091              STR      r1,[r2,#8]
;;;1327     hadc->Instance->CR2 |= ADC_CR2_CONTINUOUS(hadc->Init.ContinuousConvMode);
0000c4  6801              LDR      r1,[r0,#0]
0000c6  688a              LDR      r2,[r1,#8]
0000c8  6981              LDR      r1,[r0,#0x18]
0000ca  ea420141          ORR      r1,r2,r1,LSL #1
0000ce  6802              LDR      r2,[r0,#0]
0000d0  6091              STR      r1,[r2,#8]
;;;1328     
;;;1329     if(hadc->Init.DiscontinuousConvMode != DISABLE)
0000d2  6a41              LDR      r1,[r0,#0x24]
0000d4  b1d1              CBZ      r1,|L4.268|
;;;1330     {
;;;1331       assert_param(IS_ADC_REGULAR_DISC_NUMBER(hadc->Init.NbrOfDiscConversion));
;;;1332     
;;;1333       /* Enable the selected ADC regular discontinuous mode */
;;;1334       hadc->Instance->CR1 |= (uint32_t)ADC_CR1_DISCEN;
0000d6  6801              LDR      r1,[r0,#0]
0000d8  6849              LDR      r1,[r1,#4]
0000da  f4416100          ORR      r1,r1,#0x800
0000de  6802              LDR      r2,[r0,#0]
0000e0  6051              STR      r1,[r2,#4]
;;;1335       
;;;1336       /* Set the number of channels to be converted in discontinuous mode */
;;;1337       hadc->Instance->CR1 &= ~(ADC_CR1_DISCNUM);
0000e2  6801              LDR      r1,[r0,#0]
0000e4  6849              LDR      r1,[r1,#4]
0000e6  f4214160          BIC      r1,r1,#0xe000
0000ea  6802              LDR      r2,[r0,#0]
0000ec  6051              STR      r1,[r2,#4]
;;;1338       hadc->Instance->CR1 |=  ADC_CR1_DISCONTINUOUS(hadc->Init.NbrOfDiscConversion);
0000ee  6801              LDR      r1,[r0,#0]
0000f0  684a              LDR      r2,[r1,#4]
0000f2  6a81              LDR      r1,[r0,#0x28]
0000f4  1e49              SUBS     r1,r1,#1
0000f6  f44f4360          MOV      r3,#0xe000
0000fa  fa93f3a3          RBIT     r3,r3
0000fe  fab3f383          CLZ      r3,r3
000102  4099              LSLS     r1,r1,r3
000104  430a              ORRS     r2,r2,r1
000106  6801              LDR      r1,[r0,#0]
000108  604a              STR      r2,[r1,#4]
00010a  e005              B        |L4.280|
                  |L4.268|
;;;1339     }
;;;1340     else
;;;1341     {
;;;1342       /* Disable the selected ADC regular discontinuous mode */
;;;1343       hadc->Instance->CR1 &= ~(ADC_CR1_DISCEN);
00010c  6801              LDR      r1,[r0,#0]
00010e  6849              LDR      r1,[r1,#4]
000110  f4216100          BIC      r1,r1,#0x800
000114  6802              LDR      r2,[r0,#0]
000116  6051              STR      r1,[r2,#4]
                  |L4.280|
;;;1344     }
;;;1345     
;;;1346     /* Set ADC number of conversion */
;;;1347     hadc->Instance->SQR1 &= ~(ADC_SQR1_L);
000118  6801              LDR      r1,[r0,#0]
00011a  6ac9              LDR      r1,[r1,#0x2c]
00011c  f4210170          BIC      r1,r1,#0xf00000
000120  6802              LDR      r2,[r0,#0]
000122  62d1              STR      r1,[r2,#0x2c]
;;;1348     hadc->Instance->SQR1 |=  ADC_SQR1(hadc->Init.NbrOfConversion);
000124  6801              LDR      r1,[r0,#0]
000126  6aca              LDR      r2,[r1,#0x2c]
000128  8c01              LDRH     r1,[r0,#0x20]
00012a  1e49              SUBS     r1,r1,#1
00012c  ea425101          ORR      r1,r2,r1,LSL #20
000130  6802              LDR      r2,[r0,#0]
000132  62d1              STR      r1,[r2,#0x2c]
;;;1349     
;;;1350     /* Enable or disable ADC DMA continuous request */
;;;1351     hadc->Instance->CR2 &= ~(ADC_CR2_DDS);
000134  6801              LDR      r1,[r0,#0]
000136  6889              LDR      r1,[r1,#8]
000138  f4217100          BIC      r1,r1,#0x200
00013c  6802              LDR      r2,[r0,#0]
00013e  6091              STR      r1,[r2,#8]
;;;1352     hadc->Instance->CR2 |= ADC_CR2_DMAContReq(hadc->Init.DMAContinuousRequests);
000140  6801              LDR      r1,[r0,#0]
000142  688a              LDR      r2,[r1,#8]
000144  69c1              LDR      r1,[r0,#0x1c]
000146  ea422141          ORR      r1,r2,r1,LSL #9
00014a  6802              LDR      r2,[r0,#0]
00014c  6091              STR      r1,[r2,#8]
;;;1353     
;;;1354     /* Enable or disable ADC end of conversion selection */
;;;1355     hadc->Instance->CR2 &= ~(ADC_CR2_EOCS);
00014e  6801              LDR      r1,[r0,#0]
000150  6889              LDR      r1,[r1,#8]
000152  f4216180          BIC      r1,r1,#0x400
000156  6802              LDR      r2,[r0,#0]
000158  6091              STR      r1,[r2,#8]
;;;1356     hadc->Instance->CR2 |= ADC_CR2_EOCSelection(hadc->Init.EOCSelection);
00015a  6801              LDR      r1,[r0,#0]
00015c  688a              LDR      r2,[r1,#8]
00015e  6941              LDR      r1,[r0,#0x14]
000160  ea422181          ORR      r1,r2,r1,LSL #10
000164  6802              LDR      r2,[r0,#0]
000166  6091              STR      r1,[r2,#8]
;;;1357   }
000168  4770              BX       lr
;;;1358   
                          ENDP

00016a  0000              DCW      0x0000
                  |L4.364|
                          DCD      0x40012304
                  |L4.368|
                          DCD      0x40012000
                  |L4.372|
                          DCD      0x0f000001

                          AREA ||i.HAL_ADC_AnalogWDGConfig||, CODE, READONLY, ALIGN=2

                  HAL_ADC_AnalogWDGConfig PROC
;;;1169     */
;;;1170   HAL_StatusTypeDef HAL_ADC_AnalogWDGConfig(ADC_HandleTypeDef* hadc, ADC_AnalogWDGConfTypeDef* AnalogWDGConfig)
000000  4602              MOV      r2,r0
;;;1171   {
;;;1172   #ifdef USE_FULL_ASSERT  
;;;1173     uint32_t tmp = 0;
;;;1174   #endif /* USE_FULL_ASSERT  */  
;;;1175     
;;;1176     /* Check the parameters */
;;;1177     assert_param(IS_ADC_ANALOG_WATCHDOG(AnalogWDGConfig->WatchdogMode));
;;;1178     assert_param(IS_ADC_CHANNEL(AnalogWDGConfig->Channel));
;;;1179     assert_param(IS_FUNCTIONAL_STATE(AnalogWDGConfig->ITMode));
;;;1180   
;;;1181   #ifdef USE_FULL_ASSERT  
;;;1182     tmp = ADC_GET_RESOLUTION(hadc);
;;;1183     assert_param(IS_ADC_RANGE(tmp, AnalogWDGConfig->HighThreshold));
;;;1184     assert_param(IS_ADC_RANGE(tmp, AnalogWDGConfig->LowThreshold));
;;;1185   #endif /* USE_FULL_ASSERT  */
;;;1186     
;;;1187     /* Process locked */
;;;1188     __HAL_LOCK(hadc);
000002  bf00              NOP      
000004  f892003c          LDRB     r0,[r2,#0x3c]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L5.16|
00000c  2002              MOVS     r0,#2
                  |L5.14|
;;;1189     
;;;1190     if(AnalogWDGConfig->ITMode == ENABLE)
;;;1191     {
;;;1192       /* Enable the ADC Analog watchdog interrupt */
;;;1193       __HAL_ADC_ENABLE_IT(hadc, ADC_IT_AWD);
;;;1194     }
;;;1195     else
;;;1196     {
;;;1197       /* Disable the ADC Analog watchdog interrupt */
;;;1198       __HAL_ADC_DISABLE_IT(hadc, ADC_IT_AWD);
;;;1199     }
;;;1200     
;;;1201     /* Clear AWDEN, JAWDEN and AWDSGL bits */
;;;1202     hadc->Instance->CR1 &=  ~(ADC_CR1_AWDSGL | ADC_CR1_JAWDEN | ADC_CR1_AWDEN);
;;;1203     
;;;1204     /* Set the analog watchdog enable mode */
;;;1205     hadc->Instance->CR1 |= AnalogWDGConfig->WatchdogMode;
;;;1206     
;;;1207     /* Set the high threshold */
;;;1208     hadc->Instance->HTR = AnalogWDGConfig->HighThreshold;
;;;1209     
;;;1210     /* Set the low threshold */
;;;1211     hadc->Instance->LTR = AnalogWDGConfig->LowThreshold;
;;;1212     
;;;1213     /* Clear the Analog watchdog channel select bits */
;;;1214     hadc->Instance->CR1 &= ~ADC_CR1_AWDCH;
;;;1215     
;;;1216     /* Set the Analog watchdog channel */
;;;1217     hadc->Instance->CR1 |= (uint32_t)((uint16_t)(AnalogWDGConfig->Channel));
;;;1218     
;;;1219     /* Process unlocked */
;;;1220     __HAL_UNLOCK(hadc);
;;;1221     
;;;1222     /* Return function status */
;;;1223     return HAL_OK;
;;;1224   }
00000e  4770              BX       lr
                  |L5.16|
000010  2001              MOVS     r0,#1                 ;1188
000012  f882003c          STRB     r0,[r2,#0x3c]         ;1188
000016  bf00              NOP                            ;1188
000018  6908              LDR      r0,[r1,#0x10]         ;1190
00001a  2801              CMP      r0,#1                 ;1190
00001c  d106              BNE      |L5.44|
00001e  6810              LDR      r0,[r2,#0]            ;1193
000020  6840              LDR      r0,[r0,#4]            ;1193
000022  f0400040          ORR      r0,r0,#0x40           ;1193
000026  6813              LDR      r3,[r2,#0]            ;1193
000028  6058              STR      r0,[r3,#4]            ;1193
00002a  e005              B        |L5.56|
                  |L5.44|
00002c  6810              LDR      r0,[r2,#0]            ;1198
00002e  6840              LDR      r0,[r0,#4]            ;1198
000030  f0200040          BIC      r0,r0,#0x40           ;1198
000034  6813              LDR      r3,[r2,#0]            ;1198
000036  6058              STR      r0,[r3,#4]            ;1198
                  |L5.56|
000038  6810              LDR      r0,[r2,#0]            ;1202
00003a  6840              LDR      r0,[r0,#4]            ;1202
00003c  4b11              LDR      r3,|L5.132|
00003e  4018              ANDS     r0,r0,r3              ;1202
000040  6813              LDR      r3,[r2,#0]            ;1202
000042  6058              STR      r0,[r3,#4]            ;1202
000044  6810              LDR      r0,[r2,#0]            ;1205
000046  6840              LDR      r0,[r0,#4]            ;1205
000048  680b              LDR      r3,[r1,#0]            ;1205
00004a  4318              ORRS     r0,r0,r3              ;1205
00004c  6813              LDR      r3,[r2,#0]            ;1205
00004e  6058              STR      r0,[r3,#4]            ;1205
000050  6848              LDR      r0,[r1,#4]            ;1208
000052  6813              LDR      r3,[r2,#0]            ;1208
000054  6258              STR      r0,[r3,#0x24]         ;1208
000056  6888              LDR      r0,[r1,#8]            ;1211
000058  6813              LDR      r3,[r2,#0]            ;1211
00005a  6298              STR      r0,[r3,#0x28]         ;1211
00005c  6810              LDR      r0,[r2,#0]            ;1214
00005e  6840              LDR      r0,[r0,#4]            ;1214
000060  f020001f          BIC      r0,r0,#0x1f           ;1214
000064  6813              LDR      r3,[r2,#0]            ;1214
000066  6058              STR      r0,[r3,#4]            ;1214
000068  6810              LDR      r0,[r2,#0]            ;1217
00006a  6840              LDR      r0,[r0,#4]            ;1217
00006c  898b              LDRH     r3,[r1,#0xc]          ;1217
00006e  b29b              UXTH     r3,r3                 ;1217
000070  4318              ORRS     r0,r0,r3              ;1217
000072  6813              LDR      r3,[r2,#0]            ;1217
000074  6058              STR      r0,[r3,#4]            ;1217
000076  bf00              NOP                            ;1220
000078  2000              MOVS     r0,#0                 ;1220
00007a  f882003c          STRB     r0,[r2,#0x3c]         ;1220
00007e  bf00              NOP                            ;1220
000080  bf00              NOP                            ;1223
000082  e7c4              B        |L5.14|
;;;1225   
                          ENDP

                  |L5.132|
                          DCD      0xff3ffdff

                          AREA ||i.HAL_ADC_ConfigChannel||, CODE, READONLY, ALIGN=2

                  HAL_ADC_ConfigChannel PROC
;;;1066     */
;;;1067   HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef* hadc, ADC_ChannelConfTypeDef* sConfig)
000000  b518              PUSH     {r3,r4,lr}
;;;1068   {
000002  4602              MOV      r2,r0
;;;1069     __IO uint32_t counter = 0;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;1070     
;;;1071     /* Check the parameters */
;;;1072     assert_param(IS_ADC_CHANNEL(sConfig->Channel));
;;;1073     assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
;;;1074     assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
;;;1075     
;;;1076     /* Process locked */
;;;1077     __HAL_LOCK(hadc);
000008  bf00              NOP      
00000a  f892003c          LDRB     r0,[r2,#0x3c]
00000e  2801              CMP      r0,#1
000010  d101              BNE      |L6.22|
000012  2002              MOVS     r0,#2
                  |L6.20|
;;;1078       
;;;1079     /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
;;;1080     if (sConfig->Channel > ADC_CHANNEL_9)
;;;1081     {
;;;1082       /* Clear the old sample time */
;;;1083       hadc->Instance->SMPR1 &= ~ADC_SMPR1(ADC_SMPR1_SMP10, sConfig->Channel);
;;;1084       
;;;1085       /* Set the new sample time */
;;;1086       hadc->Instance->SMPR1 |= ADC_SMPR1(sConfig->SamplingTime, sConfig->Channel);
;;;1087     }
;;;1088     else /* ADC_Channel include in ADC_Channel_[0..9] */
;;;1089     {
;;;1090       /* Clear the old sample time */
;;;1091       hadc->Instance->SMPR2 &= ~ADC_SMPR2(ADC_SMPR2_SMP0, sConfig->Channel);
;;;1092       
;;;1093       /* Set the new sample time */
;;;1094       hadc->Instance->SMPR2 |= ADC_SMPR2(sConfig->SamplingTime, sConfig->Channel);
;;;1095     }
;;;1096     
;;;1097     /* For Rank 1 to 6 */
;;;1098     if (sConfig->Rank < 7)
;;;1099     {
;;;1100       /* Clear the old SQx bits for the selected rank */
;;;1101       hadc->Instance->SQR3 &= ~ADC_SQR3_RK(ADC_SQR3_SQ1, sConfig->Rank);
;;;1102       
;;;1103       /* Set the SQx bits for the selected rank */
;;;1104       hadc->Instance->SQR3 |= ADC_SQR3_RK(sConfig->Channel, sConfig->Rank);
;;;1105     }
;;;1106     /* For Rank 7 to 12 */
;;;1107     else if (sConfig->Rank < 13)
;;;1108     {
;;;1109       /* Clear the old SQx bits for the selected rank */
;;;1110       hadc->Instance->SQR2 &= ~ADC_SQR2_RK(ADC_SQR2_SQ7, sConfig->Rank);
;;;1111       
;;;1112       /* Set the SQx bits for the selected rank */
;;;1113       hadc->Instance->SQR2 |= ADC_SQR2_RK(sConfig->Channel, sConfig->Rank);
;;;1114     }
;;;1115     /* For Rank 13 to 16 */
;;;1116     else
;;;1117     {
;;;1118       /* Clear the old SQx bits for the selected rank */
;;;1119       hadc->Instance->SQR1 &= ~ADC_SQR1_RK(ADC_SQR1_SQ13, sConfig->Rank);
;;;1120       
;;;1121       /* Set the SQx bits for the selected rank */
;;;1122       hadc->Instance->SQR1 |= ADC_SQR1_RK(sConfig->Channel, sConfig->Rank);
;;;1123     }
;;;1124     
;;;1125     /* if ADC1 Channel_18 is selected enable VBAT Channel */
;;;1126     if ((hadc->Instance == ADC1) && (sConfig->Channel == ADC_CHANNEL_VBAT))
;;;1127     {
;;;1128       /* Enable the VBAT channel*/
;;;1129       ADC->CCR |= ADC_CCR_VBATE;
;;;1130     }
;;;1131     
;;;1132     /* if ADC1 Channel_16 or Channel_17 is selected enable TSVREFE Channel(Temperature sensor and VREFINT) */
;;;1133     if ((hadc->Instance == ADC1) && ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) || (sConfig->Channel == ADC_CHANNEL_VREFINT)))
;;;1134     {
;;;1135       /* Enable the TSVREFE channel*/
;;;1136       ADC->CCR |= ADC_CCR_TSVREFE;
;;;1137       
;;;1138       if((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR))
;;;1139       {
;;;1140         /* Delay for temperature sensor stabilization time */
;;;1141         /* Compute number of CPU cycles to wait for */
;;;1142         counter = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000));
;;;1143         while(counter != 0)
;;;1144         {
;;;1145           counter--;
;;;1146         }
;;;1147       }
;;;1148     }
;;;1149     
;;;1150     /* Process unlocked */
;;;1151     __HAL_UNLOCK(hadc);
;;;1152     
;;;1153     /* Return function status */
;;;1154     return HAL_OK;
;;;1155   }
000014  bd18              POP      {r3,r4,pc}
                  |L6.22|
000016  2001              MOVS     r0,#1                 ;1077
000018  f882003c          STRB     r0,[r2,#0x3c]         ;1077
00001c  bf00              NOP                            ;1077
00001e  6808              LDR      r0,[r1,#0]            ;1080
000020  2809              CMP      r0,#9                 ;1080
000022  d916              BLS      |L6.82|
000024  6810              LDR      r0,[r2,#0]            ;1083
000026  68c0              LDR      r0,[r0,#0xc]          ;1083
000028  780b              LDRB     r3,[r1,#0]            ;1083
00002a  3b0a              SUBS     r3,r3,#0xa            ;1083
00002c  eb030443          ADD      r4,r3,r3,LSL #1       ;1083
000030  2307              MOVS     r3,#7                 ;1083
000032  40a3              LSLS     r3,r3,r4              ;1083
000034  4398              BICS     r0,r0,r3              ;1083
000036  6813              LDR      r3,[r2,#0]            ;1083
000038  60d8              STR      r0,[r3,#0xc]          ;1083
00003a  780b              LDRB     r3,[r1,#0]            ;1086
00003c  3b0a              SUBS     r3,r3,#0xa            ;1086
00003e  eb030343          ADD      r3,r3,r3,LSL #1       ;1086
000042  6888              LDR      r0,[r1,#8]            ;1086
000044  4098              LSLS     r0,r0,r3              ;1086
000046  6813              LDR      r3,[r2,#0]            ;1086
000048  68db              LDR      r3,[r3,#0xc]          ;1086
00004a  4318              ORRS     r0,r0,r3              ;1086
00004c  6813              LDR      r3,[r2,#0]            ;1086
00004e  60d8              STR      r0,[r3,#0xc]          ;1086
000050  e013              B        |L6.122|
                  |L6.82|
000052  6810              LDR      r0,[r2,#0]            ;1091
000054  6900              LDR      r0,[r0,#0x10]         ;1091
000056  780b              LDRB     r3,[r1,#0]            ;1091
000058  eb030443          ADD      r4,r3,r3,LSL #1       ;1091
00005c  2307              MOVS     r3,#7                 ;1091
00005e  40a3              LSLS     r3,r3,r4              ;1091
000060  4398              BICS     r0,r0,r3              ;1091
000062  6813              LDR      r3,[r2,#0]            ;1091
000064  6118              STR      r0,[r3,#0x10]         ;1091
000066  780b              LDRB     r3,[r1,#0]            ;1094
000068  eb030343          ADD      r3,r3,r3,LSL #1       ;1094
00006c  6888              LDR      r0,[r1,#8]            ;1094
00006e  4098              LSLS     r0,r0,r3              ;1094
000070  6813              LDR      r3,[r2,#0]            ;1094
000072  691b              LDR      r3,[r3,#0x10]         ;1094
000074  4318              ORRS     r0,r0,r3              ;1094
000076  6813              LDR      r3,[r2,#0]            ;1094
000078  6118              STR      r0,[r3,#0x10]         ;1094
                  |L6.122|
00007a  6848              LDR      r0,[r1,#4]            ;1098
00007c  2807              CMP      r0,#7                 ;1098
00007e  d217              BCS      |L6.176|
000080  6810              LDR      r0,[r2,#0]            ;1101
000082  6b40              LDR      r0,[r0,#0x34]         ;1101
000084  790b              LDRB     r3,[r1,#4]            ;1101
000086  1e5b              SUBS     r3,r3,#1              ;1101
000088  eb030483          ADD      r4,r3,r3,LSL #2       ;1101
00008c  231f              MOVS     r3,#0x1f              ;1101
00008e  40a3              LSLS     r3,r3,r4              ;1101
000090  4398              BICS     r0,r0,r3              ;1101
000092  6813              LDR      r3,[r2,#0]            ;1101
000094  6358              STR      r0,[r3,#0x34]         ;1101
000096  8808              LDRH     r0,[r1,#0]            ;1104
000098  b280              UXTH     r0,r0                 ;1104
00009a  790b              LDRB     r3,[r1,#4]            ;1104
00009c  1e5b              SUBS     r3,r3,#1              ;1104
00009e  eb030383          ADD      r3,r3,r3,LSL #2       ;1104
0000a2  4098              LSLS     r0,r0,r3              ;1104
0000a4  6813              LDR      r3,[r2,#0]            ;1104
0000a6  6b5b              LDR      r3,[r3,#0x34]         ;1104
0000a8  4318              ORRS     r0,r0,r3              ;1104
0000aa  6813              LDR      r3,[r2,#0]            ;1104
0000ac  6358              STR      r0,[r3,#0x34]         ;1104
0000ae  e031              B        |L6.276|
                  |L6.176|
0000b0  6848              LDR      r0,[r1,#4]            ;1107
0000b2  280d              CMP      r0,#0xd               ;1107
0000b4  d217              BCS      |L6.230|
0000b6  6810              LDR      r0,[r2,#0]            ;1110
0000b8  6b00              LDR      r0,[r0,#0x30]         ;1110
0000ba  790b              LDRB     r3,[r1,#4]            ;1110
0000bc  1fdb              SUBS     r3,r3,#7              ;1110
0000be  eb030483          ADD      r4,r3,r3,LSL #2       ;1110
0000c2  231f              MOVS     r3,#0x1f              ;1110
0000c4  40a3              LSLS     r3,r3,r4              ;1110
0000c6  4398              BICS     r0,r0,r3              ;1110
0000c8  6813              LDR      r3,[r2,#0]            ;1110
0000ca  6318              STR      r0,[r3,#0x30]         ;1110
0000cc  8808              LDRH     r0,[r1,#0]            ;1113
0000ce  b280              UXTH     r0,r0                 ;1113
0000d0  790b              LDRB     r3,[r1,#4]            ;1113
0000d2  1fdb              SUBS     r3,r3,#7              ;1113
0000d4  eb030383          ADD      r3,r3,r3,LSL #2       ;1113
0000d8  4098              LSLS     r0,r0,r3              ;1113
0000da  6813              LDR      r3,[r2,#0]            ;1113
0000dc  6b1b              LDR      r3,[r3,#0x30]         ;1113
0000de  4318              ORRS     r0,r0,r3              ;1113
0000e0  6813              LDR      r3,[r2,#0]            ;1113
0000e2  6318              STR      r0,[r3,#0x30]         ;1113
0000e4  e016              B        |L6.276|
                  |L6.230|
0000e6  6810              LDR      r0,[r2,#0]            ;1119
0000e8  6ac0              LDR      r0,[r0,#0x2c]         ;1119
0000ea  790b              LDRB     r3,[r1,#4]            ;1119
0000ec  3b0d              SUBS     r3,r3,#0xd            ;1119
0000ee  eb030483          ADD      r4,r3,r3,LSL #2       ;1119
0000f2  231f              MOVS     r3,#0x1f              ;1119
0000f4  40a3              LSLS     r3,r3,r4              ;1119
0000f6  4398              BICS     r0,r0,r3              ;1119
0000f8  6813              LDR      r3,[r2,#0]            ;1119
0000fa  62d8              STR      r0,[r3,#0x2c]         ;1119
0000fc  8808              LDRH     r0,[r1,#0]            ;1122
0000fe  b280              UXTH     r0,r0                 ;1122
000100  790b              LDRB     r3,[r1,#4]            ;1122
000102  3b0d              SUBS     r3,r3,#0xd            ;1122
000104  eb030383          ADD      r3,r3,r3,LSL #2       ;1122
000108  4098              LSLS     r0,r0,r3              ;1122
00010a  6813              LDR      r3,[r2,#0]            ;1122
00010c  6adb              LDR      r3,[r3,#0x2c]         ;1122
00010e  4318              ORRS     r0,r0,r3              ;1122
000110  6813              LDR      r3,[r2,#0]            ;1122
000112  62d8              STR      r0,[r3,#0x2c]         ;1122
                  |L6.276|
000114  4b1c              LDR      r3,|L6.392|
000116  6810              LDR      r0,[r2,#0]            ;1126
000118  4298              CMP      r0,r3                 ;1126
00011a  d108              BNE      |L6.302|
00011c  6808              LDR      r0,[r1,#0]            ;1126
00011e  2812              CMP      r0,#0x12              ;1126
000120  d105              BNE      |L6.302|
000122  481a              LDR      r0,|L6.396|
000124  6800              LDR      r0,[r0,#0]            ;1129
000126  f4400080          ORR      r0,r0,#0x400000       ;1129
00012a  f8c30304          STR      r0,[r3,#0x304]        ;1129
                  |L6.302|
00012e  4b16              LDR      r3,|L6.392|
000130  6810              LDR      r0,[r2,#0]            ;1133
000132  4298              CMP      r0,r3                 ;1133
000134  d120              BNE      |L6.376|
000136  4b16              LDR      r3,|L6.400|
000138  6808              LDR      r0,[r1,#0]            ;1133
00013a  4298              CMP      r0,r3                 ;1133
00013c  d002              BEQ      |L6.324|
00013e  6808              LDR      r0,[r1,#0]            ;1133
000140  2811              CMP      r0,#0x11              ;1133
000142  d119              BNE      |L6.376|
                  |L6.324|
000144  4811              LDR      r0,|L6.396|
000146  6800              LDR      r0,[r0,#0]            ;1136
000148  f4400000          ORR      r0,r0,#0x800000       ;1136
00014c  4b0f              LDR      r3,|L6.396|
00014e  6018              STR      r0,[r3,#0]            ;1136
000150  4b0f              LDR      r3,|L6.400|
000152  6808              LDR      r0,[r1,#0]            ;1138
000154  4298              CMP      r0,r3                 ;1138
000156  d10f              BNE      |L6.376|
000158  480e              LDR      r0,|L6.404|
00015a  6800              LDR      r0,[r0,#0]            ;1142  ; SystemCoreClock
00015c  4b0e              LDR      r3,|L6.408|
00015e  fbb0f0f3          UDIV     r0,r0,r3              ;1142
000162  eb000080          ADD      r0,r0,r0,LSL #2       ;1142
000166  0040              LSLS     r0,r0,#1              ;1142
000168  9000              STR      r0,[sp,#0]            ;1142
00016a  e002              B        |L6.370|
                  |L6.364|
00016c  9800              LDR      r0,[sp,#0]            ;1145
00016e  1e40              SUBS     r0,r0,#1              ;1145
000170  9000              STR      r0,[sp,#0]            ;1145
                  |L6.370|
000172  9800              LDR      r0,[sp,#0]            ;1143
000174  2800              CMP      r0,#0                 ;1143
000176  d1f9              BNE      |L6.364|
                  |L6.376|
000178  bf00              NOP                            ;1151
00017a  2000              MOVS     r0,#0                 ;1151
00017c  f882003c          STRB     r0,[r2,#0x3c]         ;1151
000180  bf00              NOP                            ;1151
000182  bf00              NOP                            ;1154
000184  e746              B        |L6.20|
;;;1156   
                          ENDP

000186  0000              DCW      0x0000
                  |L6.392|
                          DCD      0x40012000
                  |L6.396|
                          DCD      0x40012304
                  |L6.400|
                          DCD      0x10000012
                  |L6.404|
                          DCD      SystemCoreClock
                  |L6.408|
                          DCD      0x000f4240

                          AREA ||i.HAL_ADC_ConvCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_ADC_ConvCpltCallback PROC
;;;983      */
;;;984    __weak void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)
000000  4770              BX       lr
;;;985    {
;;;986      /* Prevent unused argument(s) compilation warning */
;;;987      UNUSED(hadc);
;;;988      /* NOTE : This function Should not be modified, when the callback is needed,
;;;989                the HAL_ADC_ConvCpltCallback could be implemented in the user file
;;;990       */
;;;991    }
;;;992    
                          ENDP


                          AREA ||i.HAL_ADC_ConvHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_ADC_ConvHalfCpltCallback PROC
;;;998      */
;;;999    __weak void HAL_ADC_ConvHalfCpltCallback(ADC_HandleTypeDef* hadc)
000000  4770              BX       lr
;;;1000   {
;;;1001     /* Prevent unused argument(s) compilation warning */
;;;1002     UNUSED(hadc);
;;;1003     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1004               the HAL_ADC_ConvHalfCpltCallback could be implemented in the user file
;;;1005      */
;;;1006   }
;;;1007   
                          ENDP


                          AREA ||i.HAL_ADC_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_ADC_DeInit PROC
;;;316      */
;;;317    HAL_StatusTypeDef HAL_ADC_DeInit(ADC_HandleTypeDef* hadc)
000000  b510              PUSH     {r4,lr}
;;;318    {
000002  4604              MOV      r4,r0
;;;319      /* Check ADC handle */
;;;320      if(hadc == NULL)
000004  b90c              CBNZ     r4,|L9.10|
;;;321      {
;;;322         return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L9.8|
;;;323      } 
;;;324      
;;;325      /* Check the parameters */
;;;326      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;327      
;;;328      /* Change ADC state */
;;;329      hadc->State = HAL_ADC_STATE_BUSY;
;;;330      
;;;331      /* DeInit the low level hardware */
;;;332      HAL_ADC_MspDeInit(hadc);
;;;333      
;;;334      /* Set ADC error code to none */
;;;335      hadc->ErrorCode = HAL_ADC_ERROR_NONE;
;;;336      
;;;337      /* Change ADC state */
;;;338      hadc->State = HAL_ADC_STATE_RESET;
;;;339      
;;;340      /* Return function status */
;;;341      return HAL_OK;
;;;342    }
000008  bd10              POP      {r4,pc}
                  |L9.10|
00000a  2002              MOVS     r0,#2                 ;329
00000c  f884003d          STRB     r0,[r4,#0x3d]         ;329
000010  4620              MOV      r0,r4                 ;332
000012  f7fffffe          BL       HAL_ADC_MspDeInit
000016  2000              MOVS     r0,#0                 ;335
000018  6420              STR      r0,[r4,#0x40]         ;335
00001a  f884003d          STRB     r0,[r4,#0x3d]         ;338
00001e  bf00              NOP                            ;341
000020  e7f2              B        |L9.8|
;;;343    
                          ENDP


                          AREA ||i.HAL_ADC_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_ADC_ErrorCallback PROC
;;;1028     */
;;;1029   __weak void HAL_ADC_ErrorCallback(ADC_HandleTypeDef *hadc)
000000  4770              BX       lr
;;;1030   {
;;;1031     /* Prevent unused argument(s) compilation warning */
;;;1032     UNUSED(hadc);
;;;1033     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1034               the HAL_ADC_ErrorCallback could be implemented in the user file
;;;1035      */
;;;1036   }
;;;1037   
                          ENDP


                          AREA ||i.HAL_ADC_GetError||, CODE, READONLY, ALIGN=1

                  HAL_ADC_GetError PROC
;;;1263     */
;;;1264   uint32_t HAL_ADC_GetError(ADC_HandleTypeDef *hadc)
000000  4601              MOV      r1,r0
;;;1265   {
;;;1266     return hadc->ErrorCode;
000002  6c08              LDR      r0,[r1,#0x40]
;;;1267   }
000004  4770              BX       lr
;;;1268   
                          ENDP


                          AREA ||i.HAL_ADC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_ADC_GetState PROC
;;;1251     */
;;;1252   HAL_ADC_StateTypeDef HAL_ADC_GetState(ADC_HandleTypeDef* hadc)
000000  4601              MOV      r1,r0
;;;1253   {
;;;1254     /* Return ADC state */
;;;1255     return hadc->State;
000002  f891003d          LDRB     r0,[r1,#0x3d]
;;;1256   }
000006  4770              BX       lr
;;;1257   
                          ENDP


                          AREA ||i.HAL_ADC_GetValue||, CODE, READONLY, ALIGN=1

                  HAL_ADC_GetValue PROC
;;;971      */
;;;972    uint32_t HAL_ADC_GetValue(ADC_HandleTypeDef* hadc)
000000  4601              MOV      r1,r0
;;;973    {       
;;;974      /* Return the selected ADC converted value */ 
;;;975      return hadc->Instance->DR;
000002  6808              LDR      r0,[r1,#0]
000004  6cc0              LDR      r0,[r0,#0x4c]
;;;976    }
000006  4770              BX       lr
;;;977    
                          ENDP


                          AREA ||i.HAL_ADC_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_ADC_IRQHandler PROC
;;;737      */
;;;738    void HAL_ADC_IRQHandler(ADC_HandleTypeDef* hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;739    {
000002  4604              MOV      r4,r0
;;;740      uint32_t tmp1 = 0, tmp2 = 0;
000004  2500              MOVS     r5,#0
000006  2600              MOVS     r6,#0
;;;741      
;;;742      /* Check the parameters */
;;;743      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
;;;744      assert_param(IS_ADC_REGULAR_LENGTH(hadc->Init.NbrOfConversion));
;;;745      assert_param(IS_ADC_EOCSelection(hadc->Init.EOCSelection));
;;;746      
;;;747      tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC);
000008  6820              LDR      r0,[r4,#0]
00000a  6800              LDR      r0,[r0,#0]
00000c  f3c00540          UBFX     r5,r0,#1,#1
;;;748      tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_EOC);
000010  6820              LDR      r0,[r4,#0]
000012  6840              LDR      r0,[r0,#4]
000014  f3c01640          UBFX     r6,r0,#5,#1
;;;749      /* Check End of conversion flag for regular channels */
;;;750      if(tmp1 && tmp2)
000018  2d00              CMP      r5,#0
00001a  d03e              BEQ      |L14.154|
00001c  2e00              CMP      r6,#0
00001e  d03c              BEQ      |L14.154|
;;;751      {
;;;752        /* Check if an injected conversion is ready */
;;;753        if(hadc->State == HAL_ADC_STATE_EOC_INJ)
000020  f894003d          LDRB     r0,[r4,#0x3d]
000024  2825              CMP      r0,#0x25
000026  d103              BNE      |L14.48|
;;;754        {
;;;755          /* Change ADC state */
;;;756          hadc->State = HAL_ADC_STATE_EOC_INJ_REG;  
000028  2035              MOVS     r0,#0x35
00002a  f884003d          STRB     r0,[r4,#0x3d]
00002e  e002              B        |L14.54|
                  |L14.48|
;;;757        }
;;;758        else
;;;759        {
;;;760          /* Change ADC state */
;;;761          hadc->State = HAL_ADC_STATE_EOC_REG;
000030  2015              MOVS     r0,#0x15
000032  f884003d          STRB     r0,[r4,#0x3d]
                  |L14.54|
;;;762        }
;;;763      
;;;764        if((hadc->Init.ContinuousConvMode == DISABLE) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
000036  69a0              LDR      r0,[r4,#0x18]
000038  bb40              CBNZ     r0,|L14.140|
00003a  6820              LDR      r0,[r4,#0]
00003c  6880              LDR      r0,[r0,#8]
00003e  f0005040          AND      r0,r0,#0x30000000
000042  bb18              CBNZ     r0,|L14.140|
;;;765        {
;;;766          if(hadc->Init.EOCSelection == ADC_EOC_SEQ_CONV)
000044  6960              LDR      r0,[r4,#0x14]
000046  b960              CBNZ     r0,|L14.98|
;;;767          {   
;;;768            /* DISABLE the ADC end of conversion interrupt for regular group */
;;;769            __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
000048  6820              LDR      r0,[r4,#0]
00004a  6840              LDR      r0,[r0,#4]
00004c  f0200020          BIC      r0,r0,#0x20
000050  6821              LDR      r1,[r4,#0]
000052  6048              STR      r0,[r1,#4]
;;;770            
;;;771            /* DISABLE the ADC overrun interrupt */
;;;772            __HAL_ADC_DISABLE_IT(hadc, ADC_IT_OVR);
000054  6820              LDR      r0,[r4,#0]
000056  6840              LDR      r0,[r0,#4]
000058  f0206080          BIC      r0,r0,#0x4000000
00005c  6821              LDR      r1,[r4,#0]
00005e  6048              STR      r0,[r1,#4]
000060  e014              B        |L14.140|
                  |L14.98|
;;;773          }
;;;774          else
;;;775          {
;;;776            if (hadc->NbrOfCurrentConversionRank == 0)
000062  6b60              LDR      r0,[r4,#0x34]
000064  b908              CBNZ     r0,|L14.106|
;;;777            {
;;;778              hadc->NbrOfCurrentConversionRank = hadc->Init.NbrOfConversion;
000066  6a20              LDR      r0,[r4,#0x20]
000068  6360              STR      r0,[r4,#0x34]
                  |L14.106|
;;;779            }
;;;780            
;;;781            /* Decrement the number of conversion when an interrupt occurs */
;;;782            hadc->NbrOfCurrentConversionRank--;
00006a  6b60              LDR      r0,[r4,#0x34]
00006c  1e40              SUBS     r0,r0,#1
00006e  6360              STR      r0,[r4,#0x34]
;;;783            
;;;784            /* Check if all conversions are finished */
;;;785            if(hadc->NbrOfCurrentConversionRank == 0)
000070  6b60              LDR      r0,[r4,#0x34]
000072  b958              CBNZ     r0,|L14.140|
;;;786            {
;;;787              /* DISABLE the ADC end of conversion interrupt for regular group */
;;;788              __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
000074  6820              LDR      r0,[r4,#0]
000076  6840              LDR      r0,[r0,#4]
000078  f0200020          BIC      r0,r0,#0x20
00007c  6821              LDR      r1,[r4,#0]
00007e  6048              STR      r0,[r1,#4]
;;;789              
;;;790              /* DISABLE the ADC overrun interrupt */
;;;791              __HAL_ADC_DISABLE_IT(hadc, ADC_IT_OVR);
000080  6820              LDR      r0,[r4,#0]
000082  6840              LDR      r0,[r0,#4]
000084  f0206080          BIC      r0,r0,#0x4000000
000088  6821              LDR      r1,[r4,#0]
00008a  6048              STR      r0,[r1,#4]
                  |L14.140|
;;;792            }
;;;793          }
;;;794        }
;;;795        
;;;796        /* Conversion complete callback */ 
;;;797        HAL_ADC_ConvCpltCallback(hadc);
00008c  4620              MOV      r0,r4
00008e  f7fffffe          BL       HAL_ADC_ConvCpltCallback
;;;798        
;;;799       /* Clear the ADCx flag for regular end of conversion */
;;;800        __HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
000092  f06f0002          MVN      r0,#2
000096  6821              LDR      r1,[r4,#0]
000098  6008              STR      r0,[r1,#0]
                  |L14.154|
;;;801      }
;;;802      
;;;803      tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOC);
00009a  6820              LDR      r0,[r4,#0]
00009c  6800              LDR      r0,[r0,#0]
00009e  f3c00580          UBFX     r5,r0,#2,#1
;;;804      tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_JEOC);                               
0000a2  6820              LDR      r0,[r4,#0]
0000a4  6840              LDR      r0,[r0,#4]
0000a6  f3c016c0          UBFX     r6,r0,#7,#1
;;;805      /* Check End of conversion flag for injected channels */
;;;806      if(tmp1 && tmp2)
0000aa  b355              CBZ      r5,|L14.258|
0000ac  b34e              CBZ      r6,|L14.258|
;;;807      {
;;;808        /* Check if a regular conversion is ready */
;;;809        if(hadc->State == HAL_ADC_STATE_EOC_REG)
0000ae  f894003d          LDRB     r0,[r4,#0x3d]
0000b2  2815              CMP      r0,#0x15
0000b4  d103              BNE      |L14.190|
;;;810        {
;;;811          /* Change ADC state */
;;;812          hadc->State = HAL_ADC_STATE_EOC_INJ_REG;  
0000b6  2035              MOVS     r0,#0x35
0000b8  f884003d          STRB     r0,[r4,#0x3d]
0000bc  e002              B        |L14.196|
                  |L14.190|
;;;813        }
;;;814        else
;;;815        {
;;;816          /* Change ADC state */
;;;817          hadc->State = HAL_ADC_STATE_EOC_INJ;
0000be  2025              MOVS     r0,#0x25
0000c0  f884003d          STRB     r0,[r4,#0x3d]
                  |L14.196|
;;;818        }
;;;819        
;;;820        tmp1 = HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO);
0000c4  6820              LDR      r0,[r4,#0]
0000c6  6840              LDR      r0,[r0,#4]
0000c8  2101              MOVS     r1,#1
0000ca  ea212590          BIC      r5,r1,r0,LSR #10
;;;821        tmp2 = HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_JEXTEN);
0000ce  6820              LDR      r0,[r4,#0]
0000d0  6880              LDR      r0,[r0,#8]
0000d2  f4001040          AND      r0,r0,#0x300000
0000d6  b908              CBNZ     r0,|L14.220|
0000d8  2001              MOVS     r0,#1
0000da  e000              B        |L14.222|
                  |L14.220|
0000dc  2000              MOVS     r0,#0
                  |L14.222|
0000de  4606              MOV      r6,r0
;;;822        if(((hadc->Init.ContinuousConvMode == DISABLE) || tmp1) && tmp2)
0000e0  69a0              LDR      r0,[r4,#0x18]
0000e2  b100              CBZ      r0,|L14.230|
0000e4  b135              CBZ      r5,|L14.244|
                  |L14.230|
0000e6  b12e              CBZ      r6,|L14.244|
;;;823        {
;;;824          /* DISABLE the ADC end of conversion interrupt for injected group */
;;;825          __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC);
0000e8  6820              LDR      r0,[r4,#0]
0000ea  6840              LDR      r0,[r0,#4]
0000ec  f0200080          BIC      r0,r0,#0x80
0000f0  6821              LDR      r1,[r4,#0]
0000f2  6048              STR      r0,[r1,#4]
                  |L14.244|
;;;826        }
;;;827        
;;;828        /* Conversion complete callback */ 
;;;829        HAL_ADCEx_InjectedConvCpltCallback(hadc);
0000f4  4620              MOV      r0,r4
0000f6  f7fffffe          BL       HAL_ADCEx_InjectedConvCpltCallback
;;;830        
;;;831       /* Clear the ADCx flag for injected end of conversion */
;;;832        __HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_JEOC);
0000fa  f06f0004          MVN      r0,#4
0000fe  6821              LDR      r1,[r4,#0]
000100  6008              STR      r0,[r1,#0]
                  |L14.258|
;;;833      }
;;;834      
;;;835      tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_AWD);
000102  6820              LDR      r0,[r4,#0]
000104  6800              LDR      r0,[r0,#0]
000106  f0000501          AND      r5,r0,#1
;;;836      tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_AWD);                          
00010a  6820              LDR      r0,[r4,#0]
00010c  6840              LDR      r0,[r0,#4]
00010e  f3c01680          UBFX     r6,r0,#6,#1
;;;837      /* Check Analog watchdog flag */
;;;838      if(tmp1 && tmp2)
000112  b155              CBZ      r5,|L14.298|
000114  b14e              CBZ      r6,|L14.298|
;;;839      {
;;;840        /* Change ADC state */
;;;841        hadc->State = HAL_ADC_STATE_AWD;
000116  2006              MOVS     r0,#6
000118  f884003d          STRB     r0,[r4,#0x3d]
;;;842          
;;;843        /* Clear the ADCx's Analog watchdog flag */
;;;844        __HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_AWD);
00011c  f06f0001          MVN      r0,#1
000120  6821              LDR      r1,[r4,#0]
000122  6008              STR      r0,[r1,#0]
;;;845        
;;;846        /* Level out of window callback */ 
;;;847        HAL_ADC_LevelOutOfWindowCallback(hadc);
000124  4620              MOV      r0,r4
000126  f7fffffe          BL       HAL_ADC_LevelOutOfWindowCallback
                  |L14.298|
;;;848      }
;;;849      
;;;850      tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_OVR);
00012a  6820              LDR      r0,[r4,#0]
00012c  6800              LDR      r0,[r0,#0]
00012e  f3c01540          UBFX     r5,r0,#5,#1
;;;851      tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_OVR);
000132  6820              LDR      r0,[r4,#0]
000134  6840              LDR      r0,[r0,#4]
000136  f3c06680          UBFX     r6,r0,#26,#1
;;;852      /* Check Overrun flag */
;;;853      if(tmp1 && tmp2)
00013a  b175              CBZ      r5,|L14.346|
00013c  b16e              CBZ      r6,|L14.346|
;;;854      {
;;;855        /* Change ADC state to overrun state */
;;;856        hadc->State = HAL_ADC_STATE_ERROR;
00013e  2004              MOVS     r0,#4
000140  f884003d          STRB     r0,[r4,#0x3d]
;;;857        
;;;858        /* Set ADC error code to overrun */
;;;859        hadc->ErrorCode |= HAL_ADC_ERROR_OVR;
000144  6c20              LDR      r0,[r4,#0x40]
000146  f0400001          ORR      r0,r0,#1
00014a  6420              STR      r0,[r4,#0x40]
;;;860        
;;;861        /* Clear the Overrun flag */
;;;862        __HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_OVR);
00014c  f06f0020          MVN      r0,#0x20
000150  6821              LDR      r1,[r4,#0]
000152  6008              STR      r0,[r1,#0]
;;;863        
;;;864        /* Error callback */ 
;;;865        HAL_ADC_ErrorCallback(hadc);
000154  4620              MOV      r0,r4
000156  f7fffffe          BL       HAL_ADC_ErrorCallback
                  |L14.346|
;;;866      }
;;;867    }
00015a  bd70              POP      {r4-r6,pc}
;;;868    
                          ENDP


                          AREA ||i.HAL_ADC_Init||, CODE, READONLY, ALIGN=2

                  HAL_ADC_Init PROC
;;;257      */
;;;258    HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef* hadc)
000000  b510              PUSH     {r4,lr}
;;;259    {
000002  4604              MOV      r4,r0
;;;260      /* Check ADC handle */
;;;261      if(hadc == NULL)
000004  b90c              CBNZ     r4,|L15.10|
;;;262      {
;;;263         return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L15.8|
;;;264      }
;;;265      
;;;266      /* Check the parameters */
;;;267      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;268      assert_param(IS_ADC_CLOCKPRESCALER(hadc->Init.ClockPrescaler));
;;;269      assert_param(IS_ADC_RESOLUTION(hadc->Init.Resolution));
;;;270      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ScanConvMode));
;;;271      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
;;;272      assert_param(IS_ADC_EXT_TRIG(hadc->Init.ExternalTrigConv));
;;;273      assert_param(IS_ADC_DATA_ALIGN(hadc->Init.DataAlign));
;;;274      assert_param(IS_ADC_REGULAR_LENGTH(hadc->Init.NbrOfConversion));
;;;275      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DMAContinuousRequests));
;;;276      assert_param(IS_ADC_EOCSelection(hadc->Init.EOCSelection));
;;;277      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DiscontinuousConvMode));
;;;278          
;;;279      if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
;;;280      {
;;;281        assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
;;;282      }
;;;283      
;;;284      if(hadc->State == HAL_ADC_STATE_RESET)
;;;285      {
;;;286        /* Allocate lock resource and initialize it */
;;;287        hadc->Lock = HAL_UNLOCKED;
;;;288        /* Init the low level hardware */
;;;289        HAL_ADC_MspInit(hadc);
;;;290      }
;;;291      
;;;292      /* Initialize the ADC state */
;;;293      hadc->State = HAL_ADC_STATE_BUSY;
;;;294      
;;;295      /* Set ADC parameters */
;;;296      ADC_Init(hadc);
;;;297      
;;;298      /* Set ADC error code to none */
;;;299      hadc->ErrorCode = HAL_ADC_ERROR_NONE;
;;;300      
;;;301      /* Initialize the ADC state */
;;;302      hadc->State = HAL_ADC_STATE_READY;
;;;303    
;;;304      /* Release Lock */
;;;305      __HAL_UNLOCK(hadc);
;;;306    
;;;307      /* Return function status */
;;;308      return HAL_OK;
;;;309    }
000008  bd10              POP      {r4,pc}
                  |L15.10|
00000a  4910              LDR      r1,|L15.76|
00000c  6ae0              LDR      r0,[r4,#0x2c]         ;279
00000e  4288              CMP      r0,r1                 ;279
000010  d000              BEQ      |L15.20|
000012  bf00              NOP                            ;281
                  |L15.20|
000014  f894003d          LDRB     r0,[r4,#0x3d]         ;284
000018  b928              CBNZ     r0,|L15.38|
00001a  2000              MOVS     r0,#0                 ;287
00001c  f884003c          STRB     r0,[r4,#0x3c]         ;287
000020  4620              MOV      r0,r4                 ;289
000022  f7fffffe          BL       HAL_ADC_MspInit
                  |L15.38|
000026  2002              MOVS     r0,#2                 ;293
000028  f884003d          STRB     r0,[r4,#0x3d]         ;293
00002c  4620              MOV      r0,r4                 ;296
00002e  f7fffffe          BL       ADC_Init
000032  2000              MOVS     r0,#0                 ;299
000034  6420              STR      r0,[r4,#0x40]         ;299
000036  2001              MOVS     r0,#1                 ;302
000038  f884003d          STRB     r0,[r4,#0x3d]         ;302
00003c  bf00              NOP                            ;305
00003e  2000              MOVS     r0,#0                 ;305
000040  f884003c          STRB     r0,[r4,#0x3c]         ;305
000044  bf00              NOP                            ;305
000046  bf00              NOP                            ;308
000048  e7de              B        |L15.8|
;;;310    
                          ENDP

00004a  0000              DCW      0x0000
                  |L15.76|
                          DCD      0x0f000001

                          AREA ||i.HAL_ADC_LevelOutOfWindowCallback||, CODE, READONLY, ALIGN=1

                  HAL_ADC_LevelOutOfWindowCallback PROC
;;;1013     */
;;;1014   __weak void HAL_ADC_LevelOutOfWindowCallback(ADC_HandleTypeDef* hadc)
000000  4770              BX       lr
;;;1015   {
;;;1016     /* Prevent unused argument(s) compilation warning */
;;;1017     UNUSED(hadc);
;;;1018     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1019               the HAL_ADC_LevelOoutOfWindowCallback could be implemented in the user file
;;;1020      */
;;;1021   }
;;;1022   
                          ENDP


                          AREA ||i.HAL_ADC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_ADC_MspDeInit PROC
;;;364      */
;;;365    __weak void HAL_ADC_MspDeInit(ADC_HandleTypeDef* hadc)
000000  4770              BX       lr
;;;366    {
;;;367      /* Prevent unused argument(s) compilation warning */
;;;368      UNUSED(hadc);
;;;369      /* NOTE : This function Should not be modified, when the callback is needed,
;;;370                the HAL_ADC_MspDeInit could be implemented in the user file
;;;371       */ 
;;;372    }
;;;373    
                          ENDP


                          AREA ||i.HAL_ADC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_ADC_MspInit PROC
;;;349      */
;;;350    __weak void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
000000  4770              BX       lr
;;;351    {
;;;352      /* Prevent unused argument(s) compilation warning */
;;;353      UNUSED(hadc);
;;;354      /* NOTE : This function Should not be modified, when the callback is needed,
;;;355                the HAL_ADC_MspInit could be implemented in the user file
;;;356       */ 
;;;357    }
;;;358    
                          ENDP


                          AREA ||i.HAL_ADC_PollForConversion||, CODE, READONLY, ALIGN=1

                  HAL_ADC_PollForConversion PROC
;;;506      */
;;;507    HAL_StatusTypeDef HAL_ADC_PollForConversion(ADC_HandleTypeDef* hadc, uint32_t Timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;508    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;509      uint32_t tickstart = 0;
000006  2600              MOVS     r6,#0
;;;510     
;;;511      /* Verification that ADC configuration is compliant with polling for      */
;;;512      /* each conversion:                                                       */
;;;513      /* Particular case is ADC configured in DMA mode and ADC sequencer with   */
;;;514      /* several ranks and polling for end of each conversion.                  */
;;;515      /* For code simplicity sake, this particular case is generalized to       */
;;;516      /* ADC configured in DMA mode and polling for end of each conversion.     */
;;;517      if (HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_EOCS) &&
000008  6820              LDR      r0,[r4,#0]
00000a  6880              LDR      r0,[r0,#8]
00000c  f4006080          AND      r0,r0,#0x400
000010  b170              CBZ      r0,|L19.48|
;;;518          HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_DMA)    )
000012  6820              LDR      r0,[r4,#0]
000014  6880              LDR      r0,[r0,#8]
000016  f4007080          AND      r0,r0,#0x100
00001a  b148              CBZ      r0,|L19.48|
;;;519      {
;;;520        /* Update ADC state machine to error */
;;;521        hadc->State = HAL_ADC_STATE_ERROR;
00001c  2004              MOVS     r0,#4
00001e  f884003d          STRB     r0,[r4,#0x3d]
;;;522        
;;;523        /* Process unlocked */
;;;524        __HAL_UNLOCK(hadc);
000022  bf00              NOP      
000024  2000              MOVS     r0,#0
000026  f884003c          STRB     r0,[r4,#0x3c]
00002a  bf00              NOP      
;;;525        
;;;526        return HAL_ERROR;
00002c  2001              MOVS     r0,#1
                  |L19.46|
;;;527      }
;;;528    
;;;529      /* Get tick */ 
;;;530      tickstart = HAL_GetTick();
;;;531    
;;;532      /* Check End of conversion flag */
;;;533      while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC)))
;;;534      {
;;;535        /* Check for the Timeout */
;;;536        if(Timeout != HAL_MAX_DELAY)
;;;537        {
;;;538          if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
;;;539          {
;;;540            hadc->State= HAL_ADC_STATE_TIMEOUT;
;;;541            /* Process unlocked */
;;;542            __HAL_UNLOCK(hadc);
;;;543            return HAL_TIMEOUT;
;;;544          }
;;;545        }
;;;546      }
;;;547      
;;;548      /* Check if an injected conversion is ready */
;;;549      if(hadc->State == HAL_ADC_STATE_EOC_INJ)
;;;550      {
;;;551        /* Change ADC state */
;;;552        hadc->State = HAL_ADC_STATE_EOC_INJ_REG;  
;;;553      }
;;;554      else
;;;555      {
;;;556        /* Change ADC state */
;;;557        hadc->State = HAL_ADC_STATE_EOC_REG;
;;;558      }
;;;559      
;;;560      /* Return ADC state */
;;;561      return HAL_OK;
;;;562    }
00002e  bd70              POP      {r4-r6,pc}
                  |L19.48|
000030  f7fffffe          BL       HAL_GetTick
000034  4606              MOV      r6,r0                 ;530
000036  e011              B        |L19.92|
                  |L19.56|
000038  1c68              ADDS     r0,r5,#1              ;536
00003a  b178              CBZ      r0,|L19.92|
00003c  b125              CBZ      r5,|L19.72|
00003e  f7fffffe          BL       HAL_GetTick
000042  1b80              SUBS     r0,r0,r6              ;538
000044  42a8              CMP      r0,r5                 ;538
000046  d909              BLS      |L19.92|
                  |L19.72|
000048  2003              MOVS     r0,#3                 ;540
00004a  f884003d          STRB     r0,[r4,#0x3d]         ;540
00004e  bf00              NOP                            ;542
000050  2000              MOVS     r0,#0                 ;542
000052  f884003c          STRB     r0,[r4,#0x3c]         ;542
000056  bf00              NOP                            ;542
000058  2003              MOVS     r0,#3                 ;543
00005a  e7e8              B        |L19.46|
                  |L19.92|
00005c  6820              LDR      r0,[r4,#0]            ;533
00005e  6800              LDR      r0,[r0,#0]            ;533
000060  f0000002          AND      r0,r0,#2              ;533
000064  2802              CMP      r0,#2                 ;533
000066  d1e7              BNE      |L19.56|
000068  f894003d          LDRB     r0,[r4,#0x3d]         ;549
00006c  2825              CMP      r0,#0x25              ;549
00006e  d103              BNE      |L19.120|
000070  2035              MOVS     r0,#0x35              ;552
000072  f884003d          STRB     r0,[r4,#0x3d]         ;552
000076  e002              B        |L19.126|
                  |L19.120|
000078  2015              MOVS     r0,#0x15              ;557
00007a  f884003d          STRB     r0,[r4,#0x3d]         ;557
                  |L19.126|
00007e  2000              MOVS     r0,#0                 ;561
000080  e7d5              B        |L19.46|
;;;563    
                          ENDP


                          AREA ||i.HAL_ADC_PollForEvent||, CODE, READONLY, ALIGN=1

                  HAL_ADC_PollForEvent PROC
;;;574      */
;;;575    HAL_StatusTypeDef HAL_ADC_PollForEvent(ADC_HandleTypeDef* hadc, uint32_t EventType, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;576    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;577      uint32_t tickstart = 0;
00000a  2700              MOVS     r7,#0
;;;578      
;;;579      /* Check the parameters */
;;;580      assert_param(IS_ADC_EVENT_TYPE(EventType));
;;;581    
;;;582      /* Get tick */
;;;583      tickstart = HAL_GetTick();
00000c  f7fffffe          BL       HAL_GetTick
000010  4607              MOV      r7,r0
;;;584    
;;;585      /* Check selected event flag */
;;;586      while(!(__HAL_ADC_GET_FLAG(hadc,EventType)))
000012  e012              B        |L20.58|
                  |L20.20|
;;;587      {
;;;588        /* Check for the Timeout */
;;;589        if(Timeout != HAL_MAX_DELAY)
000014  1c70              ADDS     r0,r6,#1
000016  b180              CBZ      r0,|L20.58|
;;;590        {
;;;591          if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
000018  b126              CBZ      r6,|L20.36|
00001a  f7fffffe          BL       HAL_GetTick
00001e  1bc0              SUBS     r0,r0,r7
000020  42b0              CMP      r0,r6
000022  d90a              BLS      |L20.58|
                  |L20.36|
;;;592          {
;;;593            hadc->State= HAL_ADC_STATE_TIMEOUT;
000024  2003              MOVS     r0,#3
000026  f884003d          STRB     r0,[r4,#0x3d]
;;;594            /* Process unlocked */
;;;595            __HAL_UNLOCK(hadc);
00002a  bf00              NOP      
00002c  2000              MOVS     r0,#0
00002e  f884003c          STRB     r0,[r4,#0x3c]
000032  bf00              NOP      
;;;596            return HAL_TIMEOUT;
000034  2003              MOVS     r0,#3
                  |L20.54|
;;;597          }
;;;598        }
;;;599      }
;;;600      
;;;601      /* Check analog watchdog flag */
;;;602      if(EventType == ADC_AWD_EVENT)
;;;603      {
;;;604         /* Change ADC state */
;;;605         hadc->State = HAL_ADC_STATE_AWD;
;;;606          
;;;607         /* Clear the ADCx's analog watchdog flag */
;;;608         __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD);
;;;609      }
;;;610      else
;;;611      {
;;;612         /* Change ADC state */
;;;613         hadc->State = HAL_ADC_STATE_ERROR;
;;;614         
;;;615         /* Clear the ADCx's Overrun flag */
;;;616         __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);
;;;617      }
;;;618      
;;;619      /* Return ADC state */
;;;620      return HAL_OK;
;;;621    }
000036  e8bd81f0          POP      {r4-r8,pc}
                  |L20.58|
00003a  6820              LDR      r0,[r4,#0]            ;586
00003c  6800              LDR      r0,[r0,#0]            ;586
00003e  4028              ANDS     r0,r0,r5              ;586
000040  42a8              CMP      r0,r5                 ;586
000042  d1e7              BNE      |L20.20|
000044  2d01              CMP      r5,#1                 ;602
000046  d106              BNE      |L20.86|
000048  2006              MOVS     r0,#6                 ;605
00004a  f884003d          STRB     r0,[r4,#0x3d]         ;605
00004e  1ee8              SUBS     r0,r5,#3              ;608
000050  6821              LDR      r1,[r4,#0]            ;608
000052  6008              STR      r0,[r1,#0]            ;608
000054  e006              B        |L20.100|
                  |L20.86|
000056  2004              MOVS     r0,#4                 ;613
000058  f884003d          STRB     r0,[r4,#0x3d]         ;613
00005c  f06f0020          MVN      r0,#0x20              ;616
000060  6821              LDR      r1,[r4,#0]            ;616
000062  6008              STR      r0,[r1,#0]            ;616
                  |L20.100|
000064  2000              MOVS     r0,#0                 ;620
000066  e7e6              B        |L20.54|
;;;622    
                          ENDP


                          AREA ||i.HAL_ADC_Start||, CODE, READONLY, ALIGN=2

                  HAL_ADC_Start PROC
;;;403      */
;;;404    HAL_StatusTypeDef HAL_ADC_Start(ADC_HandleTypeDef* hadc)
000000  b508              PUSH     {r3,lr}
;;;405    {
000002  4601              MOV      r1,r0
;;;406      __IO uint32_t counter = 0;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;407      
;;;408      /* Check the parameters */
;;;409      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
;;;410      assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge)); 
;;;411      
;;;412      /* Process locked */
;;;413      __HAL_LOCK(hadc);
000008  bf00              NOP      
00000a  f891003c          LDRB     r0,[r1,#0x3c]
00000e  2801              CMP      r0,#1
000010  d101              BNE      |L21.22|
000012  2002              MOVS     r0,#2
                  |L21.20|
;;;414      
;;;415      /* Check if an injected conversion is ongoing */
;;;416      if(hadc->State == HAL_ADC_STATE_BUSY_INJ)
;;;417      {
;;;418        /* Change ADC state */
;;;419        hadc->State = HAL_ADC_STATE_BUSY_INJ_REG;  
;;;420      }
;;;421      else
;;;422      {
;;;423        /* Change ADC state */
;;;424        hadc->State = HAL_ADC_STATE_BUSY_REG;
;;;425      } 
;;;426        
;;;427      /* Check if ADC peripheral is disabled in order to enable it and wait during 
;;;428      Tstab time the ADC's stabilization */
;;;429      if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
;;;430      {  
;;;431        /* Enable the Peripheral */
;;;432        __HAL_ADC_ENABLE(hadc);
;;;433        
;;;434        /* Delay for ADC stabilization time */
;;;435        /* Compute number of CPU cycles to wait for */
;;;436        counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
;;;437        while(counter != 0)
;;;438        {
;;;439          counter--;
;;;440        }
;;;441      }
;;;442      
;;;443      /* Process unlocked */
;;;444      __HAL_UNLOCK(hadc);
;;;445      
;;;446      /* Check if Multimode enabled */
;;;447      if(HAL_IS_BIT_CLR(ADC->CCR, ADC_CCR_MULTI))
;;;448      {
;;;449        /* if no external trigger present enable software conversion of regular channels */
;;;450        if((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET) 
;;;451        {
;;;452          /* Enable the selected ADC software conversion for regular group */
;;;453          hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
;;;454        }
;;;455      }
;;;456      else
;;;457      {
;;;458        /* if instance of handle correspond to ADC1 and  no external trigger present enable software conversion of regular channels */
;;;459        if((hadc->Instance == ADC1) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
;;;460        {
;;;461          /* Enable the selected ADC software conversion for regular group */
;;;462            hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
;;;463        }
;;;464      }
;;;465      
;;;466      /* Return function status */
;;;467      return HAL_OK;
;;;468    }
000014  bd08              POP      {r3,pc}
                  |L21.22|
000016  2001              MOVS     r0,#1                 ;413
000018  f881003c          STRB     r0,[r1,#0x3c]         ;413
00001c  bf00              NOP                            ;413
00001e  f891003d          LDRB     r0,[r1,#0x3d]         ;416
000022  2822              CMP      r0,#0x22              ;416
000024  d103              BNE      |L21.46|
000026  2032              MOVS     r0,#0x32              ;419
000028  f881003d          STRB     r0,[r1,#0x3d]         ;419
00002c  e002              B        |L21.52|
                  |L21.46|
00002e  2012              MOVS     r0,#0x12              ;424
000030  f881003d          STRB     r0,[r1,#0x3d]         ;424
                  |L21.52|
000034  6808              LDR      r0,[r1,#0]            ;429
000036  6880              LDR      r0,[r0,#8]            ;429
000038  f0000001          AND      r0,r0,#1              ;429
00003c  b9a0              CBNZ     r0,|L21.104|
00003e  6808              LDR      r0,[r1,#0]            ;432
000040  6880              LDR      r0,[r0,#8]            ;432
000042  f0400001          ORR      r0,r0,#1              ;432
000046  680a              LDR      r2,[r1,#0]            ;432
000048  6090              STR      r0,[r2,#8]            ;432
00004a  481b              LDR      r0,|L21.184|
00004c  6800              LDR      r0,[r0,#0]            ;436  ; SystemCoreClock
00004e  4a1b              LDR      r2,|L21.188|
000050  fbb0f0f2          UDIV     r0,r0,r2              ;436
000054  eb000040          ADD      r0,r0,r0,LSL #1       ;436
000058  9000              STR      r0,[sp,#0]            ;436
00005a  e002              B        |L21.98|
                  |L21.92|
00005c  9800              LDR      r0,[sp,#0]            ;439
00005e  1e40              SUBS     r0,r0,#1              ;439
000060  9000              STR      r0,[sp,#0]            ;439
                  |L21.98|
000062  9800              LDR      r0,[sp,#0]            ;437
000064  2800              CMP      r0,#0                 ;437
000066  d1f9              BNE      |L21.92|
                  |L21.104|
000068  bf00              NOP                            ;444
00006a  2000              MOVS     r0,#0                 ;444
00006c  f881003c          STRB     r0,[r1,#0x3c]         ;444
000070  bf00              NOP                            ;444
000072  4813              LDR      r0,|L21.192|
000074  6800              LDR      r0,[r0,#0]            ;447
000076  f000001f          AND      r0,r0,#0x1f           ;447
00007a  b958              CBNZ     r0,|L21.148|
00007c  6808              LDR      r0,[r1,#0]            ;450
00007e  6880              LDR      r0,[r0,#8]            ;450
000080  f0005040          AND      r0,r0,#0x30000000     ;450
000084  b9a8              CBNZ     r0,|L21.178|
000086  6808              LDR      r0,[r1,#0]            ;453
000088  6880              LDR      r0,[r0,#8]            ;453
00008a  f0404080          ORR      r0,r0,#0x40000000     ;453
00008e  680a              LDR      r2,[r1,#0]            ;453
000090  6090              STR      r0,[r2,#8]            ;453
000092  e00e              B        |L21.178|
                  |L21.148|
000094  4a0b              LDR      r2,|L21.196|
000096  6808              LDR      r0,[r1,#0]            ;459
000098  4290              CMP      r0,r2                 ;459
00009a  d10a              BNE      |L21.178|
00009c  6808              LDR      r0,[r1,#0]            ;459
00009e  6880              LDR      r0,[r0,#8]            ;459
0000a0  f0005040          AND      r0,r0,#0x30000000     ;459
0000a4  b928              CBNZ     r0,|L21.178|
0000a6  6808              LDR      r0,[r1,#0]            ;462
0000a8  6880              LDR      r0,[r0,#8]            ;462
0000aa  f0404080          ORR      r0,r0,#0x40000000     ;462
0000ae  680a              LDR      r2,[r1,#0]            ;462
0000b0  6090              STR      r0,[r2,#8]            ;462
                  |L21.178|
0000b2  2000              MOVS     r0,#0                 ;467
0000b4  e7ae              B        |L21.20|
;;;469    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L21.184|
                          DCD      SystemCoreClock
                  |L21.188|
                          DCD      0x000f4240
                  |L21.192|
                          DCD      0x40012304
                  |L21.196|
                          DCD      0x40012000

                          AREA ||i.HAL_ADC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_ADC_Start_DMA PROC
;;;876      */
;;;877    HAL_StatusTypeDef HAL_ADC_Start_DMA(ADC_HandleTypeDef* hadc, uint32_t* pData, uint32_t Length)
000000  b5f8              PUSH     {r3-r7,lr}
;;;878    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;879      __IO uint32_t counter = 0;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;880      
;;;881      /* Check the parameters */
;;;882      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
;;;883      assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
;;;884      
;;;885      /* Process locked */
;;;886      __HAL_LOCK(hadc);
00000c  bf00              NOP      
00000e  f894003c          LDRB     r0,[r4,#0x3c]
000012  2801              CMP      r0,#1
000014  d101              BNE      |L22.26|
000016  2002              MOVS     r0,#2
                  |L22.24|
;;;887      
;;;888      /* Enable ADC overrun interrupt */
;;;889      __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
;;;890      
;;;891      /* Enable ADC DMA mode */
;;;892      hadc->Instance->CR2 |= ADC_CR2_DMA;
;;;893      
;;;894      /* Set the DMA transfer complete callback */
;;;895      hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
;;;896      
;;;897      /* Set the DMA half transfer complete callback */
;;;898      hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
;;;899         
;;;900      /* Set the DMA error callback */
;;;901      hadc->DMA_Handle->XferErrorCallback = ADC_DMAError ;
;;;902      
;;;903      /* Enable the DMA Stream */
;;;904      HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
;;;905      
;;;906      /* Change ADC state */
;;;907      hadc->State = HAL_ADC_STATE_BUSY_REG;
;;;908      
;;;909      /* Process unlocked */
;;;910      __HAL_UNLOCK(hadc);
;;;911      
;;;912      /* Check if ADC peripheral is disabled in order to enable it and wait during 
;;;913         Tstab time the ADC's stabilization */
;;;914      if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
;;;915      {  
;;;916        /* Enable the Peripheral */
;;;917        __HAL_ADC_ENABLE(hadc);
;;;918        
;;;919        /* Delay for ADC stabilization time */
;;;920        /* Compute number of CPU cycles to wait for */
;;;921        counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
;;;922        while(counter != 0)
;;;923        {
;;;924          counter--;
;;;925        }
;;;926      }
;;;927      
;;;928      /* if no external trigger present enable software conversion of regular channels */
;;;929      if((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET)
;;;930      {
;;;931        /* Enable the selected ADC software conversion for regular group */
;;;932        hadc->Instance->CR2 |= ADC_CR2_SWSTART;
;;;933      }
;;;934      
;;;935      /* Return function status */
;;;936      return HAL_OK;
;;;937    }
000018  bdf8              POP      {r3-r7,pc}
                  |L22.26|
00001a  2001              MOVS     r0,#1                 ;886
00001c  f884003c          STRB     r0,[r4,#0x3c]         ;886
000020  bf00              NOP                            ;886
000022  6820              LDR      r0,[r4,#0]            ;889
000024  6840              LDR      r0,[r0,#4]            ;889
000026  f0406080          ORR      r0,r0,#0x4000000      ;889
00002a  6821              LDR      r1,[r4,#0]            ;889
00002c  6048              STR      r0,[r1,#4]            ;889
00002e  6820              LDR      r0,[r4,#0]            ;892
000030  6880              LDR      r0,[r0,#8]            ;892
000032  f4407080          ORR      r0,r0,#0x100          ;892
000036  6821              LDR      r1,[r4,#0]            ;892
000038  6088              STR      r0,[r1,#8]            ;892
00003a  4820              LDR      r0,|L22.188|
00003c  6ba1              LDR      r1,[r4,#0x38]         ;895
00003e  63c8              STR      r0,[r1,#0x3c]         ;895
000040  481f              LDR      r0,|L22.192|
000042  6ba1              LDR      r1,[r4,#0x38]         ;898
000044  6408              STR      r0,[r1,#0x40]         ;898
000046  481f              LDR      r0,|L22.196|
000048  6ba1              LDR      r1,[r4,#0x38]         ;901
00004a  6488              STR      r0,[r1,#0x48]         ;901
00004c  6822              LDR      r2,[r4,#0]            ;904
00004e  f102014c          ADD      r1,r2,#0x4c           ;904
000052  4633              MOV      r3,r6                 ;904
000054  462a              MOV      r2,r5                 ;904
000056  6ba0              LDR      r0,[r4,#0x38]         ;904
000058  f7fffffe          BL       HAL_DMA_Start_IT
00005c  2012              MOVS     r0,#0x12              ;907
00005e  f884003d          STRB     r0,[r4,#0x3d]         ;907
000062  bf00              NOP                            ;910
000064  2000              MOVS     r0,#0                 ;910
000066  f884003c          STRB     r0,[r4,#0x3c]         ;910
00006a  bf00              NOP                            ;910
00006c  6820              LDR      r0,[r4,#0]            ;914
00006e  6880              LDR      r0,[r0,#8]            ;914
000070  f0000001          AND      r0,r0,#1              ;914
000074  b9a0              CBNZ     r0,|L22.160|
000076  6820              LDR      r0,[r4,#0]            ;917
000078  6880              LDR      r0,[r0,#8]            ;917
00007a  f0400001          ORR      r0,r0,#1              ;917
00007e  6821              LDR      r1,[r4,#0]            ;917
000080  6088              STR      r0,[r1,#8]            ;917
000082  4811              LDR      r0,|L22.200|
000084  6800              LDR      r0,[r0,#0]            ;921  ; SystemCoreClock
000086  4911              LDR      r1,|L22.204|
000088  fbb0f0f1          UDIV     r0,r0,r1              ;921
00008c  eb000040          ADD      r0,r0,r0,LSL #1       ;921
000090  9000              STR      r0,[sp,#0]            ;921
000092  e002              B        |L22.154|
                  |L22.148|
000094  9800              LDR      r0,[sp,#0]            ;924
000096  1e40              SUBS     r0,r0,#1              ;924
000098  9000              STR      r0,[sp,#0]            ;924
                  |L22.154|
00009a  9800              LDR      r0,[sp,#0]            ;922
00009c  2800              CMP      r0,#0                 ;922
00009e  d1f9              BNE      |L22.148|
                  |L22.160|
0000a0  6820              LDR      r0,[r4,#0]            ;929
0000a2  6880              LDR      r0,[r0,#8]            ;929
0000a4  f0005040          AND      r0,r0,#0x30000000     ;929
0000a8  b928              CBNZ     r0,|L22.182|
0000aa  6820              LDR      r0,[r4,#0]            ;932
0000ac  6880              LDR      r0,[r0,#8]            ;932
0000ae  f0404080          ORR      r0,r0,#0x40000000     ;932
0000b2  6821              LDR      r1,[r4,#0]            ;932
0000b4  6088              STR      r0,[r1,#8]            ;932
                  |L22.182|
0000b6  2000              MOVS     r0,#0                 ;936
0000b8  e7ae              B        |L22.24|
;;;938    
                          ENDP

0000ba  0000              DCW      0x0000
                  |L22.188|
                          DCD      ADC_DMAConvCplt
                  |L22.192|
                          DCD      ADC_DMAHalfConvCplt
                  |L22.196|
                          DCD      ADC_DMAError
                  |L22.200|
                          DCD      SystemCoreClock
                  |L22.204|
                          DCD      0x000f4240

                          AREA ||i.HAL_ADC_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_ADC_Start_IT PROC
;;;629      */
;;;630    HAL_StatusTypeDef HAL_ADC_Start_IT(ADC_HandleTypeDef* hadc)
000000  b508              PUSH     {r3,lr}
;;;631    {
000002  4601              MOV      r1,r0
;;;632      __IO uint32_t counter = 0;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;633      
;;;634      /* Check the parameters */
;;;635      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
;;;636      assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
;;;637      
;;;638      /* Process locked */
;;;639      __HAL_LOCK(hadc);
000008  bf00              NOP      
00000a  f891003c          LDRB     r0,[r1,#0x3c]
00000e  2801              CMP      r0,#1
000010  d101              BNE      |L23.22|
000012  2002              MOVS     r0,#2
                  |L23.20|
;;;640      
;;;641      /* Check if an injected conversion is ongoing */
;;;642      if(hadc->State == HAL_ADC_STATE_BUSY_INJ)
;;;643      {
;;;644        /* Change ADC state */
;;;645        hadc->State = HAL_ADC_STATE_BUSY_INJ_REG;  
;;;646      }
;;;647      else
;;;648      {
;;;649        /* Change ADC state */
;;;650        hadc->State = HAL_ADC_STATE_BUSY_REG;
;;;651      } 
;;;652      
;;;653      /* Set ADC error code to none */
;;;654      hadc->ErrorCode = HAL_ADC_ERROR_NONE;
;;;655      
;;;656      /* Check if ADC peripheral is disabled in order to enable it and wait during 
;;;657         Tstab time the ADC's stabilization */
;;;658      if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
;;;659      {  
;;;660        /* Enable the Peripheral */
;;;661        __HAL_ADC_ENABLE(hadc);
;;;662        
;;;663        /* Delay for ADC stabilization time */
;;;664        /* Compute number of CPU cycles to wait for */
;;;665        counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
;;;666        while(counter != 0)
;;;667        {
;;;668          counter--;
;;;669        }
;;;670      }
;;;671      
;;;672      /* Enable the ADC overrun interrupt */
;;;673      __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
;;;674      
;;;675      /* Enable the ADC end of conversion interrupt for regular group */
;;;676      __HAL_ADC_ENABLE_IT(hadc, ADC_IT_EOC);
;;;677      
;;;678      /* Process unlocked */
;;;679      __HAL_UNLOCK(hadc);
;;;680      
;;;681      /* Check if Multimode enabled */
;;;682      if(HAL_IS_BIT_CLR(ADC->CCR, ADC_CCR_MULTI))
;;;683      {
;;;684        /* if no external trigger present enable software conversion of regular channels */
;;;685        if((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET) 
;;;686        {
;;;687          /* Enable the selected ADC software conversion for regular group */
;;;688          hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
;;;689        }
;;;690      }
;;;691      else
;;;692      {
;;;693        /* if instance of handle correspond to ADC1 and  no external trigger present enable software conversion of regular channels */
;;;694        if((hadc->Instance == (ADC_TypeDef*)0x40012000) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
;;;695        {
;;;696          /* Enable the selected ADC software conversion for regular group */
;;;697            hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
;;;698        }
;;;699      }
;;;700    
;;;701      /* Return function status */
;;;702      return HAL_OK;
;;;703    }
000014  bd08              POP      {r3,pc}
                  |L23.22|
000016  2001              MOVS     r0,#1                 ;639
000018  f881003c          STRB     r0,[r1,#0x3c]         ;639
00001c  bf00              NOP                            ;639
00001e  f891003d          LDRB     r0,[r1,#0x3d]         ;642
000022  2822              CMP      r0,#0x22              ;642
000024  d103              BNE      |L23.46|
000026  2032              MOVS     r0,#0x32              ;645
000028  f881003d          STRB     r0,[r1,#0x3d]         ;645
00002c  e002              B        |L23.52|
                  |L23.46|
00002e  2012              MOVS     r0,#0x12              ;650
000030  f881003d          STRB     r0,[r1,#0x3d]         ;650
                  |L23.52|
000034  2000              MOVS     r0,#0                 ;654
000036  6408              STR      r0,[r1,#0x40]         ;654
000038  6808              LDR      r0,[r1,#0]            ;658
00003a  6880              LDR      r0,[r0,#8]            ;658
00003c  f0000001          AND      r0,r0,#1              ;658
000040  b9a0              CBNZ     r0,|L23.108|
000042  6808              LDR      r0,[r1,#0]            ;661
000044  6880              LDR      r0,[r0,#8]            ;661
000046  f0400001          ORR      r0,r0,#1              ;661
00004a  680a              LDR      r2,[r1,#0]            ;661
00004c  6090              STR      r0,[r2,#8]            ;661
00004e  4821              LDR      r0,|L23.212|
000050  6800              LDR      r0,[r0,#0]            ;665  ; SystemCoreClock
000052  4a21              LDR      r2,|L23.216|
000054  fbb0f0f2          UDIV     r0,r0,r2              ;665
000058  eb000040          ADD      r0,r0,r0,LSL #1       ;665
00005c  9000              STR      r0,[sp,#0]            ;665
00005e  e002              B        |L23.102|
                  |L23.96|
000060  9800              LDR      r0,[sp,#0]            ;668
000062  1e40              SUBS     r0,r0,#1              ;668
000064  9000              STR      r0,[sp,#0]            ;668
                  |L23.102|
000066  9800              LDR      r0,[sp,#0]            ;666
000068  2800              CMP      r0,#0                 ;666
00006a  d1f9              BNE      |L23.96|
                  |L23.108|
00006c  6808              LDR      r0,[r1,#0]            ;673
00006e  6840              LDR      r0,[r0,#4]            ;673
000070  f0406080          ORR      r0,r0,#0x4000000      ;673
000074  680a              LDR      r2,[r1,#0]            ;673
000076  6050              STR      r0,[r2,#4]            ;673
000078  6808              LDR      r0,[r1,#0]            ;676
00007a  6840              LDR      r0,[r0,#4]            ;676
00007c  f0400020          ORR      r0,r0,#0x20           ;676
000080  680a              LDR      r2,[r1,#0]            ;676
000082  6050              STR      r0,[r2,#4]            ;676
000084  bf00              NOP                            ;679
000086  2000              MOVS     r0,#0                 ;679
000088  f881003c          STRB     r0,[r1,#0x3c]         ;679
00008c  bf00              NOP                            ;679
00008e  4813              LDR      r0,|L23.220|
000090  6800              LDR      r0,[r0,#0]            ;682
000092  f000001f          AND      r0,r0,#0x1f           ;682
000096  b958              CBNZ     r0,|L23.176|
000098  6808              LDR      r0,[r1,#0]            ;685
00009a  6880              LDR      r0,[r0,#8]            ;685
00009c  f0005040          AND      r0,r0,#0x30000000     ;685
0000a0  b9a8              CBNZ     r0,|L23.206|
0000a2  6808              LDR      r0,[r1,#0]            ;688
0000a4  6880              LDR      r0,[r0,#8]            ;688
0000a6  f0404080          ORR      r0,r0,#0x40000000     ;688
0000aa  680a              LDR      r2,[r1,#0]            ;688
0000ac  6090              STR      r0,[r2,#8]            ;688
0000ae  e00e              B        |L23.206|
                  |L23.176|
0000b0  4a0b              LDR      r2,|L23.224|
0000b2  6808              LDR      r0,[r1,#0]            ;694
0000b4  4290              CMP      r0,r2                 ;694
0000b6  d10a              BNE      |L23.206|
0000b8  6808              LDR      r0,[r1,#0]            ;694
0000ba  6880              LDR      r0,[r0,#8]            ;694
0000bc  f0005040          AND      r0,r0,#0x30000000     ;694
0000c0  b928              CBNZ     r0,|L23.206|
0000c2  6808              LDR      r0,[r1,#0]            ;697
0000c4  6880              LDR      r0,[r0,#8]            ;697
0000c6  f0404080          ORR      r0,r0,#0x40000000     ;697
0000ca  680a              LDR      r2,[r1,#0]            ;697
0000cc  6090              STR      r0,[r2,#8]            ;697
                  |L23.206|
0000ce  2000              MOVS     r0,#0                 ;702
0000d0  e7a0              B        |L23.20|
;;;704    
                          ENDP

0000d2  0000              DCW      0x0000
                  |L23.212|
                          DCD      SystemCoreClock
                  |L23.216|
                          DCD      0x000f4240
                  |L23.220|
                          DCD      0x40012304
                  |L23.224|
                          DCD      0x40012000

                          AREA ||i.HAL_ADC_Stop||, CODE, READONLY, ALIGN=1

                  HAL_ADC_Stop PROC
;;;479      */
;;;480    HAL_StatusTypeDef HAL_ADC_Stop(ADC_HandleTypeDef* hadc)
000000  4601              MOV      r1,r0
;;;481    {
;;;482      /* Disable the Peripheral */
;;;483      __HAL_ADC_DISABLE(hadc);
000002  6808              LDR      r0,[r1,#0]
000004  6880              LDR      r0,[r0,#8]
000006  f0200001          BIC      r0,r0,#1
00000a  680a              LDR      r2,[r1,#0]
00000c  6090              STR      r0,[r2,#8]
;;;484      
;;;485      /* Change ADC state */
;;;486      hadc->State = HAL_ADC_STATE_READY;
00000e  2001              MOVS     r0,#1
000010  f881003d          STRB     r0,[r1,#0x3d]
;;;487      
;;;488      /* Return function status */
;;;489      return HAL_OK;
000014  2000              MOVS     r0,#0
;;;490    }
000016  4770              BX       lr
;;;491    
                          ENDP


                          AREA ||i.HAL_ADC_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_ADC_Stop_DMA PROC
;;;944      */
;;;945    HAL_StatusTypeDef HAL_ADC_Stop_DMA(ADC_HandleTypeDef* hadc)
000000  b510              PUSH     {r4,lr}
;;;946    {
000002  4604              MOV      r4,r0
;;;947      /* Disable the Peripheral */
;;;948      __HAL_ADC_DISABLE(hadc);
000004  6820              LDR      r0,[r4,#0]
000006  6880              LDR      r0,[r0,#8]
000008  f0200001          BIC      r0,r0,#1
00000c  6821              LDR      r1,[r4,#0]
00000e  6088              STR      r0,[r1,#8]
;;;949      
;;;950      /* Disable ADC overrun interrupt */
;;;951      __HAL_ADC_DISABLE_IT(hadc, ADC_IT_OVR);
000010  6820              LDR      r0,[r4,#0]
000012  6840              LDR      r0,[r0,#4]
000014  f0206080          BIC      r0,r0,#0x4000000
000018  6821              LDR      r1,[r4,#0]
00001a  6048              STR      r0,[r1,#4]
;;;952      
;;;953      /* Disable the selected ADC DMA mode */
;;;954      hadc->Instance->CR2 &= ~ADC_CR2_DMA;
00001c  6820              LDR      r0,[r4,#0]
00001e  6880              LDR      r0,[r0,#8]
000020  f4207080          BIC      r0,r0,#0x100
000024  6821              LDR      r1,[r4,#0]
000026  6088              STR      r0,[r1,#8]
;;;955      
;;;956      /* Disable the ADC DMA Stream */
;;;957      HAL_DMA_Abort(hadc->DMA_Handle);
000028  6ba0              LDR      r0,[r4,#0x38]
00002a  f7fffffe          BL       HAL_DMA_Abort
;;;958      
;;;959      /* Change ADC state */
;;;960      hadc->State = HAL_ADC_STATE_READY;
00002e  2001              MOVS     r0,#1
000030  f884003d          STRB     r0,[r4,#0x3d]
;;;961      
;;;962      /* Return function status */
;;;963      return HAL_OK;
000034  2000              MOVS     r0,#0
;;;964    }
000036  bd10              POP      {r4,pc}
;;;965    
                          ENDP


                          AREA ||i.HAL_ADC_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_ADC_Stop_IT PROC
;;;713      */
;;;714    HAL_StatusTypeDef HAL_ADC_Stop_IT(ADC_HandleTypeDef* hadc)
000000  4601              MOV      r1,r0
;;;715    {
;;;716      /* Disable the ADC end of conversion interrupt for regular group */
;;;717      __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
000002  6808              LDR      r0,[r1,#0]
000004  6840              LDR      r0,[r0,#4]
000006  f0200020          BIC      r0,r0,#0x20
00000a  680a              LDR      r2,[r1,#0]
00000c  6050              STR      r0,[r2,#4]
;;;718      
;;;719      /* Disable the ADC end of conversion interrupt for injected group */
;;;720      __HAL_ADC_DISABLE_IT(hadc, ADC_CR1_JEOCIE);
00000e  6808              LDR      r0,[r1,#0]
000010  6840              LDR      r0,[r0,#4]
000012  f0200080          BIC      r0,r0,#0x80
000016  680a              LDR      r2,[r1,#0]
000018  6050              STR      r0,[r2,#4]
;;;721      
;;;722      /* Enable the Peripheral */
;;;723      __HAL_ADC_DISABLE(hadc);
00001a  6808              LDR      r0,[r1,#0]
00001c  6880              LDR      r0,[r0,#8]
00001e  f0200001          BIC      r0,r0,#1
000022  680a              LDR      r2,[r1,#0]
000024  6090              STR      r0,[r2,#8]
;;;724      
;;;725      /* Change ADC state */
;;;726      hadc->State = HAL_ADC_STATE_READY;
000026  2001              MOVS     r0,#1
000028  f881003d          STRB     r0,[r1,#0x3d]
;;;727      
;;;728      /* Return function status */
;;;729      return HAL_OK;
00002c  2000              MOVS     r0,#0
;;;730    }
00002e  4770              BX       lr
;;;731    
                          ENDP


;*** Start embedded assembler ***

#line 1 "HALLIB\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_adc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_adc_c_52ef8f50____REV16|
#line 388 ".\\CORE\\cmsis_armcc.h"
|__asm___19_stm32f4xx_hal_adc_c_52ef8f50____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_adc_c_52ef8f50____REVSH|
#line 402
|__asm___19_stm32f4xx_hal_adc_c_52ef8f50____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_adc_c_52ef8f50____RRX|
#line 587
|__asm___19_stm32f4xx_hal_adc_c_52ef8f50____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
