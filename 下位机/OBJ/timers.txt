; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\timers.o --asm_dir=.\OBJ\ --list_dir=.\OBJ\ --depend=.\obj\timers.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I.\CORE -I.\USER -I.\HALLIB\STM32F4xx_HAL_Driver\Inc -I.\SYSTEM -I.\Hardware -I.\App -I.\DSP_LIB\Include -I.\FreeRTOS -I.\MPU9250\DMP -I.\MPU9250 -I.\RTE\_Project -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=526 -DSTM32F427xx -DSTM32F4 -DUSE_HAL_DRIVER -DSTM32F427xx -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=.\obj\timers.crf FreeRTOS\timers.c]
                          THUMB

                          AREA ||i.pcTimerGetName||, CODE, READONLY, ALIGN=1

                  pcTimerGetName PROC
;;;456    
;;;457    const char * pcTimerGetName( TimerHandle_t xTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000000  4601              MOV      r1,r0
;;;458    {
;;;459    Timer_t *pxTimer = xTimer;
000002  460a              MOV      r2,r1
;;;460    
;;;461    	configASSERT( xTimer );
000004  b951              CBNZ     r1,|L1.28|
000006  bf00              NOP      
000008  2040              MOVS     r0,#0x40
00000a  f3808811          MSR      BASEPRI,r0
00000e  f3bf8f4f          DSB      
000012  f3bf8f6f          ISB      
000016  bf00              NOP      
000018  bf00              NOP      
                  |L1.26|
00001a  e7fe              B        |L1.26|
                  |L1.28|
;;;462    	return pxTimer->pcTimerName;
00001c  6810              LDR      r0,[r2,#0]
;;;463    }
00001e  4770              BX       lr
;;;464    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvCheckForValidListAndQueue||, CODE, READONLY, ALIGN=2

                  prvCheckForValidListAndQueue PROC
;;;897    
;;;898    static void prvCheckForValidListAndQueue( void )
000000  b510              PUSH     {r4,lr}
;;;899    {
;;;900    	/* Check that the list from which active timers are referenced, and the
;;;901    	queue used to communicate with the timer service, have been
;;;902    	initialised. */
;;;903    	taskENTER_CRITICAL();
000002  f7fffffe          BL       vPortEnterCritical
;;;904    	{
;;;905    		if( xTimerQueue == NULL )
000006  4810              LDR      r0,|L2.72|
000008  6800              LDR      r0,[r0,#0]  ; xTimerQueue
00000a  b9d0              CBNZ     r0,|L2.66|
;;;906    		{
;;;907    			vListInitialise( &xActiveTimerList1 );
00000c  480f              LDR      r0,|L2.76|
00000e  f7fffffe          BL       vListInitialise
;;;908    			vListInitialise( &xActiveTimerList2 );
000012  480f              LDR      r0,|L2.80|
000014  f7fffffe          BL       vListInitialise
;;;909    			pxCurrentTimerList = &xActiveTimerList1;
000018  480c              LDR      r0,|L2.76|
00001a  490e              LDR      r1,|L2.84|
00001c  6008              STR      r0,[r1,#0]  ; pxCurrentTimerList
;;;910    			pxOverflowTimerList = &xActiveTimerList2;
00001e  480c              LDR      r0,|L2.80|
000020  490d              LDR      r1,|L2.88|
000022  6008              STR      r0,[r1,#0]  ; pxOverflowTimerList
;;;911    
;;;912    			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;913    			{
;;;914    				/* The timer queue is allocated statically in case
;;;915    				configSUPPORT_DYNAMIC_ALLOCATION is 0. */
;;;916    				static StaticQueue_t xStaticTimerQueue; /*lint !e956 Ok to declare in this manner to prevent additional conditional compilation guards in other locations. */
;;;917    				static uint8_t ucStaticTimerQueueStorage[ ( size_t ) configTIMER_QUEUE_LENGTH * sizeof( DaemonTaskMessage_t ) ]; /*lint !e956 Ok to declare in this manner to prevent additional conditional compilation guards in other locations. */
;;;918    
;;;919    				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
;;;920    			}
;;;921    			#else
;;;922    			{
;;;923    				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
000024  2200              MOVS     r2,#0
000026  210c              MOVS     r1,#0xc
000028  200a              MOVS     r0,#0xa
00002a  f7fffffe          BL       xQueueGenericCreate
00002e  4906              LDR      r1,|L2.72|
000030  6008              STR      r0,[r1,#0]  ; xTimerQueue
;;;924    			}
;;;925    			#endif
;;;926    
;;;927    			#if ( configQUEUE_REGISTRY_SIZE > 0 )
;;;928    			{
;;;929    				if( xTimerQueue != NULL )
000032  4608              MOV      r0,r1
000034  6800              LDR      r0,[r0,#0]  ; xTimerQueue
000036  b120              CBZ      r0,|L2.66|
;;;930    				{
;;;931    					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
000038  a108              ADR      r1,|L2.92|
00003a  4803              LDR      r0,|L2.72|
00003c  6800              LDR      r0,[r0,#0]  ; xTimerQueue
00003e  f7fffffe          BL       vQueueAddToRegistry
                  |L2.66|
;;;932    				}
;;;933    				else
;;;934    				{
;;;935    					mtCOVERAGE_TEST_MARKER();
;;;936    				}
;;;937    			}
;;;938    			#endif /* configQUEUE_REGISTRY_SIZE */
;;;939    		}
;;;940    		else
;;;941    		{
;;;942    			mtCOVERAGE_TEST_MARKER();
;;;943    		}
;;;944    	}
;;;945    	taskEXIT_CRITICAL();
000042  f7fffffe          BL       vPortExitCritical
;;;946    }
000046  bd10              POP      {r4,pc}
;;;947    /*-----------------------------------------------------------*/
                          ENDP

                  |L2.72|
                          DCD      xTimerQueue
                  |L2.76|
                          DCD      xActiveTimerList1
                  |L2.80|
                          DCD      xActiveTimerList2
                  |L2.84|
                          DCD      pxCurrentTimerList
                  |L2.88|
                          DCD      pxOverflowTimerList
                  |L2.92|
00005c  546d7251          DCB      "TmrQ",0
000060  00      
000061  00                DCB      0
000062  00                DCB      0
000063  00                DCB      0

                          AREA ||i.prvGetNextExpireTime||, CODE, READONLY, ALIGN=2

                  prvGetNextExpireTime PROC
;;;601    
;;;602    static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
000000  4601              MOV      r1,r0
;;;603    {
;;;604    TickType_t xNextExpireTime;
;;;605    
;;;606    	/* Timers are listed in expiry time order, with the head of the list
;;;607    	referencing the task that will expire first.  Obtain the time at which
;;;608    	the timer with the nearest expiry time will expire.  If there are no
;;;609    	active timers then just set the next expire time to 0.  That will cause
;;;610    	this task to unblock when the tick count overflows, at which point the
;;;611    	timer lists will be switched and the next expiry time can be
;;;612    	re-assessed.  */
;;;613    	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
000002  4a08              LDR      r2,|L3.36|
000004  6812              LDR      r2,[r2,#0]  ; pxCurrentTimerList
000006  6812              LDR      r2,[r2,#0]
000008  b90a              CBNZ     r2,|L3.14|
00000a  2201              MOVS     r2,#1
00000c  e000              B        |L3.16|
                  |L3.14|
00000e  2200              MOVS     r2,#0
                  |L3.16|
000010  600a              STR      r2,[r1,#0]
;;;614    	if( *pxListWasEmpty == pdFALSE )
000012  680a              LDR      r2,[r1,#0]
000014  b922              CBNZ     r2,|L3.32|
;;;615    	{
;;;616    		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
000016  4a03              LDR      r2,|L3.36|
000018  6812              LDR      r2,[r2,#0]  ; pxCurrentTimerList
00001a  68d2              LDR      r2,[r2,#0xc]
00001c  6810              LDR      r0,[r2,#0]
00001e  e000              B        |L3.34|
                  |L3.32|
;;;617    	}
;;;618    	else
;;;619    	{
;;;620    		/* Ensure the task unblocks when the tick count rolls over. */
;;;621    		xNextExpireTime = ( TickType_t ) 0U;
000020  2000              MOVS     r0,#0
                  |L3.34|
;;;622    	}
;;;623    
;;;624    	return xNextExpireTime;
;;;625    }
000022  4770              BX       lr
;;;626    /*-----------------------------------------------------------*/
                          ENDP

                  |L3.36|
                          DCD      pxCurrentTimerList

                          AREA ||i.prvInitialiseNewTimer||, CODE, READONLY, ALIGN=1

                  prvInitialiseNewTimer PROC
;;;355    
;;;356    static void prvInitialiseNewTimer(	const char * const pcTimerName,			/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;357    									const TickType_t xTimerPeriodInTicks,
;;;358    									const UBaseType_t uxAutoReload,
;;;359    									void * const pvTimerID,
;;;360    									TimerCallbackFunction_t pxCallbackFunction,
;;;361    									Timer_t *pxNewTimer )
;;;362    {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  e9dd9408          LDRD     r9,r4,[sp,#0x20]
;;;363    	/* 0 is not a valid value for xTimerPeriodInTicks. */
;;;364    	configASSERT( ( xTimerPeriodInTicks > 0 ) );
000010  b10d              CBZ      r5,|L4.22|
000012  2001              MOVS     r0,#1
000014  e000              B        |L4.24|
                  |L4.22|
000016  2000              MOVS     r0,#0
                  |L4.24|
000018  b950              CBNZ     r0,|L4.48|
00001a  bf00              NOP      
00001c  2040              MOVS     r0,#0x40
00001e  f3808811          MSR      BASEPRI,r0
000022  f3bf8f4f          DSB      
000026  f3bf8f6f          ISB      
00002a  bf00              NOP      
00002c  bf00              NOP      
                  |L4.46|
00002e  e7fe              B        |L4.46|
                  |L4.48|
;;;365    
;;;366    	if( pxNewTimer != NULL )
000030  b15c              CBZ      r4,|L4.74|
;;;367    	{
;;;368    		/* Ensure the infrastructure used by the timer service task has been
;;;369    		created/initialised. */
;;;370    		prvCheckForValidListAndQueue();
000032  f7fffffe          BL       prvCheckForValidListAndQueue
;;;371    
;;;372    		/* Initialise the timer structure members using the function
;;;373    		parameters. */
;;;374    		pxNewTimer->pcTimerName = pcTimerName;
000036  6026              STR      r6,[r4,#0]
;;;375    		pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
000038  61a5              STR      r5,[r4,#0x18]
;;;376    		pxNewTimer->uxAutoReload = uxAutoReload;
00003a  61e7              STR      r7,[r4,#0x1c]
;;;377    		pxNewTimer->pvTimerID = pvTimerID;
00003c  f8c48020          STR      r8,[r4,#0x20]
;;;378    		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
000040  f8c49024          STR      r9,[r4,#0x24]
;;;379    		vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
000044  1d20              ADDS     r0,r4,#4
000046  f7fffffe          BL       vListInitialiseItem
                  |L4.74|
;;;380    		traceTIMER_CREATE( pxNewTimer );
;;;381    	}
;;;382    }
00004a  e8bd87f0          POP      {r4-r10,pc}
;;;383    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvInsertTimerInActiveList||, CODE, READONLY, ALIGN=2

                  prvInsertTimerInActiveList PROC
;;;650    
;;;651    static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;652    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;653    BaseType_t xProcessTimerNow = pdFALSE;
00000c  f04f0800          MOV      r8,#0
;;;654    
;;;655    	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
000010  6065              STR      r5,[r4,#4]
;;;656    	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
000012  6124              STR      r4,[r4,#0x10]
;;;657    
;;;658    	if( xNextExpiryTime <= xTimeNow )
000014  42b5              CMP      r5,r6
000016  d80c              BHI      |L5.50|
;;;659    	{
;;;660    		/* Has the expiry time elapsed between the command to start/reset a
;;;661    		timer was issued, and the time the command was processed? */
;;;662    		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000018  1bf0              SUBS     r0,r6,r7
00001a  69a1              LDR      r1,[r4,#0x18]
00001c  4288              CMP      r0,r1
00001e  d302              BCC      |L5.38|
;;;663    		{
;;;664    			/* The time between a command being issued and the command being
;;;665    			processed actually exceeds the timers period.  */
;;;666    			xProcessTimerNow = pdTRUE;
000020  f04f0801          MOV      r8,#1
000024  e011              B        |L5.74|
                  |L5.38|
;;;667    		}
;;;668    		else
;;;669    		{
;;;670    			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
000026  1d21              ADDS     r1,r4,#4
000028  4809              LDR      r0,|L5.80|
00002a  6800              LDR      r0,[r0,#0]  ; pxOverflowTimerList
00002c  f7fffffe          BL       vListInsert
000030  e00b              B        |L5.74|
                  |L5.50|
;;;671    		}
;;;672    	}
;;;673    	else
;;;674    	{
;;;675    		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
000032  42be              CMP      r6,r7
000034  d204              BCS      |L5.64|
000036  42bd              CMP      r5,r7
000038  d302              BCC      |L5.64|
;;;676    		{
;;;677    			/* If, since the command was issued, the tick count has overflowed
;;;678    			but the expiry time has not, then the timer must have already passed
;;;679    			its expiry time and should be processed immediately. */
;;;680    			xProcessTimerNow = pdTRUE;
00003a  f04f0801          MOV      r8,#1
00003e  e004              B        |L5.74|
                  |L5.64|
;;;681    		}
;;;682    		else
;;;683    		{
;;;684    			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
000040  1d21              ADDS     r1,r4,#4
000042  4804              LDR      r0,|L5.84|
000044  6800              LDR      r0,[r0,#0]  ; pxCurrentTimerList
000046  f7fffffe          BL       vListInsert
                  |L5.74|
;;;685    		}
;;;686    	}
;;;687    
;;;688    	return xProcessTimerNow;
00004a  4640              MOV      r0,r8
;;;689    }
00004c  e8bd81f0          POP      {r4-r8,pc}
;;;690    /*-----------------------------------------------------------*/
                          ENDP

                  |L5.80|
                          DCD      pxOverflowTimerList
                  |L5.84|
                          DCD      pxCurrentTimerList

                          AREA ||i.prvProcessExpiredTimer||, CODE, READONLY, ALIGN=2

                  prvProcessExpiredTimer PROC
;;;465    
;;;466    static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
000000  b5f8              PUSH     {r3-r7,lr}
;;;467    {
000002  4605              MOV      r5,r0
000004  460f              MOV      r7,r1
;;;468    BaseType_t xResult;
;;;469    Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
000006  4816              LDR      r0,|L6.96|
000008  6800              LDR      r0,[r0,#0]  ; pxCurrentTimerList
00000a  68c0              LDR      r0,[r0,#0xc]
00000c  68c4              LDR      r4,[r0,#0xc]
;;;470    
;;;471    	/* Remove the timer from the list of active timers.  A check has already
;;;472    	been performed to ensure the list is not empty. */
;;;473    	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
00000e  1d20              ADDS     r0,r4,#4
000010  f7fffffe          BL       uxListRemove
;;;474    	traceTIMER_EXPIRED( pxTimer );
;;;475    
;;;476    	/* If the timer is an auto reload timer then calculate the next
;;;477    	expiry time and re-insert the timer in the list of active timers. */
;;;478    	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
000014  69e0              LDR      r0,[r4,#0x1c]
000016  2801              CMP      r0,#1
000018  d11d              BNE      |L6.86|
;;;479    	{
;;;480    		/* The timer is inserted into a list using a time relative to anything
;;;481    		other than the current time.  It will therefore be inserted into the
;;;482    		correct list relative to the time this task thinks it is now. */
;;;483    		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
00001a  69a0              LDR      r0,[r4,#0x18]
00001c  1941              ADDS     r1,r0,r5
00001e  462b              MOV      r3,r5
000020  463a              MOV      r2,r7
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       prvInsertTimerInActiveList
000028  b1a8              CBZ      r0,|L6.86|
;;;484    		{
;;;485    			/* The timer expired before it was added to the active timer
;;;486    			list.  Reload it now.  */
;;;487    			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
00002a  2000              MOVS     r0,#0
00002c  4603              MOV      r3,r0
00002e  462a              MOV      r2,r5
000030  4601              MOV      r1,r0
000032  9000              STR      r0,[sp,#0]
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       xTimerGenericCommand
00003a  4606              MOV      r6,r0
;;;488    			configASSERT( xResult );
00003c  b956              CBNZ     r6,|L6.84|
00003e  bf00              NOP      
000040  2040              MOVS     r0,#0x40
000042  f3808811          MSR      BASEPRI,r0
000046  f3bf8f4f          DSB      
00004a  f3bf8f6f          ISB      
00004e  bf00              NOP      
000050  bf00              NOP      
                  |L6.82|
000052  e7fe              B        |L6.82|
                  |L6.84|
;;;489    			( void ) xResult;
000054  bf00              NOP      
                  |L6.86|
;;;490    		}
;;;491    		else
;;;492    		{
;;;493    			mtCOVERAGE_TEST_MARKER();
;;;494    		}
;;;495    	}
;;;496    	else
;;;497    	{
;;;498    		mtCOVERAGE_TEST_MARKER();
;;;499    	}
;;;500    
;;;501    	/* Call the timer callback. */
;;;502    	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
000056  4620              MOV      r0,r4
000058  6a61              LDR      r1,[r4,#0x24]
00005a  4788              BLX      r1
;;;503    }
00005c  bdf8              POP      {r3-r7,pc}
;;;504    /*-----------------------------------------------------------*/
                          ENDP

00005e  0000              DCW      0x0000
                  |L6.96|
                          DCD      pxCurrentTimerList

                          AREA ||i.prvProcessReceivedCommands||, CODE, READONLY, ALIGN=2

                  prvProcessReceivedCommands PROC
;;;691    
;;;692    static void	prvProcessReceivedCommands( void )
000000  b570              PUSH     {r4-r6,lr}
;;;693    {
000002  b086              SUB      sp,sp,#0x18
;;;694    DaemonTaskMessage_t xMessage;
;;;695    Timer_t *pxTimer;
;;;696    BaseType_t xTimerListsWereSwitched, xResult;
;;;697    TickType_t xTimeNow;
;;;698    
;;;699    	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
000004  e06a              B        |L7.220|
                  |L7.6|
;;;700    	{
;;;701    		#if ( INCLUDE_xTimerPendFunctionCall == 1 )
;;;702    		{
;;;703    			/* Negative commands are pended function calls rather than timer
;;;704    			commands. */
;;;705    			if( xMessage.xMessageID < ( BaseType_t ) 0 )
;;;706    			{
;;;707    				const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
;;;708    
;;;709    				/* The timer uses the xCallbackParameters member to request a
;;;710    				callback be executed.  Check the callback is not NULL. */
;;;711    				configASSERT( pxCallback );
;;;712    
;;;713    				/* Call the function. */
;;;714    				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
;;;715    			}
;;;716    			else
;;;717    			{
;;;718    				mtCOVERAGE_TEST_MARKER();
;;;719    			}
;;;720    		}
;;;721    		#endif /* INCLUDE_xTimerPendFunctionCall */
;;;722    
;;;723    		/* Commands that are positive are timer commands rather than pended
;;;724    		function calls. */
;;;725    		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
000006  9803              LDR      r0,[sp,#0xc]
000008  2800              CMP      r0,#0
00000a  db67              BLT      |L7.220|
;;;726    		{
;;;727    			/* The messages uses the xTimerParameters member to work on a
;;;728    			software timer. */
;;;729    			pxTimer = xMessage.u.xTimerParameters.pxTimer;
00000c  9c05              LDR      r4,[sp,#0x14]
;;;730    
;;;731    			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
00000e  6960              LDR      r0,[r4,#0x14]
000010  b908              CBNZ     r0,|L7.22|
000012  2001              MOVS     r0,#1
000014  e000              B        |L7.24|
                  |L7.22|
000016  2000              MOVS     r0,#0
                  |L7.24|
000018  b910              CBNZ     r0,|L7.32|
;;;732    			{
;;;733    				/* The timer is in a list, remove it. */
;;;734    				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
00001a  1d20              ADDS     r0,r4,#4
00001c  f7fffffe          BL       uxListRemove
                  |L7.32|
;;;735    			}
;;;736    			else
;;;737    			{
;;;738    				mtCOVERAGE_TEST_MARKER();
;;;739    			}
;;;740    
;;;741    			traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.u.xTimerParameters.xMessageValue );
;;;742    
;;;743    			/* In this case the xTimerListsWereSwitched parameter is not used, but
;;;744    			it must be present in the function call.  prvSampleTimeNow() must be
;;;745    			called after the message is received from xTimerQueue so there is no
;;;746    			possibility of a higher priority task adding a message to the message
;;;747    			queue with a time that is ahead of the timer daemon task (because it
;;;748    			pre-empted the timer daemon task after the xTimeNow value was set). */
;;;749    			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
000020  a802              ADD      r0,sp,#8
000022  f7fffffe          BL       prvSampleTimeNow
000026  4605              MOV      r5,r0
;;;750    
;;;751    			switch( xMessage.xMessageID )
000028  9803              LDR      r0,[sp,#0xc]
00002a  280a              CMP      r0,#0xa
00002c  d254              BCS      |L7.216|
00002e  e8dff000          TBB      [pc,r0]
000032  0905              DCB      0x09,0x05
000034  0731334f          DCB      0x07,0x31,0x33,0x4f
000038  06083234          DCB      0x06,0x08,0x32,0x34
;;;752    			{
;;;753    				case tmrCOMMAND_START :
;;;754    			    case tmrCOMMAND_START_FROM_ISR :
00003c  bf00              NOP      
;;;755    			    case tmrCOMMAND_RESET :
00003e  bf00              NOP      
;;;756    			    case tmrCOMMAND_RESET_FROM_ISR :
000040  bf00              NOP      
;;;757    				case tmrCOMMAND_START_DONT_TRACE :
000042  bf00              NOP      
;;;758    					/* Start or restart a timer. */
;;;759    					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
000044  9804              LDR      r0,[sp,#0x10]
000046  69a2              LDR      r2,[r4,#0x18]
000048  1881              ADDS     r1,r0,r2
00004a  4603              MOV      r3,r0
00004c  462a              MOV      r2,r5
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       prvInsertTimerInActiveList
000054  b1e8              CBZ      r0,|L7.146|
;;;760    					{
;;;761    						/* The timer expired before it was added to the active
;;;762    						timer list.  Process it now. */
;;;763    						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
000056  4620              MOV      r0,r4
000058  6a61              LDR      r1,[r4,#0x24]
00005a  4788              BLX      r1
;;;764    						traceTIMER_EXPIRED( pxTimer );
;;;765    
;;;766    						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
00005c  69e0              LDR      r0,[r4,#0x1c]
00005e  2801              CMP      r0,#1
000060  d117              BNE      |L7.146|
;;;767    						{
;;;768    							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
000062  2000              MOVS     r0,#0
000064  9000              STR      r0,[sp,#0]
000066  9804              LDR      r0,[sp,#0x10]
000068  69a1              LDR      r1,[r4,#0x18]
00006a  1842              ADDS     r2,r0,r1
00006c  2300              MOVS     r3,#0
00006e  4619              MOV      r1,r3
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       xTimerGenericCommand
000076  4606              MOV      r6,r0
;;;769    							configASSERT( xResult );
000078  b956              CBNZ     r6,|L7.144|
00007a  bf00              NOP      
00007c  2040              MOVS     r0,#0x40
00007e  f3808811          MSR      BASEPRI,r0
000082  f3bf8f4f          DSB      
000086  f3bf8f6f          ISB      
00008a  bf00              NOP      
00008c  bf00              NOP      
                  |L7.142|
00008e  e7fe              B        |L7.142|
                  |L7.144|
;;;770    							( void ) xResult;
000090  bf00              NOP      
                  |L7.146|
;;;771    						}
;;;772    						else
;;;773    						{
;;;774    							mtCOVERAGE_TEST_MARKER();
;;;775    						}
;;;776    					}
;;;777    					else
;;;778    					{
;;;779    						mtCOVERAGE_TEST_MARKER();
;;;780    					}
;;;781    					break;
000092  e022              B        |L7.218|
;;;782    
;;;783    				case tmrCOMMAND_STOP :
;;;784    				case tmrCOMMAND_STOP_FROM_ISR :
000094  bf00              NOP      
;;;785    					/* The timer has already been removed from the active list.
;;;786    					There is nothing to do here. */
;;;787    					break;
000096  e020              B        |L7.218|
;;;788    
;;;789    				case tmrCOMMAND_CHANGE_PERIOD :
;;;790    				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
000098  bf00              NOP      
;;;791    					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
00009a  9804              LDR      r0,[sp,#0x10]
00009c  61a0              STR      r0,[r4,#0x18]
;;;792    					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
00009e  69a0              LDR      r0,[r4,#0x18]
0000a0  b108              CBZ      r0,|L7.166|
0000a2  2001              MOVS     r0,#1
0000a4  e000              B        |L7.168|
                  |L7.166|
0000a6  2000              MOVS     r0,#0
                  |L7.168|
0000a8  b950              CBNZ     r0,|L7.192|
0000aa  bf00              NOP      
0000ac  2040              MOVS     r0,#0x40
0000ae  f3808811          MSR      BASEPRI,r0
0000b2  f3bf8f4f          DSB      
0000b6  f3bf8f6f          ISB      
0000ba  bf00              NOP      
0000bc  bf00              NOP      
                  |L7.190|
0000be  e7fe              B        |L7.190|
                  |L7.192|
;;;793    
;;;794    					/* The new period does not really have a reference, and can
;;;795    					be longer or shorter than the old one.  The command time is
;;;796    					therefore set to the current time, and as the period cannot
;;;797    					be zero the next expiry time can only be in the future,
;;;798    					meaning (unlike for the xTimerStart() case above) there is
;;;799    					no fail case that needs to be handled here. */
;;;800    					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
0000c0  69a0              LDR      r0,[r4,#0x18]
0000c2  1941              ADDS     r1,r0,r5
0000c4  462b              MOV      r3,r5
0000c6  462a              MOV      r2,r5
0000c8  4620              MOV      r0,r4
0000ca  f7fffffe          BL       prvInsertTimerInActiveList
;;;801    					break;
0000ce  e004              B        |L7.218|
;;;802    
;;;803    				case tmrCOMMAND_DELETE :
;;;804    					/* The timer has already been removed from the active list,
;;;805    					just free up the memory if the memory was dynamically
;;;806    					allocated. */
;;;807    					#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
;;;808    					{
;;;809    						/* The timer can only have been allocated dynamically -
;;;810    						free it again. */
;;;811    						vPortFree( pxTimer );
0000d0  4620              MOV      r0,r4
0000d2  f7fffffe          BL       vPortFree
;;;812    					}
;;;813    					#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
;;;814    					{
;;;815    						/* The timer could have been allocated statically or
;;;816    						dynamically, so check before attempting to free the
;;;817    						memory. */
;;;818    						if( pxTimer->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
;;;819    						{
;;;820    							vPortFree( pxTimer );
;;;821    						}
;;;822    						else
;;;823    						{
;;;824    							mtCOVERAGE_TEST_MARKER();
;;;825    						}
;;;826    					}
;;;827    					#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
;;;828    					break;
0000d6  e000              B        |L7.218|
                  |L7.216|
;;;829    
;;;830    				default	:
;;;831    					/* Don't expect to get here. */
;;;832    					break;
0000d8  bf00              NOP      
                  |L7.218|
0000da  bf00              NOP                            ;781
                  |L7.220|
0000dc  2200              MOVS     r2,#0                 ;699
0000de  a903              ADD      r1,sp,#0xc            ;699
0000e0  4803              LDR      r0,|L7.240|
0000e2  6800              LDR      r0,[r0,#0]            ;699  ; xTimerQueue
0000e4  f7fffffe          BL       xQueueReceive
0000e8  2800              CMP      r0,#0                 ;699
0000ea  d18c              BNE      |L7.6|
;;;833    			}
;;;834    		}
;;;835    	}
;;;836    }
0000ec  b006              ADD      sp,sp,#0x18
0000ee  bd70              POP      {r4-r6,pc}
;;;837    /*-----------------------------------------------------------*/
                          ENDP

                  |L7.240|
                          DCD      xTimerQueue

                          AREA ||i.prvProcessTimerOrBlockTask||, CODE, READONLY, ALIGN=2

                  prvProcessTimerOrBlockTask PROC
;;;541    
;;;542    static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
000000  b5f8              PUSH     {r3-r7,lr}
;;;543    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;544    TickType_t xTimeNow;
;;;545    BaseType_t xTimerListsWereSwitched;
;;;546    
;;;547    	vTaskSuspendAll();
000006  f7fffffe          BL       vTaskSuspendAll
;;;548    	{
;;;549    		/* Obtain the time now to make an assessment as to whether the timer
;;;550    		has expired or not.  If obtaining the time causes the lists to switch
;;;551    		then don't process this timer as any timers that remained in the list
;;;552    		when the lists were switched will have been processed within the
;;;553    		prvSampleTimeNow() function. */
;;;554    		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       prvSampleTimeNow
000010  4606              MOV      r6,r0
;;;555    		if( xTimerListsWereSwitched == pdFALSE )
000012  9800              LDR      r0,[sp,#0]
000014  bb20              CBNZ     r0,|L8.96|
;;;556    		{
;;;557    			/* The tick count has not overflowed, has the timer expired? */
;;;558    			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
000016  b944              CBNZ     r4,|L8.42|
000018  42b5              CMP      r5,r6
00001a  d806              BHI      |L8.42|
;;;559    			{
;;;560    				( void ) xTaskResumeAll();
00001c  f7fffffe          BL       xTaskResumeAll
;;;561    				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
000020  4631              MOV      r1,r6
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       prvProcessExpiredTimer
000028  e01c              B        |L8.100|
                  |L8.42|
;;;562    			}
;;;563    			else
;;;564    			{
;;;565    				/* The tick count has not overflowed, and the next expire
;;;566    				time has not been reached yet.  This task should therefore
;;;567    				block to wait for the next expire time or a command to be
;;;568    				received - whichever comes first.  The following line cannot
;;;569    				be reached unless xNextExpireTime > xTimeNow, except in the
;;;570    				case when the current timer list is empty. */
;;;571    				if( xListWasEmpty != pdFALSE )
00002a  b13c              CBZ      r4,|L8.60|
;;;572    				{
;;;573    					/* The current timer list is empty - is the overflow list
;;;574    					also empty? */
;;;575    					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
00002c  480e              LDR      r0,|L8.104|
00002e  6800              LDR      r0,[r0,#0]  ; pxOverflowTimerList
000030  6800              LDR      r0,[r0,#0]
000032  b908              CBNZ     r0,|L8.56|
000034  2001              MOVS     r0,#1
000036  e000              B        |L8.58|
                  |L8.56|
000038  2000              MOVS     r0,#0
                  |L8.58|
00003a  4604              MOV      r4,r0
                  |L8.60|
;;;576    				}
;;;577    
;;;578    				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
00003c  1ba9              SUBS     r1,r5,r6
00003e  4622              MOV      r2,r4
000040  480a              LDR      r0,|L8.108|
000042  6800              LDR      r0,[r0,#0]  ; xTimerQueue
000044  f7fffffe          BL       vQueueWaitForMessageRestricted
;;;579    
;;;580    				if( xTaskResumeAll() == pdFALSE )
000048  f7fffffe          BL       xTaskResumeAll
00004c  b950              CBNZ     r0,|L8.100|
;;;581    				{
;;;582    					/* Yield to wait for either a command to arrive, or the
;;;583    					block time to expire.  If a command arrived between the
;;;584    					critical section being exited and this yield then the yield
;;;585    					will not cause the task to block. */
;;;586    					portYIELD_WITHIN_API();
00004e  f04f5080          MOV      r0,#0x10000000
000052  4907              LDR      r1,|L8.112|
000054  6008              STR      r0,[r1,#0]
000056  f3bf8f4f          DSB      
00005a  f3bf8f6f          ISB      
00005e  e001              B        |L8.100|
                  |L8.96|
;;;587    				}
;;;588    				else
;;;589    				{
;;;590    					mtCOVERAGE_TEST_MARKER();
;;;591    				}
;;;592    			}
;;;593    		}
;;;594    		else
;;;595    		{
;;;596    			( void ) xTaskResumeAll();
000060  f7fffffe          BL       xTaskResumeAll
                  |L8.100|
;;;597    		}
;;;598    	}
;;;599    }
000064  bdf8              POP      {r3-r7,pc}
;;;600    /*-----------------------------------------------------------*/
                          ENDP

000066  0000              DCW      0x0000
                  |L8.104|
                          DCD      pxOverflowTimerList
                  |L8.108|
                          DCD      xTimerQueue
                  |L8.112|
                          DCD      0xe000ed04

                          AREA ||i.prvSampleTimeNow||, CODE, READONLY, ALIGN=2

                  prvSampleTimeNow PROC
;;;627    
;;;628    static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
000000  b570              PUSH     {r4-r6,lr}
;;;629    {
000002  4604              MOV      r4,r0
;;;630    TickType_t xTimeNow;
;;;631    PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */
;;;632    
;;;633    	xTimeNow = xTaskGetTickCount();
000004  f7fffffe          BL       xTaskGetTickCount
000008  4605              MOV      r5,r0
;;;634    
;;;635    	if( xTimeNow < xLastTime )
00000a  4807              LDR      r0,|L9.40|
00000c  6800              LDR      r0,[r0,#0]  ; xLastTime
00000e  4285              CMP      r5,r0
000010  d204              BCS      |L9.28|
;;;636    	{
;;;637    		prvSwitchTimerLists();
000012  f7fffffe          BL       prvSwitchTimerLists
;;;638    		*pxTimerListsWereSwitched = pdTRUE;
000016  2001              MOVS     r0,#1
000018  6020              STR      r0,[r4,#0]
00001a  e001              B        |L9.32|
                  |L9.28|
;;;639    	}
;;;640    	else
;;;641    	{
;;;642    		*pxTimerListsWereSwitched = pdFALSE;
00001c  2000              MOVS     r0,#0
00001e  6020              STR      r0,[r4,#0]
                  |L9.32|
;;;643    	}
;;;644    
;;;645    	xLastTime = xTimeNow;
000020  4801              LDR      r0,|L9.40|
000022  6005              STR      r5,[r0,#0]  ; xLastTime
;;;646    
;;;647    	return xTimeNow;
000024  4628              MOV      r0,r5
;;;648    }
000026  bd70              POP      {r4-r6,pc}
;;;649    /*-----------------------------------------------------------*/
                          ENDP

                  |L9.40|
                          DCD      xLastTime

                          AREA ||i.prvSwitchTimerLists||, CODE, READONLY, ALIGN=2

                  prvSwitchTimerLists PROC
;;;838    
;;;839    static void prvSwitchTimerLists( void )
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;840    {
;;;841    TickType_t xNextExpireTime, xReloadTime;
;;;842    List_t *pxTemp;
;;;843    Timer_t *pxTimer;
;;;844    BaseType_t xResult;
;;;845    
;;;846    	/* The tick count has overflowed.  The timer lists must be switched.
;;;847    	If there are any timers still referenced from the current timer list
;;;848    	then they must have expired and should be processed before the lists
;;;849    	are switched. */
;;;850    	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
000004  e032              B        |L10.108|
                  |L10.6|
;;;851    	{
;;;852    		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
000006  4824              LDR      r0,|L10.152|
000008  6800              LDR      r0,[r0,#0]  ; pxCurrentTimerList
00000a  68c0              LDR      r0,[r0,#0xc]
00000c  6805              LDR      r5,[r0,#0]
;;;853    
;;;854    		/* Remove the timer from the list. */
;;;855    		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
00000e  4822              LDR      r0,|L10.152|
000010  6800              LDR      r0,[r0,#0]  ; pxCurrentTimerList
000012  68c0              LDR      r0,[r0,#0xc]
000014  68c4              LDR      r4,[r0,#0xc]
;;;856    		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
000016  1d20              ADDS     r0,r4,#4
000018  f7fffffe          BL       uxListRemove
;;;857    		traceTIMER_EXPIRED( pxTimer );
;;;858    
;;;859    		/* Execute its callback, then send a command to restart the timer if
;;;860    		it is an auto-reload timer.  It cannot be restarted here as the lists
;;;861    		have not yet been switched. */
;;;862    		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
00001c  4620              MOV      r0,r4
00001e  6a61              LDR      r1,[r4,#0x24]
000020  4788              BLX      r1
;;;863    
;;;864    		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
000022  69e0              LDR      r0,[r4,#0x1c]
000024  2801              CMP      r0,#1
000026  d121              BNE      |L10.108|
;;;865    		{
;;;866    			/* Calculate the reload value, and if the reload value results in
;;;867    			the timer going into the same timer list then it has already expired
;;;868    			and the timer should be re-inserted into the current list so it is
;;;869    			processed again within this loop.  Otherwise a command should be sent
;;;870    			to restart the timer to ensure it is only inserted into a list after
;;;871    			the lists have been swapped. */
;;;872    			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
000028  69a0              LDR      r0,[r4,#0x18]
00002a  1946              ADDS     r6,r0,r5
;;;873    			if( xReloadTime > xNextExpireTime )
00002c  42ae              CMP      r6,r5
00002e  d907              BLS      |L10.64|
;;;874    			{
;;;875    				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
000030  6066              STR      r6,[r4,#4]
;;;876    				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
000032  6124              STR      r4,[r4,#0x10]
;;;877    				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
000034  1d21              ADDS     r1,r4,#4
000036  4818              LDR      r0,|L10.152|
000038  6800              LDR      r0,[r0,#0]  ; pxCurrentTimerList
00003a  f7fffffe          BL       vListInsert
00003e  e015              B        |L10.108|
                  |L10.64|
;;;878    			}
;;;879    			else
;;;880    			{
;;;881    				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
000040  2000              MOVS     r0,#0
000042  4603              MOV      r3,r0
000044  462a              MOV      r2,r5
000046  4601              MOV      r1,r0
000048  9000              STR      r0,[sp,#0]
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       xTimerGenericCommand
000050  4607              MOV      r7,r0
;;;882    				configASSERT( xResult );
000052  b957              CBNZ     r7,|L10.106|
000054  bf00              NOP      
000056  2040              MOVS     r0,#0x40
000058  f3808811          MSR      BASEPRI,r0
00005c  f3bf8f4f          DSB      
000060  f3bf8f6f          ISB      
000064  bf00              NOP      
000066  bf00              NOP      
                  |L10.104|
000068  e7fe              B        |L10.104|
                  |L10.106|
;;;883    				( void ) xResult;
00006a  bf00              NOP      
                  |L10.108|
00006c  480a              LDR      r0,|L10.152|
00006e  6800              LDR      r0,[r0,#0]            ;850  ; pxCurrentTimerList
000070  6800              LDR      r0,[r0,#0]            ;850
000072  b908              CBNZ     r0,|L10.120|
000074  2001              MOVS     r0,#1                 ;850
000076  e000              B        |L10.122|
                  |L10.120|
000078  2000              MOVS     r0,#0                 ;850
                  |L10.122|
00007a  2800              CMP      r0,#0                 ;850
00007c  d0c3              BEQ      |L10.6|
;;;884    			}
;;;885    		}
;;;886    		else
;;;887    		{
;;;888    			mtCOVERAGE_TEST_MARKER();
;;;889    		}
;;;890    	}
;;;891    
;;;892    	pxTemp = pxCurrentTimerList;
00007e  4806              LDR      r0,|L10.152|
000080  f8d08000          LDR      r8,[r0,#0]  ; pxCurrentTimerList
;;;893    	pxCurrentTimerList = pxOverflowTimerList;
000084  4805              LDR      r0,|L10.156|
000086  6800              LDR      r0,[r0,#0]  ; pxOverflowTimerList
000088  4903              LDR      r1,|L10.152|
00008a  6008              STR      r0,[r1,#0]  ; pxCurrentTimerList
;;;894    	pxOverflowTimerList = pxTemp;
00008c  4803              LDR      r0,|L10.156|
00008e  f8c08000          STR      r8,[r0,#0]  ; pxOverflowTimerList
;;;895    }
000092  e8bd83f8          POP      {r3-r9,pc}
;;;896    /*-----------------------------------------------------------*/
                          ENDP

000096  0000              DCW      0x0000
                  |L10.152|
                          DCD      pxCurrentTimerList
                  |L10.156|
                          DCD      pxOverflowTimerList

                          AREA ||i.prvTimerTask||, CODE, READONLY, ALIGN=1

                  prvTimerTask PROC
;;;505    
;;;506    static void prvTimerTask( void *pvParameters )
000000  b508              PUSH     {r3,lr}
;;;507    {
;;;508    TickType_t xNextExpireTime;
;;;509    BaseType_t xListWasEmpty;
;;;510    
;;;511    	/* Just to avoid compiler warnings. */
;;;512    	( void ) pvParameters;
;;;513    
;;;514    	#if( configUSE_DAEMON_TASK_STARTUP_HOOK == 1 )
;;;515    	{
;;;516    		extern void vApplicationDaemonTaskStartupHook( void );
;;;517    
;;;518    		/* Allow the application writer to execute some code in the context of
;;;519    		this task at the point the task starts executing.  This is useful if the
;;;520    		application includes initialisation code that would benefit from
;;;521    		executing after the scheduler has been started. */
;;;522    		vApplicationDaemonTaskStartupHook();
;;;523    	}
;;;524    	#endif /* configUSE_DAEMON_TASK_STARTUP_HOOK */
;;;525    
;;;526    	for( ;; )
000002  bf00              NOP      
                  |L11.4|
;;;527    	{
;;;528    		/* Query the timers list to see if it contains any timers, and if so,
;;;529    		obtain the time at which the next timer will expire. */
;;;530    		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
000004  4668              MOV      r0,sp
000006  f7fffffe          BL       prvGetNextExpireTime
00000a  4604              MOV      r4,r0
;;;531    
;;;532    		/* If a timer has expired, process it.  Otherwise, block this task
;;;533    		until either a timer does expire, or a command is received. */
;;;534    		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
00000c  4620              MOV      r0,r4
00000e  9900              LDR      r1,[sp,#0]
000010  f7fffffe          BL       prvProcessTimerOrBlockTask
;;;535    
;;;536    		/* Empty the command queue. */
;;;537    		prvProcessReceivedCommands();
000014  f7fffffe          BL       prvProcessReceivedCommands
000018  e7f4              B        |L11.4|
;;;538    	}
;;;539    }
;;;540    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.pvTimerGetTimerID||, CODE, READONLY, ALIGN=1

                  pvTimerGetTimerID PROC
;;;976    
;;;977    void *pvTimerGetTimerID( const TimerHandle_t xTimer )
000000  b570              PUSH     {r4-r6,lr}
;;;978    {
000002  4604              MOV      r4,r0
;;;979    Timer_t * const pxTimer = xTimer;
000004  4625              MOV      r5,r4
;;;980    void *pvReturn;
;;;981    
;;;982    	configASSERT( xTimer );
000006  b954              CBNZ     r4,|L12.30|
000008  bf00              NOP      
00000a  2040              MOVS     r0,#0x40
00000c  f3808811          MSR      BASEPRI,r0
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L12.28|
00001c  e7fe              B        |L12.28|
                  |L12.30|
;;;983    
;;;984    	taskENTER_CRITICAL();
00001e  f7fffffe          BL       vPortEnterCritical
;;;985    	{
;;;986    		pvReturn = pxTimer->pvTimerID;
000022  6a2e              LDR      r6,[r5,#0x20]
;;;987    	}
;;;988    	taskEXIT_CRITICAL();
000024  f7fffffe          BL       vPortExitCritical
;;;989    
;;;990    	return pvReturn;
000028  4630              MOV      r0,r6
;;;991    }
00002a  bd70              POP      {r4-r6,pc}
;;;992    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.uxTimerGetTimerNumber||, CODE, READONLY, ALIGN=1

                  uxTimerGetTimerNumber PROC
;;;1062   
;;;1063   	UBaseType_t uxTimerGetTimerNumber( TimerHandle_t xTimer )
000000  4601              MOV      r1,r0
;;;1064   	{
;;;1065   		return ( ( Timer_t * ) xTimer )->uxTimerNumber;
000002  6a88              LDR      r0,[r1,#0x28]
;;;1066   	}
000004  4770              BX       lr
;;;1067   
                          ENDP


                          AREA ||i.vTimerSetTimerID||, CODE, READONLY, ALIGN=1

                  vTimerSetTimerID PROC
;;;993    
;;;994    void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID )
000000  b570              PUSH     {r4-r6,lr}
;;;995    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;996    Timer_t * const pxTimer = xTimer;
000006  4626              MOV      r6,r4
;;;997    
;;;998    	configASSERT( xTimer );
000008  b954              CBNZ     r4,|L14.32|
00000a  bf00              NOP      
00000c  2040              MOVS     r0,#0x40
00000e  f3808811          MSR      BASEPRI,r0
000012  f3bf8f4f          DSB      
000016  f3bf8f6f          ISB      
00001a  bf00              NOP      
00001c  bf00              NOP      
                  |L14.30|
00001e  e7fe              B        |L14.30|
                  |L14.32|
;;;999    
;;;1000   	taskENTER_CRITICAL();
000020  f7fffffe          BL       vPortEnterCritical
;;;1001   	{
;;;1002   		pxTimer->pvTimerID = pvNewID;
000024  6235              STR      r5,[r6,#0x20]
;;;1003   	}
;;;1004   	taskEXIT_CRITICAL();
000026  f7fffffe          BL       vPortExitCritical
;;;1005   }
00002a  bd70              POP      {r4-r6,pc}
;;;1006   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vTimerSetTimerNumber||, CODE, READONLY, ALIGN=1

                  vTimerSetTimerNumber PROC
;;;1072   
;;;1073   	void vTimerSetTimerNumber( TimerHandle_t xTimer, UBaseType_t uxTimerNumber )
000000  6281              STR      r1,[r0,#0x28]
;;;1074   	{
;;;1075   		( ( Timer_t * ) xTimer )->uxTimerNumber = uxTimerNumber;
;;;1076   	}
000002  4770              BX       lr
;;;1077   
                          ENDP


                          AREA ||i.xTimerCreate||, CODE, READONLY, ALIGN=1

                  xTimerCreate PROC
;;;280    
;;;281    	TimerHandle_t xTimerCreate(	const char * const pcTimerName,			/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;282    								const TickType_t xTimerPeriodInTicks,
;;;283    								const UBaseType_t uxAutoReload,
;;;284    								void * const pvTimerID,
;;;285    								TimerCallbackFunction_t pxCallbackFunction )
;;;286    	{
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  f8dd9028          LDR      r9,[sp,#0x28]
;;;287    	Timer_t *pxNewTimer;
;;;288    
;;;289    		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's mame. */
000010  202c              MOVS     r0,#0x2c
000012  f7fffffe          BL       pvPortMalloc
000016  4604              MOV      r4,r0
;;;290    
;;;291    		if( pxNewTimer != NULL )
000018  b13c              CBZ      r4,|L16.42|
;;;292    		{
;;;293    			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
00001a  4643              MOV      r3,r8
00001c  463a              MOV      r2,r7
00001e  4631              MOV      r1,r6
000020  4628              MOV      r0,r5
000022  e9cd9400          STRD     r9,r4,[sp,#0]
000026  f7fffffe          BL       prvInitialiseNewTimer
                  |L16.42|
;;;294    
;;;295    			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;296    			{
;;;297    				/* Timers can be created statically or dynamically, so note this
;;;298    				timer was created dynamically in case the timer is later
;;;299    				deleted. */
;;;300    				pxNewTimer->ucStaticallyAllocated = pdFALSE;
;;;301    			}
;;;302    			#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;303    		}
;;;304    
;;;305    		return pxNewTimer;
00002a  4620              MOV      r0,r4
;;;306    	}
00002c  e8bd87fc          POP      {r2-r10,pc}
;;;307    
                          ENDP


                          AREA ||i.xTimerCreateTimerTask||, CODE, READONLY, ALIGN=2

                  xTimerCreateTimerTask PROC
;;;225    
;;;226    BaseType_t xTimerCreateTimerTask( void )
000000  b51c              PUSH     {r2-r4,lr}
;;;227    {
;;;228    BaseType_t xReturn = pdFAIL;
000002  2400              MOVS     r4,#0
;;;229    
;;;230    	/* This function is called when the scheduler is started if
;;;231    	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
;;;232    	timer service task has been created/initialised.  If timers have already
;;;233    	been created then the initialisation will already have been performed. */
;;;234    	prvCheckForValidListAndQueue();
000004  f7fffffe          BL       prvCheckForValidListAndQueue
;;;235    
;;;236    	if( xTimerQueue != NULL )
000008  480d              LDR      r0,|L17.64|
00000a  6800              LDR      r0,[r0,#0]  ; xTimerQueue
00000c  b150              CBZ      r0,|L17.36|
;;;237    	{
;;;238    		#if( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;239    		{
;;;240    			StaticTask_t *pxTimerTaskTCBBuffer = NULL;
;;;241    			StackType_t *pxTimerTaskStackBuffer = NULL;
;;;242    			uint32_t ulTimerTaskStackSize;
;;;243    
;;;244    			vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
;;;245    			xTimerTaskHandle = xTaskCreateStatic(	prvTimerTask,
;;;246    													configTIMER_SERVICE_TASK_NAME,
;;;247    													ulTimerTaskStackSize,
;;;248    													NULL,
;;;249    													( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT,
;;;250    													pxTimerTaskStackBuffer,
;;;251    													pxTimerTaskTCBBuffer );
;;;252    
;;;253    			if( xTimerTaskHandle != NULL )
;;;254    			{
;;;255    				xReturn = pdPASS;
;;;256    			}
;;;257    		}
;;;258    		#else
;;;259    		{
;;;260    			xReturn = xTaskCreate(	prvTimerTask,
00000e  480d              LDR      r0,|L17.68|
000010  2102              MOVS     r1,#2
000012  2300              MOVS     r3,#0
000014  01ca              LSLS     r2,r1,#7
000016  e9cd1000          STRD     r1,r0,[sp,#0]
00001a  a10b              ADR      r1,|L17.72|
00001c  480e              LDR      r0,|L17.88|
00001e  f7fffffe          BL       xTaskCreate
000022  4604              MOV      r4,r0
                  |L17.36|
;;;261    									configTIMER_SERVICE_TASK_NAME,
;;;262    									configTIMER_TASK_STACK_DEPTH,
;;;263    									NULL,
;;;264    									( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT,
;;;265    									&xTimerTaskHandle );
;;;266    		}
;;;267    		#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;268    	}
;;;269    	else
;;;270    	{
;;;271    		mtCOVERAGE_TEST_MARKER();
;;;272    	}
;;;273    
;;;274    	configASSERT( xReturn );
000024  b954              CBNZ     r4,|L17.60|
000026  bf00              NOP      
000028  2040              MOVS     r0,#0x40
00002a  f3808811          MSR      BASEPRI,r0
00002e  f3bf8f4f          DSB      
000032  f3bf8f6f          ISB      
000036  bf00              NOP      
000038  bf00              NOP      
                  |L17.58|
00003a  e7fe              B        |L17.58|
                  |L17.60|
;;;275    	return xReturn;
00003c  4620              MOV      r0,r4
;;;276    }
00003e  bd1c              POP      {r2-r4,pc}
;;;277    /*-----------------------------------------------------------*/
                          ENDP

                  |L17.64|
                          DCD      xTimerQueue
                  |L17.68|
                          DCD      xTimerTaskHandle
                  |L17.72|
000048  54696d65          DCB      "Timer_Service",0
00004c  725f5365
000050  72766963
000054  6500    
000056  00                DCB      0
000057  00                DCB      0
                  |L17.88|
                          DCD      prvTimerTask

                          AREA ||i.xTimerGenericCommand||, CODE, READONLY, ALIGN=2

                  xTimerGenericCommand PROC
;;;384    
;;;385    BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;386    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8028          LDR      r8,[sp,#0x28]
;;;387    BaseType_t xReturn = pdFAIL;
000010  f04f0900          MOV      r9,#0
;;;388    DaemonTaskMessage_t xMessage;
;;;389    
;;;390    	configASSERT( xTimer );
000014  b954              CBNZ     r4,|L18.44|
000016  bf00              NOP      
000018  2040              MOVS     r0,#0x40
00001a  f3808811          MSR      BASEPRI,r0
00001e  f3bf8f4f          DSB      
000022  f3bf8f6f          ISB      
000026  bf00              NOP      
000028  bf00              NOP      
                  |L18.42|
00002a  e7fe              B        |L18.42|
                  |L18.44|
;;;391    
;;;392    	/* Send a message to the timer service task to perform a particular action
;;;393    	on a particular timer definition. */
;;;394    	if( xTimerQueue != NULL )
00002c  4814              LDR      r0,|L18.128|
00002e  6800              LDR      r0,[r0,#0]  ; xTimerQueue
000030  b310              CBZ      r0,|L18.120|
;;;395    	{
;;;396    		/* Send a command to the timer service task to start the xTimer timer. */
;;;397    		xMessage.xMessageID = xCommandID;
000032  9500              STR      r5,[sp,#0]
;;;398    		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
000034  9601              STR      r6,[sp,#4]
;;;399    		xMessage.u.xTimerParameters.pxTimer = xTimer;
000036  9402              STR      r4,[sp,#8]
;;;400    
;;;401    		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
000038  2d06              CMP      r5,#6
00003a  da15              BGE      |L18.104|
;;;402    		{
;;;403    			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
00003c  f7fffffe          BL       xTaskGetSchedulerState
000040  2802              CMP      r0,#2
000042  d108              BNE      |L18.86|
;;;404    			{
;;;405    				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
000044  2300              MOVS     r3,#0
000046  4642              MOV      r2,r8
000048  4669              MOV      r1,sp
00004a  480d              LDR      r0,|L18.128|
00004c  6800              LDR      r0,[r0,#0]  ; xTimerQueue
00004e  f7fffffe          BL       xQueueGenericSend
000052  4681              MOV      r9,r0
000054  e010              B        |L18.120|
                  |L18.86|
;;;406    			}
;;;407    			else
;;;408    			{
;;;409    				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
000056  2300              MOVS     r3,#0
000058  461a              MOV      r2,r3
00005a  4669              MOV      r1,sp
00005c  4808              LDR      r0,|L18.128|
00005e  6800              LDR      r0,[r0,#0]  ; xTimerQueue
000060  f7fffffe          BL       xQueueGenericSend
000064  4681              MOV      r9,r0
000066  e007              B        |L18.120|
                  |L18.104|
;;;410    			}
;;;411    		}
;;;412    		else
;;;413    		{
;;;414    			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
000068  2300              MOVS     r3,#0
00006a  463a              MOV      r2,r7
00006c  4669              MOV      r1,sp
00006e  4804              LDR      r0,|L18.128|
000070  6800              LDR      r0,[r0,#0]  ; xTimerQueue
000072  f7fffffe          BL       xQueueGenericSendFromISR
000076  4681              MOV      r9,r0
                  |L18.120|
;;;415    		}
;;;416    
;;;417    		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
;;;418    	}
;;;419    	else
;;;420    	{
;;;421    		mtCOVERAGE_TEST_MARKER();
;;;422    	}
;;;423    
;;;424    	return xReturn;
000078  4648              MOV      r0,r9
;;;425    }
00007a  e8bd83fe          POP      {r1-r9,pc}
;;;426    /*-----------------------------------------------------------*/
                          ENDP

00007e  0000              DCW      0x0000
                  |L18.128|
                          DCD      xTimerQueue

                          AREA ||i.xTimerGetExpiryTime||, CODE, READONLY, ALIGN=1

                  xTimerGetExpiryTime PROC
;;;445    
;;;446    TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer )
000000  b510              PUSH     {r4,lr}
;;;447    {
000002  4601              MOV      r1,r0
;;;448    Timer_t * pxTimer =  xTimer;
000004  460a              MOV      r2,r1
;;;449    TickType_t xReturn;
;;;450    
;;;451    	configASSERT( xTimer );
000006  b951              CBNZ     r1,|L19.30|
000008  bf00              NOP      
00000a  2340              MOVS     r3,#0x40
00000c  f3838811          MSR      BASEPRI,r3
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L19.28|
00001c  e7fe              B        |L19.28|
                  |L19.30|
;;;452    	xReturn = listGET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ) );
00001e  6850              LDR      r0,[r2,#4]
;;;453    	return xReturn;
;;;454    }
000020  bd10              POP      {r4,pc}
;;;455    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xTimerGetPeriod||, CODE, READONLY, ALIGN=1

                  xTimerGetPeriod PROC
;;;436    
;;;437    TickType_t xTimerGetPeriod( TimerHandle_t xTimer )
000000  4601              MOV      r1,r0
;;;438    {
;;;439    Timer_t *pxTimer = xTimer;
000002  460a              MOV      r2,r1
;;;440    
;;;441    	configASSERT( xTimer );
000004  b951              CBNZ     r1,|L20.28|
000006  bf00              NOP      
000008  2040              MOVS     r0,#0x40
00000a  f3808811          MSR      BASEPRI,r0
00000e  f3bf8f4f          DSB      
000012  f3bf8f6f          ISB      
000016  bf00              NOP      
000018  bf00              NOP      
                  |L20.26|
00001a  e7fe              B        |L20.26|
                  |L20.28|
;;;442    	return pxTimer->xTimerPeriodInTicks;
00001c  6990              LDR      r0,[r2,#0x18]
;;;443    }
00001e  4770              BX       lr
;;;444    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xTimerGetTimerDaemonTaskHandle||, CODE, READONLY, ALIGN=2

                  xTimerGetTimerDaemonTaskHandle PROC
;;;427    
;;;428    TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )
000000  480a              LDR      r0,|L21.44|
;;;429    {
;;;430    	/* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
;;;431    	started, then xTimerTaskHandle will be NULL. */
;;;432    	configASSERT( ( xTimerTaskHandle != NULL ) );
000002  6800              LDR      r0,[r0,#0]  ; xTimerTaskHandle
000004  b108              CBZ      r0,|L21.10|
000006  2001              MOVS     r0,#1
000008  e000              B        |L21.12|
                  |L21.10|
00000a  2000              MOVS     r0,#0
                  |L21.12|
00000c  b950              CBNZ     r0,|L21.36|
00000e  bf00              NOP      
000010  2040              MOVS     r0,#0x40
000012  f3808811          MSR      BASEPRI,r0
000016  f3bf8f4f          DSB      
00001a  f3bf8f6f          ISB      
00001e  bf00              NOP      
000020  bf00              NOP      
                  |L21.34|
000022  e7fe              B        |L21.34|
                  |L21.36|
;;;433    	return xTimerTaskHandle;
000024  4801              LDR      r0,|L21.44|
000026  6800              LDR      r0,[r0,#0]  ; xTimerTaskHandle
;;;434    }
000028  4770              BX       lr
;;;435    /*-----------------------------------------------------------*/
                          ENDP

00002a  0000              DCW      0x0000
                  |L21.44|
                          DCD      xTimerTaskHandle

                          AREA ||i.xTimerIsTimerActive||, CODE, READONLY, ALIGN=1

                  xTimerIsTimerActive PROC
;;;948    
;;;949    BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
000000  b570              PUSH     {r4-r6,lr}
;;;950    {
000002  4604              MOV      r4,r0
;;;951    BaseType_t xTimerIsInActiveList;
;;;952    Timer_t *pxTimer = xTimer;
000004  4626              MOV      r6,r4
;;;953    
;;;954    	configASSERT( xTimer );
000006  b954              CBNZ     r4,|L22.30|
000008  bf00              NOP      
00000a  2040              MOVS     r0,#0x40
00000c  f3808811          MSR      BASEPRI,r0
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L22.28|
00001c  e7fe              B        |L22.28|
                  |L22.30|
;;;955    
;;;956    	/* Is the timer in the list of active timers? */
;;;957    	taskENTER_CRITICAL();
00001e  f7fffffe          BL       vPortEnterCritical
;;;958    	{
;;;959    		/* Checking to see if it is in the NULL list in effect checks to see if
;;;960    		it is referenced from either the current or the overflow timer lists in
;;;961    		one go, but the logic has to be reversed, hence the '!'. */
;;;962    		if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdTRUE )
000022  6970              LDR      r0,[r6,#0x14]
000024  b908              CBNZ     r0,|L22.42|
000026  2001              MOVS     r0,#1
000028  e000              B        |L22.44|
                  |L22.42|
00002a  2000              MOVS     r0,#0
                  |L22.44|
00002c  2801              CMP      r0,#1
00002e  d101              BNE      |L22.52|
;;;963    		{
;;;964    			xTimerIsInActiveList = pdFALSE;
000030  2500              MOVS     r5,#0
000032  e000              B        |L22.54|
                  |L22.52|
;;;965    		}
;;;966    		else
;;;967    		{
;;;968    			xTimerIsInActiveList = pdTRUE;
000034  2501              MOVS     r5,#1
                  |L22.54|
;;;969    		}
;;;970    	}
;;;971    	taskEXIT_CRITICAL();
000036  f7fffffe          BL       vPortExitCritical
;;;972    
;;;973    	return xTimerIsInActiveList;
00003a  4628              MOV      r0,r5
;;;974    } /*lint !e818 Can't be pointer to const due to the typedef. */
00003c  bd70              POP      {r4-r6,pc}
;;;975    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  xActiveTimerList1
                          %        20
                  xActiveTimerList2
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  pxCurrentTimerList
                          DCD      0x00000000
                  pxOverflowTimerList
                          DCD      0x00000000
                  xTimerQueue
                          DCD      0x00000000
                  xTimerTaskHandle
                          DCD      0x00000000
                  xLastTime
                          DCD      0x00000000
