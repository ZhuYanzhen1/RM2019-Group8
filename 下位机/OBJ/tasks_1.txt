; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\tasks_1.o --asm_dir=.\OBJ\ --list_dir=.\OBJ\ --depend=.\obj\tasks_1.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I.\CORE -I.\USER -I.\HALLIB\STM32F4xx_HAL_Driver\Inc -I.\SYSTEM -I.\Hardware -I.\App -I.\DSP_LIB\Include -I.\FreeRTOS -I.\MPU9250\DMP -I.\MPU9250 -I.\RTE\_Project -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=526 -DSTM32F427xx -DSTM32F4 -DUSE_HAL_DRIVER -DSTM32F427xx -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=.\obj\tasks_1.crf FreeRTOS\tasks.c]
                          THUMB

                          AREA ||i.eTaskGetState||, CODE, READONLY, ALIGN=2

                  eTaskGetState PROC
;;;1348   
;;;1349   	eTaskState eTaskGetState( TaskHandle_t xTask )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1350   	{
000004  4607              MOV      r7,r0
;;;1351   	eTaskState eReturn;
;;;1352   	List_t const * pxStateList, *pxDelayedList, *pxOverflowedDelayedList;
;;;1353   	const TCB_t * const pxTCB = xTask;
000006  463e              MOV      r6,r7
;;;1354   
;;;1355   		configASSERT( pxTCB );
000008  b956              CBNZ     r6,|L1.32|
00000a  bf00              NOP      
00000c  2040              MOVS     r0,#0x40
00000e  f3808811          MSR      BASEPRI,r0
000012  f3bf8f4f          DSB      
000016  f3bf8f6f          ISB      
00001a  bf00              NOP      
00001c  bf00              NOP      
                  |L1.30|
00001e  e7fe              B        |L1.30|
                  |L1.32|
;;;1356   
;;;1357   		if( pxTCB == pxCurrentTCB )
000020  4817              LDR      r0,|L1.128|
000022  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000024  4286              CMP      r6,r0
000026  d101              BNE      |L1.44|
;;;1358   		{
;;;1359   			/* The task calling this function is querying its own state. */
;;;1360   			eReturn = eRunning;
000028  2400              MOVS     r4,#0
00002a  e026              B        |L1.122|
                  |L1.44|
;;;1361   		}
;;;1362   		else
;;;1363   		{
;;;1364   			taskENTER_CRITICAL();
00002c  f7fffffe          BL       vPortEnterCritical
;;;1365   			{
;;;1366   				pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
000030  6975              LDR      r5,[r6,#0x14]
;;;1367   				pxDelayedList = pxDelayedTaskList;
000032  4814              LDR      r0,|L1.132|
000034  f8d08000          LDR      r8,[r0,#0]  ; pxDelayedTaskList
;;;1368   				pxOverflowedDelayedList = pxOverflowDelayedTaskList;
000038  4813              LDR      r0,|L1.136|
00003a  f8d09000          LDR      r9,[r0,#0]  ; pxOverflowDelayedTaskList
;;;1369   			}
;;;1370   			taskEXIT_CRITICAL();
00003e  f7fffffe          BL       vPortExitCritical
;;;1371   
;;;1372   			if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
000042  4545              CMP      r5,r8
000044  d001              BEQ      |L1.74|
000046  454d              CMP      r5,r9
000048  d101              BNE      |L1.78|
                  |L1.74|
;;;1373   			{
;;;1374   				/* The task being queried is referenced from one of the Blocked
;;;1375   				lists. */
;;;1376   				eReturn = eBlocked;
00004a  2402              MOVS     r4,#2
00004c  e015              B        |L1.122|
                  |L1.78|
;;;1377   			}
;;;1378   
;;;1379   			#if ( INCLUDE_vTaskSuspend == 1 )
;;;1380   				else if( pxStateList == &xSuspendedTaskList )
00004e  480f              LDR      r0,|L1.140|
000050  4285              CMP      r5,r0
000052  d10b              BNE      |L1.108|
;;;1381   				{
;;;1382   					/* The task being queried is referenced from the suspended
;;;1383   					list.  Is it genuinely suspended or is it blocked
;;;1384   					indefinitely? */
;;;1385   					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
000054  6ab0              LDR      r0,[r6,#0x28]
000056  b938              CBNZ     r0,|L1.104|
;;;1386   					{
;;;1387   						#if( configUSE_TASK_NOTIFICATIONS == 1 )
;;;1388   						{
;;;1389   							/* The task does not appear on the event list item of
;;;1390   							and of the RTOS objects, but could still be in the
;;;1391   							blocked state if it is waiting on its notification
;;;1392   							rather than waiting on an object. */
;;;1393   							if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
000058  f896005c          LDRB     r0,[r6,#0x5c]
00005c  2801              CMP      r0,#1
00005e  d101              BNE      |L1.100|
;;;1394   							{
;;;1395   								eReturn = eBlocked;
000060  2402              MOVS     r4,#2
000062  e00a              B        |L1.122|
                  |L1.100|
;;;1396   							}
;;;1397   							else
;;;1398   							{
;;;1399   								eReturn = eSuspended;
000064  2403              MOVS     r4,#3
000066  e008              B        |L1.122|
                  |L1.104|
;;;1400   							}
;;;1401   						}
;;;1402   						#else
;;;1403   						{
;;;1404   							eReturn = eSuspended;
;;;1405   						}
;;;1406   						#endif
;;;1407   					}
;;;1408   					else
;;;1409   					{
;;;1410   						eReturn = eBlocked;
000068  2402              MOVS     r4,#2
00006a  e006              B        |L1.122|
                  |L1.108|
;;;1411   					}
;;;1412   				}
;;;1413   			#endif
;;;1414   
;;;1415   			#if ( INCLUDE_vTaskDelete == 1 )
;;;1416   				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
00006c  4808              LDR      r0,|L1.144|
00006e  4285              CMP      r5,r0
000070  d000              BEQ      |L1.116|
000072  b90d              CBNZ     r5,|L1.120|
                  |L1.116|
;;;1417   				{
;;;1418   					/* The task being queried is referenced from the deleted
;;;1419   					tasks list, or it is not referenced from any lists at
;;;1420   					all. */
;;;1421   					eReturn = eDeleted;
000074  2404              MOVS     r4,#4
000076  e000              B        |L1.122|
                  |L1.120|
;;;1422   				}
;;;1423   			#endif
;;;1424   
;;;1425   			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
;;;1426   			{
;;;1427   				/* If the task is not in any other state, it must be in the
;;;1428   				Ready (including pending ready) state. */
;;;1429   				eReturn = eReady;
000078  2401              MOVS     r4,#1
                  |L1.122|
;;;1430   			}
;;;1431   		}
;;;1432   
;;;1433   		return eReturn;
00007a  4620              MOV      r0,r4
;;;1434   	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
00007c  e8bd87f0          POP      {r4-r10,pc}
;;;1435   
                          ENDP

                  |L1.128|
                          DCD      pxCurrentTCB
                  |L1.132|
                          DCD      pxDelayedTaskList
                  |L1.136|
                          DCD      pxOverflowDelayedTaskList
                  |L1.140|
                          DCD      xSuspendedTaskList
                  |L1.144|
                          DCD      xTasksWaitingTermination

                          AREA ||i.pcTaskGetName||, CODE, READONLY, ALIGN=2

                  pcTaskGetName PROC
;;;2307   
;;;2308   char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000000  4601              MOV      r1,r0
;;;2309   {
;;;2310   TCB_t *pxTCB;
;;;2311   
;;;2312   	/* If null is passed in here then the name of the calling task is being
;;;2313   	queried. */
;;;2314   	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
000002  b911              CBNZ     r1,|L2.10|
000004  4809              LDR      r0,|L2.44|
000006  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000008  e000              B        |L2.12|
                  |L2.10|
00000a  4608              MOV      r0,r1
                  |L2.12|
00000c  4602              MOV      r2,r0
;;;2315   	configASSERT( pxTCB );
00000e  b952              CBNZ     r2,|L2.38|
000010  bf00              NOP      
000012  2040              MOVS     r0,#0x40
000014  f3808811          MSR      BASEPRI,r0
000018  f3bf8f4f          DSB      
00001c  f3bf8f6f          ISB      
000020  bf00              NOP      
000022  bf00              NOP      
                  |L2.36|
000024  e7fe              B        |L2.36|
                  |L2.38|
;;;2316   	return &( pxTCB->pcTaskName[ 0 ] );
000026  f1020034          ADD      r0,r2,#0x34
;;;2317   }
00002a  4770              BX       lr
;;;2318   /*-----------------------------------------------------------*/
                          ENDP

                  |L2.44|
                          DCD      pxCurrentTCB

                          AREA ||i.prvAddCurrentTaskToDelayedList||, CODE, READONLY, ALIGN=2

                  prvAddCurrentTaskToDelayedList PROC
;;;4985   
;;;4986   static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;4987   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;4988   TickType_t xTimeToWake;
;;;4989   const TickType_t xConstTickCount = xTickCount;
000008  481c              LDR      r0,|L3.124|
00000a  6807              LDR      r7,[r0,#0]  ; xTickCount
;;;4990   
;;;4991   	#if( INCLUDE_xTaskAbortDelay == 1 )
;;;4992   	{
;;;4993   		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
;;;4994   		reset to pdFALSE so it can be detected as having been set to pdTRUE
;;;4995   		when the task leaves the Blocked state. */
;;;4996   		pxCurrentTCB->ucDelayAborted = pdFALSE;
;;;4997   	}
;;;4998   	#endif
;;;4999   
;;;5000   	/* Remove the task from the ready list before adding it to the blocked list
;;;5001   	as the same list item is used for both lists. */
;;;5002   	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
00000c  481c              LDR      r0,|L3.128|
00000e  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000010  1d00              ADDS     r0,r0,#4
000012  f7fffffe          BL       uxListRemove
000016  b950              CBNZ     r0,|L3.46|
;;;5003   	{
;;;5004   		/* The current task must be in a ready list, so there is no need to
;;;5005   		check, and the port reset macro can be called directly. */
;;;5006   		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentTCB cannot change as it is the calling task.  pxCurrentTCB->uxPriority and uxTopReadyPriority cannot change as called with scheduler suspended or in a critical section. */
000018  4819              LDR      r0,|L3.128|
00001a  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00001c  f890102c          LDRB     r1,[r0,#0x2c]
000020  2001              MOVS     r0,#1
000022  4088              LSLS     r0,r0,r1
000024  4917              LDR      r1,|L3.132|
000026  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000028  4381              BICS     r1,r1,r0
00002a  4816              LDR      r0,|L3.132|
00002c  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L3.46|
;;;5007   	}
;;;5008   	else
;;;5009   	{
;;;5010   		mtCOVERAGE_TEST_MARKER();
;;;5011   	}
;;;5012   
;;;5013   	#if ( INCLUDE_vTaskSuspend == 1 )
;;;5014   	{
;;;5015   		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
00002e  1c68              ADDS     r0,r5,#1
000030  b938              CBNZ     r0,|L3.66|
000032  b136              CBZ      r6,|L3.66|
;;;5016   		{
;;;5017   			/* Add the task to the suspended task list instead of a delayed task
;;;5018   			list to ensure it is not woken by a timing event.  It will block
;;;5019   			indefinitely. */
;;;5020   			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
000034  4812              LDR      r0,|L3.128|
000036  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
000038  1d09              ADDS     r1,r1,#4
00003a  4813              LDR      r0,|L3.136|
00003c  f7fffffe          BL       vListInsertEnd
000040  e01a              B        |L3.120|
                  |L3.66|
;;;5021   		}
;;;5022   		else
;;;5023   		{
;;;5024   			/* Calculate the time at which the task should be woken if the event
;;;5025   			does not occur.  This may overflow but this doesn't matter, the
;;;5026   			kernel will manage it correctly. */
;;;5027   			xTimeToWake = xConstTickCount + xTicksToWait;
000042  197c              ADDS     r4,r7,r5
;;;5028   
;;;5029   			/* The list item will be inserted in wake time order. */
;;;5030   			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
000044  480e              LDR      r0,|L3.128|
000046  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000048  6044              STR      r4,[r0,#4]
;;;5031   
;;;5032   			if( xTimeToWake < xConstTickCount )
00004a  42bc              CMP      r4,r7
00004c  d207              BCS      |L3.94|
;;;5033   			{
;;;5034   				/* Wake time has overflowed.  Place this item in the overflow
;;;5035   				list. */
;;;5036   				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
00004e  480c              LDR      r0,|L3.128|
000050  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
000052  1d09              ADDS     r1,r1,#4
000054  480d              LDR      r0,|L3.140|
000056  6800              LDR      r0,[r0,#0]  ; pxOverflowDelayedTaskList
000058  f7fffffe          BL       vListInsert
00005c  e00c              B        |L3.120|
                  |L3.94|
;;;5037   			}
;;;5038   			else
;;;5039   			{
;;;5040   				/* The wake time has not overflowed, so the current block list
;;;5041   				is used. */
;;;5042   				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
00005e  4808              LDR      r0,|L3.128|
000060  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
000062  1d09              ADDS     r1,r1,#4
000064  480a              LDR      r0,|L3.144|
000066  6800              LDR      r0,[r0,#0]  ; pxDelayedTaskList
000068  f7fffffe          BL       vListInsert
;;;5043   
;;;5044   				/* If the task entering the blocked state was placed at the
;;;5045   				head of the list of blocked tasks then xNextTaskUnblockTime
;;;5046   				needs to be updated too. */
;;;5047   				if( xTimeToWake < xNextTaskUnblockTime )
00006c  4809              LDR      r0,|L3.148|
00006e  6800              LDR      r0,[r0,#0]  ; xNextTaskUnblockTime
000070  4284              CMP      r4,r0
000072  d201              BCS      |L3.120|
;;;5048   				{
;;;5049   					xNextTaskUnblockTime = xTimeToWake;
000074  4807              LDR      r0,|L3.148|
000076  6004              STR      r4,[r0,#0]  ; xNextTaskUnblockTime
                  |L3.120|
;;;5050   				}
;;;5051   				else
;;;5052   				{
;;;5053   					mtCOVERAGE_TEST_MARKER();
;;;5054   				}
;;;5055   			}
;;;5056   		}
;;;5057   	}
;;;5058   	#else /* INCLUDE_vTaskSuspend */
;;;5059   	{
;;;5060   		/* Calculate the time at which the task should be woken if the event
;;;5061   		does not occur.  This may overflow but this doesn't matter, the kernel
;;;5062   		will manage it correctly. */
;;;5063   		xTimeToWake = xConstTickCount + xTicksToWait;
;;;5064   
;;;5065   		/* The list item will be inserted in wake time order. */
;;;5066   		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
;;;5067   
;;;5068   		if( xTimeToWake < xConstTickCount )
;;;5069   		{
;;;5070   			/* Wake time has overflowed.  Place this item in the overflow list. */
;;;5071   			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
;;;5072   		}
;;;5073   		else
;;;5074   		{
;;;5075   			/* The wake time has not overflowed, so the current block list is used. */
;;;5076   			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
;;;5077   
;;;5078   			/* If the task entering the blocked state was placed at the head of the
;;;5079   			list of blocked tasks then xNextTaskUnblockTime needs to be updated
;;;5080   			too. */
;;;5081   			if( xTimeToWake < xNextTaskUnblockTime )
;;;5082   			{
;;;5083   				xNextTaskUnblockTime = xTimeToWake;
;;;5084   			}
;;;5085   			else
;;;5086   			{
;;;5087   				mtCOVERAGE_TEST_MARKER();
;;;5088   			}
;;;5089   		}
;;;5090   
;;;5091   		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
;;;5092   		( void ) xCanBlockIndefinitely;
;;;5093   	}
;;;5094   	#endif /* INCLUDE_vTaskSuspend */
;;;5095   }
000078  e8bd81f0          POP      {r4-r8,pc}
;;;5096   
                          ENDP

                  |L3.124|
                          DCD      xTickCount
                  |L3.128|
                          DCD      pxCurrentTCB
                  |L3.132|
                          DCD      uxTopReadyPriority
                  |L3.136|
                          DCD      xSuspendedTaskList
                  |L3.140|
                          DCD      pxOverflowDelayedTaskList
                  |L3.144|
                          DCD      pxDelayedTaskList
                  |L3.148|
                          DCD      xNextTaskUnblockTime

                          AREA ||i.prvAddNewTaskToReadyList||, CODE, READONLY, ALIGN=2

                  prvAddNewTaskToReadyList PROC
;;;1042   
;;;1043   static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
000000  b510              PUSH     {r4,lr}
;;;1044   {
000002  4604              MOV      r4,r0
;;;1045   	/* Ensure interrupts don't access the task lists while the lists are being
;;;1046   	updated. */
;;;1047   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1048   	{
;;;1049   		uxCurrentNumberOfTasks++;
000008  4824              LDR      r0,|L4.156|
00000a  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
00000c  1c40              ADDS     r0,r0,#1
00000e  4923              LDR      r1,|L4.156|
000010  6008              STR      r0,[r1,#0]  ; uxCurrentNumberOfTasks
;;;1050   		if( pxCurrentTCB == NULL )
000012  4823              LDR      r0,|L4.160|
000014  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000016  b940              CBNZ     r0,|L4.42|
;;;1051   		{
;;;1052   			/* There are no other tasks, or all the other tasks are in
;;;1053   			the suspended state - make this the current task. */
;;;1054   			pxCurrentTCB = pxNewTCB;
000018  4821              LDR      r0,|L4.160|
00001a  6004              STR      r4,[r0,#0]  ; pxCurrentTCB
;;;1055   
;;;1056   			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
00001c  4608              MOV      r0,r1
00001e  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
000020  2801              CMP      r0,#1
000022  d10d              BNE      |L4.64|
;;;1057   			{
;;;1058   				/* This is the first task to be created so do the preliminary
;;;1059   				initialisation required.  We will not recover if this call
;;;1060   				fails, but we will report the failure. */
;;;1061   				prvInitialiseTaskLists();
000024  f7fffffe          BL       prvInitialiseTaskLists
000028  e00a              B        |L4.64|
                  |L4.42|
;;;1062   			}
;;;1063   			else
;;;1064   			{
;;;1065   				mtCOVERAGE_TEST_MARKER();
;;;1066   			}
;;;1067   		}
;;;1068   		else
;;;1069   		{
;;;1070   			/* If the scheduler is not already running, make this task the
;;;1071   			current task if it is the highest priority task to be created
;;;1072   			so far. */
;;;1073   			if( xSchedulerRunning == pdFALSE )
00002a  481e              LDR      r0,|L4.164|
00002c  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
00002e  b938              CBNZ     r0,|L4.64|
;;;1074   			{
;;;1075   				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
000030  481b              LDR      r0,|L4.160|
000032  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000034  6ac0              LDR      r0,[r0,#0x2c]
000036  6ae1              LDR      r1,[r4,#0x2c]
000038  4288              CMP      r0,r1
00003a  d801              BHI      |L4.64|
;;;1076   				{
;;;1077   					pxCurrentTCB = pxNewTCB;
00003c  4818              LDR      r0,|L4.160|
00003e  6004              STR      r4,[r0,#0]  ; pxCurrentTCB
                  |L4.64|
;;;1078   				}
;;;1079   				else
;;;1080   				{
;;;1081   					mtCOVERAGE_TEST_MARKER();
;;;1082   				}
;;;1083   			}
;;;1084   			else
;;;1085   			{
;;;1086   				mtCOVERAGE_TEST_MARKER();
;;;1087   			}
;;;1088   		}
;;;1089   
;;;1090   		uxTaskNumber++;
000040  4819              LDR      r0,|L4.168|
000042  6800              LDR      r0,[r0,#0]  ; uxTaskNumber
000044  1c40              ADDS     r0,r0,#1
000046  4918              LDR      r1,|L4.168|
000048  6008              STR      r0,[r1,#0]  ; uxTaskNumber
;;;1091   
;;;1092   		#if ( configUSE_TRACE_FACILITY == 1 )
;;;1093   		{
;;;1094   			/* Add a counter into the TCB for tracing only. */
;;;1095   			pxNewTCB->uxTCBNumber = uxTaskNumber;
00004a  4608              MOV      r0,r1
00004c  6800              LDR      r0,[r0,#0]  ; uxTaskNumber
00004e  6460              STR      r0,[r4,#0x44]
;;;1096   		}
;;;1097   		#endif /* configUSE_TRACE_FACILITY */
;;;1098   		traceTASK_CREATE( pxNewTCB );
;;;1099   
;;;1100   		prvAddTaskToReadyList( pxNewTCB );
000050  f894102c          LDRB     r1,[r4,#0x2c]
000054  2001              MOVS     r0,#1
000056  4088              LSLS     r0,r0,r1
000058  4914              LDR      r1,|L4.172|
00005a  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
00005c  4308              ORRS     r0,r0,r1
00005e  4913              LDR      r1,|L4.172|
000060  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
000062  6ae1              LDR      r1,[r4,#0x2c]
000064  eb010181          ADD      r1,r1,r1,LSL #2
000068  4a11              LDR      r2,|L4.176|
00006a  eb020081          ADD      r0,r2,r1,LSL #2
00006e  1d21              ADDS     r1,r4,#4
000070  f7fffffe          BL       vListInsertEnd
;;;1101   
;;;1102   		portSETUP_TCB( pxNewTCB );
;;;1103   	}
;;;1104   	taskEXIT_CRITICAL();
000074  f7fffffe          BL       vPortExitCritical
;;;1105   
;;;1106   	if( xSchedulerRunning != pdFALSE )
000078  480a              LDR      r0,|L4.164|
00007a  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
00007c  b168              CBZ      r0,|L4.154|
;;;1107   	{
;;;1108   		/* If the created task is of a higher priority than the current task
;;;1109   		then it should run now. */
;;;1110   		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
00007e  4808              LDR      r0,|L4.160|
000080  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000082  6ac0              LDR      r0,[r0,#0x2c]
000084  6ae1              LDR      r1,[r4,#0x2c]
000086  4288              CMP      r0,r1
000088  d207              BCS      |L4.154|
;;;1111   		{
;;;1112   			taskYIELD_IF_USING_PREEMPTION();
00008a  f04f5080          MOV      r0,#0x10000000
00008e  4909              LDR      r1,|L4.180|
000090  6008              STR      r0,[r1,#0]
000092  f3bf8f4f          DSB      
000096  f3bf8f6f          ISB      
                  |L4.154|
;;;1113   		}
;;;1114   		else
;;;1115   		{
;;;1116   			mtCOVERAGE_TEST_MARKER();
;;;1117   		}
;;;1118   	}
;;;1119   	else
;;;1120   	{
;;;1121   		mtCOVERAGE_TEST_MARKER();
;;;1122   	}
;;;1123   }
00009a  bd10              POP      {r4,pc}
;;;1124   /*-----------------------------------------------------------*/
                          ENDP

                  |L4.156|
                          DCD      uxCurrentNumberOfTasks
                  |L4.160|
                          DCD      pxCurrentTCB
                  |L4.164|
                          DCD      xSchedulerRunning
                  |L4.168|
                          DCD      uxTaskNumber
                  |L4.172|
                          DCD      uxTopReadyPriority
                  |L4.176|
                          DCD      pxReadyTasksLists
                  |L4.180|
                          DCD      0xe000ed04

                          AREA ||i.prvCheckTasksWaitingTermination||, CODE, READONLY, ALIGN=2

                  prvCheckTasksWaitingTermination PROC
;;;3529   
;;;3530   static void prvCheckTasksWaitingTermination( void )
000000  b510              PUSH     {r4,lr}
;;;3531   {
;;;3532   
;;;3533   	/** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
;;;3534   
;;;3535   	#if ( INCLUDE_vTaskDelete == 1 )
;;;3536   	{
;;;3537   		TCB_t *pxTCB;
;;;3538   
;;;3539   		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
;;;3540   		being called too often in the idle task. */
;;;3541   		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
000002  e016              B        |L5.50|
                  |L5.4|
;;;3542   		{
;;;3543   			taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;3544   			{
;;;3545   				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
000008  480c              LDR      r0,|L5.60|
00000a  68c0              LDR      r0,[r0,#0xc]
00000c  68c4              LDR      r4,[r0,#0xc]
;;;3546   				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
00000e  1d20              ADDS     r0,r4,#4
000010  f7fffffe          BL       uxListRemove
;;;3547   				--uxCurrentNumberOfTasks;
000014  480a              LDR      r0,|L5.64|
000016  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
000018  1e40              SUBS     r0,r0,#1
00001a  4909              LDR      r1,|L5.64|
00001c  6008              STR      r0,[r1,#0]  ; uxCurrentNumberOfTasks
;;;3548   				--uxDeletedTasksWaitingCleanUp;
00001e  4809              LDR      r0,|L5.68|
000020  6800              LDR      r0,[r0,#0]  ; uxDeletedTasksWaitingCleanUp
000022  1e40              SUBS     r0,r0,#1
000024  4907              LDR      r1,|L5.68|
000026  6008              STR      r0,[r1,#0]  ; uxDeletedTasksWaitingCleanUp
;;;3549   			}
;;;3550   			taskEXIT_CRITICAL();
000028  f7fffffe          BL       vPortExitCritical
;;;3551   
;;;3552   			prvDeleteTCB( pxTCB );
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       prvDeleteTCB
                  |L5.50|
000032  4804              LDR      r0,|L5.68|
000034  6800              LDR      r0,[r0,#0]            ;3541  ; uxDeletedTasksWaitingCleanUp
000036  2800              CMP      r0,#0                 ;3541
000038  d1e4              BNE      |L5.4|
;;;3553   		}
;;;3554   	}
;;;3555   	#endif /* INCLUDE_vTaskDelete */
;;;3556   }
00003a  bd10              POP      {r4,pc}
;;;3557   /*-----------------------------------------------------------*/
                          ENDP

                  |L5.60|
                          DCD      xTasksWaitingTermination
                  |L5.64|
                          DCD      uxCurrentNumberOfTasks
                  |L5.68|
                          DCD      uxDeletedTasksWaitingCleanUp

                          AREA ||i.prvDeleteTCB||, CODE, READONLY, ALIGN=1

                  prvDeleteTCB PROC
;;;3737   
;;;3738   	static void prvDeleteTCB( TCB_t *pxTCB )
000000  b510              PUSH     {r4,lr}
;;;3739   	{
000002  4604              MOV      r4,r0
;;;3740   		/* This call is required specifically for the TriCore port.  It must be
;;;3741   		above the vPortFree() calls.  The call is also used by ports/demos that
;;;3742   		want to allocate and clean RAM statically. */
;;;3743   		portCLEAN_UP_TCB( pxTCB );
;;;3744   
;;;3745   		/* Free up the memory allocated by the scheduler for the task.  It is up
;;;3746   		to the task to free any memory allocated at the application level. */
;;;3747   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;3748   		{
;;;3749   			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
;;;3750   		}
;;;3751   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;3752   
;;;3753   		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
;;;3754   		{
;;;3755   			/* The task can only have been allocated dynamically - free both
;;;3756   			the stack and TCB. */
;;;3757   			vPortFree( pxTCB->pxStack );
000004  6b20              LDR      r0,[r4,#0x30]
000006  f7fffffe          BL       vPortFree
;;;3758   			vPortFree( pxTCB );
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       vPortFree
;;;3759   		}
;;;3760   		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */
;;;3761   		{
;;;3762   			/* The task could have been allocated statically or dynamically, so
;;;3763   			check what was statically allocated before trying to free the
;;;3764   			memory. */
;;;3765   			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
;;;3766   			{
;;;3767   				/* Both the stack and TCB were allocated dynamically, so both
;;;3768   				must be freed. */
;;;3769   				vPortFree( pxTCB->pxStack );
;;;3770   				vPortFree( pxTCB );
;;;3771   			}
;;;3772   			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
;;;3773   			{
;;;3774   				/* Only the stack was statically allocated, so the TCB is the
;;;3775   				only memory that must be freed. */
;;;3776   				vPortFree( pxTCB );
;;;3777   			}
;;;3778   			else
;;;3779   			{
;;;3780   				/* Neither the stack nor the TCB were allocated dynamically, so
;;;3781   				nothing needs to be freed. */
;;;3782   				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
;;;3783   				mtCOVERAGE_TEST_MARKER();
;;;3784   			}
;;;3785   		}
;;;3786   		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
;;;3787   	}
000010  bd10              POP      {r4,pc}
;;;3788   
                          ENDP


                          AREA ||i.prvIdleTask||, CODE, READONLY, ALIGN=2

                  prvIdleTask PROC
;;;3285    */
;;;3286   static portTASK_FUNCTION( prvIdleTask, pvParameters )
000000  bf00              NOP      
                  |L7.2|
;;;3287   {
;;;3288   	/* Stop warnings. */
;;;3289   	( void ) pvParameters;
;;;3290   
;;;3291   	/** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
;;;3292   	SCHEDULER IS STARTED. **/
;;;3293   
;;;3294   	/* In case a task that has a secure context deletes itself, in which case
;;;3295   	the idle task is responsible for deleting the task's secure context, if
;;;3296   	any. */
;;;3297   	portTASK_CALLS_SECURE_FUNCTIONS();
;;;3298   
;;;3299   	for( ;; )
;;;3300   	{
;;;3301   		/* See if any tasks have deleted themselves - if so then the idle task
;;;3302   		is responsible for freeing the deleted task's TCB and stack. */
;;;3303   		prvCheckTasksWaitingTermination();
000002  f7fffffe          BL       prvCheckTasksWaitingTermination
;;;3304   
;;;3305   		#if ( configUSE_PREEMPTION == 0 )
;;;3306   		{
;;;3307   			/* If we are not using preemption we keep forcing a task switch to
;;;3308   			see if any other task has become available.  If we are using
;;;3309   			preemption we don't need to do this as any task becoming available
;;;3310   			will automatically get the processor anyway. */
;;;3311   			taskYIELD();
;;;3312   		}
;;;3313   		#endif /* configUSE_PREEMPTION */
;;;3314   
;;;3315   		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
;;;3316   		{
;;;3317   			/* When using preemption tasks of equal priority will be
;;;3318   			timesliced.  If a task that is sharing the idle priority is ready
;;;3319   			to run then the idle task should yield before the end of the
;;;3320   			timeslice.
;;;3321   
;;;3322   			A critical region is not required here as we are just reading from
;;;3323   			the list, and an occasional incorrect value will not matter.  If
;;;3324   			the ready list at the idle priority contains more than one task
;;;3325   			then a task other than the idle task is ready to execute. */
;;;3326   			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
000006  4806              LDR      r0,|L7.32|
000008  6800              LDR      r0,[r0,#0]  ; pxReadyTasksLists
00000a  2801              CMP      r0,#1
00000c  d9f9              BLS      |L7.2|
;;;3327   			{
;;;3328   				taskYIELD();
00000e  f04f5080          MOV      r0,#0x10000000
000012  4904              LDR      r1,|L7.36|
000014  6008              STR      r0,[r1,#0]
000016  f3bf8f4f          DSB      
00001a  f3bf8f6f          ISB      
00001e  e7f0              B        |L7.2|
;;;3329   			}
;;;3330   			else
;;;3331   			{
;;;3332   				mtCOVERAGE_TEST_MARKER();
;;;3333   			}
;;;3334   		}
;;;3335   		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
;;;3336   
;;;3337   		#if ( configUSE_IDLE_HOOK == 1 )
;;;3338   		{
;;;3339   			extern void vApplicationIdleHook( void );
;;;3340   
;;;3341   			/* Call the user defined function from within the idle task.  This
;;;3342   			allows the application designer to add background functionality
;;;3343   			without the overhead of a separate task.
;;;3344   			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
;;;3345   			CALL A FUNCTION THAT MIGHT BLOCK. */
;;;3346   			vApplicationIdleHook();
;;;3347   		}
;;;3348   		#endif /* configUSE_IDLE_HOOK */
;;;3349   
;;;3350   		/* This conditional compilation should use inequality to 0, not equality
;;;3351   		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
;;;3352   		user defined low power mode	implementations require
;;;3353   		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
;;;3354   		#if ( configUSE_TICKLESS_IDLE != 0 )
;;;3355   		{
;;;3356   		TickType_t xExpectedIdleTime;
;;;3357   
;;;3358   			/* It is not desirable to suspend then resume the scheduler on
;;;3359   			each iteration of the idle task.  Therefore, a preliminary
;;;3360   			test of the expected idle time is performed without the
;;;3361   			scheduler suspended.  The result here is not necessarily
;;;3362   			valid. */
;;;3363   			xExpectedIdleTime = prvGetExpectedIdleTime();
;;;3364   
;;;3365   			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;3366   			{
;;;3367   				vTaskSuspendAll();
;;;3368   				{
;;;3369   					/* Now the scheduler is suspended, the expected idle
;;;3370   					time can be sampled again, and this time its value can
;;;3371   					be used. */
;;;3372   					configASSERT( xNextTaskUnblockTime >= xTickCount );
;;;3373   					xExpectedIdleTime = prvGetExpectedIdleTime();
;;;3374   
;;;3375   					/* Define the following macro to set xExpectedIdleTime to 0
;;;3376   					if the application does not want
;;;3377   					portSUPPRESS_TICKS_AND_SLEEP() to be called. */
;;;3378   					configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( xExpectedIdleTime );
;;;3379   
;;;3380   					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;3381   					{
;;;3382   						traceLOW_POWER_IDLE_BEGIN();
;;;3383   						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
;;;3384   						traceLOW_POWER_IDLE_END();
;;;3385   					}
;;;3386   					else
;;;3387   					{
;;;3388   						mtCOVERAGE_TEST_MARKER();
;;;3389   					}
;;;3390   				}
;;;3391   				( void ) xTaskResumeAll();
;;;3392   			}
;;;3393   			else
;;;3394   			{
;;;3395   				mtCOVERAGE_TEST_MARKER();
;;;3396   			}
;;;3397   		}
;;;3398   		#endif /* configUSE_TICKLESS_IDLE */
;;;3399   	}
;;;3400   }
;;;3401   /*-----------------------------------------------------------*/
                          ENDP

                  |L7.32|
                          DCD      pxReadyTasksLists
                  |L7.36|
                          DCD      0xe000ed04

                          AREA ||i.prvInitialiseNewTask||, CODE, READONLY, ALIGN=1

                  prvInitialiseNewTask PROC
;;;836    
;;;837    static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;838    									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
;;;839    									const uint32_t ulStackDepth,
;;;840    									void * const pvParameters,
;;;841    									UBaseType_t uxPriority,
;;;842    									TaskHandle_t * const pxCreatedTask,
;;;843    									TCB_t *pxNewTCB,
;;;844    									const MemoryRegion_t * const xRegions )
;;;845    {
000004  4682              MOV      r10,r0
000006  460e              MOV      r6,r1
000008  4690              MOV      r8,r2
00000a  469b              MOV      r11,r3
00000c  9f0a              LDR      r7,[sp,#0x28]
00000e  9c0c              LDR      r4,[sp,#0x30]
;;;846    StackType_t *pxTopOfStack;
;;;847    UBaseType_t x;
;;;848    
;;;849    	#if( portUSING_MPU_WRAPPERS == 1 )
;;;850    		/* Should the task be created in privileged mode? */
;;;851    		BaseType_t xRunPrivileged;
;;;852    		if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
;;;853    		{
;;;854    			xRunPrivileged = pdTRUE;
;;;855    		}
;;;856    		else
;;;857    		{
;;;858    			xRunPrivileged = pdFALSE;
;;;859    		}
;;;860    		uxPriority &= ~portPRIVILEGE_BIT;
;;;861    	#endif /* portUSING_MPU_WRAPPERS == 1 */
;;;862    
;;;863    	configASSERT( pcName );
000010  b956              CBNZ     r6,|L8.40|
000012  bf00              NOP      
000014  2040              MOVS     r0,#0x40
000016  f3808811          MSR      BASEPRI,r0
00001a  f3bf8f4f          DSB      
00001e  f3bf8f6f          ISB      
000022  bf00              NOP      
000024  bf00              NOP      
                  |L8.38|
000026  e7fe              B        |L8.38|
                  |L8.40|
;;;864    
;;;865    	/* Avoid dependency on memset() if it is not required. */
;;;866    	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
;;;867    	{
;;;868    		/* Fill the stack with a known value to assist debugging. */
;;;869    		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
000028  ea4f0188          LSL      r1,r8,#2
00002c  22a5              MOVS     r2,#0xa5
00002e  6b20              LDR      r0,[r4,#0x30]
000030  f7fffffe          BL       __aeabi_memset
;;;870    	}
;;;871    	#endif /* tskSET_NEW_STACKS_TO_KNOWN_VALUE */
;;;872    
;;;873    	/* Calculate the top of stack address.  This depends on whether the stack
;;;874    	grows from high memory to low (as per the 80x86) or vice versa.
;;;875    	portSTACK_GROWTH is used to make the result positive or negative as required
;;;876    	by the port. */
;;;877    	#if( portSTACK_GROWTH < 0 )
;;;878    	{
;;;879    		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
000034  f1a80001          SUB      r0,r8,#1
000038  6b21              LDR      r1,[r4,#0x30]
00003a  eb010980          ADD      r9,r1,r0,LSL #2
;;;880    		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
00003e  f0290907          BIC      r9,r9,#7
;;;881    
;;;882    		/* Check the alignment of the calculated top of stack is correct. */
;;;883    		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
000042  f0090007          AND      r0,r9,#7
000046  b908              CBNZ     r0,|L8.76|
000048  2001              MOVS     r0,#1
00004a  e000              B        |L8.78|
                  |L8.76|
00004c  2000              MOVS     r0,#0
                  |L8.78|
00004e  b950              CBNZ     r0,|L8.102|
000050  bf00              NOP      
000052  2040              MOVS     r0,#0x40
000054  f3808811          MSR      BASEPRI,r0
000058  f3bf8f4f          DSB      
00005c  f3bf8f6f          ISB      
000060  bf00              NOP      
000062  bf00              NOP      
                  |L8.100|
000064  e7fe              B        |L8.100|
                  |L8.102|
;;;884    
;;;885    		#if( configRECORD_STACK_HIGH_ADDRESS == 1 )
;;;886    		{
;;;887    			/* Also record the stack's high address, which may assist
;;;888    			debugging. */
;;;889    			pxNewTCB->pxEndOfStack = pxTopOfStack;
;;;890    		}
;;;891    		#endif /* configRECORD_STACK_HIGH_ADDRESS */
;;;892    	}
;;;893    	#else /* portSTACK_GROWTH */
;;;894    	{
;;;895    		pxTopOfStack = pxNewTCB->pxStack;
;;;896    
;;;897    		/* Check the alignment of the stack buffer is correct. */
;;;898    		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
;;;899    
;;;900    		/* The other extreme of the stack space is required if stack checking is
;;;901    		performed. */
;;;902    		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
;;;903    	}
;;;904    	#endif /* portSTACK_GROWTH */
;;;905    
;;;906    	/* Store the task name in the TCB. */
;;;907    	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
000066  2500              MOVS     r5,#0
000068  e007              B        |L8.122|
                  |L8.106|
;;;908    	{
;;;909    		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
00006a  5d71              LDRB     r1,[r6,r5]
00006c  f1040034          ADD      r0,r4,#0x34
000070  5541              STRB     r1,[r0,r5]
;;;910    
;;;911    		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
;;;912    		configMAX_TASK_NAME_LEN characters just in case the memory after the
;;;913    		string is not accessible (extremely unlikely). */
;;;914    		if( pcName[ x ] == ( char ) 0x00 )
000072  5d70              LDRB     r0,[r6,r5]
000074  b900              CBNZ     r0,|L8.120|
;;;915    		{
;;;916    			break;
000076  e002              B        |L8.126|
                  |L8.120|
000078  1c6d              ADDS     r5,r5,#1              ;907
                  |L8.122|
00007a  2d10              CMP      r5,#0x10              ;907
00007c  d3f5              BCC      |L8.106|
                  |L8.126|
00007e  bf00              NOP      
;;;917    		}
;;;918    		else
;;;919    		{
;;;920    			mtCOVERAGE_TEST_MARKER();
;;;921    		}
;;;922    	}
;;;923    
;;;924    	/* Ensure the name string is terminated in the case that the string length
;;;925    	was greater or equal to configMAX_TASK_NAME_LEN. */
;;;926    	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
000080  2100              MOVS     r1,#0
000082  2043              MOVS     r0,#0x43
000084  5501              STRB     r1,[r0,r4]
;;;927    
;;;928    	/* This is used as an array index so must ensure it's not too large.  First
;;;929    	remove the privilege bit if one is present. */
;;;930    	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
000086  2f05              CMP      r7,#5
000088  d300              BCC      |L8.140|
;;;931    	{
;;;932    		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
00008a  2704              MOVS     r7,#4
                  |L8.140|
;;;933    	}
;;;934    	else
;;;935    	{
;;;936    		mtCOVERAGE_TEST_MARKER();
;;;937    	}
;;;938    
;;;939    	pxNewTCB->uxPriority = uxPriority;
00008c  62e7              STR      r7,[r4,#0x2c]
;;;940    	#if ( configUSE_MUTEXES == 1 )
;;;941    	{
;;;942    		pxNewTCB->uxBasePriority = uxPriority;
00008e  64e7              STR      r7,[r4,#0x4c]
;;;943    		pxNewTCB->uxMutexesHeld = 0;
000090  2000              MOVS     r0,#0
000092  6520              STR      r0,[r4,#0x50]
;;;944    	}
;;;945    	#endif /* configUSE_MUTEXES */
;;;946    
;;;947    	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
000094  1d20              ADDS     r0,r4,#4
000096  f7fffffe          BL       vListInitialiseItem
;;;948    	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
00009a  f1040018          ADD      r0,r4,#0x18
00009e  f7fffffe          BL       vListInitialiseItem
;;;949    
;;;950    	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
;;;951    	back to	the containing TCB from a generic item in a list. */
;;;952    	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
0000a2  6124              STR      r4,[r4,#0x10]
;;;953    
;;;954    	/* Event lists are always in priority order. */
;;;955    	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
0000a4  f1c70005          RSB      r0,r7,#5
0000a8  61a0              STR      r0,[r4,#0x18]
;;;956    	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
0000aa  6264              STR      r4,[r4,#0x24]
;;;957    
;;;958    	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
;;;959    	{
;;;960    		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
;;;961    	}
;;;962    	#endif /* portCRITICAL_NESTING_IN_TCB */
;;;963    
;;;964    	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
;;;965    	{
;;;966    		pxNewTCB->pxTaskTag = NULL;
;;;967    	}
;;;968    	#endif /* configUSE_APPLICATION_TASK_TAG */
;;;969    
;;;970    	#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;971    	{
;;;972    		pxNewTCB->ulRunTimeCounter = 0UL;
0000ac  2000              MOVS     r0,#0
0000ae  6560              STR      r0,[r4,#0x54]
;;;973    	}
;;;974    	#endif /* configGENERATE_RUN_TIME_STATS */
;;;975    
;;;976    	#if ( portUSING_MPU_WRAPPERS == 1 )
;;;977    	{
;;;978    		vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth );
;;;979    	}
;;;980    	#else
;;;981    	{
;;;982    		/* Avoid compiler warning about unreferenced parameter. */
;;;983    		( void ) xRegions;
;;;984    	}
;;;985    	#endif
;;;986    
;;;987    	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
;;;988    	{
;;;989    		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
;;;990    		{
;;;991    			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
;;;992    		}
;;;993    	}
;;;994    	#endif
;;;995    
;;;996    	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
;;;997    	{
;;;998    		pxNewTCB->ulNotifiedValue = 0;
0000b0  65a0              STR      r0,[r4,#0x58]
;;;999    		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
0000b2  f884005c          STRB     r0,[r4,#0x5c]
;;;1000   	}
;;;1001   	#endif
;;;1002   
;;;1003   	#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;1004   	{
;;;1005   		/* Initialise this task's Newlib reent structure. */
;;;1006   		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
;;;1007   	}
;;;1008   	#endif
;;;1009   
;;;1010   	#if( INCLUDE_xTaskAbortDelay == 1 )
;;;1011   	{
;;;1012   		pxNewTCB->ucDelayAborted = pdFALSE;
;;;1013   	}
;;;1014   	#endif
;;;1015   
;;;1016   	/* Initialize the TCB stack to look as if the task was already running,
;;;1017   	but had been interrupted by the scheduler.  The return address is set
;;;1018   	to the start of the task function. Once the stack has been initialised
;;;1019   	the top of stack variable is updated. */
;;;1020   	#if( portUSING_MPU_WRAPPERS == 1 )
;;;1021   	{
;;;1022   		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
;;;1023   	}
;;;1024   	#else /* portUSING_MPU_WRAPPERS */
;;;1025   	{
;;;1026   		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
0000b6  465a              MOV      r2,r11
0000b8  4651              MOV      r1,r10
0000ba  4648              MOV      r0,r9
0000bc  f7fffffe          BL       pxPortInitialiseStack
0000c0  6020              STR      r0,[r4,#0]
;;;1027   	}
;;;1028   	#endif /* portUSING_MPU_WRAPPERS */
;;;1029   
;;;1030   	if( pxCreatedTask != NULL )
0000c2  980b              LDR      r0,[sp,#0x2c]
0000c4  b108              CBZ      r0,|L8.202|
;;;1031   	{
;;;1032   		/* Pass the handle out in an anonymous way.  The handle can be used to
;;;1033   		change the created task's priority, delete the created task, etc.*/
;;;1034   		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
0000c6  980b              LDR      r0,[sp,#0x2c]
0000c8  6004              STR      r4,[r0,#0]
                  |L8.202|
;;;1035   	}
;;;1036   	else
;;;1037   	{
;;;1038   		mtCOVERAGE_TEST_MARKER();
;;;1039   	}
;;;1040   }
0000ca  e8bd9ff0          POP      {r4-r12,pc}
;;;1041   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvInitialiseTaskLists||, CODE, READONLY, ALIGN=2

                  prvInitialiseTaskLists PROC
;;;3497   
;;;3498   static void prvInitialiseTaskLists( void )
000000  b510              PUSH     {r4,lr}
;;;3499   {
;;;3500   UBaseType_t uxPriority;
;;;3501   
;;;3502   	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
000002  2400              MOVS     r4,#0
000004  e007              B        |L9.22|
                  |L9.6|
;;;3503   	{
;;;3504   		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
000006  eb040184          ADD      r1,r4,r4,LSL #2
00000a  4a0f              LDR      r2,|L9.72|
00000c  eb020081          ADD      r0,r2,r1,LSL #2
000010  f7fffffe          BL       vListInitialise
000014  1c64              ADDS     r4,r4,#1              ;3502
                  |L9.22|
000016  2c05              CMP      r4,#5                 ;3502
000018  d3f5              BCC      |L9.6|
;;;3505   	}
;;;3506   
;;;3507   	vListInitialise( &xDelayedTaskList1 );
00001a  480c              LDR      r0,|L9.76|
00001c  f7fffffe          BL       vListInitialise
;;;3508   	vListInitialise( &xDelayedTaskList2 );
000020  480b              LDR      r0,|L9.80|
000022  f7fffffe          BL       vListInitialise
;;;3509   	vListInitialise( &xPendingReadyList );
000026  480b              LDR      r0,|L9.84|
000028  f7fffffe          BL       vListInitialise
;;;3510   
;;;3511   	#if ( INCLUDE_vTaskDelete == 1 )
;;;3512   	{
;;;3513   		vListInitialise( &xTasksWaitingTermination );
00002c  480a              LDR      r0,|L9.88|
00002e  f7fffffe          BL       vListInitialise
;;;3514   	}
;;;3515   	#endif /* INCLUDE_vTaskDelete */
;;;3516   
;;;3517   	#if ( INCLUDE_vTaskSuspend == 1 )
;;;3518   	{
;;;3519   		vListInitialise( &xSuspendedTaskList );
000032  480a              LDR      r0,|L9.92|
000034  f7fffffe          BL       vListInitialise
;;;3520   	}
;;;3521   	#endif /* INCLUDE_vTaskSuspend */
;;;3522   
;;;3523   	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
;;;3524   	using list2. */
;;;3525   	pxDelayedTaskList = &xDelayedTaskList1;
000038  4804              LDR      r0,|L9.76|
00003a  4909              LDR      r1,|L9.96|
00003c  6008              STR      r0,[r1,#0]  ; pxDelayedTaskList
;;;3526   	pxOverflowDelayedTaskList = &xDelayedTaskList2;
00003e  4804              LDR      r0,|L9.80|
000040  4908              LDR      r1,|L9.100|
000042  6008              STR      r0,[r1,#0]  ; pxOverflowDelayedTaskList
;;;3527   }
000044  bd10              POP      {r4,pc}
;;;3528   /*-----------------------------------------------------------*/
                          ENDP

000046  0000              DCW      0x0000
                  |L9.72|
                          DCD      pxReadyTasksLists
                  |L9.76|
                          DCD      xDelayedTaskList1
                  |L9.80|
                          DCD      xDelayedTaskList2
                  |L9.84|
                          DCD      xPendingReadyList
                  |L9.88|
                          DCD      xTasksWaitingTermination
                  |L9.92|
                          DCD      xSuspendedTaskList
                  |L9.96|
                          DCD      pxDelayedTaskList
                  |L9.100|
                          DCD      pxOverflowDelayedTaskList

                          AREA ||i.prvListTasksWithinSingleList||, CODE, READONLY, ALIGN=1

                  prvListTasksWithinSingleList PROC
;;;3656   
;;;3657   	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;3658   	{
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4690              MOV      r8,r2
;;;3659   	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
;;;3660   	UBaseType_t uxTask = 0;
00000a  2600              MOVS     r6,#0
;;;3661   
;;;3662   		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
00000c  6820              LDR      r0,[r4,#0]
00000e  b348              CBZ      r0,|L10.100|
;;;3663   		{
;;;3664   			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
000010  4620              MOV      r0,r4
000012  6841              LDR      r1,[r0,#4]
000014  6849              LDR      r1,[r1,#4]
000016  6041              STR      r1,[r0,#4]
000018  f1000108          ADD      r1,r0,#8
00001c  6842              LDR      r2,[r0,#4]
00001e  428a              CMP      r2,r1
000020  d102              BNE      |L10.40|
000022  6841              LDR      r1,[r0,#4]
000024  6849              LDR      r1,[r1,#4]
000026  6041              STR      r1,[r0,#4]
                  |L10.40|
000028  6841              LDR      r1,[r0,#4]
00002a  f8d1900c          LDR      r9,[r1,#0xc]
;;;3665   
;;;3666   			/* Populate an TaskStatus_t structure within the
;;;3667   			pxTaskStatusArray array for each task that is referenced from
;;;3668   			pxList.  See the definition of TaskStatus_t in task.h for the
;;;3669   			meaning of each TaskStatus_t structure member. */
;;;3670   			do
00002e  bf00              NOP      
                  |L10.48|
;;;3671   			{
;;;3672   				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
000030  4620              MOV      r0,r4
000032  6841              LDR      r1,[r0,#4]
000034  6849              LDR      r1,[r1,#4]
000036  6041              STR      r1,[r0,#4]
000038  f1000108          ADD      r1,r0,#8
00003c  6842              LDR      r2,[r0,#4]
00003e  428a              CMP      r2,r1
000040  d102              BNE      |L10.72|
000042  6841              LDR      r1,[r0,#4]
000044  6849              LDR      r1,[r1,#4]
000046  6041              STR      r1,[r0,#4]
                  |L10.72|
000048  6841              LDR      r1,[r0,#4]
00004a  68cd              LDR      r5,[r1,#0xc]
;;;3673   				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
00004c  eb0600c6          ADD      r0,r6,r6,LSL #3
000050  eb070180          ADD      r1,r7,r0,LSL #2
000054  4643              MOV      r3,r8
000056  2201              MOVS     r2,#1
000058  4628              MOV      r0,r5
00005a  f7fffffe          BL       vTaskGetInfo
;;;3674   				uxTask++;
00005e  1c76              ADDS     r6,r6,#1
;;;3675   			} while( pxNextTCB != pxFirstTCB );
000060  454d              CMP      r5,r9
000062  d1e5              BNE      |L10.48|
                  |L10.100|
;;;3676   		}
;;;3677   		else
;;;3678   		{
;;;3679   			mtCOVERAGE_TEST_MARKER();
;;;3680   		}
;;;3681   
;;;3682   		return uxTask;
000064  4630              MOV      r0,r6
;;;3683   	}
000066  e8bd87f0          POP      {r4-r10,pc}
;;;3684   
                          ENDP


                          AREA ||i.prvResetNextTaskUnblockTime||, CODE, READONLY, ALIGN=2

                  prvResetNextTaskUnblockTime PROC
;;;3791   
;;;3792   static void prvResetNextTaskUnblockTime( void )
000000  490a              LDR      r1,|L11.44|
;;;3793   {
;;;3794   TCB_t *pxTCB;
;;;3795   
;;;3796   	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
000002  6809              LDR      r1,[r1,#0]  ; pxDelayedTaskList
000004  6809              LDR      r1,[r1,#0]
000006  b909              CBNZ     r1,|L11.12|
000008  2101              MOVS     r1,#1
00000a  e000              B        |L11.14|
                  |L11.12|
00000c  2100              MOVS     r1,#0
                  |L11.14|
00000e  b121              CBZ      r1,|L11.26|
;;;3797   	{
;;;3798   		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
;;;3799   		the maximum possible value so it is	extremely unlikely that the
;;;3800   		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
;;;3801   		there is an item in the delayed list. */
;;;3802   		xNextTaskUnblockTime = portMAX_DELAY;
000010  f04f31ff          MOV      r1,#0xffffffff
000014  4a06              LDR      r2,|L11.48|
000016  6011              STR      r1,[r2,#0]  ; xNextTaskUnblockTime
000018  e006              B        |L11.40|
                  |L11.26|
;;;3803   	}
;;;3804   	else
;;;3805   	{
;;;3806   		/* The new current delayed list is not empty, get the value of
;;;3807   		the item at the head of the delayed list.  This is the time at
;;;3808   		which the task at the head of the delayed list should be removed
;;;3809   		from the Blocked state. */
;;;3810   		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
00001a  4904              LDR      r1,|L11.44|
00001c  6809              LDR      r1,[r1,#0]  ; pxDelayedTaskList
00001e  68c9              LDR      r1,[r1,#0xc]
000020  68c8              LDR      r0,[r1,#0xc]
;;;3811   		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
000022  4a03              LDR      r2,|L11.48|
000024  6841              LDR      r1,[r0,#4]
000026  6011              STR      r1,[r2,#0]  ; xNextTaskUnblockTime
                  |L11.40|
;;;3812   	}
;;;3813   }
000028  4770              BX       lr
;;;3814   /*-----------------------------------------------------------*/
                          ENDP

00002a  0000              DCW      0x0000
                  |L11.44|
                          DCD      pxDelayedTaskList
                  |L11.48|
                          DCD      xNextTaskUnblockTime

                          AREA ||i.prvTaskCheckFreeStackSpace||, CODE, READONLY, ALIGN=1

                  prvTaskCheckFreeStackSpace PROC
;;;3689   
;;;3690   	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
000000  4602              MOV      r2,r0
;;;3691   	{
;;;3692   	uint32_t ulCount = 0U;
000002  2100              MOVS     r1,#0
;;;3693   
;;;3694   		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
000004  e001              B        |L12.10|
                  |L12.6|
;;;3695   		{
;;;3696   			pucStackByte -= portSTACK_GROWTH;
000006  1c52              ADDS     r2,r2,#1
;;;3697   			ulCount++;
000008  1c49              ADDS     r1,r1,#1
                  |L12.10|
00000a  7810              LDRB     r0,[r2,#0]            ;3694
00000c  28a5              CMP      r0,#0xa5              ;3694
00000e  d0fa              BEQ      |L12.6|
;;;3698   		}
;;;3699   
;;;3700   		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
000010  0889              LSRS     r1,r1,#2
;;;3701   
;;;3702   		return ( configSTACK_DEPTH_TYPE ) ulCount;
000012  b288              UXTH     r0,r1
;;;3703   	}
000014  4770              BX       lr
;;;3704   
                          ENDP


                          AREA ||i.prvTaskIsTaskSuspended||, CODE, READONLY, ALIGN=2

                  prvTaskIsTaskSuspended PROC
;;;1767   
;;;1768   	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
000000  b510              PUSH     {r4,lr}
;;;1769   	{
000002  4602              MOV      r2,r0
;;;1770   	BaseType_t xReturn = pdFALSE;
000004  2000              MOVS     r0,#0
;;;1771   	const TCB_t * const pxTCB = xTask;
000006  4611              MOV      r1,r2
;;;1772   
;;;1773   		/* Accesses xPendingReadyList so must be called from a critical
;;;1774   		section. */
;;;1775   
;;;1776   		/* It does not make sense to check if the calling task is suspended. */
;;;1777   		configASSERT( xTask );
000008  b952              CBNZ     r2,|L13.32|
00000a  bf00              NOP      
00000c  2340              MOVS     r3,#0x40
00000e  f3838811          MSR      BASEPRI,r3
000012  f3bf8f4f          DSB      
000016  f3bf8f6f          ISB      
00001a  bf00              NOP      
00001c  bf00              NOP      
                  |L13.30|
00001e  e7fe              B        |L13.30|
                  |L13.32|
;;;1778   
;;;1779   		/* Is the task being resumed actually in the suspended list? */
;;;1780   		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
000020  4c0b              LDR      r4,|L13.80|
000022  694b              LDR      r3,[r1,#0x14]
000024  42a3              CMP      r3,r4
000026  d101              BNE      |L13.44|
000028  2301              MOVS     r3,#1
00002a  e000              B        |L13.46|
                  |L13.44|
00002c  2300              MOVS     r3,#0
                  |L13.46|
00002e  b173              CBZ      r3,|L13.78|
;;;1781   		{
;;;1782   			/* Has the task already been resumed from within an ISR? */
;;;1783   			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
000030  4c08              LDR      r4,|L13.84|
000032  6a8b              LDR      r3,[r1,#0x28]
000034  42a3              CMP      r3,r4
000036  d101              BNE      |L13.60|
000038  2301              MOVS     r3,#1
00003a  e000              B        |L13.62|
                  |L13.60|
00003c  2300              MOVS     r3,#0
                  |L13.62|
00003e  b933              CBNZ     r3,|L13.78|
;;;1784   			{
;;;1785   				/* Is it in the suspended list because it is in the	Suspended
;;;1786   				state, or because is is blocked with no timeout? */
;;;1787   				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
000040  6a8b              LDR      r3,[r1,#0x28]
000042  b90b              CBNZ     r3,|L13.72|
000044  2301              MOVS     r3,#1
000046  e000              B        |L13.74|
                  |L13.72|
000048  2300              MOVS     r3,#0
                  |L13.74|
00004a  b103              CBZ      r3,|L13.78|
;;;1788   				{
;;;1789   					xReturn = pdTRUE;
00004c  2001              MOVS     r0,#1
                  |L13.78|
;;;1790   				}
;;;1791   				else
;;;1792   				{
;;;1793   					mtCOVERAGE_TEST_MARKER();
;;;1794   				}
;;;1795   			}
;;;1796   			else
;;;1797   			{
;;;1798   				mtCOVERAGE_TEST_MARKER();
;;;1799   			}
;;;1800   		}
;;;1801   		else
;;;1802   		{
;;;1803   			mtCOVERAGE_TEST_MARKER();
;;;1804   		}
;;;1805   
;;;1806   		return xReturn;
;;;1807   	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
00004e  bd10              POP      {r4,pc}
;;;1808   
                          ENDP

                  |L13.80|
                          DCD      xSuspendedTaskList
                  |L13.84|
                          DCD      xPendingReadyList

                          AREA ||i.prvWriteNameToBuffer||, CODE, READONLY, ALIGN=1

                  prvWriteNameToBuffer PROC
;;;4194   
;;;4195   	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
000000  b570              PUSH     {r4-r6,lr}
;;;4196   	{
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;4197   	size_t x;
;;;4198   
;;;4199   		/* Start by copying the entire string. */
;;;4200   		strcpy( pcBuffer, pcTaskName );
000006  4631              MOV      r1,r6
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       strcpy
;;;4201   
;;;4202   		/* Pad the end of the string with spaces to ensure columns line up when
;;;4203   		printed out. */
;;;4204   		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       strlen
000014  4604              MOV      r4,r0
000016  e002              B        |L14.30|
                  |L14.24|
;;;4205   		{
;;;4206   			pcBuffer[ x ] = ' ';
000018  2020              MOVS     r0,#0x20
00001a  5528              STRB     r0,[r5,r4]
00001c  1c64              ADDS     r4,r4,#1              ;4204
                  |L14.30|
00001e  2c0f              CMP      r4,#0xf               ;4204
000020  d3fa              BCC      |L14.24|
;;;4207   		}
;;;4208   
;;;4209   		/* Terminate. */
;;;4210   		pcBuffer[ x ] = ( char ) 0x00;
000022  2000              MOVS     r0,#0
000024  5528              STRB     r0,[r5,r4]
;;;4211   
;;;4212   		/* Return the new end of string. */
;;;4213   		return &( pcBuffer[ x ] );
000026  1928              ADDS     r0,r5,r4
;;;4214   	}
000028  bd70              POP      {r4-r6,pc}
;;;4215   
                          ENDP


                          AREA ||i.pvTaskIncrementMutexHeldCount||, CODE, READONLY, ALIGN=2

                  pvTaskIncrementMutexHeldCount PROC
;;;4460   
;;;4461   	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
000000  4806              LDR      r0,|L15.28|
;;;4462   	{
;;;4463   		/* If xSemaphoreCreateMutex() is called before any tasks have been created
;;;4464   		then pxCurrentTCB will be NULL. */
;;;4465   		if( pxCurrentTCB != NULL )
000002  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000004  b130              CBZ      r0,|L15.20|
;;;4466   		{
;;;4467   			( pxCurrentTCB->uxMutexesHeld )++;
000006  4905              LDR      r1,|L15.28|
000008  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00000a  f1010050          ADD      r0,r1,#0x50
00000e  6d09              LDR      r1,[r1,#0x50]
000010  1c49              ADDS     r1,r1,#1
000012  6001              STR      r1,[r0,#0]
                  |L15.20|
;;;4468   		}
;;;4469   
;;;4470   		return pxCurrentTCB;
000014  4801              LDR      r0,|L15.28|
000016  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
;;;4471   	}
000018  4770              BX       lr
;;;4472   
                          ENDP

00001a  0000              DCW      0x0000
                  |L15.28|
                          DCD      pxCurrentTCB

                          AREA ||i.ulTaskNotifyTake||, CODE, READONLY, ALIGN=2

                  ulTaskNotifyTake PROC
;;;4477   
;;;4478   	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
000000  b570              PUSH     {r4-r6,lr}
;;;4479   	{
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;4480   	uint32_t ulReturn;
;;;4481   
;;;4482   		taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;4483   		{
;;;4484   			/* Only block if the notification count is not already non-zero. */
;;;4485   			if( pxCurrentTCB->ulNotifiedValue == 0UL )
00000a  4818              LDR      r0,|L16.108|
00000c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000e  6d80              LDR      r0,[r0,#0x58]
000010  b988              CBNZ     r0,|L16.54|
;;;4486   			{
;;;4487   				/* Mark this task as waiting for a notification. */
;;;4488   				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
000012  2001              MOVS     r0,#1
000014  4915              LDR      r1,|L16.108|
000016  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000018  f881005c          STRB     r0,[r1,#0x5c]
;;;4489   
;;;4490   				if( xTicksToWait > ( TickType_t ) 0 )
00001c  b15d              CBZ      r5,|L16.54|
;;;4491   				{
;;;4492   					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
00001e  2101              MOVS     r1,#1
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;4493   					traceTASK_NOTIFY_TAKE_BLOCK();
;;;4494   
;;;4495   					/* All ports are written to allow a yield in a critical
;;;4496   					section (some will yield immediately, others wait until the
;;;4497   					critical section exits) - but it is not something that
;;;4498   					application code should ever do. */
;;;4499   					portYIELD_WITHIN_API();
000026  f04f5080          MOV      r0,#0x10000000
00002a  4911              LDR      r1,|L16.112|
00002c  6008              STR      r0,[r1,#0]
00002e  f3bf8f4f          DSB      
000032  f3bf8f6f          ISB      
                  |L16.54|
;;;4500   				}
;;;4501   				else
;;;4502   				{
;;;4503   					mtCOVERAGE_TEST_MARKER();
;;;4504   				}
;;;4505   			}
;;;4506   			else
;;;4507   			{
;;;4508   				mtCOVERAGE_TEST_MARKER();
;;;4509   			}
;;;4510   		}
;;;4511   		taskEXIT_CRITICAL();
000036  f7fffffe          BL       vPortExitCritical
;;;4512   
;;;4513   		taskENTER_CRITICAL();
00003a  f7fffffe          BL       vPortEnterCritical
;;;4514   		{
;;;4515   			traceTASK_NOTIFY_TAKE();
;;;4516   			ulReturn = pxCurrentTCB->ulNotifiedValue;
00003e  480b              LDR      r0,|L16.108|
000040  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000042  6d84              LDR      r4,[r0,#0x58]
;;;4517   
;;;4518   			if( ulReturn != 0UL )
000044  b14c              CBZ      r4,|L16.90|
;;;4519   			{
;;;4520   				if( xClearCountOnExit != pdFALSE )
000046  b126              CBZ      r6,|L16.82|
;;;4521   				{
;;;4522   					pxCurrentTCB->ulNotifiedValue = 0UL;
000048  2000              MOVS     r0,#0
00004a  4908              LDR      r1,|L16.108|
00004c  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00004e  6588              STR      r0,[r1,#0x58]
000050  e003              B        |L16.90|
                  |L16.82|
;;;4523   				}
;;;4524   				else
;;;4525   				{
;;;4526   					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
000052  1e60              SUBS     r0,r4,#1
000054  4905              LDR      r1,|L16.108|
000056  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000058  6588              STR      r0,[r1,#0x58]
                  |L16.90|
;;;4527   				}
;;;4528   			}
;;;4529   			else
;;;4530   			{
;;;4531   				mtCOVERAGE_TEST_MARKER();
;;;4532   			}
;;;4533   
;;;4534   			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
00005a  2000              MOVS     r0,#0
00005c  4903              LDR      r1,|L16.108|
00005e  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000060  f881005c          STRB     r0,[r1,#0x5c]
;;;4535   		}
;;;4536   		taskEXIT_CRITICAL();
000064  f7fffffe          BL       vPortExitCritical
;;;4537   
;;;4538   		return ulReturn;
000068  4620              MOV      r0,r4
;;;4539   	}
00006a  bd70              POP      {r4-r6,pc}
;;;4540   
                          ENDP

                  |L16.108|
                          DCD      pxCurrentTCB
                  |L16.112|
                          DCD      0xe000ed04

                          AREA ||i.uxTaskGetNumberOfTasks||, CODE, READONLY, ALIGN=2

                  uxTaskGetNumberOfTasks PROC
;;;2299   
;;;2300   UBaseType_t uxTaskGetNumberOfTasks( void )
000000  4801              LDR      r0,|L17.8|
;;;2301   {
;;;2302   	/* A critical section is not required because the variables are of type
;;;2303   	BaseType_t. */
;;;2304   	return uxCurrentNumberOfTasks;
000002  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
;;;2305   }
000004  4770              BX       lr
;;;2306   /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L17.8|
                          DCD      uxCurrentNumberOfTasks

                          AREA ||i.uxTaskGetSystemState||, CODE, READONLY, ALIGN=2

                  uxTaskGetSystemState PROC
;;;2454   
;;;2455   	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2456   	{
000004  4605              MOV      r5,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
;;;2457   	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
00000a  2400              MOVS     r4,#0
00000c  2705              MOVS     r7,#5
;;;2458   
;;;2459   		vTaskSuspendAll();
00000e  f7fffffe          BL       vTaskSuspendAll
;;;2460   		{
;;;2461   			/* Is there a space in the array for each task in the system? */
;;;2462   			if( uxArraySize >= uxCurrentNumberOfTasks )
000012  4822              LDR      r0,|L18.156|
000014  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
000016  4580              CMP      r8,r0
000018  d33b              BCC      |L18.146|
;;;2463   			{
;;;2464   				/* Fill in an TaskStatus_t structure with information on each
;;;2465   				task in the Ready state. */
;;;2466   				do
00001a  bf00              NOP      
                  |L18.28|
;;;2467   				{
;;;2468   					uxQueue--;
00001c  1e7f              SUBS     r7,r7,#1
;;;2469   					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
00001e  eb070287          ADD      r2,r7,r7,LSL #2
000022  4b1f              LDR      r3,|L18.160|
000024  eb030182          ADD      r1,r3,r2,LSL #2
000028  eb0402c4          ADD      r2,r4,r4,LSL #3
00002c  eb050082          ADD      r0,r5,r2,LSL #2
000030  2201              MOVS     r2,#1
000032  f7fffffe          BL       prvListTasksWithinSingleList
000036  4404              ADD      r4,r4,r0
;;;2470   
;;;2471   				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000038  2f00              CMP      r7,#0
00003a  d1ef              BNE      |L18.28|
;;;2472   
;;;2473   				/* Fill in an TaskStatus_t structure with information on each
;;;2474   				task in the Blocked state. */
;;;2475   				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
00003c  eb0401c4          ADD      r1,r4,r4,LSL #3
000040  eb050081          ADD      r0,r5,r1,LSL #2
000044  2202              MOVS     r2,#2
000046  4917              LDR      r1,|L18.164|
000048  6809              LDR      r1,[r1,#0]  ; pxDelayedTaskList
00004a  f7fffffe          BL       prvListTasksWithinSingleList
00004e  4404              ADD      r4,r4,r0
;;;2476   				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
000050  eb0401c4          ADD      r1,r4,r4,LSL #3
000054  eb050081          ADD      r0,r5,r1,LSL #2
000058  2202              MOVS     r2,#2
00005a  4913              LDR      r1,|L18.168|
00005c  6809              LDR      r1,[r1,#0]  ; pxOverflowDelayedTaskList
00005e  f7fffffe          BL       prvListTasksWithinSingleList
000062  4404              ADD      r4,r4,r0
;;;2477   
;;;2478   				#if( INCLUDE_vTaskDelete == 1 )
;;;2479   				{
;;;2480   					/* Fill in an TaskStatus_t structure with information on
;;;2481   					each task that has been deleted but not yet cleaned up. */
;;;2482   					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
000064  eb0401c4          ADD      r1,r4,r4,LSL #3
000068  eb050081          ADD      r0,r5,r1,LSL #2
00006c  2204              MOVS     r2,#4
00006e  490f              LDR      r1,|L18.172|
000070  f7fffffe          BL       prvListTasksWithinSingleList
000074  4404              ADD      r4,r4,r0
;;;2483   				}
;;;2484   				#endif
;;;2485   
;;;2486   				#if ( INCLUDE_vTaskSuspend == 1 )
;;;2487   				{
;;;2488   					/* Fill in an TaskStatus_t structure with information on
;;;2489   					each task in the Suspended state. */
;;;2490   					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
000076  eb0401c4          ADD      r1,r4,r4,LSL #3
00007a  eb050081          ADD      r0,r5,r1,LSL #2
00007e  2203              MOVS     r2,#3
000080  490b              LDR      r1,|L18.176|
000082  f7fffffe          BL       prvListTasksWithinSingleList
000086  4404              ADD      r4,r4,r0
;;;2491   				}
;;;2492   				#endif
;;;2493   
;;;2494   				#if ( configGENERATE_RUN_TIME_STATS == 1)
;;;2495   				{
;;;2496   					if( pulTotalRunTime != NULL )
000088  b11e              CBZ      r6,|L18.146|
;;;2497   					{
;;;2498   						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
;;;2499   							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
;;;2500   						#else
;;;2501   							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
00008a  490a              LDR      r1,|L18.180|
00008c  6808              LDR      r0,[r1,#0]  ; FreeRTOSRunTimeTicks
00008e  6849              LDR      r1,[r1,#4]  ; FreeRTOSRunTimeTicks
000090  6030              STR      r0,[r6,#0]
                  |L18.146|
;;;2502   						#endif
;;;2503   					}
;;;2504   				}
;;;2505   				#else
;;;2506   				{
;;;2507   					if( pulTotalRunTime != NULL )
;;;2508   					{
;;;2509   						*pulTotalRunTime = 0;
;;;2510   					}
;;;2511   				}
;;;2512   				#endif
;;;2513   			}
;;;2514   			else
;;;2515   			{
;;;2516   				mtCOVERAGE_TEST_MARKER();
;;;2517   			}
;;;2518   		}
;;;2519   		( void ) xTaskResumeAll();
000092  f7fffffe          BL       xTaskResumeAll
;;;2520   
;;;2521   		return uxTask;
000096  4620              MOV      r0,r4
;;;2522   	}
000098  e8bd81f0          POP      {r4-r8,pc}
;;;2523   
                          ENDP

                  |L18.156|
                          DCD      uxCurrentNumberOfTasks
                  |L18.160|
                          DCD      pxReadyTasksLists
                  |L18.164|
                          DCD      pxDelayedTaskList
                  |L18.168|
                          DCD      pxOverflowDelayedTaskList
                  |L18.172|
                          DCD      xTasksWaitingTermination
                  |L18.176|
                          DCD      xSuspendedTaskList
                  |L18.180|
                          DCD      FreeRTOSRunTimeTicks

                          AREA ||i.uxTaskGetTaskNumber||, CODE, READONLY, ALIGN=1

                  uxTaskGetTaskNumber PROC
;;;3238   
;;;3239   	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
000000  4601              MOV      r1,r0
;;;3240   	{
;;;3241   	UBaseType_t uxReturn;
;;;3242   	TCB_t const *pxTCB;
;;;3243   
;;;3244   		if( xTask != NULL )
000002  b111              CBZ      r1,|L19.10|
;;;3245   		{
;;;3246   			pxTCB = xTask;
000004  460a              MOV      r2,r1
;;;3247   			uxReturn = pxTCB->uxTaskNumber;
000006  6c90              LDR      r0,[r2,#0x48]
000008  e000              B        |L19.12|
                  |L19.10|
;;;3248   		}
;;;3249   		else
;;;3250   		{
;;;3251   			uxReturn = 0U;
00000a  2000              MOVS     r0,#0
                  |L19.12|
;;;3252   		}
;;;3253   
;;;3254   		return uxReturn;
;;;3255   	}
00000c  4770              BX       lr
;;;3256   
                          ENDP


                          AREA ||i.uxTaskPriorityGet||, CODE, READONLY, ALIGN=2

                  uxTaskPriorityGet PROC
;;;1440   
;;;1441   	UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
000000  b570              PUSH     {r4-r6,lr}
;;;1442   	{
000002  4604              MOV      r4,r0
;;;1443   	TCB_t const *pxTCB;
;;;1444   	UBaseType_t uxReturn;
;;;1445   
;;;1446   		taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1447   		{
;;;1448   			/* If null is passed in here then it is the priority of the task
;;;1449   			that called uxTaskPriorityGet() that is being queried. */
;;;1450   			pxTCB = prvGetTCBFromHandle( xTask );
000008  b914              CBNZ     r4,|L20.16|
00000a  4805              LDR      r0,|L20.32|
00000c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000e  e000              B        |L20.18|
                  |L20.16|
000010  4620              MOV      r0,r4
                  |L20.18|
000012  4606              MOV      r6,r0
;;;1451   			uxReturn = pxTCB->uxPriority;
000014  6af5              LDR      r5,[r6,#0x2c]
;;;1452   		}
;;;1453   		taskEXIT_CRITICAL();
000016  f7fffffe          BL       vPortExitCritical
;;;1454   
;;;1455   		return uxReturn;
00001a  4628              MOV      r0,r5
;;;1456   	}
00001c  bd70              POP      {r4-r6,pc}
;;;1457   
                          ENDP

00001e  0000              DCW      0x0000
                  |L20.32|
                          DCD      pxCurrentTCB

                          AREA ||i.uxTaskPriorityGetFromISR||, CODE, READONLY, ALIGN=2

                  uxTaskPriorityGetFromISR PROC
;;;1462   
;;;1463   	UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1464   	{
000004  4605              MOV      r5,r0
;;;1465   	TCB_t const *pxTCB;
;;;1466   	UBaseType_t uxReturn, uxSavedInterruptState;
;;;1467   
;;;1468   		/* RTOS ports that support interrupt nesting have the concept of a
;;;1469   		maximum	system call (or maximum API call) interrupt priority.
;;;1470   		Interrupts that are	above the maximum system call priority are keep
;;;1471   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;1472   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;1473   		is defined in FreeRTOSConfig.h then
;;;1474   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1475   		failure if a FreeRTOS API function is called from an interrupt that has
;;;1476   		been assigned a priority above the configured maximum system call
;;;1477   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;1478   		from interrupts	that have been assigned a priority at or (logically)
;;;1479   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;1480   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;1481   		simple as possible.  More information (albeit Cortex-M specific) is
;;;1482   		provided on the following link:
;;;1483   		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1484   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000006  f7fffffe          BL       vPortValidateInterruptPriority
;;;1485   
;;;1486   		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
00000a  bf00              NOP      
00000c  2140              MOVS     r1,#0x40
00000e  f3ef8011          MRS      r0,BASEPRI
000012  f3818811          MSR      BASEPRI,r1
000016  f3bf8f4f          DSB      
00001a  f3bf8f6f          ISB      
00001e  bf00              NOP      
000020  4604              MOV      r4,r0
;;;1487   		{
;;;1488   			/* If null is passed in here then it is the priority of the calling
;;;1489   			task that is being queried. */
;;;1490   			pxTCB = prvGetTCBFromHandle( xTask );
000022  b915              CBNZ     r5,|L21.42|
000024  4806              LDR      r0,|L21.64|
000026  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000028  e000              B        |L21.44|
                  |L21.42|
00002a  4628              MOV      r0,r5
                  |L21.44|
00002c  4607              MOV      r7,r0
;;;1491   			uxReturn = pxTCB->uxPriority;
00002e  6afe              LDR      r6,[r7,#0x2c]
;;;1492   		}
;;;1493   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
000030  bf00              NOP      
000032  f3848811          MSR      BASEPRI,r4
000036  bf00              NOP      
;;;1494   
;;;1495   		return uxReturn;
000038  4630              MOV      r0,r6
;;;1496   	}
00003a  e8bd81f0          POP      {r4-r8,pc}
;;;1497   
                          ENDP

00003e  0000              DCW      0x0000
                  |L21.64|
                          DCD      pxCurrentTCB

                          AREA ||i.uxTaskResetEventItemValue||, CODE, READONLY, ALIGN=2

                  uxTaskResetEventItemValue PROC
;;;4444   
;;;4445   TickType_t uxTaskResetEventItemValue( void )
000000  4905              LDR      r1,|L22.24|
;;;4446   {
;;;4447   TickType_t uxReturn;
;;;4448   
;;;4449   	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
000002  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000004  6988              LDR      r0,[r1,#0x18]
;;;4450   
;;;4451   	/* Reset the event list item to its normal value - so it can be used with
;;;4452   	queues and semaphores. */
;;;4453   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000006  4904              LDR      r1,|L22.24|
000008  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00000a  6ac9              LDR      r1,[r1,#0x2c]
00000c  f1c10105          RSB      r1,r1,#5
000010  4a01              LDR      r2,|L22.24|
000012  6812              LDR      r2,[r2,#0]  ; pxCurrentTCB
000014  6191              STR      r1,[r2,#0x18]
;;;4454   
;;;4455   	return uxReturn;
;;;4456   }
000016  4770              BX       lr
;;;4457   /*-----------------------------------------------------------*/
                          ENDP

                  |L22.24|
                          DCD      pxCurrentTCB

                          AREA ||i.vTaskDelay||, CODE, READONLY, ALIGN=2

                  vTaskDelay PROC
;;;1303   
;;;1304   	void vTaskDelay( const TickType_t xTicksToDelay )
000000  b570              PUSH     {r4-r6,lr}
;;;1305   	{
000002  4604              MOV      r4,r0
;;;1306   	BaseType_t xAlreadyYielded = pdFALSE;
000004  2500              MOVS     r5,#0
;;;1307   
;;;1308   		/* A delay time of zero just forces a reschedule. */
;;;1309   		if( xTicksToDelay > ( TickType_t ) 0U )
000006  b1d4              CBZ      r4,|L23.62|
;;;1310   		{
;;;1311   			configASSERT( uxSchedulerSuspended == 0 );
000008  4812              LDR      r0,|L23.84|
00000a  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00000c  b908              CBNZ     r0,|L23.18|
00000e  2001              MOVS     r0,#1
000010  e000              B        |L23.20|
                  |L23.18|
000012  2000              MOVS     r0,#0
                  |L23.20|
000014  b950              CBNZ     r0,|L23.44|
000016  bf00              NOP      
000018  2040              MOVS     r0,#0x40
00001a  f3808811          MSR      BASEPRI,r0
00001e  f3bf8f4f          DSB      
000022  f3bf8f6f          ISB      
000026  bf00              NOP      
000028  bf00              NOP      
                  |L23.42|
00002a  e7fe              B        |L23.42|
                  |L23.44|
;;;1312   			vTaskSuspendAll();
00002c  f7fffffe          BL       vTaskSuspendAll
;;;1313   			{
;;;1314   				traceTASK_DELAY();
;;;1315   
;;;1316   				/* A task that is removed from the event list while the
;;;1317   				scheduler is suspended will not get placed in the ready
;;;1318   				list or removed from the blocked list until the scheduler
;;;1319   				is resumed.
;;;1320   
;;;1321   				This task cannot be in an event list as it is the currently
;;;1322   				executing task. */
;;;1323   				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
000030  2100              MOVS     r1,#0
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;1324   			}
;;;1325   			xAlreadyYielded = xTaskResumeAll();
000038  f7fffffe          BL       xTaskResumeAll
00003c  4605              MOV      r5,r0
                  |L23.62|
;;;1326   		}
;;;1327   		else
;;;1328   		{
;;;1329   			mtCOVERAGE_TEST_MARKER();
;;;1330   		}
;;;1331   
;;;1332   		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;1333   		have put ourselves to sleep. */
;;;1334   		if( xAlreadyYielded == pdFALSE )
00003e  b93d              CBNZ     r5,|L23.80|
;;;1335   		{
;;;1336   			portYIELD_WITHIN_API();
000040  f04f5080          MOV      r0,#0x10000000
000044  4904              LDR      r1,|L23.88|
000046  6008              STR      r0,[r1,#0]
000048  f3bf8f4f          DSB      
00004c  f3bf8f6f          ISB      
                  |L23.80|
;;;1337   		}
;;;1338   		else
;;;1339   		{
;;;1340   			mtCOVERAGE_TEST_MARKER();
;;;1341   		}
;;;1342   	}
000050  bd70              POP      {r4-r6,pc}
;;;1343   
                          ENDP

000052  0000              DCW      0x0000
                  |L23.84|
                          DCD      uxSchedulerSuspended
                  |L23.88|
                          DCD      0xe000ed04

                          AREA ||i.vTaskDelayUntil||, CODE, READONLY, ALIGN=2

                  vTaskDelayUntil PROC
;;;1219   
;;;1220   	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1221   	{
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;1222   	TickType_t xTimeToWake;
;;;1223   	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
000008  f04f0900          MOV      r9,#0
;;;1224   
;;;1225   		configASSERT( pxPreviousWakeTime );
00000c  b954              CBNZ     r4,|L24.36|
00000e  bf00              NOP      
000010  2040              MOVS     r0,#0x40
000012  f3808811          MSR      BASEPRI,r0
000016  f3bf8f4f          DSB      
00001a  f3bf8f6f          ISB      
00001e  bf00              NOP      
000020  bf00              NOP      
                  |L24.34|
000022  e7fe              B        |L24.34|
                  |L24.36|
;;;1226   		configASSERT( ( xTimeIncrement > 0U ) );
000024  b10f              CBZ      r7,|L24.42|
000026  2001              MOVS     r0,#1
000028  e000              B        |L24.44|
                  |L24.42|
00002a  2000              MOVS     r0,#0
                  |L24.44|
00002c  b950              CBNZ     r0,|L24.68|
00002e  bf00              NOP      
000030  2040              MOVS     r0,#0x40
000032  f3808811          MSR      BASEPRI,r0
000036  f3bf8f4f          DSB      
00003a  f3bf8f6f          ISB      
00003e  bf00              NOP      
000040  bf00              NOP      
                  |L24.66|
000042  e7fe              B        |L24.66|
                  |L24.68|
;;;1227   		configASSERT( uxSchedulerSuspended == 0 );
000044  4820              LDR      r0,|L24.200|
000046  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000048  b908              CBNZ     r0,|L24.78|
00004a  2001              MOVS     r0,#1
00004c  e000              B        |L24.80|
                  |L24.78|
00004e  2000              MOVS     r0,#0
                  |L24.80|
000050  b950              CBNZ     r0,|L24.104|
000052  bf00              NOP      
000054  2040              MOVS     r0,#0x40
000056  f3808811          MSR      BASEPRI,r0
00005a  f3bf8f4f          DSB      
00005e  f3bf8f6f          ISB      
000062  bf00              NOP      
000064  bf00              NOP      
                  |L24.102|
000066  e7fe              B        |L24.102|
                  |L24.104|
;;;1228   
;;;1229   		vTaskSuspendAll();
000068  f7fffffe          BL       vTaskSuspendAll
;;;1230   		{
;;;1231   			/* Minor optimisation.  The tick count cannot change in this
;;;1232   			block. */
;;;1233   			const TickType_t xConstTickCount = xTickCount;
00006c  4817              LDR      r0,|L24.204|
00006e  6806              LDR      r6,[r0,#0]  ; xTickCount
;;;1234   
;;;1235   			/* Generate the tick time at which the task wants to wake. */
;;;1236   			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
000070  6820              LDR      r0,[r4,#0]
000072  19c5              ADDS     r5,r0,r7
;;;1237   
;;;1238   			if( xConstTickCount < *pxPreviousWakeTime )
000074  6820              LDR      r0,[r4,#0]
000076  42b0              CMP      r0,r6
000078  d907              BLS      |L24.138|
;;;1239   			{
;;;1240   				/* The tick count has overflowed since this function was
;;;1241   				lasted called.  In this case the only time we should ever
;;;1242   				actually delay is if the wake time has also	overflowed,
;;;1243   				and the wake time is greater than the tick time.  When this
;;;1244   				is the case it is as if neither time had overflowed. */
;;;1245   				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
00007a  6820              LDR      r0,[r4,#0]
00007c  42a8              CMP      r0,r5
00007e  d90b              BLS      |L24.152|
000080  42b5              CMP      r5,r6
000082  d909              BLS      |L24.152|
;;;1246   				{
;;;1247   					xShouldDelay = pdTRUE;
000084  f04f0901          MOV      r9,#1
000088  e006              B        |L24.152|
                  |L24.138|
;;;1248   				}
;;;1249   				else
;;;1250   				{
;;;1251   					mtCOVERAGE_TEST_MARKER();
;;;1252   				}
;;;1253   			}
;;;1254   			else
;;;1255   			{
;;;1256   				/* The tick time has not overflowed.  In this case we will
;;;1257   				delay if either the wake time has overflowed, and/or the
;;;1258   				tick time is less than the wake time. */
;;;1259   				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
00008a  6820              LDR      r0,[r4,#0]
00008c  42a8              CMP      r0,r5
00008e  d801              BHI      |L24.148|
000090  42b5              CMP      r5,r6
000092  d901              BLS      |L24.152|
                  |L24.148|
;;;1260   				{
;;;1261   					xShouldDelay = pdTRUE;
000094  f04f0901          MOV      r9,#1
                  |L24.152|
;;;1262   				}
;;;1263   				else
;;;1264   				{
;;;1265   					mtCOVERAGE_TEST_MARKER();
;;;1266   				}
;;;1267   			}
;;;1268   
;;;1269   			/* Update the wake time ready for the next call. */
;;;1270   			*pxPreviousWakeTime = xTimeToWake;
000098  6025              STR      r5,[r4,#0]
;;;1271   
;;;1272   			if( xShouldDelay != pdFALSE )
00009a  f1b90f00          CMP      r9,#0
00009e  d003              BEQ      |L24.168|
;;;1273   			{
;;;1274   				traceTASK_DELAY_UNTIL( xTimeToWake );
;;;1275   
;;;1276   				/* prvAddCurrentTaskToDelayedList() needs the block time, not
;;;1277   				the time to wake, so subtract the current tick count. */
;;;1278   				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
0000a0  1ba8              SUBS     r0,r5,r6
0000a2  2100              MOVS     r1,#0
0000a4  f7fffffe          BL       prvAddCurrentTaskToDelayedList
                  |L24.168|
;;;1279   			}
;;;1280   			else
;;;1281   			{
;;;1282   				mtCOVERAGE_TEST_MARKER();
;;;1283   			}
;;;1284   		}
;;;1285   		xAlreadyYielded = xTaskResumeAll();
0000a8  f7fffffe          BL       xTaskResumeAll
0000ac  4680              MOV      r8,r0
;;;1286   
;;;1287   		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;1288   		have put ourselves to sleep. */
;;;1289   		if( xAlreadyYielded == pdFALSE )
0000ae  f1b80f00          CMP      r8,#0
0000b2  d107              BNE      |L24.196|
;;;1290   		{
;;;1291   			portYIELD_WITHIN_API();
0000b4  f04f5080          MOV      r0,#0x10000000
0000b8  4905              LDR      r1,|L24.208|
0000ba  6008              STR      r0,[r1,#0]
0000bc  f3bf8f4f          DSB      
0000c0  f3bf8f6f          ISB      
                  |L24.196|
;;;1292   		}
;;;1293   		else
;;;1294   		{
;;;1295   			mtCOVERAGE_TEST_MARKER();
;;;1296   		}
;;;1297   	}
0000c4  e8bd87f0          POP      {r4-r10,pc}
;;;1298   
                          ENDP

                  |L24.200|
                          DCD      uxSchedulerSuspended
                  |L24.204|
                          DCD      xTickCount
                  |L24.208|
                          DCD      0xe000ed04

                          AREA ||i.vTaskDelete||, CODE, READONLY, ALIGN=2

                  vTaskDelete PROC
;;;1127   
;;;1128   	void vTaskDelete( TaskHandle_t xTaskToDelete )
000000  b570              PUSH     {r4-r6,lr}
;;;1129   	{
000002  4605              MOV      r5,r0
;;;1130   	TCB_t *pxTCB;
;;;1131   
;;;1132   		taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1133   		{
;;;1134   			/* If null is passed in here then it is the calling task that is
;;;1135   			being deleted. */
;;;1136   			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
000008  b915              CBNZ     r5,|L25.16|
00000a  4830              LDR      r0,|L25.204|
00000c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000e  e000              B        |L25.18|
                  |L25.16|
000010  4628              MOV      r0,r5
                  |L25.18|
000012  4604              MOV      r4,r0
;;;1137   
;;;1138   			/* Remove task from the ready list. */
;;;1139   			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000014  1d20              ADDS     r0,r4,#4
000016  f7fffffe          BL       uxListRemove
00001a  b978              CBNZ     r0,|L25.60|
;;;1140   			{
;;;1141   				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
00001c  6ae0              LDR      r0,[r4,#0x2c]
00001e  eb000080          ADD      r0,r0,r0,LSL #2
000022  492b              LDR      r1,|L25.208|
000024  f8510020          LDR      r0,[r1,r0,LSL #2]
000028  b940              CBNZ     r0,|L25.60|
00002a  f894102c          LDRB     r1,[r4,#0x2c]
00002e  2001              MOVS     r0,#1
000030  4088              LSLS     r0,r0,r1
000032  4928              LDR      r1,|L25.212|
000034  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000036  4381              BICS     r1,r1,r0
000038  4826              LDR      r0,|L25.212|
00003a  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L25.60|
;;;1142   			}
;;;1143   			else
;;;1144   			{
;;;1145   				mtCOVERAGE_TEST_MARKER();
;;;1146   			}
;;;1147   
;;;1148   			/* Is the task waiting on an event also? */
;;;1149   			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
00003c  6aa0              LDR      r0,[r4,#0x28]
00003e  b118              CBZ      r0,|L25.72|
;;;1150   			{
;;;1151   				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
000040  f1040018          ADD      r0,r4,#0x18
000044  f7fffffe          BL       uxListRemove
                  |L25.72|
;;;1152   			}
;;;1153   			else
;;;1154   			{
;;;1155   				mtCOVERAGE_TEST_MARKER();
;;;1156   			}
;;;1157   
;;;1158   			/* Increment the uxTaskNumber also so kernel aware debuggers can
;;;1159   			detect that the task lists need re-generating.  This is done before
;;;1160   			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
;;;1161   			not return. */
;;;1162   			uxTaskNumber++;
000048  4823              LDR      r0,|L25.216|
00004a  6800              LDR      r0,[r0,#0]  ; uxTaskNumber
00004c  1c40              ADDS     r0,r0,#1
00004e  4922              LDR      r1,|L25.216|
000050  6008              STR      r0,[r1,#0]  ; uxTaskNumber
;;;1163   
;;;1164   			if( pxTCB == pxCurrentTCB )
000052  481e              LDR      r0,|L25.204|
000054  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000056  4284              CMP      r4,r0
000058  d109              BNE      |L25.110|
;;;1165   			{
;;;1166   				/* A task is deleting itself.  This cannot complete within the
;;;1167   				task itself, as a context switch to another task is required.
;;;1168   				Place the task in the termination list.  The idle task will
;;;1169   				check the termination list and free up any memory allocated by
;;;1170   				the scheduler for the TCB and stack of the deleted task. */
;;;1171   				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
00005a  1d21              ADDS     r1,r4,#4
00005c  481f              LDR      r0,|L25.220|
00005e  f7fffffe          BL       vListInsertEnd
;;;1172   
;;;1173   				/* Increment the ucTasksDeleted variable so the idle task knows
;;;1174   				there is a task that has been deleted and that it should therefore
;;;1175   				check the xTasksWaitingTermination list. */
;;;1176   				++uxDeletedTasksWaitingCleanUp;
000062  481f              LDR      r0,|L25.224|
000064  6800              LDR      r0,[r0,#0]  ; uxDeletedTasksWaitingCleanUp
000066  1c40              ADDS     r0,r0,#1
000068  491d              LDR      r1,|L25.224|
00006a  6008              STR      r0,[r1,#0]  ; uxDeletedTasksWaitingCleanUp
00006c  e009              B        |L25.130|
                  |L25.110|
;;;1177   
;;;1178   				/* The pre-delete hook is primarily for the Windows simulator,
;;;1179   				in which Windows specific clean up operations are performed,
;;;1180   				after which it is not possible to yield away from this task -
;;;1181   				hence xYieldPending is used to latch that a context switch is
;;;1182   				required. */
;;;1183   				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
;;;1184   			}
;;;1185   			else
;;;1186   			{
;;;1187   				--uxCurrentNumberOfTasks;
00006e  481d              LDR      r0,|L25.228|
000070  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
000072  1e40              SUBS     r0,r0,#1
000074  491b              LDR      r1,|L25.228|
000076  6008              STR      r0,[r1,#0]  ; uxCurrentNumberOfTasks
;;;1188   				prvDeleteTCB( pxTCB );
000078  4620              MOV      r0,r4
00007a  f7fffffe          BL       prvDeleteTCB
;;;1189   
;;;1190   				/* Reset the next expected unblock time in case it referred to
;;;1191   				the task that has just been deleted. */
;;;1192   				prvResetNextTaskUnblockTime();
00007e  f7fffffe          BL       prvResetNextTaskUnblockTime
                  |L25.130|
;;;1193   			}
;;;1194   
;;;1195   			traceTASK_DELETE( pxTCB );
;;;1196   		}
;;;1197   		taskEXIT_CRITICAL();
000082  f7fffffe          BL       vPortExitCritical
;;;1198   
;;;1199   		/* Force a reschedule if it is the currently running task that has just
;;;1200   		been deleted. */
;;;1201   		if( xSchedulerRunning != pdFALSE )
000086  4818              LDR      r0,|L25.232|
000088  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
00008a  b1e8              CBZ      r0,|L25.200|
;;;1202   		{
;;;1203   			if( pxTCB == pxCurrentTCB )
00008c  480f              LDR      r0,|L25.204|
00008e  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000090  4284              CMP      r4,r0
000092  d119              BNE      |L25.200|
;;;1204   			{
;;;1205   				configASSERT( uxSchedulerSuspended == 0 );
000094  4815              LDR      r0,|L25.236|
000096  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000098  b908              CBNZ     r0,|L25.158|
00009a  2001              MOVS     r0,#1
00009c  e000              B        |L25.160|
                  |L25.158|
00009e  2000              MOVS     r0,#0
                  |L25.160|
0000a0  b950              CBNZ     r0,|L25.184|
0000a2  bf00              NOP      
0000a4  2040              MOVS     r0,#0x40
0000a6  f3808811          MSR      BASEPRI,r0
0000aa  f3bf8f4f          DSB      
0000ae  f3bf8f6f          ISB      
0000b2  bf00              NOP      
0000b4  bf00              NOP      
                  |L25.182|
0000b6  e7fe              B        |L25.182|
                  |L25.184|
;;;1206   				portYIELD_WITHIN_API();
0000b8  f04f5080          MOV      r0,#0x10000000
0000bc  490c              LDR      r1,|L25.240|
0000be  6008              STR      r0,[r1,#0]
0000c0  f3bf8f4f          DSB      
0000c4  f3bf8f6f          ISB      
                  |L25.200|
;;;1207   			}
;;;1208   			else
;;;1209   			{
;;;1210   				mtCOVERAGE_TEST_MARKER();
;;;1211   			}
;;;1212   		}
;;;1213   	}
0000c8  bd70              POP      {r4-r6,pc}
;;;1214   
                          ENDP

0000ca  0000              DCW      0x0000
                  |L25.204|
                          DCD      pxCurrentTCB
                  |L25.208|
                          DCD      pxReadyTasksLists
                  |L25.212|
                          DCD      uxTopReadyPriority
                  |L25.216|
                          DCD      uxTaskNumber
                  |L25.220|
                          DCD      xTasksWaitingTermination
                  |L25.224|
                          DCD      uxDeletedTasksWaitingCleanUp
                  |L25.228|
                          DCD      uxCurrentNumberOfTasks
                  |L25.232|
                          DCD      xSchedulerRunning
                  |L25.236|
                          DCD      uxSchedulerSuspended
                  |L25.240|
                          DCD      0xe000ed04

                          AREA ||i.vTaskEndScheduler||, CODE, READONLY, ALIGN=2

                  vTaskEndScheduler PROC
;;;2059   
;;;2060   void vTaskEndScheduler( void )
000000  b510              PUSH     {r4,lr}
;;;2061   {
;;;2062   	/* Stop the scheduler interrupts and call the portable scheduler end
;;;2063   	routine so the original ISRs can be restored if necessary.  The port
;;;2064   	layer must ensure interrupts enable	bit is left in the correct state. */
;;;2065   	portDISABLE_INTERRUPTS();
000002  bf00              NOP      
000004  2040              MOVS     r0,#0x40
000006  f3808811          MSR      BASEPRI,r0
00000a  f3bf8f4f          DSB      
00000e  f3bf8f6f          ISB      
000012  bf00              NOP      
;;;2066   	xSchedulerRunning = pdFALSE;
000014  2000              MOVS     r0,#0
000016  4902              LDR      r1,|L26.32|
000018  6008              STR      r0,[r1,#0]  ; xSchedulerRunning
;;;2067   	vPortEndScheduler();
00001a  f7fffffe          BL       vPortEndScheduler
;;;2068   }
00001e  bd10              POP      {r4,pc}
;;;2069   /*----------------------------------------------------------*/
                          ENDP

                  |L26.32|
                          DCD      xSchedulerRunning

                          AREA ||i.vTaskGetInfo||, CODE, READONLY, ALIGN=2

                  vTaskGetInfo PROC
;;;3560   
;;;3561   	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3562   	{
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4690              MOV      r8,r2
00000a  461e              MOV      r6,r3
;;;3563   	TCB_t *pxTCB;
;;;3564   
;;;3565   		/* xTask is NULL then get the state of the calling task. */
;;;3566   		pxTCB = prvGetTCBFromHandle( xTask );
00000c  b917              CBNZ     r7,|L27.20|
00000e  481c              LDR      r0,|L27.128|
000010  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000012  e000              B        |L27.22|
                  |L27.20|
000014  4638              MOV      r0,r7
                  |L27.22|
000016  4605              MOV      r5,r0
;;;3567   
;;;3568   		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
000018  6025              STR      r5,[r4,#0]
;;;3569   		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
00001a  f1050034          ADD      r0,r5,#0x34
00001e  6060              STR      r0,[r4,#4]
;;;3570   		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
000020  6ae8              LDR      r0,[r5,#0x2c]
000022  6120              STR      r0,[r4,#0x10]
;;;3571   		pxTaskStatus->pxStackBase = pxTCB->pxStack;
000024  6b28              LDR      r0,[r5,#0x30]
000026  61e0              STR      r0,[r4,#0x1c]
;;;3572   		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
000028  6c68              LDR      r0,[r5,#0x44]
00002a  60a0              STR      r0,[r4,#8]
;;;3573   
;;;3574   		#if ( configUSE_MUTEXES == 1 )
;;;3575   		{
;;;3576   			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
00002c  6ce8              LDR      r0,[r5,#0x4c]
00002e  6160              STR      r0,[r4,#0x14]
;;;3577   		}
;;;3578   		#else
;;;3579   		{
;;;3580   			pxTaskStatus->uxBasePriority = 0;
;;;3581   		}
;;;3582   		#endif
;;;3583   
;;;3584   		#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;3585   		{
;;;3586   			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
000030  6d68              LDR      r0,[r5,#0x54]
000032  61a0              STR      r0,[r4,#0x18]
;;;3587   		}
;;;3588   		#else
;;;3589   		{
;;;3590   			pxTaskStatus->ulRunTimeCounter = 0;
;;;3591   		}
;;;3592   		#endif
;;;3593   
;;;3594   		/* Obtaining the task state is a little fiddly, so is only done if the
;;;3595   		value of eState passed into this function is eInvalid - otherwise the
;;;3596   		state is just set to whatever is passed in. */
;;;3597   		if( eState != eInvalid )
000034  2e05              CMP      r6,#5
000036  d012              BEQ      |L27.94|
;;;3598   		{
;;;3599   			if( pxTCB == pxCurrentTCB )
000038  4811              LDR      r0,|L27.128|
00003a  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00003c  4285              CMP      r5,r0
00003e  d102              BNE      |L27.70|
;;;3600   			{
;;;3601   				pxTaskStatus->eCurrentState = eRunning;
000040  2000              MOVS     r0,#0
000042  7320              STRB     r0,[r4,#0xc]
000044  e00f              B        |L27.102|
                  |L27.70|
;;;3602   			}
;;;3603   			else
;;;3604   			{
;;;3605   				pxTaskStatus->eCurrentState = eState;
000046  7326              STRB     r6,[r4,#0xc]
;;;3606   
;;;3607   				#if ( INCLUDE_vTaskSuspend == 1 )
;;;3608   				{
;;;3609   					/* If the task is in the suspended list then there is a
;;;3610   					chance it is actually just blocked indefinitely - so really
;;;3611   					it should be reported as being in the Blocked state. */
;;;3612   					if( eState == eSuspended )
000048  2e03              CMP      r6,#3
00004a  d10c              BNE      |L27.102|
;;;3613   					{
;;;3614   						vTaskSuspendAll();
00004c  f7fffffe          BL       vTaskSuspendAll
;;;3615   						{
;;;3616   							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
000050  6aa8              LDR      r0,[r5,#0x28]
000052  b108              CBZ      r0,|L27.88|
;;;3617   							{
;;;3618   								pxTaskStatus->eCurrentState = eBlocked;
000054  2002              MOVS     r0,#2
000056  7320              STRB     r0,[r4,#0xc]
                  |L27.88|
;;;3619   							}
;;;3620   						}
;;;3621   						( void ) xTaskResumeAll();
000058  f7fffffe          BL       xTaskResumeAll
00005c  e003              B        |L27.102|
                  |L27.94|
;;;3622   					}
;;;3623   				}
;;;3624   				#endif /* INCLUDE_vTaskSuspend */
;;;3625   			}
;;;3626   		}
;;;3627   		else
;;;3628   		{
;;;3629   			pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
00005e  4628              MOV      r0,r5
000060  f7fffffe          BL       eTaskGetState
000064  7320              STRB     r0,[r4,#0xc]
                  |L27.102|
;;;3630   		}
;;;3631   
;;;3632   		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
;;;3633   		parameter is provided to allow it to be skipped. */
;;;3634   		if( xGetFreeStackSpace != pdFALSE )
000066  f1b80f00          CMP      r8,#0
00006a  d004              BEQ      |L27.118|
;;;3635   		{
;;;3636   			#if ( portSTACK_GROWTH > 0 )
;;;3637   			{
;;;3638   				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
;;;3639   			}
;;;3640   			#else
;;;3641   			{
;;;3642   				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
00006c  6b28              LDR      r0,[r5,#0x30]
00006e  f7fffffe          BL       prvTaskCheckFreeStackSpace
000072  8420              STRH     r0,[r4,#0x20]
000074  e001              B        |L27.122|
                  |L27.118|
;;;3643   			}
;;;3644   			#endif
;;;3645   		}
;;;3646   		else
;;;3647   		{
;;;3648   			pxTaskStatus->usStackHighWaterMark = 0;
000076  2000              MOVS     r0,#0
000078  8420              STRH     r0,[r4,#0x20]
                  |L27.122|
;;;3649   		}
;;;3650   	}
00007a  e8bd81f0          POP      {r4-r8,pc}
;;;3651   
                          ENDP

00007e  0000              DCW      0x0000
                  |L27.128|
                          DCD      pxCurrentTCB

                          AREA ||i.vTaskGetRunTimeStats||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_u
                          REQUIRE _printf_int_dec
                  vTaskGetRunTimeStats PROC
;;;4319   
;;;4320   	void vTaskGetRunTimeStats( char *pcWriteBuffer )
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;4321   	{
000004  4606              MOV      r6,r0
;;;4322   	TaskStatus_t *pxTaskStatusArray;
;;;4323   	UBaseType_t uxArraySize, x;
;;;4324   	uint32_t ulTotalTime, ulStatsAsPercentage;
;;;4325   
;;;4326   		#if( configUSE_TRACE_FACILITY != 1 )
;;;4327   		{
;;;4328   			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTimeStats().
;;;4329   		}
;;;4330   		#endif
;;;4331   
;;;4332   		/*
;;;4333   		 * PLEASE NOTE:
;;;4334   		 *
;;;4335   		 * This function is provided for convenience only, and is used by many
;;;4336   		 * of the demo applications.  Do not consider it to be part of the
;;;4337   		 * scheduler.
;;;4338   		 *
;;;4339   		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
;;;4340   		 * of the uxTaskGetSystemState() output into a human readable table that
;;;4341   		 * displays the amount of time each task has spent in the Running state
;;;4342   		 * in both absolute and percentage terms.
;;;4343   		 *
;;;4344   		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
;;;4345   		 * function that might bloat the code size, use a lot of stack, and
;;;4346   		 * provide different results on different platforms.  An alternative,
;;;4347   		 * tiny, third party, and limited functionality implementation of
;;;4348   		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
;;;4349   		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
;;;4350   		 * a full snprintf() implementation!).
;;;4351   		 *
;;;4352   		 * It is recommended that production systems call uxTaskGetSystemState()
;;;4353   		 * directly to get access to raw stats data, rather than indirectly
;;;4354   		 * through a call to vTaskGetRunTimeStats().
;;;4355   		 */
;;;4356   
;;;4357   		/* Make sure the write buffer does not contain a string. */
;;;4358   		*pcWriteBuffer = ( char ) 0x00;
000006  2000              MOVS     r0,#0
000008  7030              STRB     r0,[r6,#0]
;;;4359   
;;;4360   		/* Take a snapshot of the number of tasks in case it changes while this
;;;4361   		function is executing. */
;;;4362   		uxArraySize = uxCurrentNumberOfTasks;
00000a  4827              LDR      r0,|L28.168|
00000c  f8d08000          LDR      r8,[r0,#0]  ; uxCurrentNumberOfTasks
;;;4363   
;;;4364   		/* Allocate an array index for each task.  NOTE!  If
;;;4365   		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
;;;4366   		equate to NULL. */
;;;4367   		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation allocates a struct that has the alignment requirements of a pointer. */
000010  4601              MOV      r1,r0
000012  6809              LDR      r1,[r1,#0]  ; uxCurrentNumberOfTasks
000014  eb0101c1          ADD      r1,r1,r1,LSL #3
000018  0088              LSLS     r0,r1,#2
00001a  f7fffffe          BL       pvPortMalloc
00001e  4605              MOV      r5,r0
;;;4368   
;;;4369   		if( pxTaskStatusArray != NULL )
000020  2d00              CMP      r5,#0
000022  d03f              BEQ      |L28.164|
;;;4370   		{
;;;4371   			/* Generate the (binary) data. */
;;;4372   			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
000024  466a              MOV      r2,sp
000026  4641              MOV      r1,r8
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       uxTaskGetSystemState
00002e  4680              MOV      r8,r0
;;;4373   
;;;4374   			/* For percentage calculations. */
;;;4375   			ulTotalTime /= 100UL;
000030  2164              MOVS     r1,#0x64
000032  9800              LDR      r0,[sp,#0]
000034  fbb0f0f1          UDIV     r0,r0,r1
000038  9000              STR      r0,[sp,#0]
;;;4376   
;;;4377   			/* Avoid divide by zero errors. */
;;;4378   			if( ulTotalTime > 0UL )
00003a  9800              LDR      r0,[sp,#0]
00003c  2800              CMP      r0,#0
00003e  d02e              BEQ      |L28.158|
;;;4379   			{
;;;4380   				/* Create a human readable table from the binary data. */
;;;4381   				for( x = 0; x < uxArraySize; x++ )
000040  2400              MOVS     r4,#0
000042  e02a              B        |L28.154|
                  |L28.68|
;;;4382   				{
;;;4383   					/* What percentage of the total run time has the task used?
;;;4384   					This will always be rounded down to the nearest integer.
;;;4385   					ulTotalRunTimeDiv100 has already been divided by 100. */
;;;4386   					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
000044  eb0400c4          ADD      r0,r4,r4,LSL #3
000048  eb050080          ADD      r0,r5,r0,LSL #2
00004c  6980              LDR      r0,[r0,#0x18]
00004e  9900              LDR      r1,[sp,#0]
000050  fbb0f7f1          UDIV     r7,r0,r1
;;;4387   
;;;4388   					/* Write the task name to the string, padding with
;;;4389   					spaces so it can be printed in tabular form more
;;;4390   					easily. */
;;;4391   					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
000054  eb0400c4          ADD      r0,r4,r4,LSL #3
000058  eb050080          ADD      r0,r5,r0,LSL #2
00005c  6841              LDR      r1,[r0,#4]
00005e  4630              MOV      r0,r6
000060  f7fffffe          BL       prvWriteNameToBuffer
000064  4606              MOV      r6,r0
;;;4392   
;;;4393   					if( ulStatsAsPercentage > 0UL )
000066  b157              CBZ      r7,|L28.126|
;;;4394   					{
;;;4395   						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
;;;4396   						{
;;;4397   							sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
;;;4398   						}
;;;4399   						#else
;;;4400   						{
;;;4401   							/* sizeof( int ) == sizeof( long ) so a smaller
;;;4402   							printf() library can be used. */
;;;4403   							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */
000068  eb0400c4          ADD      r0,r4,r4,LSL #3
00006c  eb050080          ADD      r0,r5,r0,LSL #2
000070  463b              MOV      r3,r7
000072  a10e              ADR      r1,|L28.172|
000074  6982              LDR      r2,[r0,#0x18]
000076  4630              MOV      r0,r6
000078  f7fffffe          BL       __2sprintf
00007c  e008              B        |L28.144|
                  |L28.126|
;;;4404   						}
;;;4405   						#endif
;;;4406   					}
;;;4407   					else
;;;4408   					{
;;;4409   						/* If the percentage is zero here then the task has
;;;4410   						consumed less than 1% of the total run time. */
;;;4411   						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
;;;4412   						{
;;;4413   							sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
;;;4414   						}
;;;4415   						#else
;;;4416   						{
;;;4417   							/* sizeof( int ) == sizeof( long ) so a smaller
;;;4418   							printf() library can be used. */
;;;4419   							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */
00007e  eb0400c4          ADD      r0,r4,r4,LSL #3
000082  eb050080          ADD      r0,r5,r0,LSL #2
000086  a10c              ADR      r1,|L28.184|
000088  6982              LDR      r2,[r0,#0x18]
00008a  4630              MOV      r0,r6
00008c  f7fffffe          BL       __2sprintf
                  |L28.144|
;;;4420   						}
;;;4421   						#endif
;;;4422   					}
;;;4423   
;;;4424   					pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers especially as in this case where it best denotes the intent of the code. */
000090  4630              MOV      r0,r6
000092  f7fffffe          BL       strlen
000096  4406              ADD      r6,r6,r0
000098  1c64              ADDS     r4,r4,#1              ;4381
                  |L28.154|
00009a  4544              CMP      r4,r8                 ;4381
00009c  d3d2              BCC      |L28.68|
                  |L28.158|
;;;4425   				}
;;;4426   			}
;;;4427   			else
;;;4428   			{
;;;4429   				mtCOVERAGE_TEST_MARKER();
;;;4430   			}
;;;4431   
;;;4432   			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
;;;4433   			is 0 then vPortFree() will be #defined to nothing. */
;;;4434   			vPortFree( pxTaskStatusArray );
00009e  4628              MOV      r0,r5
0000a0  f7fffffe          BL       vPortFree
                  |L28.164|
;;;4435   		}
;;;4436   		else
;;;4437   		{
;;;4438   			mtCOVERAGE_TEST_MARKER();
;;;4439   		}
;;;4440   	}
0000a4  e8bd83f8          POP      {r3-r9,pc}
;;;4441   
                          ENDP

                  |L28.168|
                          DCD      uxCurrentNumberOfTasks
                  |L28.172|
0000ac  09257509          DCB      "\t%u\t\t%u%%\r\n",0
0000b0  09257525
0000b4  250d0a00
                  |L28.184|
0000b8  09257509          DCB      "\t%u\t\t<1%%\r\n",0
0000bc  093c3125
0000c0  250d0a00

                          AREA ||i.vTaskInternalSetTimeOutState||, CODE, READONLY, ALIGN=2

                  vTaskInternalSetTimeOutState PROC
;;;3159   
;;;3160   void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
000000  4903              LDR      r1,|L29.16|
;;;3161   {
;;;3162   	/* For internal use only as it does not use a critical section. */
;;;3163   	pxTimeOut->xOverflowCount = xNumOfOverflows;
000002  6809              LDR      r1,[r1,#0]  ; xNumOfOverflows
000004  6001              STR      r1,[r0,#0]
;;;3164   	pxTimeOut->xTimeOnEntering = xTickCount;
000006  4903              LDR      r1,|L29.20|
000008  6809              LDR      r1,[r1,#0]  ; xTickCount
00000a  6041              STR      r1,[r0,#4]
;;;3165   }
00000c  4770              BX       lr
;;;3166   /*-----------------------------------------------------------*/
                          ENDP

00000e  0000              DCW      0x0000
                  |L29.16|
                          DCD      xNumOfOverflows
                  |L29.20|
                          DCD      xTickCount

                          AREA ||i.vTaskList||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_u
                          REQUIRE _printf_c
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  vTaskList PROC
;;;4220   
;;;4221   	void vTaskList( char * pcWriteBuffer )
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;4222   	{
000004  4606              MOV      r6,r0
;;;4223   	TaskStatus_t *pxTaskStatusArray;
;;;4224   	UBaseType_t uxArraySize, x;
;;;4225   	char cStatus;
;;;4226   
;;;4227   		/*
;;;4228   		 * PLEASE NOTE:
;;;4229   		 *
;;;4230   		 * This function is provided for convenience only, and is used by many
;;;4231   		 * of the demo applications.  Do not consider it to be part of the
;;;4232   		 * scheduler.
;;;4233   		 *
;;;4234   		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
;;;4235   		 * uxTaskGetSystemState() output into a human readable table that
;;;4236   		 * displays task names, states and stack usage.
;;;4237   		 *
;;;4238   		 * vTaskList() has a dependency on the sprintf() C library function that
;;;4239   		 * might bloat the code size, use a lot of stack, and provide different
;;;4240   		 * results on different platforms.  An alternative, tiny, third party,
;;;4241   		 * and limited functionality implementation of sprintf() is provided in
;;;4242   		 * many of the FreeRTOS/Demo sub-directories in a file called
;;;4243   		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
;;;4244   		 * snprintf() implementation!).
;;;4245   		 *
;;;4246   		 * It is recommended that production systems call uxTaskGetSystemState()
;;;4247   		 * directly to get access to raw stats data, rather than indirectly
;;;4248   		 * through a call to vTaskList().
;;;4249   		 */
;;;4250   
;;;4251   
;;;4252   		/* Make sure the write buffer does not contain a string. */
;;;4253   		*pcWriteBuffer = ( char ) 0x00;
000006  2000              MOVS     r0,#0
000008  7030              STRB     r0,[r6,#0]
;;;4254   
;;;4255   		/* Take a snapshot of the number of tasks in case it changes while this
;;;4256   		function is executing. */
;;;4257   		uxArraySize = uxCurrentNumberOfTasks;
00000a  482f              LDR      r0,|L30.200|
00000c  6807              LDR      r7,[r0,#0]  ; uxCurrentNumberOfTasks
;;;4258   
;;;4259   		/* Allocate an array index for each task.  NOTE!  if
;;;4260   		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
;;;4261   		equate to NULL. */
;;;4262   		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation allocates a struct that has the alignment requirements of a pointer. */
00000e  4601              MOV      r1,r0
000010  6809              LDR      r1,[r1,#0]  ; uxCurrentNumberOfTasks
000012  eb0101c1          ADD      r1,r1,r1,LSL #3
000016  0088              LSLS     r0,r1,#2
000018  f7fffffe          BL       pvPortMalloc
00001c  4605              MOV      r5,r0
;;;4263   
;;;4264   		if( pxTaskStatusArray != NULL )
00001e  2d00              CMP      r5,#0
000020  d050              BEQ      |L30.196|
;;;4265   		{
;;;4266   			/* Generate the (binary) data. */
;;;4267   			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
000022  2200              MOVS     r2,#0
000024  4639              MOV      r1,r7
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       uxTaskGetSystemState
00002c  4607              MOV      r7,r0
;;;4268   
;;;4269   			/* Create a human readable table from the binary data. */
;;;4270   			for( x = 0; x < uxArraySize; x++ )
00002e  2400              MOVS     r4,#0
000030  e043              B        |L30.186|
                  |L30.50|
;;;4271   			{
;;;4272   				switch( pxTaskStatusArray[ x ].eCurrentState )
000032  eb0400c4          ADD      r0,r4,r4,LSL #3
000036  eb050080          ADD      r0,r5,r0,LSL #2
00003a  7b00              LDRB     r0,[r0,#0xc]
00003c  2806              CMP      r0,#6
00003e  d213              BCS      |L30.104|
000040  e8dff000          TBB      [pc,r0]
000044  0306090c          DCB      0x03,0x06,0x09,0x0c
000048  0f13              DCB      0x0f,0x13
;;;4273   				{
;;;4274   					case eRunning:		cStatus = tskRUNNING_CHAR;
00004a  f04f0858          MOV      r8,#0x58
;;;4275   										break;
00004e  e00f              B        |L30.112|
;;;4276   
;;;4277   					case eReady:		cStatus = tskREADY_CHAR;
000050  f04f0852          MOV      r8,#0x52
;;;4278   										break;
000054  e00c              B        |L30.112|
;;;4279   
;;;4280   					case eBlocked:		cStatus = tskBLOCKED_CHAR;
000056  f04f0842          MOV      r8,#0x42
;;;4281   										break;
00005a  e009              B        |L30.112|
;;;4282   
;;;4283   					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
00005c  f04f0853          MOV      r8,#0x53
;;;4284   										break;
000060  e006              B        |L30.112|
;;;4285   
;;;4286   					case eDeleted:		cStatus = tskDELETED_CHAR;
000062  f04f0844          MOV      r8,#0x44
;;;4287   										break;
000066  e003              B        |L30.112|
                  |L30.104|
;;;4288   
;;;4289   					case eInvalid:		/* Fall through. */
000068  bf00              NOP      
;;;4290   					default:			/* Should not get here, but it is included
;;;4291   										to prevent static checking errors. */
;;;4292   										cStatus = ( char ) 0x00;
00006a  f04f0800          MOV      r8,#0
;;;4293   										break;
00006e  bf00              NOP      
                  |L30.112|
000070  bf00              NOP                            ;4275
;;;4294   				}
;;;4295   
;;;4296   				/* Write the task name to the string, padding with spaces so it
;;;4297   				can be printed in tabular form more easily. */
;;;4298   				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
000072  eb0400c4          ADD      r0,r4,r4,LSL #3
000076  eb050080          ADD      r0,r5,r0,LSL #2
00007a  6841              LDR      r1,[r0,#4]
00007c  4630              MOV      r0,r6
00007e  f7fffffe          BL       prvWriteNameToBuffer
000082  4606              MOV      r6,r0
;;;4299   
;;;4300   				/* Write the rest of the string. */
;;;4301   				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */
000084  eb0400c4          ADD      r0,r4,r4,LSL #3
000088  eb050080          ADD      r0,r5,r0,LSL #2
00008c  6880              LDR      r0,[r0,#8]
00008e  eb0401c4          ADD      r1,r4,r4,LSL #3
000092  eb050181          ADD      r1,r5,r1,LSL #2
000096  8c09              LDRH     r1,[r1,#0x20]
000098  e9cd1000          STRD     r1,r0,[sp,#0]
00009c  eb0400c4          ADD      r0,r4,r4,LSL #3
0000a0  eb050080          ADD      r0,r5,r0,LSL #2
0000a4  4642              MOV      r2,r8
0000a6  a109              ADR      r1,|L30.204|
0000a8  6903              LDR      r3,[r0,#0x10]
0000aa  4630              MOV      r0,r6
0000ac  f7fffffe          BL       __2sprintf
;;;4302   				pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers especially as in this case where it best denotes the intent of the code. */
0000b0  4630              MOV      r0,r6
0000b2  f7fffffe          BL       strlen
0000b6  4406              ADD      r6,r6,r0
0000b8  1c64              ADDS     r4,r4,#1              ;4270
                  |L30.186|
0000ba  42bc              CMP      r4,r7                 ;4270
0000bc  d3b9              BCC      |L30.50|
;;;4303   			}
;;;4304   
;;;4305   			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
;;;4306   			is 0 then vPortFree() will be #defined to nothing. */
;;;4307   			vPortFree( pxTaskStatusArray );
0000be  4628              MOV      r0,r5
0000c0  f7fffffe          BL       vPortFree
                  |L30.196|
;;;4308   		}
;;;4309   		else
;;;4310   		{
;;;4311   			mtCOVERAGE_TEST_MARKER();
;;;4312   		}
;;;4313   	}
0000c4  e8bd81fc          POP      {r2-r8,pc}
;;;4314   
                          ENDP

                  |L30.200|
                          DCD      uxCurrentNumberOfTasks
                  |L30.204|
0000cc  09256309          DCB      "\t%c\t%u\t%u\t%u\r\n",0
0000d0  25750925
0000d4  75092575
0000d8  0d0a00  
0000db  00                DCB      0

                          AREA ||i.vTaskMissedYield||, CODE, READONLY, ALIGN=2

                  vTaskMissedYield PROC
;;;3230   
;;;3231   void vTaskMissedYield( void )
000000  2001              MOVS     r0,#1
;;;3232   {
;;;3233   	xYieldPending = pdTRUE;
000002  4901              LDR      r1,|L31.8|
000004  6008              STR      r0,[r1,#0]  ; xYieldPending
;;;3234   }
000006  4770              BX       lr
;;;3235   /*-----------------------------------------------------------*/
                          ENDP

                  |L31.8|
                          DCD      xYieldPending

                          AREA ||i.vTaskNotifyGiveFromISR||, CODE, READONLY, ALIGN=2

                  vTaskNotifyGiveFromISR PROC
;;;4868   
;;;4869   	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;4870   	{
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
;;;4871   	TCB_t * pxTCB;
;;;4872   	uint8_t ucOriginalNotifyState;
;;;4873   	UBaseType_t uxSavedInterruptStatus;
;;;4874   
;;;4875   		configASSERT( xTaskToNotify );
000008  b955              CBNZ     r5,|L32.32|
00000a  bf00              NOP      
00000c  2040              MOVS     r0,#0x40
00000e  f3808811          MSR      BASEPRI,r0
000012  f3bf8f4f          DSB      
000016  f3bf8f6f          ISB      
00001a  bf00              NOP      
00001c  bf00              NOP      
                  |L32.30|
00001e  e7fe              B        |L32.30|
                  |L32.32|
;;;4876   
;;;4877   		/* RTOS ports that support interrupt nesting have the concept of a
;;;4878   		maximum	system call (or maximum API call) interrupt priority.
;;;4879   		Interrupts that are	above the maximum system call priority are keep
;;;4880   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;4881   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;4882   		is defined in FreeRTOSConfig.h then
;;;4883   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;4884   		failure if a FreeRTOS API function is called from an interrupt that has
;;;4885   		been assigned a priority above the configured maximum system call
;;;4886   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;4887   		from interrupts	that have been assigned a priority at or (logically)
;;;4888   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;4889   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;4890   		simple as possible.  More information (albeit Cortex-M specific) is
;;;4891   		provided on the following link:
;;;4892   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;4893   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000020  f7fffffe          BL       vPortValidateInterruptPriority
;;;4894   
;;;4895   		pxTCB = xTaskToNotify;
000024  462c              MOV      r4,r5
;;;4896   
;;;4897   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000026  bf00              NOP      
000028  2140              MOVS     r1,#0x40
00002a  f3ef8011          MRS      r0,BASEPRI
00002e  f3818811          MSR      BASEPRI,r1
000032  f3bf8f4f          DSB      
000036  f3bf8f6f          ISB      
00003a  bf00              NOP      
00003c  4606              MOV      r6,r0
;;;4898   		{
;;;4899   			ucOriginalNotifyState = pxTCB->ucNotifyState;
00003e  f894805c          LDRB     r8,[r4,#0x5c]
;;;4900   			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
000042  2002              MOVS     r0,#2
000044  f884005c          STRB     r0,[r4,#0x5c]
;;;4901   
;;;4902   			/* 'Giving' is equivalent to incrementing a count in a counting
;;;4903   			semaphore. */
;;;4904   			( pxTCB->ulNotifiedValue )++;
000048  6da0              LDR      r0,[r4,#0x58]
00004a  1c40              ADDS     r0,r0,#1
00004c  65a0              STR      r0,[r4,#0x58]
;;;4905   
;;;4906   			traceTASK_NOTIFY_GIVE_FROM_ISR();
;;;4907   
;;;4908   			/* If the task is in the blocked state specifically to wait for a
;;;4909   			notification then unblock it now. */
;;;4910   			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
00004e  f1b80f01          CMP      r8,#1
000052  d13a              BNE      |L32.202|
;;;4911   			{
;;;4912   				/* The task should not have been on an event list. */
;;;4913   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
000054  6aa0              LDR      r0,[r4,#0x28]
000056  b908              CBNZ     r0,|L32.92|
000058  2001              MOVS     r0,#1
00005a  e000              B        |L32.94|
                  |L32.92|
00005c  2000              MOVS     r0,#0
                  |L32.94|
00005e  b950              CBNZ     r0,|L32.118|
000060  bf00              NOP      
000062  2040              MOVS     r0,#0x40
000064  f3808811          MSR      BASEPRI,r0
000068  f3bf8f4f          DSB      
00006c  f3bf8f6f          ISB      
000070  bf00              NOP      
000072  bf00              NOP      
                  |L32.116|
000074  e7fe              B        |L32.116|
                  |L32.118|
;;;4914   
;;;4915   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000076  4818              LDR      r0,|L32.216|
000078  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00007a  b9a8              CBNZ     r0,|L32.168|
;;;4916   				{
;;;4917   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
00007c  1d20              ADDS     r0,r4,#4
00007e  f7fffffe          BL       uxListRemove
;;;4918   					prvAddTaskToReadyList( pxTCB );
000082  f894102c          LDRB     r1,[r4,#0x2c]
000086  2001              MOVS     r0,#1
000088  4088              LSLS     r0,r0,r1
00008a  4914              LDR      r1,|L32.220|
00008c  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
00008e  4308              ORRS     r0,r0,r1
000090  4912              LDR      r1,|L32.220|
000092  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
000094  6ae1              LDR      r1,[r4,#0x2c]
000096  eb010181          ADD      r1,r1,r1,LSL #2
00009a  4a11              LDR      r2,|L32.224|
00009c  eb020081          ADD      r0,r2,r1,LSL #2
0000a0  1d21              ADDS     r1,r4,#4
0000a2  f7fffffe          BL       vListInsertEnd
0000a6  e004              B        |L32.178|
                  |L32.168|
;;;4919   				}
;;;4920   				else
;;;4921   				{
;;;4922   					/* The delayed and ready lists cannot be accessed, so hold
;;;4923   					this task pending until the scheduler is resumed. */
;;;4924   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
0000a8  f1040118          ADD      r1,r4,#0x18
0000ac  480d              LDR      r0,|L32.228|
0000ae  f7fffffe          BL       vListInsertEnd
                  |L32.178|
;;;4925   				}
;;;4926   
;;;4927   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
0000b2  490d              LDR      r1,|L32.232|
0000b4  6ae0              LDR      r0,[r4,#0x2c]
0000b6  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
0000b8  6ac9              LDR      r1,[r1,#0x2c]
0000ba  4288              CMP      r0,r1
0000bc  d905              BLS      |L32.202|
;;;4928   				{
;;;4929   					/* The notified task has a priority above the currently
;;;4930   					executing task so a yield is required. */
;;;4931   					if( pxHigherPriorityTaskWoken != NULL )
0000be  b10f              CBZ      r7,|L32.196|
;;;4932   					{
;;;4933   						*pxHigherPriorityTaskWoken = pdTRUE;
0000c0  2001              MOVS     r0,#1
0000c2  6038              STR      r0,[r7,#0]
                  |L32.196|
;;;4934   					}
;;;4935   
;;;4936   					/* Mark that a yield is pending in case the user is not
;;;4937   					using the "xHigherPriorityTaskWoken" parameter in an ISR
;;;4938   					safe FreeRTOS function. */
;;;4939   					xYieldPending = pdTRUE;
0000c4  2001              MOVS     r0,#1
0000c6  4909              LDR      r1,|L32.236|
0000c8  6008              STR      r0,[r1,#0]  ; xYieldPending
                  |L32.202|
;;;4940   				}
;;;4941   				else
;;;4942   				{
;;;4943   					mtCOVERAGE_TEST_MARKER();
;;;4944   				}
;;;4945   			}
;;;4946   		}
;;;4947   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0000ca  bf00              NOP      
0000cc  f3868811          MSR      BASEPRI,r6
0000d0  bf00              NOP      
;;;4948   	}
0000d2  e8bd81f0          POP      {r4-r8,pc}
;;;4949   
                          ENDP

0000d6  0000              DCW      0x0000
                  |L32.216|
                          DCD      uxSchedulerSuspended
                  |L32.220|
                          DCD      uxTopReadyPriority
                  |L32.224|
                          DCD      pxReadyTasksLists
                  |L32.228|
                          DCD      xPendingReadyList
                  |L32.232|
                          DCD      pxCurrentTCB
                  |L32.236|
                          DCD      xYieldPending

                          AREA ||i.vTaskPlaceOnEventList||, CODE, READONLY, ALIGN=2

                  vTaskPlaceOnEventList PROC
;;;2971   
;;;2972   void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
000000  b570              PUSH     {r4-r6,lr}
;;;2973   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2974   	configASSERT( pxEventList );
000006  b954              CBNZ     r4,|L33.30|
000008  bf00              NOP      
00000a  2040              MOVS     r0,#0x40
00000c  f3808811          MSR      BASEPRI,r0
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L33.28|
00001c  e7fe              B        |L33.28|
                  |L33.30|
;;;2975   
;;;2976   	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
;;;2977   	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
;;;2978   
;;;2979   	/* Place the event list item of the TCB in the appropriate event list.
;;;2980   	This is placed in the list in priority order so the highest priority task
;;;2981   	is the first to be woken by the event.  The queue that contains the event
;;;2982   	list is locked, preventing simultaneous access from interrupts. */
;;;2983   	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
00001e  4805              LDR      r0,|L33.52|
000020  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
000022  3118              ADDS     r1,r1,#0x18
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       vListInsert
;;;2984   
;;;2985   	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
00002a  2101              MOVS     r1,#1
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;2986   }
000032  bd70              POP      {r4-r6,pc}
;;;2987   /*-----------------------------------------------------------*/
                          ENDP

                  |L33.52|
                          DCD      pxCurrentTCB

                          AREA ||i.vTaskPlaceOnEventListRestricted||, CODE, READONLY, ALIGN=2

                  vTaskPlaceOnEventListRestricted PROC
;;;3014   
;;;3015   	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
000000  b570              PUSH     {r4-r6,lr}
;;;3016   	{
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;3017   		configASSERT( pxEventList );
000008  b955              CBNZ     r5,|L34.32|
00000a  bf00              NOP      
00000c  2040              MOVS     r0,#0x40
00000e  f3808811          MSR      BASEPRI,r0
000012  f3bf8f4f          DSB      
000016  f3bf8f6f          ISB      
00001a  bf00              NOP      
00001c  bf00              NOP      
                  |L34.30|
00001e  e7fe              B        |L34.30|
                  |L34.32|
;;;3018   
;;;3019   		/* This function should not be called by application code hence the
;;;3020   		'Restricted' in its name.  It is not part of the public API.  It is
;;;3021   		designed for use by kernel code, and has special calling requirements -
;;;3022   		it should be called with the scheduler suspended. */
;;;3023   
;;;3024   
;;;3025   		/* Place the event list item of the TCB in the appropriate event list.
;;;3026   		In this case it is assume that this is the only task that is going to
;;;3027   		be waiting on this event list, so the faster vListInsertEnd() function
;;;3028   		can be used in place of vListInsert. */
;;;3029   		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
000020  4806              LDR      r0,|L34.60|
000022  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
000024  3118              ADDS     r1,r1,#0x18
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       vListInsertEnd
;;;3030   
;;;3031   		/* If the task should block indefinitely then set the block time to a
;;;3032   		value that will be recognised as an indefinite delay inside the
;;;3033   		prvAddCurrentTaskToDelayedList() function. */
;;;3034   		if( xWaitIndefinitely != pdFALSE )
00002c  b10c              CBZ      r4,|L34.50|
;;;3035   		{
;;;3036   			xTicksToWait = portMAX_DELAY;
00002e  f04f36ff          MOV      r6,#0xffffffff
                  |L34.50|
;;;3037   		}
;;;3038   
;;;3039   		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
;;;3040   		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
000032  4621              MOV      r1,r4
000034  4630              MOV      r0,r6
000036  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;3041   	}
00003a  bd70              POP      {r4-r6,pc}
;;;3042   
                          ENDP

                  |L34.60|
                          DCD      pxCurrentTCB

                          AREA ||i.vTaskPlaceOnUnorderedEventList||, CODE, READONLY, ALIGN=2

                  vTaskPlaceOnUnorderedEventList PROC
;;;2988   
;;;2989   void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
000000  b570              PUSH     {r4-r6,lr}
;;;2990   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;2991   	configASSERT( pxEventList );
000008  b954              CBNZ     r4,|L35.32|
00000a  bf00              NOP      
00000c  2040              MOVS     r0,#0x40
00000e  f3808811          MSR      BASEPRI,r0
000012  f3bf8f4f          DSB      
000016  f3bf8f6f          ISB      
00001a  bf00              NOP      
00001c  bf00              NOP      
                  |L35.30|
00001e  e7fe              B        |L35.30|
                  |L35.32|
;;;2992   
;;;2993   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
;;;2994   	the event groups implementation. */
;;;2995   	configASSERT( uxSchedulerSuspended != 0 );
000020  4810              LDR      r0,|L35.100|
000022  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000024  b108              CBZ      r0,|L35.42|
000026  2001              MOVS     r0,#1
000028  e000              B        |L35.44|
                  |L35.42|
00002a  2000              MOVS     r0,#0
                  |L35.44|
00002c  b950              CBNZ     r0,|L35.68|
00002e  bf00              NOP      
000030  2040              MOVS     r0,#0x40
000032  f3808811          MSR      BASEPRI,r0
000036  f3bf8f4f          DSB      
00003a  f3bf8f6f          ISB      
00003e  bf00              NOP      
000040  bf00              NOP      
                  |L35.66|
000042  e7fe              B        |L35.66|
                  |L35.68|
;;;2996   
;;;2997   	/* Store the item value in the event list item.  It is safe to access the
;;;2998   	event list item here as interrupts won't access the event list item of a
;;;2999   	task that is not in the Blocked state. */
;;;3000   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
000044  f0454000          ORR      r0,r5,#0x80000000
000048  4907              LDR      r1,|L35.104|
00004a  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00004c  6188              STR      r0,[r1,#0x18]
;;;3001   
;;;3002   	/* Place the event list item of the TCB at the end of the appropriate event
;;;3003   	list.  It is safe to access the event list here because it is part of an
;;;3004   	event group implementation - and interrupts don't access event groups
;;;3005   	directly (instead they access them indirectly by pending function calls to
;;;3006   	the task level). */
;;;3007   	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
00004e  4806              LDR      r0,|L35.104|
000050  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
000052  3118              ADDS     r1,r1,#0x18
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       vListInsertEnd
;;;3008   
;;;3009   	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
00005a  2101              MOVS     r1,#1
00005c  4630              MOV      r0,r6
00005e  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;3010   }
000062  bd70              POP      {r4-r6,pc}
;;;3011   /*-----------------------------------------------------------*/
                          ENDP

                  |L35.100|
                          DCD      uxSchedulerSuspended
                  |L35.104|
                          DCD      pxCurrentTCB

                          AREA ||i.vTaskPriorityDisinheritAfterTimeout||, CODE, READONLY, ALIGN=2

                  vTaskPriorityDisinheritAfterTimeout PROC
;;;4029   
;;;4030   	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;4031   	{
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;4032   	TCB_t * const pxTCB = pxMutexHolder;
000008  4634              MOV      r4,r6
;;;4033   	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
;;;4034   	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
00000a  f04f0901          MOV      r9,#1
;;;4035   
;;;4036   		if( pxMutexHolder != NULL )
00000e  2e00              CMP      r6,#0
000010  d067              BEQ      |L36.226|
;;;4037   		{
;;;4038   			/* If pxMutexHolder is not NULL then the holder must hold at least
;;;4039   			one mutex. */
;;;4040   			configASSERT( pxTCB->uxMutexesHeld );
000012  6d20              LDR      r0,[r4,#0x50]
000014  b950              CBNZ     r0,|L36.44|
000016  bf00              NOP      
000018  2040              MOVS     r0,#0x40
00001a  f3808811          MSR      BASEPRI,r0
00001e  f3bf8f4f          DSB      
000022  f3bf8f6f          ISB      
000026  bf00              NOP      
000028  bf00              NOP      
                  |L36.42|
00002a  e7fe              B        |L36.42|
                  |L36.44|
;;;4041   
;;;4042   			/* Determine the priority to which the priority of the task that
;;;4043   			holds the mutex should be set.  This will be the greater of the
;;;4044   			holding task's base priority and the priority of the highest
;;;4045   			priority task that is waiting to obtain the mutex. */
;;;4046   			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
00002c  6ce0              LDR      r0,[r4,#0x4c]
00002e  42b8              CMP      r0,r7
000030  d201              BCS      |L36.54|
;;;4047   			{
;;;4048   				uxPriorityToUse = uxHighestPriorityWaitingTask;
000032  463d              MOV      r5,r7
000034  e000              B        |L36.56|
                  |L36.54|
;;;4049   			}
;;;4050   			else
;;;4051   			{
;;;4052   				uxPriorityToUse = pxTCB->uxBasePriority;
000036  6ce5              LDR      r5,[r4,#0x4c]
                  |L36.56|
;;;4053   			}
;;;4054   
;;;4055   			/* Does the priority need to change? */
;;;4056   			if( pxTCB->uxPriority != uxPriorityToUse )
000038  6ae0              LDR      r0,[r4,#0x2c]
00003a  42a8              CMP      r0,r5
00003c  d051              BEQ      |L36.226|
;;;4057   			{
;;;4058   				/* Only disinherit if no other mutexes are held.  This is a
;;;4059   				simplification in the priority inheritance implementation.  If
;;;4060   				the task that holds the mutex is also holding other mutexes then
;;;4061   				the other mutexes may have caused the priority inheritance. */
;;;4062   				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
00003e  6d20              LDR      r0,[r4,#0x50]
000040  2801              CMP      r0,#1
000042  d14e              BNE      |L36.226|
;;;4063   				{
;;;4064   					/* If a task has timed out because it already holds the
;;;4065   					mutex it was trying to obtain then it cannot of inherited
;;;4066   					its own priority. */
;;;4067   					configASSERT( pxTCB != pxCurrentTCB );
000044  4828              LDR      r0,|L36.232|
000046  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000048  4284              CMP      r4,r0
00004a  d001              BEQ      |L36.80|
00004c  2001              MOVS     r0,#1
00004e  e000              B        |L36.82|
                  |L36.80|
000050  2000              MOVS     r0,#0
                  |L36.82|
000052  b950              CBNZ     r0,|L36.106|
000054  bf00              NOP      
000056  2040              MOVS     r0,#0x40
000058  f3808811          MSR      BASEPRI,r0
00005c  f3bf8f4f          DSB      
000060  f3bf8f6f          ISB      
000064  bf00              NOP      
000066  bf00              NOP      
                  |L36.104|
000068  e7fe              B        |L36.104|
                  |L36.106|
;;;4068   
;;;4069   					/* Disinherit the priority, remembering the previous
;;;4070   					priority to facilitate determining the subject task's
;;;4071   					state. */
;;;4072   					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
;;;4073   					uxPriorityUsedOnEntry = pxTCB->uxPriority;
00006a  f8d4802c          LDR      r8,[r4,#0x2c]
;;;4074   					pxTCB->uxPriority = uxPriorityToUse;
00006e  62e5              STR      r5,[r4,#0x2c]
;;;4075   
;;;4076   					/* Only reset the event list item value if the value is not
;;;4077   					being used for anything else. */
;;;4078   					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
000070  69a0              LDR      r0,[r4,#0x18]
000072  f0004000          AND      r0,r0,#0x80000000
000076  b910              CBNZ     r0,|L36.126|
;;;4079   					{
;;;4080   						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000078  f1c50005          RSB      r0,r5,#5
00007c  61a0              STR      r0,[r4,#0x18]
                  |L36.126|
;;;4081   					}
;;;4082   					else
;;;4083   					{
;;;4084   						mtCOVERAGE_TEST_MARKER();
;;;4085   					}
;;;4086   
;;;4087   					/* If the running task is not the task that holds the mutex
;;;4088   					then the task that holds the mutex could be in either the
;;;4089   					Ready, Blocked or Suspended states.  Only remove the task
;;;4090   					from its current state list if it is in the Ready state as
;;;4091   					the task's priority is going to change and there is one
;;;4092   					Ready list per priority. */
;;;4093   					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
00007e  eb080188          ADD      r1,r8,r8,LSL #2
000082  4a1a              LDR      r2,|L36.236|
000084  eb020181          ADD      r1,r2,r1,LSL #2
000088  6960              LDR      r0,[r4,#0x14]
00008a  4288              CMP      r0,r1
00008c  d101              BNE      |L36.146|
00008e  2001              MOVS     r0,#1
000090  e000              B        |L36.148|
                  |L36.146|
000092  2000              MOVS     r0,#0
                  |L36.148|
000094  b328              CBZ      r0,|L36.226|
;;;4094   					{
;;;4095   						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000096  1d20              ADDS     r0,r4,#4
000098  f7fffffe          BL       uxListRemove
00009c  b978              CBNZ     r0,|L36.190|
;;;4096   						{
;;;4097   							taskRESET_READY_PRIORITY( pxTCB->uxPriority );
00009e  6ae0              LDR      r0,[r4,#0x2c]
0000a0  eb000080          ADD      r0,r0,r0,LSL #2
0000a4  4911              LDR      r1,|L36.236|
0000a6  f8510020          LDR      r0,[r1,r0,LSL #2]
0000aa  b940              CBNZ     r0,|L36.190|
0000ac  f894102c          LDRB     r1,[r4,#0x2c]
0000b0  2001              MOVS     r0,#1
0000b2  4088              LSLS     r0,r0,r1
0000b4  490e              LDR      r1,|L36.240|
0000b6  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
0000b8  4381              BICS     r1,r1,r0
0000ba  480d              LDR      r0,|L36.240|
0000bc  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L36.190|
;;;4098   						}
;;;4099   						else
;;;4100   						{
;;;4101   							mtCOVERAGE_TEST_MARKER();
;;;4102   						}
;;;4103   
;;;4104   						prvAddTaskToReadyList( pxTCB );
0000be  f894102c          LDRB     r1,[r4,#0x2c]
0000c2  2001              MOVS     r0,#1
0000c4  4088              LSLS     r0,r0,r1
0000c6  490a              LDR      r1,|L36.240|
0000c8  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
0000ca  4308              ORRS     r0,r0,r1
0000cc  4908              LDR      r1,|L36.240|
0000ce  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
0000d0  6ae1              LDR      r1,[r4,#0x2c]
0000d2  eb010181          ADD      r1,r1,r1,LSL #2
0000d6  4a05              LDR      r2,|L36.236|
0000d8  eb020081          ADD      r0,r2,r1,LSL #2
0000dc  1d21              ADDS     r1,r4,#4
0000de  f7fffffe          BL       vListInsertEnd
                  |L36.226|
;;;4105   					}
;;;4106   					else
;;;4107   					{
;;;4108   						mtCOVERAGE_TEST_MARKER();
;;;4109   					}
;;;4110   				}
;;;4111   				else
;;;4112   				{
;;;4113   					mtCOVERAGE_TEST_MARKER();
;;;4114   				}
;;;4115   			}
;;;4116   			else
;;;4117   			{
;;;4118   				mtCOVERAGE_TEST_MARKER();
;;;4119   			}
;;;4120   		}
;;;4121   		else
;;;4122   		{
;;;4123   			mtCOVERAGE_TEST_MARKER();
;;;4124   		}
;;;4125   	}
0000e2  e8bd87f0          POP      {r4-r10,pc}
;;;4126   
                          ENDP

0000e6  0000              DCW      0x0000
                  |L36.232|
                          DCD      pxCurrentTCB
                  |L36.236|
                          DCD      pxReadyTasksLists
                  |L36.240|
                          DCD      uxTopReadyPriority

                          AREA ||i.vTaskPrioritySet||, CODE, READONLY, ALIGN=2

                  vTaskPrioritySet PROC
;;;1502   
;;;1503   	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1504   	{
000004  4680              MOV      r8,r0
000006  460d              MOV      r5,r1
;;;1505   	TCB_t *pxTCB;
;;;1506   	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
;;;1507   	BaseType_t xYieldRequired = pdFALSE;
000008  f04f0900          MOV      r9,#0
;;;1508   
;;;1509   		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
00000c  2d05              CMP      r5,#5
00000e  d201              BCS      |L37.20|
000010  2001              MOVS     r0,#1
000012  e000              B        |L37.22|
                  |L37.20|
000014  2000              MOVS     r0,#0
                  |L37.22|
000016  b950              CBNZ     r0,|L37.46|
000018  bf00              NOP      
00001a  2040              MOVS     r0,#0x40
00001c  f3808811          MSR      BASEPRI,r0
000020  f3bf8f4f          DSB      
000024  f3bf8f6f          ISB      
000028  bf00              NOP      
00002a  bf00              NOP      
                  |L37.44|
00002c  e7fe              B        |L37.44|
                  |L37.46|
;;;1510   
;;;1511   		/* Ensure the new priority is valid. */
;;;1512   		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
00002e  2d05              CMP      r5,#5
000030  d300              BCC      |L37.52|
;;;1513   		{
;;;1514   			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
000032  2504              MOVS     r5,#4
                  |L37.52|
;;;1515   		}
;;;1516   		else
;;;1517   		{
;;;1518   			mtCOVERAGE_TEST_MARKER();
;;;1519   		}
;;;1520   
;;;1521   		taskENTER_CRITICAL();
000034  f7fffffe          BL       vPortEnterCritical
;;;1522   		{
;;;1523   			/* If null is passed in here then it is the priority of the calling
;;;1524   			task that is being changed. */
;;;1525   			pxTCB = prvGetTCBFromHandle( xTask );
000038  f1b80f00          CMP      r8,#0
00003c  d102              BNE      |L37.68|
00003e  4831              LDR      r0,|L37.260|
000040  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000042  e000              B        |L37.70|
                  |L37.68|
000044  4640              MOV      r0,r8
                  |L37.70|
000046  4604              MOV      r4,r0
;;;1526   
;;;1527   			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
;;;1528   
;;;1529   			#if ( configUSE_MUTEXES == 1 )
;;;1530   			{
;;;1531   				uxCurrentBasePriority = pxTCB->uxBasePriority;
000048  6ce6              LDR      r6,[r4,#0x4c]
;;;1532   			}
;;;1533   			#else
;;;1534   			{
;;;1535   				uxCurrentBasePriority = pxTCB->uxPriority;
;;;1536   			}
;;;1537   			#endif
;;;1538   
;;;1539   			if( uxCurrentBasePriority != uxNewPriority )
00004a  42ae              CMP      r6,r5
00004c  d056              BEQ      |L37.252|
;;;1540   			{
;;;1541   				/* The priority change may have readied a task of higher
;;;1542   				priority than the calling task. */
;;;1543   				if( uxNewPriority > uxCurrentBasePriority )
00004e  42b5              CMP      r5,r6
000050  d90b              BLS      |L37.106|
;;;1544   				{
;;;1545   					if( pxTCB != pxCurrentTCB )
000052  482c              LDR      r0,|L37.260|
000054  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000056  4284              CMP      r4,r0
000058  d00d              BEQ      |L37.118|
;;;1546   					{
;;;1547   						/* The priority of a task other than the currently
;;;1548   						running task is being raised.  Is the priority being
;;;1549   						raised above that of the running task? */
;;;1550   						if( uxNewPriority >= pxCurrentTCB->uxPriority )
00005a  482a              LDR      r0,|L37.260|
00005c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00005e  6ac0              LDR      r0,[r0,#0x2c]
000060  42a8              CMP      r0,r5
000062  d808              BHI      |L37.118|
;;;1551   						{
;;;1552   							xYieldRequired = pdTRUE;
000064  f04f0901          MOV      r9,#1
000068  e005              B        |L37.118|
                  |L37.106|
;;;1553   						}
;;;1554   						else
;;;1555   						{
;;;1556   							mtCOVERAGE_TEST_MARKER();
;;;1557   						}
;;;1558   					}
;;;1559   					else
;;;1560   					{
;;;1561   						/* The priority of the running task is being raised,
;;;1562   						but the running task must already be the highest
;;;1563   						priority task able to run so no yield is required. */
;;;1564   					}
;;;1565   				}
;;;1566   				else if( pxTCB == pxCurrentTCB )
00006a  4826              LDR      r0,|L37.260|
00006c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00006e  4284              CMP      r4,r0
000070  d101              BNE      |L37.118|
;;;1567   				{
;;;1568   					/* Setting the priority of the running task down means
;;;1569   					there may now be another task of higher priority that
;;;1570   					is ready to execute. */
;;;1571   					xYieldRequired = pdTRUE;
000072  f04f0901          MOV      r9,#1
                  |L37.118|
;;;1572   				}
;;;1573   				else
;;;1574   				{
;;;1575   					/* Setting the priority of any other task down does not
;;;1576   					require a yield as the running task must be above the
;;;1577   					new priority of the task being modified. */
;;;1578   				}
;;;1579   
;;;1580   				/* Remember the ready list the task might be referenced from
;;;1581   				before its uxPriority member is changed so the
;;;1582   				taskRESET_READY_PRIORITY() macro can function correctly. */
;;;1583   				uxPriorityUsedOnEntry = pxTCB->uxPriority;
000076  6ae7              LDR      r7,[r4,#0x2c]
;;;1584   
;;;1585   				#if ( configUSE_MUTEXES == 1 )
;;;1586   				{
;;;1587   					/* Only change the priority being used if the task is not
;;;1588   					currently using an inherited priority. */
;;;1589   					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
000078  6ae1              LDR      r1,[r4,#0x2c]
00007a  6ce0              LDR      r0,[r4,#0x4c]
00007c  4288              CMP      r0,r1
00007e  d100              BNE      |L37.130|
;;;1590   					{
;;;1591   						pxTCB->uxPriority = uxNewPriority;
000080  62e5              STR      r5,[r4,#0x2c]
                  |L37.130|
;;;1592   					}
;;;1593   					else
;;;1594   					{
;;;1595   						mtCOVERAGE_TEST_MARKER();
;;;1596   					}
;;;1597   
;;;1598   					/* The base priority gets set whatever. */
;;;1599   					pxTCB->uxBasePriority = uxNewPriority;
000082  64e5              STR      r5,[r4,#0x4c]
;;;1600   				}
;;;1601   				#else
;;;1602   				{
;;;1603   					pxTCB->uxPriority = uxNewPriority;
;;;1604   				}
;;;1605   				#endif
;;;1606   
;;;1607   				/* Only reset the event list item value if the value is not
;;;1608   				being used for anything else. */
;;;1609   				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
000084  69a0              LDR      r0,[r4,#0x18]
000086  f0004000          AND      r0,r0,#0x80000000
00008a  b910              CBNZ     r0,|L37.146|
;;;1610   				{
;;;1611   					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00008c  f1c50005          RSB      r0,r5,#5
000090  61a0              STR      r0,[r4,#0x18]
                  |L37.146|
;;;1612   				}
;;;1613   				else
;;;1614   				{
;;;1615   					mtCOVERAGE_TEST_MARKER();
;;;1616   				}
;;;1617   
;;;1618   				/* If the task is in the blocked or suspended list we need do
;;;1619   				nothing more than change its priority variable. However, if
;;;1620   				the task is in a ready list it needs to be removed and placed
;;;1621   				in the list appropriate to its new priority. */
;;;1622   				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
000092  eb070187          ADD      r1,r7,r7,LSL #2
000096  4a1c              LDR      r2,|L37.264|
000098  eb020181          ADD      r1,r2,r1,LSL #2
00009c  6960              LDR      r0,[r4,#0x14]
00009e  4288              CMP      r0,r1
0000a0  d101              BNE      |L37.166|
0000a2  2001              MOVS     r0,#1
0000a4  e000              B        |L37.168|
                  |L37.166|
0000a6  2000              MOVS     r0,#0
                  |L37.168|
0000a8  b1e0              CBZ      r0,|L37.228|
;;;1623   				{
;;;1624   					/* The task is currently in its ready list - remove before
;;;1625   					adding it to it's new ready list.  As we are in a critical
;;;1626   					section we can do this even if the scheduler is suspended. */
;;;1627   					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
0000aa  1d20              ADDS     r0,r4,#4
0000ac  f7fffffe          BL       uxListRemove
0000b0  b930              CBNZ     r0,|L37.192|
;;;1628   					{
;;;1629   						/* It is known that the task is in its ready list so
;;;1630   						there is no need to check again and the port level
;;;1631   						reset macro can be called directly. */
;;;1632   						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
0000b2  2001              MOVS     r0,#1
0000b4  40b8              LSLS     r0,r0,r7
0000b6  4915              LDR      r1,|L37.268|
0000b8  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
0000ba  4381              BICS     r1,r1,r0
0000bc  4813              LDR      r0,|L37.268|
0000be  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L37.192|
;;;1633   					}
;;;1634   					else
;;;1635   					{
;;;1636   						mtCOVERAGE_TEST_MARKER();
;;;1637   					}
;;;1638   					prvAddTaskToReadyList( pxTCB );
0000c0  f894102c          LDRB     r1,[r4,#0x2c]
0000c4  2001              MOVS     r0,#1
0000c6  4088              LSLS     r0,r0,r1
0000c8  4910              LDR      r1,|L37.268|
0000ca  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
0000cc  4308              ORRS     r0,r0,r1
0000ce  490f              LDR      r1,|L37.268|
0000d0  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
0000d2  6ae1              LDR      r1,[r4,#0x2c]
0000d4  eb010181          ADD      r1,r1,r1,LSL #2
0000d8  4a0b              LDR      r2,|L37.264|
0000da  eb020081          ADD      r0,r2,r1,LSL #2
0000de  1d21              ADDS     r1,r4,#4
0000e0  f7fffffe          BL       vListInsertEnd
                  |L37.228|
;;;1639   				}
;;;1640   				else
;;;1641   				{
;;;1642   					mtCOVERAGE_TEST_MARKER();
;;;1643   				}
;;;1644   
;;;1645   				if( xYieldRequired != pdFALSE )
0000e4  f1b90f00          CMP      r9,#0
0000e8  d007              BEQ      |L37.250|
;;;1646   				{
;;;1647   					taskYIELD_IF_USING_PREEMPTION();
0000ea  f04f5080          MOV      r0,#0x10000000
0000ee  4908              LDR      r1,|L37.272|
0000f0  6008              STR      r0,[r1,#0]
0000f2  f3bf8f4f          DSB      
0000f6  f3bf8f6f          ISB      
                  |L37.250|
;;;1648   				}
;;;1649   				else
;;;1650   				{
;;;1651   					mtCOVERAGE_TEST_MARKER();
;;;1652   				}
;;;1653   
;;;1654   				/* Remove compiler warning about unused variables when the port
;;;1655   				optimised task selection is not being used. */
;;;1656   				( void ) uxPriorityUsedOnEntry;
0000fa  bf00              NOP      
                  |L37.252|
;;;1657   			}
;;;1658   		}
;;;1659   		taskEXIT_CRITICAL();
0000fc  f7fffffe          BL       vPortExitCritical
;;;1660   	}
000100  e8bd87f0          POP      {r4-r10,pc}
;;;1661   
                          ENDP

                  |L37.260|
                          DCD      pxCurrentTCB
                  |L37.264|
                          DCD      pxReadyTasksLists
                  |L37.268|
                          DCD      uxTopReadyPriority
                  |L37.272|
                          DCD      0xe000ed04

                          AREA ||i.vTaskRemoveFromUnorderedEventList||, CODE, READONLY, ALIGN=2

                  vTaskRemoveFromUnorderedEventList PROC
;;;3113   
;;;3114   void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
000000  b570              PUSH     {r4-r6,lr}
;;;3115   {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;3116   TCB_t *pxUnblockedTCB;
;;;3117   
;;;3118   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
;;;3119   	the event flags implementation. */
;;;3120   	configASSERT( uxSchedulerSuspended != pdFALSE );
000006  4822              LDR      r0,|L38.144|
000008  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00000a  b108              CBZ      r0,|L38.16|
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L38.18|
                  |L38.16|
000010  2000              MOVS     r0,#0
                  |L38.18|
000012  b950              CBNZ     r0,|L38.42|
000014  bf00              NOP      
000016  2040              MOVS     r0,#0x40
000018  f3808811          MSR      BASEPRI,r0
00001c  f3bf8f4f          DSB      
000020  f3bf8f6f          ISB      
000024  bf00              NOP      
000026  bf00              NOP      
                  |L38.40|
000028  e7fe              B        |L38.40|
                  |L38.42|
;;;3121   
;;;3122   	/* Store the new item value in the event list. */
;;;3123   	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
00002a  f0464000          ORR      r0,r6,#0x80000000
00002e  6028              STR      r0,[r5,#0]
;;;3124   
;;;3125   	/* Remove the event list form the event flag.  Interrupts do not access
;;;3126   	event flags. */
;;;3127   	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
000030  68ec              LDR      r4,[r5,#0xc]
;;;3128   	configASSERT( pxUnblockedTCB );
000032  b954              CBNZ     r4,|L38.74|
000034  bf00              NOP      
000036  2040              MOVS     r0,#0x40
000038  f3808811          MSR      BASEPRI,r0
00003c  f3bf8f4f          DSB      
000040  f3bf8f6f          ISB      
000044  bf00              NOP      
000046  bf00              NOP      
                  |L38.72|
000048  e7fe              B        |L38.72|
                  |L38.74|
;;;3129   	( void ) uxListRemove( pxEventListItem );
00004a  4628              MOV      r0,r5
00004c  f7fffffe          BL       uxListRemove
;;;3130   
;;;3131   	/* Remove the task from the delayed list and add it to the ready list.  The
;;;3132   	scheduler is suspended so interrupts will not be accessing the ready
;;;3133   	lists. */
;;;3134   	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
000050  1d20              ADDS     r0,r4,#4
000052  f7fffffe          BL       uxListRemove
;;;3135   	prvAddTaskToReadyList( pxUnblockedTCB );
000056  f894102c          LDRB     r1,[r4,#0x2c]
00005a  2001              MOVS     r0,#1
00005c  4088              LSLS     r0,r0,r1
00005e  490d              LDR      r1,|L38.148|
000060  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000062  4308              ORRS     r0,r0,r1
000064  490b              LDR      r1,|L38.148|
000066  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
000068  6ae1              LDR      r1,[r4,#0x2c]
00006a  eb010181          ADD      r1,r1,r1,LSL #2
00006e  4a0a              LDR      r2,|L38.152|
000070  eb020081          ADD      r0,r2,r1,LSL #2
000074  1d21              ADDS     r1,r4,#4
000076  f7fffffe          BL       vListInsertEnd
;;;3136   
;;;3137   	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
00007a  4908              LDR      r1,|L38.156|
00007c  6ae0              LDR      r0,[r4,#0x2c]
00007e  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000080  6ac9              LDR      r1,[r1,#0x2c]
000082  4288              CMP      r0,r1
000084  d902              BLS      |L38.140|
;;;3138   	{
;;;3139   		/* The unblocked task has a priority above that of the calling task, so
;;;3140   		a context switch is required.  This function is called with the
;;;3141   		scheduler suspended so xYieldPending is set so the context switch
;;;3142   		occurs immediately that the scheduler is resumed (unsuspended). */
;;;3143   		xYieldPending = pdTRUE;
000086  2001              MOVS     r0,#1
000088  4905              LDR      r1,|L38.160|
00008a  6008              STR      r0,[r1,#0]  ; xYieldPending
                  |L38.140|
;;;3144   	}
;;;3145   }
00008c  bd70              POP      {r4-r6,pc}
;;;3146   /*-----------------------------------------------------------*/
                          ENDP

00008e  0000              DCW      0x0000
                  |L38.144|
                          DCD      uxSchedulerSuspended
                  |L38.148|
                          DCD      uxTopReadyPriority
                  |L38.152|
                          DCD      pxReadyTasksLists
                  |L38.156|
                          DCD      pxCurrentTCB
                  |L38.160|
                          DCD      xYieldPending

                          AREA ||i.vTaskResume||, CODE, READONLY, ALIGN=2

                  vTaskResume PROC
;;;1813   
;;;1814   	void vTaskResume( TaskHandle_t xTaskToResume )
000000  b570              PUSH     {r4-r6,lr}
;;;1815   	{
000002  4605              MOV      r5,r0
;;;1816   	TCB_t * const pxTCB = xTaskToResume;
000004  462c              MOV      r4,r5
;;;1817   
;;;1818   		/* It does not make sense to resume the calling task. */
;;;1819   		configASSERT( xTaskToResume );
000006  b955              CBNZ     r5,|L39.30|
000008  bf00              NOP      
00000a  2040              MOVS     r0,#0x40
00000c  f3808811          MSR      BASEPRI,r0
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L39.28|
00001c  e7fe              B        |L39.28|
                  |L39.30|
;;;1820   
;;;1821   		/* The parameter cannot be NULL as it is impossible to resume the
;;;1822   		currently executing task. */
;;;1823   		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
00001e  4818              LDR      r0,|L39.128|
000020  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000022  4284              CMP      r4,r0
000024  d02b              BEQ      |L39.126|
000026  b354              CBZ      r4,|L39.126|
;;;1824   		{
;;;1825   			taskENTER_CRITICAL();
000028  f7fffffe          BL       vPortEnterCritical
;;;1826   			{
;;;1827   				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       prvTaskIsTaskSuspended
000032  b310              CBZ      r0,|L39.122|
;;;1828   				{
;;;1829   					traceTASK_RESUME( pxTCB );
;;;1830   
;;;1831   					/* The ready list can be accessed even if the scheduler is
;;;1832   					suspended because this is inside a critical section. */
;;;1833   					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
000034  1d20              ADDS     r0,r4,#4
000036  f7fffffe          BL       uxListRemove
;;;1834   					prvAddTaskToReadyList( pxTCB );
00003a  f894102c          LDRB     r1,[r4,#0x2c]
00003e  2001              MOVS     r0,#1
000040  4088              LSLS     r0,r0,r1
000042  4910              LDR      r1,|L39.132|
000044  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000046  4308              ORRS     r0,r0,r1
000048  490e              LDR      r1,|L39.132|
00004a  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
00004c  6ae1              LDR      r1,[r4,#0x2c]
00004e  eb010181          ADD      r1,r1,r1,LSL #2
000052  4a0d              LDR      r2,|L39.136|
000054  eb020081          ADD      r0,r2,r1,LSL #2
000058  1d21              ADDS     r1,r4,#4
00005a  f7fffffe          BL       vListInsertEnd
;;;1835   
;;;1836   					/* A higher priority task may have just been resumed. */
;;;1837   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
00005e  4908              LDR      r1,|L39.128|
000060  6ae0              LDR      r0,[r4,#0x2c]
000062  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000064  6ac9              LDR      r1,[r1,#0x2c]
000066  4288              CMP      r0,r1
000068  d307              BCC      |L39.122|
;;;1838   					{
;;;1839   						/* This yield may not cause the task just resumed to run,
;;;1840   						but will leave the lists in the correct state for the
;;;1841   						next yield. */
;;;1842   						taskYIELD_IF_USING_PREEMPTION();
00006a  f04f5080          MOV      r0,#0x10000000
00006e  4907              LDR      r1,|L39.140|
000070  6008              STR      r0,[r1,#0]
000072  f3bf8f4f          DSB      
000076  f3bf8f6f          ISB      
                  |L39.122|
;;;1843   					}
;;;1844   					else
;;;1845   					{
;;;1846   						mtCOVERAGE_TEST_MARKER();
;;;1847   					}
;;;1848   				}
;;;1849   				else
;;;1850   				{
;;;1851   					mtCOVERAGE_TEST_MARKER();
;;;1852   				}
;;;1853   			}
;;;1854   			taskEXIT_CRITICAL();
00007a  f7fffffe          BL       vPortExitCritical
                  |L39.126|
;;;1855   		}
;;;1856   		else
;;;1857   		{
;;;1858   			mtCOVERAGE_TEST_MARKER();
;;;1859   		}
;;;1860   	}
00007e  bd70              POP      {r4-r6,pc}
;;;1861   
                          ENDP

                  |L39.128|
                          DCD      pxCurrentTCB
                  |L39.132|
                          DCD      uxTopReadyPriority
                  |L39.136|
                          DCD      pxReadyTasksLists
                  |L39.140|
                          DCD      0xe000ed04

                          AREA ||i.vTaskSetTaskNumber||, CODE, READONLY, ALIGN=1

                  vTaskSetTaskNumber PROC
;;;3261   
;;;3262   	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
000000  b108              CBZ      r0,|L40.6|
;;;3263   	{
;;;3264   	TCB_t * pxTCB;
;;;3265   
;;;3266   		if( xTask != NULL )
;;;3267   		{
;;;3268   			pxTCB = xTask;
000002  4602              MOV      r2,r0
;;;3269   			pxTCB->uxTaskNumber = uxHandle;
000004  6491              STR      r1,[r2,#0x48]
                  |L40.6|
;;;3270   		}
;;;3271   	}
000006  4770              BX       lr
;;;3272   
                          ENDP


                          AREA ||i.vTaskSetTimeOutState||, CODE, READONLY, ALIGN=2

                  vTaskSetTimeOutState PROC
;;;3147   
;;;3148   void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
000000  b510              PUSH     {r4,lr}
;;;3149   {
000002  4604              MOV      r4,r0
;;;3150   	configASSERT( pxTimeOut );
000004  b954              CBNZ     r4,|L41.28|
000006  bf00              NOP      
000008  2040              MOVS     r0,#0x40
00000a  f3808811          MSR      BASEPRI,r0
00000e  f3bf8f4f          DSB      
000012  f3bf8f6f          ISB      
000016  bf00              NOP      
000018  bf00              NOP      
                  |L41.26|
00001a  e7fe              B        |L41.26|
                  |L41.28|
;;;3151   	taskENTER_CRITICAL();
00001c  f7fffffe          BL       vPortEnterCritical
;;;3152   	{
;;;3153   		pxTimeOut->xOverflowCount = xNumOfOverflows;
000020  4804              LDR      r0,|L41.52|
000022  6800              LDR      r0,[r0,#0]  ; xNumOfOverflows
000024  6020              STR      r0,[r4,#0]
;;;3154   		pxTimeOut->xTimeOnEntering = xTickCount;
000026  4804              LDR      r0,|L41.56|
000028  6800              LDR      r0,[r0,#0]  ; xTickCount
00002a  6060              STR      r0,[r4,#4]
;;;3155   	}
;;;3156   	taskEXIT_CRITICAL();
00002c  f7fffffe          BL       vPortExitCritical
;;;3157   }
000030  bd10              POP      {r4,pc}
;;;3158   /*-----------------------------------------------------------*/
                          ENDP

000032  0000              DCW      0x0000
                  |L41.52|
                          DCD      xNumOfOverflows
                  |L41.56|
                          DCD      xTickCount

                          AREA ||i.vTaskStartScheduler||, CODE, READONLY, ALIGN=2

                  vTaskStartScheduler PROC
;;;1937   
;;;1938   void vTaskStartScheduler( void )
000000  b51c              PUSH     {r2-r4,lr}
;;;1939   {
;;;1940   BaseType_t xReturn;
;;;1941   
;;;1942   	/* Add the idle task at the lowest priority. */
;;;1943   	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;1944   	{
;;;1945   		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
;;;1946   		StackType_t *pxIdleTaskStackBuffer = NULL;
;;;1947   		uint32_t ulIdleTaskStackSize;
;;;1948   
;;;1949   		/* The Idle task is created using user provided RAM - obtain the
;;;1950   		address of the RAM then create the idle task. */
;;;1951   		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
;;;1952   		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
;;;1953   												configIDLE_TASK_NAME,
;;;1954   												ulIdleTaskStackSize,
;;;1955   												( void * ) NULL, /*lint !e961.  The cast is not redundant for all compilers. */
;;;1956   												portPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIORITY is zero. */
;;;1957   												pxIdleTaskStackBuffer,
;;;1958   												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
;;;1959   
;;;1960   		if( xIdleTaskHandle != NULL )
;;;1961   		{
;;;1962   			xReturn = pdPASS;
;;;1963   		}
;;;1964   		else
;;;1965   		{
;;;1966   			xReturn = pdFAIL;
;;;1967   		}
;;;1968   	}
;;;1969   	#else
;;;1970   	{
;;;1971   		/* The Idle task is being created using dynamically allocated RAM. */
;;;1972   		xReturn = xTaskCreate(	prvIdleTask,
000002  481e              LDR      r0,|L42.124|
000004  2100              MOVS     r1,#0
000006  460b              MOV      r3,r1
000008  2280              MOVS     r2,#0x80
00000a  e9cd1000          STRD     r1,r0,[sp,#0]
00000e  a11c              ADR      r1,|L42.128|
000010  481d              LDR      r0,|L42.136|
000012  f7fffffe          BL       xTaskCreate
000016  4604              MOV      r4,r0
;;;1973   								configIDLE_TASK_NAME,
;;;1974   								configMINIMAL_STACK_SIZE,
;;;1975   								( void * ) NULL,
;;;1976   								portPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIORITY is zero. */
;;;1977   								&xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
;;;1978   	}
;;;1979   	#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;1980   
;;;1981   	#if ( configUSE_TIMERS == 1 )
;;;1982   	{
;;;1983   		if( xReturn == pdPASS )
000018  2c01              CMP      r4,#1
00001a  d102              BNE      |L42.34|
;;;1984   		{
;;;1985   			xReturn = xTimerCreateTimerTask();
00001c  f7fffffe          BL       xTimerCreateTimerTask
000020  4604              MOV      r4,r0
                  |L42.34|
;;;1986   		}
;;;1987   		else
;;;1988   		{
;;;1989   			mtCOVERAGE_TEST_MARKER();
;;;1990   		}
;;;1991   	}
;;;1992   	#endif /* configUSE_TIMERS */
;;;1993   
;;;1994   	if( xReturn == pdPASS )
000022  2c01              CMP      r4,#1
000024  d117              BNE      |L42.86|
;;;1995   	{
;;;1996   		/* freertos_tasks_c_additions_init() should only be called if the user
;;;1997   		definable macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is
;;;1998   		the only macro called by the function. */
;;;1999   		#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
;;;2000   		{
;;;2001   			freertos_tasks_c_additions_init();
;;;2002   		}
;;;2003   		#endif
;;;2004   
;;;2005   		/* Interrupts are turned off here, to ensure a tick does not occur
;;;2006   		before or during the call to xPortStartScheduler().  The stacks of
;;;2007   		the created tasks contain a status word with interrupts switched on
;;;2008   		so interrupts will automatically get re-enabled when the first task
;;;2009   		starts to run. */
;;;2010   		portDISABLE_INTERRUPTS();
000026  bf00              NOP      
000028  2040              MOVS     r0,#0x40
00002a  f3808811          MSR      BASEPRI,r0
00002e  f3bf8f4f          DSB      
000032  f3bf8f6f          ISB      
000036  bf00              NOP      
;;;2011   
;;;2012   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;2013   		{
;;;2014   			/* Switch Newlib's _impure_ptr variable to point to the _reent
;;;2015   			structure specific to the task that will run first. */
;;;2016   			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
;;;2017   		}
;;;2018   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;2019   
;;;2020   		xNextTaskUnblockTime = portMAX_DELAY;
000038  f04f30ff          MOV      r0,#0xffffffff
00003c  4913              LDR      r1,|L42.140|
00003e  6008              STR      r0,[r1,#0]  ; xNextTaskUnblockTime
;;;2021   		xSchedulerRunning = pdTRUE;
000040  2001              MOVS     r0,#1
000042  4913              LDR      r1,|L42.144|
000044  6008              STR      r0,[r1,#0]  ; xSchedulerRunning
;;;2022   		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
000046  2000              MOVS     r0,#0
000048  4912              LDR      r1,|L42.148|
00004a  6008              STR      r0,[r1,#0]  ; xTickCount
;;;2023   
;;;2024   		/* If configGENERATE_RUN_TIME_STATS is defined then the following
;;;2025   		macro must be defined to configure the timer/counter used to generate
;;;2026   		the run time counter time base.   NOTE:  If configGENERATE_RUN_TIME_STATS
;;;2027   		is set to 0 and the following line fails to build then ensure you do not
;;;2028   		have portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() defined in your
;;;2029   		FreeRTOSConfig.h file. */
;;;2030   		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
00004c  f7fffffe          BL       ConfigureTimeForRunTimeStats
;;;2031   
;;;2032   		traceTASK_SWITCHED_IN();
;;;2033   
;;;2034   		/* Setting up the timer tick is hardware specific and thus in the
;;;2035   		portable interface. */
;;;2036   		if( xPortStartScheduler() != pdFALSE )
000050  f7fffffe          BL       xPortStartScheduler
000054  e010              B        |L42.120|
                  |L42.86|
;;;2037   		{
;;;2038   			/* Should not reach here as if the scheduler is running the
;;;2039   			function will not return. */
;;;2040   		}
;;;2041   		else
;;;2042   		{
;;;2043   			/* Should only reach here if a task calls xTaskEndScheduler(). */
;;;2044   		}
;;;2045   	}
;;;2046   	else
;;;2047   	{
;;;2048   		/* This line will only be reached if the kernel could not be started,
;;;2049   		because there was not enough FreeRTOS heap to create the idle task
;;;2050   		or the timer task. */
;;;2051   		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
000056  1c60              ADDS     r0,r4,#1
000058  b108              CBZ      r0,|L42.94|
00005a  2001              MOVS     r0,#1
00005c  e000              B        |L42.96|
                  |L42.94|
00005e  2000              MOVS     r0,#0
                  |L42.96|
000060  b950              CBNZ     r0,|L42.120|
000062  bf00              NOP      
000064  2040              MOVS     r0,#0x40
000066  f3808811          MSR      BASEPRI,r0
00006a  f3bf8f4f          DSB      
00006e  f3bf8f6f          ISB      
000072  bf00              NOP      
000074  bf00              NOP      
                  |L42.118|
000076  e7fe              B        |L42.118|
                  |L42.120|
;;;2052   	}
;;;2053   
;;;2054   	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
;;;2055   	meaning xIdleTaskHandle is not used anywhere else. */
;;;2056   	( void ) xIdleTaskHandle;
;;;2057   }
000078  bd1c              POP      {r2-r4,pc}
;;;2058   /*-----------------------------------------------------------*/
                          ENDP

00007a  0000              DCW      0x0000
                  |L42.124|
                          DCD      xIdleTaskHandle
                  |L42.128|
000080  49444c45          DCB      "IDLE",0
000084  00      
000085  00                DCB      0
000086  00                DCB      0
000087  00                DCB      0
                  |L42.136|
                          DCD      prvIdleTask
                  |L42.140|
                          DCD      xNextTaskUnblockTime
                  |L42.144|
                          DCD      xSchedulerRunning
                  |L42.148|
                          DCD      xTickCount

                          AREA ||i.vTaskSuspend||, CODE, READONLY, ALIGN=2

                  vTaskSuspend PROC
;;;1666   
;;;1667   	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
000000  b570              PUSH     {r4-r6,lr}
;;;1668   	{
000002  4605              MOV      r5,r0
;;;1669   	TCB_t *pxTCB;
;;;1670   
;;;1671   		taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1672   		{
;;;1673   			/* If null is passed in here then it is the running task that is
;;;1674   			being suspended. */
;;;1675   			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
000008  b915              CBNZ     r5,|L43.16|
00000a  4832              LDR      r0,|L43.212|
00000c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000e  e000              B        |L43.18|
                  |L43.16|
000010  4628              MOV      r0,r5
                  |L43.18|
000012  4604              MOV      r4,r0
;;;1676   
;;;1677   			traceTASK_SUSPEND( pxTCB );
;;;1678   
;;;1679   			/* Remove task from the ready/delayed list and place in the
;;;1680   			suspended list. */
;;;1681   			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000014  1d20              ADDS     r0,r4,#4
000016  f7fffffe          BL       uxListRemove
00001a  b978              CBNZ     r0,|L43.60|
;;;1682   			{
;;;1683   				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
00001c  6ae0              LDR      r0,[r4,#0x2c]
00001e  eb000080          ADD      r0,r0,r0,LSL #2
000022  492d              LDR      r1,|L43.216|
000024  f8510020          LDR      r0,[r1,r0,LSL #2]
000028  b940              CBNZ     r0,|L43.60|
00002a  f894102c          LDRB     r1,[r4,#0x2c]
00002e  2001              MOVS     r0,#1
000030  4088              LSLS     r0,r0,r1
000032  492a              LDR      r1,|L43.220|
000034  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000036  4381              BICS     r1,r1,r0
000038  4828              LDR      r0,|L43.220|
00003a  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L43.60|
;;;1684   			}
;;;1685   			else
;;;1686   			{
;;;1687   				mtCOVERAGE_TEST_MARKER();
;;;1688   			}
;;;1689   
;;;1690   			/* Is the task waiting on an event also? */
;;;1691   			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
00003c  6aa0              LDR      r0,[r4,#0x28]
00003e  b118              CBZ      r0,|L43.72|
;;;1692   			{
;;;1693   				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
000040  f1040018          ADD      r0,r4,#0x18
000044  f7fffffe          BL       uxListRemove
                  |L43.72|
;;;1694   			}
;;;1695   			else
;;;1696   			{
;;;1697   				mtCOVERAGE_TEST_MARKER();
;;;1698   			}
;;;1699   
;;;1700   			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
000048  1d21              ADDS     r1,r4,#4
00004a  4825              LDR      r0,|L43.224|
00004c  f7fffffe          BL       vListInsertEnd
;;;1701   
;;;1702   			#if( configUSE_TASK_NOTIFICATIONS == 1 )
;;;1703   			{
;;;1704   				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
000050  f894005c          LDRB     r0,[r4,#0x5c]
000054  2801              CMP      r0,#1
000056  d102              BNE      |L43.94|
;;;1705   				{
;;;1706   					/* The task was blocked to wait for a notification, but is
;;;1707   					now suspended, so no notification was received. */
;;;1708   					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
000058  2000              MOVS     r0,#0
00005a  f884005c          STRB     r0,[r4,#0x5c]
                  |L43.94|
;;;1709   				}
;;;1710   			}
;;;1711   			#endif
;;;1712   		}
;;;1713   		taskEXIT_CRITICAL();
00005e  f7fffffe          BL       vPortExitCritical
;;;1714   
;;;1715   		if( xSchedulerRunning != pdFALSE )
000062  4820              LDR      r0,|L43.228|
000064  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
000066  b128              CBZ      r0,|L43.116|
;;;1716   		{
;;;1717   			/* Reset the next expected unblock time in case it referred to the
;;;1718   			task that is now in the Suspended state. */
;;;1719   			taskENTER_CRITICAL();
000068  f7fffffe          BL       vPortEnterCritical
;;;1720   			{
;;;1721   				prvResetNextTaskUnblockTime();
00006c  f7fffffe          BL       prvResetNextTaskUnblockTime
;;;1722   			}
;;;1723   			taskEXIT_CRITICAL();
000070  f7fffffe          BL       vPortExitCritical
                  |L43.116|
;;;1724   		}
;;;1725   		else
;;;1726   		{
;;;1727   			mtCOVERAGE_TEST_MARKER();
;;;1728   		}
;;;1729   
;;;1730   		if( pxTCB == pxCurrentTCB )
000074  4817              LDR      r0,|L43.212|
000076  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000078  4284              CMP      r4,r0
00007a  d129              BNE      |L43.208|
;;;1731   		{
;;;1732   			if( xSchedulerRunning != pdFALSE )
00007c  4819              LDR      r0,|L43.228|
00007e  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
000080  b1d0              CBZ      r0,|L43.184|
;;;1733   			{
;;;1734   				/* The current task has just been suspended. */
;;;1735   				configASSERT( uxSchedulerSuspended == 0 );
000082  4819              LDR      r0,|L43.232|
000084  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000086  b908              CBNZ     r0,|L43.140|
000088  2001              MOVS     r0,#1
00008a  e000              B        |L43.142|
                  |L43.140|
00008c  2000              MOVS     r0,#0
                  |L43.142|
00008e  b950              CBNZ     r0,|L43.166|
000090  bf00              NOP      
000092  2040              MOVS     r0,#0x40
000094  f3808811          MSR      BASEPRI,r0
000098  f3bf8f4f          DSB      
00009c  f3bf8f6f          ISB      
0000a0  bf00              NOP      
0000a2  bf00              NOP      
                  |L43.164|
0000a4  e7fe              B        |L43.164|
                  |L43.166|
;;;1736   				portYIELD_WITHIN_API();
0000a6  f04f5080          MOV      r0,#0x10000000
0000aa  4910              LDR      r1,|L43.236|
0000ac  6008              STR      r0,[r1,#0]
0000ae  f3bf8f4f          DSB      
0000b2  f3bf8f6f          ISB      
0000b6  e00b              B        |L43.208|
                  |L43.184|
;;;1737   			}
;;;1738   			else
;;;1739   			{
;;;1740   				/* The scheduler is not running, but the task that was pointed
;;;1741   				to by pxCurrentTCB has just been suspended and pxCurrentTCB
;;;1742   				must be adjusted to point to a different task. */
;;;1743   				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
0000b8  4809              LDR      r0,|L43.224|
0000ba  6800              LDR      r0,[r0,#0]  ; xSuspendedTaskList
0000bc  490c              LDR      r1,|L43.240|
0000be  6809              LDR      r1,[r1,#0]  ; uxCurrentNumberOfTasks
0000c0  4288              CMP      r0,r1
0000c2  d103              BNE      |L43.204|
;;;1744   				{
;;;1745   					/* No other tasks are ready, so set pxCurrentTCB back to
;;;1746   					NULL so when the next task is created pxCurrentTCB will
;;;1747   					be set to point to it no matter what its relative priority
;;;1748   					is. */
;;;1749   					pxCurrentTCB = NULL;
0000c4  2000              MOVS     r0,#0
0000c6  4903              LDR      r1,|L43.212|
0000c8  6008              STR      r0,[r1,#0]  ; pxCurrentTCB
0000ca  e001              B        |L43.208|
                  |L43.204|
;;;1750   				}
;;;1751   				else
;;;1752   				{
;;;1753   					vTaskSwitchContext();
0000cc  f7fffffe          BL       vTaskSwitchContext
                  |L43.208|
;;;1754   				}
;;;1755   			}
;;;1756   		}
;;;1757   		else
;;;1758   		{
;;;1759   			mtCOVERAGE_TEST_MARKER();
;;;1760   		}
;;;1761   	}
0000d0  bd70              POP      {r4-r6,pc}
;;;1762   
                          ENDP

0000d2  0000              DCW      0x0000
                  |L43.212|
                          DCD      pxCurrentTCB
                  |L43.216|
                          DCD      pxReadyTasksLists
                  |L43.220|
                          DCD      uxTopReadyPriority
                  |L43.224|
                          DCD      xSuspendedTaskList
                  |L43.228|
                          DCD      xSchedulerRunning
                  |L43.232|
                          DCD      uxSchedulerSuspended
                  |L43.236|
                          DCD      0xe000ed04
                  |L43.240|
                          DCD      uxCurrentNumberOfTasks

                          AREA ||i.vTaskSuspendAll||, CODE, READONLY, ALIGN=2

                  vTaskSuspendAll PROC
;;;2070   
;;;2071   void vTaskSuspendAll( void )
000000  4802              LDR      r0,|L44.12|
;;;2072   {
;;;2073   	/* A critical section is not required as the variable is of type
;;;2074   	BaseType_t.  Please read Richard Barry's reply in the following link to a
;;;2075   	post in the FreeRTOS support forum before reporting this as a bug! -
;;;2076   	http://goo.gl/wu4acr */
;;;2077   	++uxSchedulerSuspended;
000002  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000004  1c40              ADDS     r0,r0,#1
000006  4901              LDR      r1,|L44.12|
000008  6008              STR      r0,[r1,#0]  ; uxSchedulerSuspended
;;;2078   }
00000a  4770              BX       lr
;;;2079   /*----------------------------------------------------------*/
                          ENDP

                  |L44.12|
                          DCD      uxSchedulerSuspended

                          AREA ||i.vTaskSwitchContext||, CODE, READONLY, ALIGN=2

                  vTaskSwitchContext PROC
;;;2898   
;;;2899   void vTaskSwitchContext( void )
000000  482a              LDR      r0,|L45.172|
;;;2900   {
;;;2901   	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
000002  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000004  b118              CBZ      r0,|L45.14|
;;;2902   	{
;;;2903   		/* The scheduler is currently suspended - do not allow a context
;;;2904   		switch. */
;;;2905   		xYieldPending = pdTRUE;
000006  2001              MOVS     r0,#1
000008  4929              LDR      r1,|L45.176|
00000a  6008              STR      r0,[r1,#0]  ; xYieldPending
00000c  e04d              B        |L45.170|
                  |L45.14|
;;;2906   	}
;;;2907   	else
;;;2908   	{
;;;2909   		xYieldPending = pdFALSE;
00000e  2000              MOVS     r0,#0
000010  4927              LDR      r1,|L45.176|
000012  6008              STR      r0,[r1,#0]  ; xYieldPending
;;;2910   		traceTASK_SWITCHED_OUT();
;;;2911   
;;;2912   		#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;2913   		{
;;;2914   				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
;;;2915   					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
;;;2916   				#else
;;;2917   					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
000014  4927              LDR      r1,|L45.180|
000016  6808              LDR      r0,[r1,#0]  ; FreeRTOSRunTimeTicks
000018  6849              LDR      r1,[r1,#4]  ; FreeRTOSRunTimeTicks
00001a  4927              LDR      r1,|L45.184|
00001c  6008              STR      r0,[r1,#0]  ; ulTotalRunTime
;;;2918   				#endif
;;;2919   
;;;2920   				/* Add the amount of time the task has been running to the
;;;2921   				accumulated time so far.  The time the task started running was
;;;2922   				stored in ulTaskSwitchedInTime.  Note that there is no overflow
;;;2923   				protection here so count values are only valid until the timer
;;;2924   				overflows.  The guard against negative values is to protect
;;;2925   				against suspect run time stat counter implementations - which
;;;2926   				are provided by the application, not the kernel. */
;;;2927   				if( ulTotalRunTime > ulTaskSwitchedInTime )
00001e  4608              MOV      r0,r1
000020  6800              LDR      r0,[r0,#0]  ; ulTotalRunTime
000022  4926              LDR      r1,|L45.188|
000024  6809              LDR      r1,[r1,#0]  ; ulTaskSwitchedInTime
000026  4288              CMP      r0,r1
000028  d90b              BLS      |L45.66|
;;;2928   				{
;;;2929   					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
00002a  4925              LDR      r1,|L45.192|
00002c  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00002e  f1010054          ADD      r0,r1,#0x54
000032  6d4a              LDR      r2,[r1,#0x54]
000034  4920              LDR      r1,|L45.184|
000036  6809              LDR      r1,[r1,#0]  ; ulTotalRunTime
000038  4b20              LDR      r3,|L45.188|
00003a  681b              LDR      r3,[r3,#0]  ; ulTaskSwitchedInTime
00003c  1ac9              SUBS     r1,r1,r3
00003e  4411              ADD      r1,r1,r2
000040  6001              STR      r1,[r0,#0]
                  |L45.66|
;;;2930   				}
;;;2931   				else
;;;2932   				{
;;;2933   					mtCOVERAGE_TEST_MARKER();
;;;2934   				}
;;;2935   				ulTaskSwitchedInTime = ulTotalRunTime;
000042  481d              LDR      r0,|L45.184|
000044  6800              LDR      r0,[r0,#0]  ; ulTotalRunTime
000046  491d              LDR      r1,|L45.188|
000048  6008              STR      r0,[r1,#0]  ; ulTaskSwitchedInTime
;;;2936   		}
;;;2937   		#endif /* configGENERATE_RUN_TIME_STATS */
;;;2938   
;;;2939   		/* Check for stack overflow, if configured. */
;;;2940   		taskCHECK_FOR_STACK_OVERFLOW();
;;;2941   
;;;2942   		/* Before the currently running task is switched out, save its errno. */
;;;2943   		#if( configUSE_POSIX_ERRNO == 1 )
;;;2944   		{
;;;2945   			pxCurrentTCB->iTaskErrno = FreeRTOS_errno;
;;;2946   		}
;;;2947   		#endif
;;;2948   
;;;2949   		/* Select a new task to run using either the generic C or port
;;;2950   		optimised asm code. */
;;;2951   		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
00004a  481e              LDR      r0,|L45.196|
00004c  6800              LDR      r0,[r0,#0]  ; uxTopReadyPriority
00004e  fab0f080          CLZ      r0,r0
000052  f1c0011f          RSB      r1,r0,#0x1f
000056  eb010081          ADD      r0,r1,r1,LSL #2
00005a  4a1b              LDR      r2,|L45.200|
00005c  f8520020          LDR      r0,[r2,r0,LSL #2]
000060  b108              CBZ      r0,|L45.102|
000062  2001              MOVS     r0,#1
000064  e000              B        |L45.104|
                  |L45.102|
000066  2000              MOVS     r0,#0
                  |L45.104|
000068  b950              CBNZ     r0,|L45.128|
00006a  bf00              NOP      
00006c  2040              MOVS     r0,#0x40
00006e  f3808811          MSR      BASEPRI,r0
000072  f3bf8f4f          DSB      
000076  f3bf8f6f          ISB      
00007a  bf00              NOP      
00007c  bf00              NOP      
                  |L45.126|
00007e  e7fe              B        |L45.126|
                  |L45.128|
000080  eb010281          ADD      r2,r1,r1,LSL #2
000084  4b10              LDR      r3,|L45.200|
000086  eb030082          ADD      r0,r3,r2,LSL #2
00008a  6842              LDR      r2,[r0,#4]
00008c  6852              LDR      r2,[r2,#4]
00008e  6042              STR      r2,[r0,#4]
000090  f1000208          ADD      r2,r0,#8
000094  6843              LDR      r3,[r0,#4]
000096  4293              CMP      r3,r2
000098  d102              BNE      |L45.160|
00009a  6842              LDR      r2,[r0,#4]
00009c  6852              LDR      r2,[r2,#4]
00009e  6042              STR      r2,[r0,#4]
                  |L45.160|
0000a0  6842              LDR      r2,[r0,#4]
0000a2  68d2              LDR      r2,[r2,#0xc]
0000a4  4b06              LDR      r3,|L45.192|
0000a6  601a              STR      r2,[r3,#0]  ; pxCurrentTCB
0000a8  bf00              NOP      
                  |L45.170|
;;;2952   		traceTASK_SWITCHED_IN();
;;;2953   
;;;2954   		/* After the new task is switched in, update the global errno. */
;;;2955   		#if( configUSE_POSIX_ERRNO == 1 )
;;;2956   		{
;;;2957   			FreeRTOS_errno = pxCurrentTCB->iTaskErrno;
;;;2958   		}
;;;2959   		#endif
;;;2960   
;;;2961   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;2962   		{
;;;2963   			/* Switch Newlib's _impure_ptr variable to point to the _reent
;;;2964   			structure specific to this task. */
;;;2965   			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
;;;2966   		}
;;;2967   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;2968   	}
;;;2969   }
0000aa  4770              BX       lr
;;;2970   /*-----------------------------------------------------------*/
                          ENDP

                  |L45.172|
                          DCD      uxSchedulerSuspended
                  |L45.176|
                          DCD      xYieldPending
                  |L45.180|
                          DCD      FreeRTOSRunTimeTicks
                  |L45.184|
                          DCD      ulTotalRunTime
                  |L45.188|
                          DCD      ulTaskSwitchedInTime
                  |L45.192|
                          DCD      pxCurrentTCB
                  |L45.196|
                          DCD      uxTopReadyPriority
                  |L45.200|
                          DCD      pxReadyTasksLists

                          AREA ||i.xTaskCheckForTimeOut||, CODE, READONLY, ALIGN=2

                  xTaskCheckForTimeOut PROC
;;;3167   
;;;3168   BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
000000  b570              PUSH     {r4-r6,lr}
;;;3169   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;3170   BaseType_t xReturn;
;;;3171   
;;;3172   	configASSERT( pxTimeOut );
000006  b955              CBNZ     r5,|L46.30|
000008  bf00              NOP      
00000a  2040              MOVS     r0,#0x40
00000c  f3808811          MSR      BASEPRI,r0
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L46.28|
00001c  e7fe              B        |L46.28|
                  |L46.30|
;;;3173   	configASSERT( pxTicksToWait );
00001e  b954              CBNZ     r4,|L46.54|
000020  bf00              NOP      
000022  2040              MOVS     r0,#0x40
000024  f3808811          MSR      BASEPRI,r0
000028  f3bf8f4f          DSB      
00002c  f3bf8f6f          ISB      
000030  bf00              NOP      
000032  bf00              NOP      
                  |L46.52|
000034  e7fe              B        |L46.52|
                  |L46.54|
;;;3174   
;;;3175   	taskENTER_CRITICAL();
000036  f7fffffe          BL       vPortEnterCritical
;;;3176   	{
;;;3177   		/* Minor optimisation.  The tick count cannot change in this block. */
;;;3178   		const TickType_t xConstTickCount = xTickCount;
00003a  4812              LDR      r0,|L46.132|
00003c  6802              LDR      r2,[r0,#0]  ; xTickCount
;;;3179   		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
00003e  6868              LDR      r0,[r5,#4]
000040  1a13              SUBS     r3,r2,r0
;;;3180   
;;;3181   		#if( INCLUDE_xTaskAbortDelay == 1 )
;;;3182   			if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
;;;3183   			{
;;;3184   				/* The delay was aborted, which is not the same as a time out,
;;;3185   				but has the same result. */
;;;3186   				pxCurrentTCB->ucDelayAborted = pdFALSE;
;;;3187   				xReturn = pdTRUE;
;;;3188   			}
;;;3189   			else
;;;3190   		#endif
;;;3191   
;;;3192   		#if ( INCLUDE_vTaskSuspend == 1 )
;;;3193   			if( *pxTicksToWait == portMAX_DELAY )
000042  6820              LDR      r0,[r4,#0]
000044  1c40              ADDS     r0,r0,#1
000046  b908              CBNZ     r0,|L46.76|
;;;3194   			{
;;;3195   				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
;;;3196   				specified is the maximum block time then the task should block
;;;3197   				indefinitely, and therefore never time out. */
;;;3198   				xReturn = pdFALSE;
000048  2600              MOVS     r6,#0
00004a  e017              B        |L46.124|
                  |L46.76|
;;;3199   			}
;;;3200   			else
;;;3201   		#endif
;;;3202   
;;;3203   		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
00004c  490e              LDR      r1,|L46.136|
00004e  6828              LDR      r0,[r5,#0]
000050  6809              LDR      r1,[r1,#0]  ; xNumOfOverflows
000052  4288              CMP      r0,r1
000054  d004              BEQ      |L46.96|
000056  6868              LDR      r0,[r5,#4]
000058  4290              CMP      r0,r2
00005a  d801              BHI      |L46.96|
;;;3204   		{
;;;3205   			/* The tick count is greater than the time at which
;;;3206   			vTaskSetTimeout() was called, but has also overflowed since
;;;3207   			vTaskSetTimeOut() was called.  It must have wrapped all the way
;;;3208   			around and gone past again. This passed since vTaskSetTimeout()
;;;3209   			was called. */
;;;3210   			xReturn = pdTRUE;
00005c  2601              MOVS     r6,#1
00005e  e00d              B        |L46.124|
                  |L46.96|
;;;3211   		}
;;;3212   		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
000060  6820              LDR      r0,[r4,#0]
000062  4298              CMP      r0,r3
000064  d907              BLS      |L46.118|
;;;3213   		{
;;;3214   			/* Not a genuine timeout. Adjust parameters for time remaining. */
;;;3215   			*pxTicksToWait -= xElapsedTime;
000066  6820              LDR      r0,[r4,#0]
000068  1ac0              SUBS     r0,r0,r3
00006a  6020              STR      r0,[r4,#0]
;;;3216   			vTaskInternalSetTimeOutState( pxTimeOut );
00006c  4628              MOV      r0,r5
00006e  f7fffffe          BL       vTaskInternalSetTimeOutState
;;;3217   			xReturn = pdFALSE;
000072  2600              MOVS     r6,#0
000074  e002              B        |L46.124|
                  |L46.118|
;;;3218   		}
;;;3219   		else
;;;3220   		{
;;;3221   			*pxTicksToWait = 0;
000076  2000              MOVS     r0,#0
000078  6020              STR      r0,[r4,#0]
;;;3222   			xReturn = pdTRUE;
00007a  2601              MOVS     r6,#1
                  |L46.124|
;;;3223   		}
;;;3224   	}
;;;3225   	taskEXIT_CRITICAL();
00007c  f7fffffe          BL       vPortExitCritical
;;;3226   
;;;3227   	return xReturn;
000080  4630              MOV      r0,r6
;;;3228   }
000082  bd70              POP      {r4-r6,pc}
;;;3229   /*-----------------------------------------------------------*/
                          ENDP

                  |L46.132|
                          DCD      xTickCount
                  |L46.136|
                          DCD      xNumOfOverflows

                          AREA ||i.xTaskCreate||, CODE, READONLY, ALIGN=1

                  xTaskCreate PROC
;;;745    
;;;746    	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;747    							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
;;;748    							const configSTACK_DEPTH_TYPE usStackDepth,
;;;749    							void * const pvParameters,
;;;750    							UBaseType_t uxPriority,
;;;751    							TaskHandle_t * const pxCreatedTask )
;;;752    	{
000004  b085              SUB      sp,sp,#0x14
000006  4680              MOV      r8,r0
000008  4689              MOV      r9,r1
00000a  4617              MOV      r7,r2
00000c  e9ddab12          LDRD     r10,r11,[sp,#0x48]
;;;753    	TCB_t *pxNewTCB;
;;;754    	BaseType_t xReturn;
;;;755    
;;;756    		/* If the stack grows down then allocate the stack then the TCB so the stack
;;;757    		does not grow into the TCB.  Likewise if the stack grows up then allocate
;;;758    		the TCB then the stack. */
;;;759    		#if( portSTACK_GROWTH > 0 )
;;;760    		{
;;;761    			/* Allocate space for the TCB.  Where the memory comes from depends on
;;;762    			the implementation of the port malloc function and whether or not static
;;;763    			allocation is being used. */
;;;764    			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
;;;765    
;;;766    			if( pxNewTCB != NULL )
;;;767    			{
;;;768    				/* Allocate space for the stack used by the task being created.
;;;769    				The base of the stack memory stored in the TCB so the task can
;;;770    				be deleted later if required. */
;;;771    				pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
;;;772    
;;;773    				if( pxNewTCB->pxStack == NULL )
;;;774    				{
;;;775    					/* Could not allocate the stack.  Delete the allocated TCB. */
;;;776    					vPortFree( pxNewTCB );
;;;777    					pxNewTCB = NULL;
;;;778    				}
;;;779    			}
;;;780    		}
;;;781    		#else /* portSTACK_GROWTH */
;;;782    		{
;;;783    		StackType_t *pxStack;
;;;784    
;;;785    			/* Allocate space for the stack used by the task being created. */
;;;786    			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
000010  00b8              LSLS     r0,r7,#2
000012  f7fffffe          BL       pvPortMalloc
000016  4606              MOV      r6,r0
;;;787    
;;;788    			if( pxStack != NULL )
000018  b156              CBZ      r6,|L47.48|
;;;789    			{
;;;790    				/* Allocate space for the TCB. */
;;;791    				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
00001a  2060              MOVS     r0,#0x60
00001c  f7fffffe          BL       pvPortMalloc
000020  4604              MOV      r4,r0
;;;792    
;;;793    				if( pxNewTCB != NULL )
000022  b10c              CBZ      r4,|L47.40|
;;;794    				{
;;;795    					/* Store the stack location in the TCB. */
;;;796    					pxNewTCB->pxStack = pxStack;
000024  6326              STR      r6,[r4,#0x30]
000026  e004              B        |L47.50|
                  |L47.40|
;;;797    				}
;;;798    				else
;;;799    				{
;;;800    					/* The stack cannot be used as the TCB was not created.  Free
;;;801    					it again. */
;;;802    					vPortFree( pxStack );
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       vPortFree
00002e  e000              B        |L47.50|
                  |L47.48|
;;;803    				}
;;;804    			}
;;;805    			else
;;;806    			{
;;;807    				pxNewTCB = NULL;
000030  2400              MOVS     r4,#0
                  |L47.50|
;;;808    			}
;;;809    		}
;;;810    		#endif /* portSTACK_GROWTH */
;;;811    
;;;812    		if( pxNewTCB != NULL )
000032  b17c              CBZ      r4,|L47.84|
;;;813    		{
;;;814    			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e9029 !e731 Macro has been consolidated for readability reasons. */
;;;815    			{
;;;816    				/* Tasks can be created statically or dynamically, so note this
;;;817    				task was created dynamically in case it is later deleted. */
;;;818    				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
;;;819    			}
;;;820    			#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;821    
;;;822    			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
000034  2000              MOVS     r0,#0
000036  e9cdab00          STRD     r10,r11,[sp,#0]
00003a  e9cd4002          STRD     r4,r0,[sp,#8]
00003e  463a              MOV      r2,r7
000040  4649              MOV      r1,r9
000042  4640              MOV      r0,r8
000044  9b08              LDR      r3,[sp,#0x20]
000046  f7fffffe          BL       prvInitialiseNewTask
;;;823    			prvAddNewTaskToReadyList( pxNewTCB );
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       prvAddNewTaskToReadyList
;;;824    			xReturn = pdPASS;
000050  2501              MOVS     r5,#1
000052  e001              B        |L47.88|
                  |L47.84|
;;;825    		}
;;;826    		else
;;;827    		{
;;;828    			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
000054  f04f35ff          MOV      r5,#0xffffffff
                  |L47.88|
;;;829    		}
;;;830    
;;;831    		return xReturn;
000058  4628              MOV      r0,r5
;;;832    	}
00005a  b009              ADD      sp,sp,#0x24
00005c  e8bd8ff0          POP      {r4-r11,pc}
;;;833    
                          ENDP


                          AREA ||i.xTaskGenericNotify||, CODE, READONLY, ALIGN=2

                  xTaskGenericNotify PROC
;;;4625   
;;;4626   	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;4627   	{
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;4628   	TCB_t * pxTCB;
;;;4629   	BaseType_t xReturn = pdPASS;
00000c  f04f0a01          MOV      r10,#1
;;;4630   	uint8_t ucOriginalNotifyState;
;;;4631   
;;;4632   		configASSERT( xTaskToNotify );
000010  b956              CBNZ     r6,|L48.40|
000012  bf00              NOP      
000014  2040              MOVS     r0,#0x40
000016  f3808811          MSR      BASEPRI,r0
00001a  f3bf8f4f          DSB      
00001e  f3bf8f6f          ISB      
000022  bf00              NOP      
000024  bf00              NOP      
                  |L48.38|
000026  e7fe              B        |L48.38|
                  |L48.40|
;;;4633   		pxTCB = xTaskToNotify;
000028  4634              MOV      r4,r6
;;;4634   
;;;4635   		taskENTER_CRITICAL();
00002a  f7fffffe          BL       vPortEnterCritical
;;;4636   		{
;;;4637   			if( pulPreviousNotificationValue != NULL )
00002e  f1b80f00          CMP      r8,#0
000032  d002              BEQ      |L48.58|
;;;4638   			{
;;;4639   				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
000034  6da0              LDR      r0,[r4,#0x58]
000036  f8c80000          STR      r0,[r8,#0]
                  |L48.58|
;;;4640   			}
;;;4641   
;;;4642   			ucOriginalNotifyState = pxTCB->ucNotifyState;
00003a  f894905c          LDRB     r9,[r4,#0x5c]
;;;4643   
;;;4644   			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
00003e  2002              MOVS     r0,#2
000040  f884005c          STRB     r0,[r4,#0x5c]
;;;4645   
;;;4646   			switch( eAction )
000044  2f05              CMP      r7,#5
000046  d217              BCS      |L48.120|
000048  e8dff007          TBB      [pc,r7]
00004c  1503070b          DCB      0x15,0x03,0x07,0x0b
000050  0d00              DCB      0x0d,0x00
;;;4647   			{
;;;4648   				case eSetBits	:
;;;4649   					pxTCB->ulNotifiedValue |= ulValue;
000052  6da0              LDR      r0,[r4,#0x58]
000054  4328              ORRS     r0,r0,r5
000056  65a0              STR      r0,[r4,#0x58]
;;;4650   					break;
000058  e021              B        |L48.158|
;;;4651   
;;;4652   				case eIncrement	:
;;;4653   					( pxTCB->ulNotifiedValue )++;
00005a  6da0              LDR      r0,[r4,#0x58]
00005c  1c40              ADDS     r0,r0,#1
00005e  65a0              STR      r0,[r4,#0x58]
;;;4654   					break;
000060  e01d              B        |L48.158|
;;;4655   
;;;4656   				case eSetValueWithOverwrite	:
;;;4657   					pxTCB->ulNotifiedValue = ulValue;
000062  65a5              STR      r5,[r4,#0x58]
;;;4658   					break;
000064  e01b              B        |L48.158|
;;;4659   
;;;4660   				case eSetValueWithoutOverwrite :
;;;4661   					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
000066  f1b90f02          CMP      r9,#2
00006a  d001              BEQ      |L48.112|
;;;4662   					{
;;;4663   						pxTCB->ulNotifiedValue = ulValue;
00006c  65a5              STR      r5,[r4,#0x58]
00006e  e001              B        |L48.116|
                  |L48.112|
;;;4664   					}
;;;4665   					else
;;;4666   					{
;;;4667   						/* The value could not be written to the task. */
;;;4668   						xReturn = pdFAIL;
000070  f04f0a00          MOV      r10,#0
                  |L48.116|
;;;4669   					}
;;;4670   					break;
000074  e013              B        |L48.158|
;;;4671   
;;;4672   				case eNoAction:
;;;4673   					/* The task is being notified without its notify value being
;;;4674   					updated. */
;;;4675   					break;
000076  e012              B        |L48.158|
                  |L48.120|
;;;4676   
;;;4677   				default:
;;;4678   					/* Should not get here if all enums are handled.
;;;4679   					Artificially force an assert by testing a value the
;;;4680   					compiler can't assume is const. */
;;;4681   					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
000078  6da0              LDR      r0,[r4,#0x58]
00007a  1c40              ADDS     r0,r0,#1
00007c  b908              CBNZ     r0,|L48.130|
00007e  2001              MOVS     r0,#1
000080  e000              B        |L48.132|
                  |L48.130|
000082  2000              MOVS     r0,#0
                  |L48.132|
000084  b950              CBNZ     r0,|L48.156|
000086  bf00              NOP      
000088  2040              MOVS     r0,#0x40
00008a  f3808811          MSR      BASEPRI,r0
00008e  f3bf8f4f          DSB      
000092  f3bf8f6f          ISB      
000096  bf00              NOP      
000098  bf00              NOP      
                  |L48.154|
00009a  e7fe              B        |L48.154|
                  |L48.156|
;;;4682   
;;;4683   					break;
00009c  bf00              NOP      
                  |L48.158|
00009e  bf00              NOP                            ;4650
;;;4684   			}
;;;4685   
;;;4686   			traceTASK_NOTIFY();
;;;4687   
;;;4688   			/* If the task is in the blocked state specifically to wait for a
;;;4689   			notification then unblock it now. */
;;;4690   			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
0000a0  f1b90f01          CMP      r9,#1
0000a4  d133              BNE      |L48.270|
;;;4691   			{
;;;4692   				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
0000a6  1d20              ADDS     r0,r4,#4
0000a8  f7fffffe          BL       uxListRemove
;;;4693   				prvAddTaskToReadyList( pxTCB );
0000ac  f894102c          LDRB     r1,[r4,#0x2c]
0000b0  2001              MOVS     r0,#1
0000b2  4088              LSLS     r0,r0,r1
0000b4  4918              LDR      r1,|L48.280|
0000b6  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
0000b8  4308              ORRS     r0,r0,r1
0000ba  4917              LDR      r1,|L48.280|
0000bc  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
0000be  6ae1              LDR      r1,[r4,#0x2c]
0000c0  eb010181          ADD      r1,r1,r1,LSL #2
0000c4  4a15              LDR      r2,|L48.284|
0000c6  eb020081          ADD      r0,r2,r1,LSL #2
0000ca  1d21              ADDS     r1,r4,#4
0000cc  f7fffffe          BL       vListInsertEnd
;;;4694   
;;;4695   				/* The task should not have been on an event list. */
;;;4696   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
0000d0  6aa0              LDR      r0,[r4,#0x28]
0000d2  b908              CBNZ     r0,|L48.216|
0000d4  2001              MOVS     r0,#1
0000d6  e000              B        |L48.218|
                  |L48.216|
0000d8  2000              MOVS     r0,#0
                  |L48.218|
0000da  b950              CBNZ     r0,|L48.242|
0000dc  bf00              NOP      
0000de  2040              MOVS     r0,#0x40
0000e0  f3808811          MSR      BASEPRI,r0
0000e4  f3bf8f4f          DSB      
0000e8  f3bf8f6f          ISB      
0000ec  bf00              NOP      
0000ee  bf00              NOP      
                  |L48.240|
0000f0  e7fe              B        |L48.240|
                  |L48.242|
;;;4697   
;;;4698   				#if( configUSE_TICKLESS_IDLE != 0 )
;;;4699   				{
;;;4700   					/* If a task is blocked waiting for a notification then
;;;4701   					xNextTaskUnblockTime might be set to the blocked task's time
;;;4702   					out time.  If the task is unblocked for a reason other than
;;;4703   					a timeout xNextTaskUnblockTime is normally left unchanged,
;;;4704   					because it will automatically get reset to a new value when
;;;4705   					the tick count equals xNextTaskUnblockTime.  However if
;;;4706   					tickless idling is used it might be more important to enter
;;;4707   					sleep mode at the earliest possible time - so reset
;;;4708   					xNextTaskUnblockTime here to ensure it is updated at the
;;;4709   					earliest possible time. */
;;;4710   					prvResetNextTaskUnblockTime();
;;;4711   				}
;;;4712   				#endif
;;;4713   
;;;4714   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
0000f2  490b              LDR      r1,|L48.288|
0000f4  6ae0              LDR      r0,[r4,#0x2c]
0000f6  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
0000f8  6ac9              LDR      r1,[r1,#0x2c]
0000fa  4288              CMP      r0,r1
0000fc  d907              BLS      |L48.270|
;;;4715   				{
;;;4716   					/* The notified task has a priority above the currently
;;;4717   					executing task so a yield is required. */
;;;4718   					taskYIELD_IF_USING_PREEMPTION();
0000fe  f04f5080          MOV      r0,#0x10000000
000102  4908              LDR      r1,|L48.292|
000104  6008              STR      r0,[r1,#0]
000106  f3bf8f4f          DSB      
00010a  f3bf8f6f          ISB      
                  |L48.270|
;;;4719   				}
;;;4720   				else
;;;4721   				{
;;;4722   					mtCOVERAGE_TEST_MARKER();
;;;4723   				}
;;;4724   			}
;;;4725   			else
;;;4726   			{
;;;4727   				mtCOVERAGE_TEST_MARKER();
;;;4728   			}
;;;4729   		}
;;;4730   		taskEXIT_CRITICAL();
00010e  f7fffffe          BL       vPortExitCritical
;;;4731   
;;;4732   		return xReturn;
000112  4650              MOV      r0,r10
;;;4733   	}
000114  e8bd87f0          POP      {r4-r10,pc}
;;;4734   
                          ENDP

                  |L48.280|
                          DCD      uxTopReadyPriority
                  |L48.284|
                          DCD      pxReadyTasksLists
                  |L48.288|
                          DCD      pxCurrentTCB
                  |L48.292|
                          DCD      0xe000ed04

                          AREA ||i.xTaskGenericNotifyFromISR||, CODE, READONLY, ALIGN=2

                  xTaskGenericNotifyFromISR PROC
;;;4739   
;;;4740   	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;4741   	{
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  f8ddb028          LDR      r11,[sp,#0x28]
;;;4742   	TCB_t * pxTCB;
;;;4743   	uint8_t ucOriginalNotifyState;
;;;4744   	BaseType_t xReturn = pdPASS;
000010  2001              MOVS     r0,#1
000012  9000              STR      r0,[sp,#0]
;;;4745   	UBaseType_t uxSavedInterruptStatus;
;;;4746   
;;;4747   		configASSERT( xTaskToNotify );
000014  b957              CBNZ     r7,|L49.44|
000016  bf00              NOP      
000018  2040              MOVS     r0,#0x40
00001a  f3808811          MSR      BASEPRI,r0
00001e  f3bf8f4f          DSB      
000022  f3bf8f6f          ISB      
000026  bf00              NOP      
000028  bf00              NOP      
                  |L49.42|
00002a  e7fe              B        |L49.42|
                  |L49.44|
;;;4748   
;;;4749   		/* RTOS ports that support interrupt nesting have the concept of a
;;;4750   		maximum	system call (or maximum API call) interrupt priority.
;;;4751   		Interrupts that are	above the maximum system call priority are keep
;;;4752   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;4753   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;4754   		is defined in FreeRTOSConfig.h then
;;;4755   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;4756   		failure if a FreeRTOS API function is called from an interrupt that has
;;;4757   		been assigned a priority above the configured maximum system call
;;;4758   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;4759   		from interrupts	that have been assigned a priority at or (logically)
;;;4760   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;4761   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;4762   		simple as possible.  More information (albeit Cortex-M specific) is
;;;4763   		provided on the following link:
;;;4764   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;4765   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
00002c  f7fffffe          BL       vPortValidateInterruptPriority
;;;4766   
;;;4767   		pxTCB = xTaskToNotify;
000030  463c              MOV      r4,r7
;;;4768   
;;;4769   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000032  bf00              NOP      
000034  2140              MOVS     r1,#0x40
000036  f3ef8011          MRS      r0,BASEPRI
00003a  f3818811          MSR      BASEPRI,r1
00003e  f3bf8f4f          DSB      
000042  f3bf8f6f          ISB      
000046  bf00              NOP      
000048  4605              MOV      r5,r0
;;;4770   		{
;;;4771   			if( pulPreviousNotificationValue != NULL )
00004a  f1b90f00          CMP      r9,#0
00004e  d002              BEQ      |L49.86|
;;;4772   			{
;;;4773   				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
000050  6da0              LDR      r0,[r4,#0x58]
000052  f8c90000          STR      r0,[r9,#0]
                  |L49.86|
;;;4774   			}
;;;4775   
;;;4776   			ucOriginalNotifyState = pxTCB->ucNotifyState;
000056  f894a05c          LDRB     r10,[r4,#0x5c]
;;;4777   			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
00005a  2002              MOVS     r0,#2
00005c  f884005c          STRB     r0,[r4,#0x5c]
;;;4778   
;;;4779   			switch( eAction )
000060  f1b80f05          CMP      r8,#5
000064  d217              BCS      |L49.150|
000066  e8dff008          TBB      [pc,r8]
00006a  1503              DCB      0x15,0x03
00006c  070b0d00          DCB      0x07,0x0b,0x0d,0x00
;;;4780   			{
;;;4781   				case eSetBits	:
;;;4782   					pxTCB->ulNotifiedValue |= ulValue;
000070  6da0              LDR      r0,[r4,#0x58]
000072  4330              ORRS     r0,r0,r6
000074  65a0              STR      r0,[r4,#0x58]
;;;4783   					break;
000076  e021              B        |L49.188|
;;;4784   
;;;4785   				case eIncrement	:
;;;4786   					( pxTCB->ulNotifiedValue )++;
000078  6da0              LDR      r0,[r4,#0x58]
00007a  1c40              ADDS     r0,r0,#1
00007c  65a0              STR      r0,[r4,#0x58]
;;;4787   					break;
00007e  e01d              B        |L49.188|
;;;4788   
;;;4789   				case eSetValueWithOverwrite	:
;;;4790   					pxTCB->ulNotifiedValue = ulValue;
000080  65a6              STR      r6,[r4,#0x58]
;;;4791   					break;
000082  e01b              B        |L49.188|
;;;4792   
;;;4793   				case eSetValueWithoutOverwrite :
;;;4794   					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
000084  f1ba0f02          CMP      r10,#2
000088  d001              BEQ      |L49.142|
;;;4795   					{
;;;4796   						pxTCB->ulNotifiedValue = ulValue;
00008a  65a6              STR      r6,[r4,#0x58]
00008c  e001              B        |L49.146|
                  |L49.142|
;;;4797   					}
;;;4798   					else
;;;4799   					{
;;;4800   						/* The value could not be written to the task. */
;;;4801   						xReturn = pdFAIL;
00008e  2000              MOVS     r0,#0
000090  9000              STR      r0,[sp,#0]
                  |L49.146|
;;;4802   					}
;;;4803   					break;
000092  e013              B        |L49.188|
;;;4804   
;;;4805   				case eNoAction :
;;;4806   					/* The task is being notified without its notify value being
;;;4807   					updated. */
;;;4808   					break;
000094  e012              B        |L49.188|
                  |L49.150|
;;;4809   
;;;4810   				default:
;;;4811   					/* Should not get here if all enums are handled.
;;;4812   					Artificially force an assert by testing a value the
;;;4813   					compiler can't assume is const. */
;;;4814   					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
000096  6da0              LDR      r0,[r4,#0x58]
000098  1c40              ADDS     r0,r0,#1
00009a  b908              CBNZ     r0,|L49.160|
00009c  2001              MOVS     r0,#1
00009e  e000              B        |L49.162|
                  |L49.160|
0000a0  2000              MOVS     r0,#0
                  |L49.162|
0000a2  b950              CBNZ     r0,|L49.186|
0000a4  bf00              NOP      
0000a6  2040              MOVS     r0,#0x40
0000a8  f3808811          MSR      BASEPRI,r0
0000ac  f3bf8f4f          DSB      
0000b0  f3bf8f6f          ISB      
0000b4  bf00              NOP      
0000b6  bf00              NOP      
                  |L49.184|
0000b8  e7fe              B        |L49.184|
                  |L49.186|
;;;4815   					break;
0000ba  bf00              NOP      
                  |L49.188|
0000bc  bf00              NOP                            ;4783
;;;4816   			}
;;;4817   
;;;4818   			traceTASK_NOTIFY_FROM_ISR();
;;;4819   
;;;4820   			/* If the task is in the blocked state specifically to wait for a
;;;4821   			notification then unblock it now. */
;;;4822   			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
0000be  f1ba0f01          CMP      r10,#1
0000c2  d13d              BNE      |L49.320|
;;;4823   			{
;;;4824   				/* The task should not have been on an event list. */
;;;4825   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
0000c4  6aa0              LDR      r0,[r4,#0x28]
0000c6  b908              CBNZ     r0,|L49.204|
0000c8  2001              MOVS     r0,#1
0000ca  e000              B        |L49.206|
                  |L49.204|
0000cc  2000              MOVS     r0,#0
                  |L49.206|
0000ce  b950              CBNZ     r0,|L49.230|
0000d0  bf00              NOP      
0000d2  2040              MOVS     r0,#0x40
0000d4  f3808811          MSR      BASEPRI,r0
0000d8  f3bf8f4f          DSB      
0000dc  f3bf8f6f          ISB      
0000e0  bf00              NOP      
0000e2  bf00              NOP      
                  |L49.228|
0000e4  e7fe              B        |L49.228|
                  |L49.230|
;;;4826   
;;;4827   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
0000e6  481a              LDR      r0,|L49.336|
0000e8  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
0000ea  b9a8              CBNZ     r0,|L49.280|
;;;4828   				{
;;;4829   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
0000ec  1d20              ADDS     r0,r4,#4
0000ee  f7fffffe          BL       uxListRemove
;;;4830   					prvAddTaskToReadyList( pxTCB );
0000f2  f894102c          LDRB     r1,[r4,#0x2c]
0000f6  2001              MOVS     r0,#1
0000f8  4088              LSLS     r0,r0,r1
0000fa  4916              LDR      r1,|L49.340|
0000fc  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
0000fe  4308              ORRS     r0,r0,r1
000100  4914              LDR      r1,|L49.340|
000102  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
000104  6ae1              LDR      r1,[r4,#0x2c]
000106  eb010181          ADD      r1,r1,r1,LSL #2
00010a  4a13              LDR      r2,|L49.344|
00010c  eb020081          ADD      r0,r2,r1,LSL #2
000110  1d21              ADDS     r1,r4,#4
000112  f7fffffe          BL       vListInsertEnd
000116  e004              B        |L49.290|
                  |L49.280|
;;;4831   				}
;;;4832   				else
;;;4833   				{
;;;4834   					/* The delayed and ready lists cannot be accessed, so hold
;;;4835   					this task pending until the scheduler is resumed. */
;;;4836   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
000118  f1040118          ADD      r1,r4,#0x18
00011c  480f              LDR      r0,|L49.348|
00011e  f7fffffe          BL       vListInsertEnd
                  |L49.290|
;;;4837   				}
;;;4838   
;;;4839   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
000122  490f              LDR      r1,|L49.352|
000124  6ae0              LDR      r0,[r4,#0x2c]
000126  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000128  6ac9              LDR      r1,[r1,#0x2c]
00012a  4288              CMP      r0,r1
00012c  d908              BLS      |L49.320|
;;;4840   				{
;;;4841   					/* The notified task has a priority above the currently
;;;4842   					executing task so a yield is required. */
;;;4843   					if( pxHigherPriorityTaskWoken != NULL )
00012e  f1bb0f00          CMP      r11,#0
000132  d002              BEQ      |L49.314|
;;;4844   					{
;;;4845   						*pxHigherPriorityTaskWoken = pdTRUE;
000134  2001              MOVS     r0,#1
000136  f8cb0000          STR      r0,[r11,#0]
                  |L49.314|
;;;4846   					}
;;;4847   
;;;4848   					/* Mark that a yield is pending in case the user is not
;;;4849   					using the "xHigherPriorityTaskWoken" parameter to an ISR
;;;4850   					safe FreeRTOS function. */
;;;4851   					xYieldPending = pdTRUE;
00013a  2001              MOVS     r0,#1
00013c  4909              LDR      r1,|L49.356|
00013e  6008              STR      r0,[r1,#0]  ; xYieldPending
                  |L49.320|
;;;4852   				}
;;;4853   				else
;;;4854   				{
;;;4855   					mtCOVERAGE_TEST_MARKER();
;;;4856   				}
;;;4857   			}
;;;4858   		}
;;;4859   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000140  bf00              NOP      
000142  f3858811          MSR      BASEPRI,r5
000146  bf00              NOP      
;;;4860   
;;;4861   		return xReturn;
000148  9800              LDR      r0,[sp,#0]
;;;4862   	}
00014a  e8bd8ff8          POP      {r3-r11,pc}
;;;4863   
                          ENDP

00014e  0000              DCW      0x0000
                  |L49.336|
                          DCD      uxSchedulerSuspended
                  |L49.340|
                          DCD      uxTopReadyPriority
                  |L49.344|
                          DCD      pxReadyTasksLists
                  |L49.348|
                          DCD      xPendingReadyList
                  |L49.352|
                          DCD      pxCurrentTCB
                  |L49.356|
                          DCD      xYieldPending

                          AREA ||i.xTaskGetCurrentTaskHandle||, CODE, READONLY, ALIGN=2

                  xTaskGetCurrentTaskHandle PROC
;;;3817   
;;;3818   	TaskHandle_t xTaskGetCurrentTaskHandle( void )
000000  4901              LDR      r1,|L50.8|
;;;3819   	{
;;;3820   	TaskHandle_t xReturn;
;;;3821   
;;;3822   		/* A critical section is not required as this is not called from
;;;3823   		an interrupt and the current TCB will always be the same for any
;;;3824   		individual execution thread. */
;;;3825   		xReturn = pxCurrentTCB;
000002  6808              LDR      r0,[r1,#0]  ; pxCurrentTCB
;;;3826   
;;;3827   		return xReturn;
;;;3828   	}
000004  4770              BX       lr
;;;3829   
                          ENDP

000006  0000              DCW      0x0000
                  |L50.8|
                          DCD      pxCurrentTCB

                          AREA ||i.xTaskGetSchedulerState||, CODE, READONLY, ALIGN=2

                  xTaskGetSchedulerState PROC
;;;3834   
;;;3835   	BaseType_t xTaskGetSchedulerState( void )
000000  4905              LDR      r1,|L51.24|
;;;3836   	{
;;;3837   	BaseType_t xReturn;
;;;3838   
;;;3839   		if( xSchedulerRunning == pdFALSE )
000002  6809              LDR      r1,[r1,#0]  ; xSchedulerRunning
000004  b909              CBNZ     r1,|L51.10|
;;;3840   		{
;;;3841   			xReturn = taskSCHEDULER_NOT_STARTED;
000006  2001              MOVS     r0,#1
000008  e005              B        |L51.22|
                  |L51.10|
;;;3842   		}
;;;3843   		else
;;;3844   		{
;;;3845   			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
00000a  4904              LDR      r1,|L51.28|
00000c  6809              LDR      r1,[r1,#0]  ; uxSchedulerSuspended
00000e  b909              CBNZ     r1,|L51.20|
;;;3846   			{
;;;3847   				xReturn = taskSCHEDULER_RUNNING;
000010  2002              MOVS     r0,#2
000012  e000              B        |L51.22|
                  |L51.20|
;;;3848   			}
;;;3849   			else
;;;3850   			{
;;;3851   				xReturn = taskSCHEDULER_SUSPENDED;
000014  2000              MOVS     r0,#0
                  |L51.22|
;;;3852   			}
;;;3853   		}
;;;3854   
;;;3855   		return xReturn;
;;;3856   	}
000016  4770              BX       lr
;;;3857   
                          ENDP

                  |L51.24|
                          DCD      xSchedulerRunning
                  |L51.28|
                          DCD      uxSchedulerSuspended

                          AREA ||i.xTaskGetTickCount||, CODE, READONLY, ALIGN=2

                  xTaskGetTickCount PROC
;;;2253   
;;;2254   TickType_t xTaskGetTickCount( void )
000000  4901              LDR      r1,|L52.8|
;;;2255   {
;;;2256   TickType_t xTicks;
;;;2257   
;;;2258   	/* Critical section required if running on a 16 bit processor. */
;;;2259   	portTICK_TYPE_ENTER_CRITICAL();
;;;2260   	{
;;;2261   		xTicks = xTickCount;
000002  6808              LDR      r0,[r1,#0]  ; xTickCount
;;;2262   	}
;;;2263   	portTICK_TYPE_EXIT_CRITICAL();
;;;2264   
;;;2265   	return xTicks;
;;;2266   }
000004  4770              BX       lr
;;;2267   /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L52.8|
                          DCD      xTickCount

                          AREA ||i.xTaskGetTickCountFromISR||, CODE, READONLY, ALIGN=2

                  xTaskGetTickCountFromISR PROC
;;;2268   
;;;2269   TickType_t xTaskGetTickCountFromISR( void )
000000  b570              PUSH     {r4-r6,lr}
;;;2270   {
;;;2271   TickType_t xReturn;
;;;2272   UBaseType_t uxSavedInterruptStatus;
;;;2273   
;;;2274   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;2275   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;2276   	above the maximum system call priority are kept permanently enabled, even
;;;2277   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;2278   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;2279   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;2280   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;2281   	assigned a priority above the configured maximum system call priority.
;;;2282   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;2283   	that have been assigned a priority at or (logically) below the maximum
;;;2284   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;2285   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;2286   	More information (albeit Cortex-M specific) is provided on the following
;;;2287   	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;2288   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000002  f7fffffe          BL       vPortValidateInterruptPriority
;;;2289   
;;;2290   	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
000006  2500              MOVS     r5,#0
;;;2291   	{
;;;2292   		xReturn = xTickCount;
000008  4801              LDR      r0,|L53.16|
00000a  6804              LDR      r4,[r0,#0]  ; xTickCount
;;;2293   	}
;;;2294   	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;2295   
;;;2296   	return xReturn;
00000c  4620              MOV      r0,r4
;;;2297   }
00000e  bd70              POP      {r4-r6,pc}
;;;2298   /*-----------------------------------------------------------*/
                          ENDP

                  |L53.16|
                          DCD      xTickCount

                          AREA ||i.xTaskIncrementTick||, CODE, READONLY, ALIGN=2

                  xTaskIncrementTick PROC
;;;2634   
;;;2635   BaseType_t xTaskIncrementTick( void )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2636   {
;;;2637   TCB_t * pxTCB;
;;;2638   TickType_t xItemValue;
;;;2639   BaseType_t xSwitchRequired = pdFALSE;
000004  f04f0800          MOV      r8,#0
;;;2640   
;;;2641   	/* Called by the portable layer each time a tick interrupt occurs.
;;;2642   	Increments the tick then checks to see if the new tick value will cause any
;;;2643   	tasks to be unblocked. */
;;;2644   	traceTASK_INCREMENT_TICK( xTickCount );
;;;2645   	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000008  4844              LDR      r0,|L54.284|
00000a  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00000c  2800              CMP      r0,#0
00000e  d177              BNE      |L54.256|
;;;2646   	{
;;;2647   		/* Minor optimisation.  The tick count cannot change in this
;;;2648   		block. */
;;;2649   		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
000010  4843              LDR      r0,|L54.288|
000012  6800              LDR      r0,[r0,#0]  ; xTickCount
000014  1c45              ADDS     r5,r0,#1
;;;2650   
;;;2651   		/* Increment the RTOS tick, switching the delayed and overflowed
;;;2652   		delayed lists if it wraps to 0. */
;;;2653   		xTickCount = xConstTickCount;
000016  4842              LDR      r0,|L54.288|
000018  6005              STR      r5,[r0,#0]  ; xTickCount
;;;2654   
;;;2655   		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
00001a  bb15              CBNZ     r5,|L54.98|
;;;2656   		{
;;;2657   			taskSWITCH_DELAYED_LISTS();
00001c  4841              LDR      r0,|L54.292|
00001e  6800              LDR      r0,[r0,#0]  ; pxDelayedTaskList
000020  6800              LDR      r0,[r0,#0]
000022  b908              CBNZ     r0,|L54.40|
000024  2001              MOVS     r0,#1
000026  e000              B        |L54.42|
                  |L54.40|
000028  2000              MOVS     r0,#0
                  |L54.42|
00002a  b950              CBNZ     r0,|L54.66|
00002c  bf00              NOP      
00002e  2040              MOVS     r0,#0x40
000030  f3808811          MSR      BASEPRI,r0
000034  f3bf8f4f          DSB      
000038  f3bf8f6f          ISB      
00003c  bf00              NOP      
00003e  bf00              NOP      
                  |L54.64|
000040  e7fe              B        |L54.64|
                  |L54.66|
000042  4838              LDR      r0,|L54.292|
000044  6807              LDR      r7,[r0,#0]  ; pxDelayedTaskList
000046  4838              LDR      r0,|L54.296|
000048  6800              LDR      r0,[r0,#0]  ; pxOverflowDelayedTaskList
00004a  4936              LDR      r1,|L54.292|
00004c  6008              STR      r0,[r1,#0]  ; pxDelayedTaskList
00004e  4836              LDR      r0,|L54.296|
000050  6007              STR      r7,[r0,#0]  ; pxOverflowDelayedTaskList
000052  4836              LDR      r0,|L54.300|
000054  6800              LDR      r0,[r0,#0]  ; xNumOfOverflows
000056  1c40              ADDS     r0,r0,#1
000058  4934              LDR      r1,|L54.300|
00005a  6008              STR      r0,[r1,#0]  ; xNumOfOverflows
00005c  f7fffffe          BL       prvResetNextTaskUnblockTime
000060  bf00              NOP      
                  |L54.98|
;;;2658   		}
;;;2659   		else
;;;2660   		{
;;;2661   			mtCOVERAGE_TEST_MARKER();
;;;2662   		}
;;;2663   
;;;2664   		/* See if this tick has made a timeout expire.  Tasks are stored in
;;;2665   		the	queue in the order of their wake time - meaning once one task
;;;2666   		has been found whose block time has not expired there is no need to
;;;2667   		look any further down the list. */
;;;2668   		if( xConstTickCount >= xNextTaskUnblockTime )
000062  4833              LDR      r0,|L54.304|
000064  6800              LDR      r0,[r0,#0]  ; xNextTaskUnblockTime
000066  4285              CMP      r5,r0
000068  d33c              BCC      |L54.228|
;;;2669   		{
;;;2670   			for( ;; )
00006a  bf00              NOP      
                  |L54.108|
;;;2671   			{
;;;2672   				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
00006c  482d              LDR      r0,|L54.292|
00006e  6800              LDR      r0,[r0,#0]  ; pxDelayedTaskList
000070  6800              LDR      r0,[r0,#0]
000072  b908              CBNZ     r0,|L54.120|
000074  2001              MOVS     r0,#1
000076  e000              B        |L54.122|
                  |L54.120|
000078  2000              MOVS     r0,#0
                  |L54.122|
00007a  b120              CBZ      r0,|L54.134|
;;;2673   				{
;;;2674   					/* The delayed list is empty.  Set xNextTaskUnblockTime
;;;2675   					to the maximum possible value so it is extremely
;;;2676   					unlikely that the
;;;2677   					if( xTickCount >= xNextTaskUnblockTime ) test will pass
;;;2678   					next time through. */
;;;2679   					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00007c  f04f30ff          MOV      r0,#0xffffffff
000080  492b              LDR      r1,|L54.304|
000082  6008              STR      r0,[r1,#0]  ; xNextTaskUnblockTime
;;;2680   					break;
000084  e02d              B        |L54.226|
                  |L54.134|
;;;2681   				}
;;;2682   				else
;;;2683   				{
;;;2684   					/* The delayed list is not empty, get the value of the
;;;2685   					item at the head of the delayed list.  This is the time
;;;2686   					at which the task at the head of the delayed list must
;;;2687   					be removed from the Blocked state. */
;;;2688   					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
000086  4827              LDR      r0,|L54.292|
000088  6800              LDR      r0,[r0,#0]  ; pxDelayedTaskList
00008a  68c0              LDR      r0,[r0,#0xc]
00008c  68c4              LDR      r4,[r0,#0xc]
;;;2689   					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
00008e  6866              LDR      r6,[r4,#4]
;;;2690   
;;;2691   					if( xConstTickCount < xItemValue )
000090  42b5              CMP      r5,r6
000092  d202              BCS      |L54.154|
;;;2692   					{
;;;2693   						/* It is not time to unblock this item yet, but the
;;;2694   						item value is the time at which the task at the head
;;;2695   						of the blocked list must be removed from the Blocked
;;;2696   						state -	so record the item value in
;;;2697   						xNextTaskUnblockTime. */
;;;2698   						xNextTaskUnblockTime = xItemValue;
000094  4826              LDR      r0,|L54.304|
000096  6006              STR      r6,[r0,#0]  ; xNextTaskUnblockTime
;;;2699   						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
000098  e023              B        |L54.226|
                  |L54.154|
;;;2700   					}
;;;2701   					else
;;;2702   					{
;;;2703   						mtCOVERAGE_TEST_MARKER();
;;;2704   					}
;;;2705   
;;;2706   					/* It is time to remove the item from the Blocked state. */
;;;2707   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
00009a  1d20              ADDS     r0,r4,#4
00009c  f7fffffe          BL       uxListRemove
;;;2708   
;;;2709   					/* Is the task waiting on an event also?  If so remove
;;;2710   					it from the event list. */
;;;2711   					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
0000a0  6aa0              LDR      r0,[r4,#0x28]
0000a2  b118              CBZ      r0,|L54.172|
;;;2712   					{
;;;2713   						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
0000a4  f1040018          ADD      r0,r4,#0x18
0000a8  f7fffffe          BL       uxListRemove
                  |L54.172|
;;;2714   					}
;;;2715   					else
;;;2716   					{
;;;2717   						mtCOVERAGE_TEST_MARKER();
;;;2718   					}
;;;2719   
;;;2720   					/* Place the unblocked task into the appropriate ready
;;;2721   					list. */
;;;2722   					prvAddTaskToReadyList( pxTCB );
0000ac  f894102c          LDRB     r1,[r4,#0x2c]
0000b0  2001              MOVS     r0,#1
0000b2  4088              LSLS     r0,r0,r1
0000b4  491f              LDR      r1,|L54.308|
0000b6  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
0000b8  4308              ORRS     r0,r0,r1
0000ba  491e              LDR      r1,|L54.308|
0000bc  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
0000be  6ae1              LDR      r1,[r4,#0x2c]
0000c0  eb010181          ADD      r1,r1,r1,LSL #2
0000c4  4a1c              LDR      r2,|L54.312|
0000c6  eb020081          ADD      r0,r2,r1,LSL #2
0000ca  1d21              ADDS     r1,r4,#4
0000cc  f7fffffe          BL       vListInsertEnd
;;;2723   
;;;2724   					/* A task being unblocked cannot cause an immediate
;;;2725   					context switch if preemption is turned off. */
;;;2726   					#if (  configUSE_PREEMPTION == 1 )
;;;2727   					{
;;;2728   						/* Preemption is on, but a context switch should
;;;2729   						only be performed if the unblocked task has a
;;;2730   						priority that is equal to or higher than the
;;;2731   						currently executing task. */
;;;2732   						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
0000d0  491a              LDR      r1,|L54.316|
0000d2  6ae0              LDR      r0,[r4,#0x2c]
0000d4  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
0000d6  6ac9              LDR      r1,[r1,#0x2c]
0000d8  4288              CMP      r0,r1
0000da  d3c7              BCC      |L54.108|
;;;2733   						{
;;;2734   							xSwitchRequired = pdTRUE;
0000dc  f04f0801          MOV      r8,#1
0000e0  e7c4              B        |L54.108|
                  |L54.226|
0000e2  bf00              NOP                            ;2680
                  |L54.228|
;;;2735   						}
;;;2736   						else
;;;2737   						{
;;;2738   							mtCOVERAGE_TEST_MARKER();
;;;2739   						}
;;;2740   					}
;;;2741   					#endif /* configUSE_PREEMPTION */
;;;2742   				}
;;;2743   			}
;;;2744   		}
;;;2745   
;;;2746   		/* Tasks of equal priority to the currently running task will share
;;;2747   		processing time (time slice) if preemption is on, and the application
;;;2748   		writer has not explicitly turned time slicing off. */
;;;2749   		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
;;;2750   		{
;;;2751   			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
0000e4  4815              LDR      r0,|L54.316|
0000e6  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
0000e8  6ac0              LDR      r0,[r0,#0x2c]
0000ea  eb000080          ADD      r0,r0,r0,LSL #2
0000ee  4912              LDR      r1,|L54.312|
0000f0  f8510020          LDR      r0,[r1,r0,LSL #2]
0000f4  2801              CMP      r0,#1
0000f6  d901              BLS      |L54.252|
;;;2752   			{
;;;2753   				xSwitchRequired = pdTRUE;
0000f8  f04f0801          MOV      r8,#1
                  |L54.252|
;;;2754   			}
;;;2755   			else
;;;2756   			{
;;;2757   				mtCOVERAGE_TEST_MARKER();
;;;2758   			}
;;;2759   		}
;;;2760   		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
;;;2761   
;;;2762   		#if ( configUSE_TICK_HOOK == 1 )
;;;2763   		{
;;;2764   			/* Guard against the tick hook being called when the pended tick
;;;2765   			count is being unwound (when the scheduler is being unlocked). */
;;;2766   			if( uxPendedTicks == ( UBaseType_t ) 0U )
;;;2767   			{
;;;2768   				vApplicationTickHook();
;;;2769   			}
;;;2770   			else
;;;2771   			{
;;;2772   				mtCOVERAGE_TEST_MARKER();
;;;2773   			}
;;;2774   		}
;;;2775   		#endif /* configUSE_TICK_HOOK */
;;;2776   	}
0000fc  e005              B        |L54.266|
0000fe  e7ff              B        |L54.256|
                  |L54.256|
;;;2777   	else
;;;2778   	{
;;;2779   		++uxPendedTicks;
000100  480f              LDR      r0,|L54.320|
000102  6800              LDR      r0,[r0,#0]  ; uxPendedTicks
000104  1c40              ADDS     r0,r0,#1
000106  490e              LDR      r1,|L54.320|
000108  6008              STR      r0,[r1,#0]  ; uxPendedTicks
                  |L54.266|
;;;2780   
;;;2781   		/* The tick hook gets called at regular intervals, even if the
;;;2782   		scheduler is locked. */
;;;2783   		#if ( configUSE_TICK_HOOK == 1 )
;;;2784   		{
;;;2785   			vApplicationTickHook();
;;;2786   		}
;;;2787   		#endif
;;;2788   	}
;;;2789   
;;;2790   	#if ( configUSE_PREEMPTION == 1 )
;;;2791   	{
;;;2792   		if( xYieldPending != pdFALSE )
00010a  480e              LDR      r0,|L54.324|
00010c  6800              LDR      r0,[r0,#0]  ; xYieldPending
00010e  b108              CBZ      r0,|L54.276|
;;;2793   		{
;;;2794   			xSwitchRequired = pdTRUE;
000110  f04f0801          MOV      r8,#1
                  |L54.276|
;;;2795   		}
;;;2796   		else
;;;2797   		{
;;;2798   			mtCOVERAGE_TEST_MARKER();
;;;2799   		}
;;;2800   	}
;;;2801   	#endif /* configUSE_PREEMPTION */
;;;2802   
;;;2803   	return xSwitchRequired;
000114  4640              MOV      r0,r8
;;;2804   }
000116  e8bd81f0          POP      {r4-r8,pc}
;;;2805   /*-----------------------------------------------------------*/
                          ENDP

00011a  0000              DCW      0x0000
                  |L54.284|
                          DCD      uxSchedulerSuspended
                  |L54.288|
                          DCD      xTickCount
                  |L54.292|
                          DCD      pxDelayedTaskList
                  |L54.296|
                          DCD      pxOverflowDelayedTaskList
                  |L54.300|
                          DCD      xNumOfOverflows
                  |L54.304|
                          DCD      xNextTaskUnblockTime
                  |L54.308|
                          DCD      uxTopReadyPriority
                  |L54.312|
                          DCD      pxReadyTasksLists
                  |L54.316|
                          DCD      pxCurrentTCB
                  |L54.320|
                          DCD      uxPendedTicks
                  |L54.324|
                          DCD      xYieldPending

                          AREA ||i.xTaskNotifyStateClear||, CODE, READONLY, ALIGN=2

                  xTaskNotifyStateClear PROC
;;;4955   
;;;4956   	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
000000  b570              PUSH     {r4-r6,lr}
;;;4957   	{
000002  4605              MOV      r5,r0
;;;4958   	TCB_t *pxTCB;
;;;4959   	BaseType_t xReturn;
;;;4960   
;;;4961   		/* If null is passed in here then it is the calling task that is having
;;;4962   		its notification state cleared. */
;;;4963   		pxTCB = prvGetTCBFromHandle( xTask );
000004  b915              CBNZ     r5,|L55.12|
000006  480a              LDR      r0,|L55.48|
000008  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000a  e000              B        |L55.14|
                  |L55.12|
00000c  4628              MOV      r0,r5
                  |L55.14|
00000e  4606              MOV      r6,r0
;;;4964   
;;;4965   		taskENTER_CRITICAL();
000010  f7fffffe          BL       vPortEnterCritical
;;;4966   		{
;;;4967   			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
000014  f896005c          LDRB     r0,[r6,#0x5c]
000018  2802              CMP      r0,#2
00001a  d104              BNE      |L55.38|
;;;4968   			{
;;;4969   				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
00001c  2000              MOVS     r0,#0
00001e  f886005c          STRB     r0,[r6,#0x5c]
;;;4970   				xReturn = pdPASS;
000022  2401              MOVS     r4,#1
000024  e000              B        |L55.40|
                  |L55.38|
;;;4971   			}
;;;4972   			else
;;;4973   			{
;;;4974   				xReturn = pdFAIL;
000026  2400              MOVS     r4,#0
                  |L55.40|
;;;4975   			}
;;;4976   		}
;;;4977   		taskEXIT_CRITICAL();
000028  f7fffffe          BL       vPortExitCritical
;;;4978   
;;;4979   		return xReturn;
00002c  4620              MOV      r0,r4
;;;4980   	}
00002e  bd70              POP      {r4-r6,pc}
;;;4981   
                          ENDP

                  |L55.48|
                          DCD      pxCurrentTCB

                          AREA ||i.xTaskNotifyWait||, CODE, READONLY, ALIGN=2

                  xTaskNotifyWait PROC
;;;4545   
;;;4546   	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;4547   	{
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;4548   	BaseType_t xReturn;
;;;4549   
;;;4550   		taskENTER_CRITICAL();
00000c  f7fffffe          BL       vPortEnterCritical
;;;4551   		{
;;;4552   			/* Only block if a notification is not already pending. */
;;;4553   			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
000010  4821              LDR      r0,|L56.152|
000012  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000014  f890005c          LDRB     r0,[r0,#0x5c]
000018  2802              CMP      r0,#2
00001a  d018              BEQ      |L56.78|
;;;4554   			{
;;;4555   				/* Clear bits in the task's notification value as bits may get
;;;4556   				set	by the notifying task or interrupt.  This can be used to
;;;4557   				clear the value to zero. */
;;;4558   				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
00001c  491e              LDR      r1,|L56.152|
00001e  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000020  f1010058          ADD      r0,r1,#0x58
000024  6d89              LDR      r1,[r1,#0x58]
000026  43b9              BICS     r1,r1,r7
000028  6001              STR      r1,[r0,#0]
;;;4559   
;;;4560   				/* Mark this task as waiting for a notification. */
;;;4561   				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
00002a  2001              MOVS     r0,#1
00002c  491a              LDR      r1,|L56.152|
00002e  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000030  f881005c          STRB     r0,[r1,#0x5c]
;;;4562   
;;;4563   				if( xTicksToWait > ( TickType_t ) 0 )
000034  b15d              CBZ      r5,|L56.78|
;;;4564   				{
;;;4565   					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
000036  2101              MOVS     r1,#1
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;4566   					traceTASK_NOTIFY_WAIT_BLOCK();
;;;4567   
;;;4568   					/* All ports are written to allow a yield in a critical
;;;4569   					section (some will yield immediately, others wait until the
;;;4570   					critical section exits) - but it is not something that
;;;4571   					application code should ever do. */
;;;4572   					portYIELD_WITHIN_API();
00003e  f04f5080          MOV      r0,#0x10000000
000042  4916              LDR      r1,|L56.156|
000044  6008              STR      r0,[r1,#0]
000046  f3bf8f4f          DSB      
00004a  f3bf8f6f          ISB      
                  |L56.78|
;;;4573   				}
;;;4574   				else
;;;4575   				{
;;;4576   					mtCOVERAGE_TEST_MARKER();
;;;4577   				}
;;;4578   			}
;;;4579   			else
;;;4580   			{
;;;4581   				mtCOVERAGE_TEST_MARKER();
;;;4582   			}
;;;4583   		}
;;;4584   		taskEXIT_CRITICAL();
00004e  f7fffffe          BL       vPortExitCritical
;;;4585   
;;;4586   		taskENTER_CRITICAL();
000052  f7fffffe          BL       vPortEnterCritical
;;;4587   		{
;;;4588   			traceTASK_NOTIFY_WAIT();
;;;4589   
;;;4590   			if( pulNotificationValue != NULL )
000056  b11c              CBZ      r4,|L56.96|
;;;4591   			{
;;;4592   				/* Output the current notification value, which may or may not
;;;4593   				have changed. */
;;;4594   				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
000058  480f              LDR      r0,|L56.152|
00005a  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00005c  6d80              LDR      r0,[r0,#0x58]
00005e  6020              STR      r0,[r4,#0]
                  |L56.96|
;;;4595   			}
;;;4596   
;;;4597   			/* If ucNotifyValue is set then either the task never entered the
;;;4598   			blocked state (because a notification was already pending) or the
;;;4599   			task unblocked because of a notification.  Otherwise the task
;;;4600   			unblocked because of a timeout. */
;;;4601   			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
000060  480d              LDR      r0,|L56.152|
000062  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000064  f890005c          LDRB     r0,[r0,#0x5c]
000068  2802              CMP      r0,#2
00006a  d001              BEQ      |L56.112|
;;;4602   			{
;;;4603   				/* A notification was not received. */
;;;4604   				xReturn = pdFALSE;
00006c  2600              MOVS     r6,#0
00006e  e008              B        |L56.130|
                  |L56.112|
;;;4605   			}
;;;4606   			else
;;;4607   			{
;;;4608   				/* A notification was already pending or a notification was
;;;4609   				received while the task was waiting. */
;;;4610   				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
000070  4909              LDR      r1,|L56.152|
000072  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000074  f1010058          ADD      r0,r1,#0x58
000078  6d89              LDR      r1,[r1,#0x58]
00007a  ea210108          BIC      r1,r1,r8
00007e  6001              STR      r1,[r0,#0]
;;;4611   				xReturn = pdTRUE;
000080  2601              MOVS     r6,#1
                  |L56.130|
;;;4612   			}
;;;4613   
;;;4614   			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
000082  2000              MOVS     r0,#0
000084  4904              LDR      r1,|L56.152|
000086  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000088  f881005c          STRB     r0,[r1,#0x5c]
;;;4615   		}
;;;4616   		taskEXIT_CRITICAL();
00008c  f7fffffe          BL       vPortExitCritical
;;;4617   
;;;4618   		return xReturn;
000090  4630              MOV      r0,r6
;;;4619   	}
000092  e8bd81f0          POP      {r4-r8,pc}
;;;4620   
                          ENDP

000096  0000              DCW      0x0000
                  |L56.152|
                          DCD      pxCurrentTCB
                  |L56.156|
                          DCD      0xe000ed04

                          AREA ||i.xTaskPriorityDisinherit||, CODE, READONLY, ALIGN=2

                  xTaskPriorityDisinherit PROC
;;;3949   
;;;3950   	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
000000  b570              PUSH     {r4-r6,lr}
;;;3951   	{
000002  4605              MOV      r5,r0
;;;3952   	TCB_t * const pxTCB = pxMutexHolder;
000004  462c              MOV      r4,r5
;;;3953   	BaseType_t xReturn = pdFALSE;
000006  2600              MOVS     r6,#0
;;;3954   
;;;3955   		if( pxMutexHolder != NULL )
000008  2d00              CMP      r5,#0
00000a  d055              BEQ      |L57.184|
;;;3956   		{
;;;3957   			/* A task can only have an inherited priority if it holds the mutex.
;;;3958   			If the mutex is held by a task then it cannot be given from an
;;;3959   			interrupt, and if a mutex is given by the holding task then it must
;;;3960   			be the running state task. */
;;;3961   			configASSERT( pxTCB == pxCurrentTCB );
00000c  482b              LDR      r0,|L57.188|
00000e  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000010  4284              CMP      r4,r0
000012  d101              BNE      |L57.24|
000014  2001              MOVS     r0,#1
000016  e000              B        |L57.26|
                  |L57.24|
000018  2000              MOVS     r0,#0
                  |L57.26|
00001a  b950              CBNZ     r0,|L57.50|
00001c  bf00              NOP      
00001e  2040              MOVS     r0,#0x40
000020  f3808811          MSR      BASEPRI,r0
000024  f3bf8f4f          DSB      
000028  f3bf8f6f          ISB      
00002c  bf00              NOP      
00002e  bf00              NOP      
                  |L57.48|
000030  e7fe              B        |L57.48|
                  |L57.50|
;;;3962   			configASSERT( pxTCB->uxMutexesHeld );
000032  6d20              LDR      r0,[r4,#0x50]
000034  b950              CBNZ     r0,|L57.76|
000036  bf00              NOP      
000038  2040              MOVS     r0,#0x40
00003a  f3808811          MSR      BASEPRI,r0
00003e  f3bf8f4f          DSB      
000042  f3bf8f6f          ISB      
000046  bf00              NOP      
000048  bf00              NOP      
                  |L57.74|
00004a  e7fe              B        |L57.74|
                  |L57.76|
;;;3963   			( pxTCB->uxMutexesHeld )--;
00004c  6d20              LDR      r0,[r4,#0x50]
00004e  1e40              SUBS     r0,r0,#1
000050  6520              STR      r0,[r4,#0x50]
;;;3964   
;;;3965   			/* Has the holder of the mutex inherited the priority of another
;;;3966   			task? */
;;;3967   			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
000052  6ce1              LDR      r1,[r4,#0x4c]
000054  6ae0              LDR      r0,[r4,#0x2c]
000056  4288              CMP      r0,r1
000058  d02e              BEQ      |L57.184|
;;;3968   			{
;;;3969   				/* Only disinherit if no other mutexes are held. */
;;;3970   				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
00005a  6d20              LDR      r0,[r4,#0x50]
00005c  bb60              CBNZ     r0,|L57.184|
;;;3971   				{
;;;3972   					/* A task can only have an inherited priority if it holds
;;;3973   					the mutex.  If the mutex is held by a task then it cannot be
;;;3974   					given from an interrupt, and if a mutex is given by the
;;;3975   					holding task then it must be the running state task.  Remove
;;;3976   					the holding task from the ready list. */
;;;3977   					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
00005e  1d20              ADDS     r0,r4,#4
000060  f7fffffe          BL       uxListRemove
000064  b978              CBNZ     r0,|L57.134|
;;;3978   					{
;;;3979   						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
000066  6ae0              LDR      r0,[r4,#0x2c]
000068  eb000080          ADD      r0,r0,r0,LSL #2
00006c  4914              LDR      r1,|L57.192|
00006e  f8510020          LDR      r0,[r1,r0,LSL #2]
000072  b940              CBNZ     r0,|L57.134|
000074  f894102c          LDRB     r1,[r4,#0x2c]
000078  2001              MOVS     r0,#1
00007a  4088              LSLS     r0,r0,r1
00007c  4911              LDR      r1,|L57.196|
00007e  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000080  4381              BICS     r1,r1,r0
000082  4810              LDR      r0,|L57.196|
000084  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L57.134|
;;;3980   					}
;;;3981   					else
;;;3982   					{
;;;3983   						mtCOVERAGE_TEST_MARKER();
;;;3984   					}
;;;3985   
;;;3986   					/* Disinherit the priority before adding the task into the
;;;3987   					new	ready list. */
;;;3988   					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
;;;3989   					pxTCB->uxPriority = pxTCB->uxBasePriority;
000086  6ce0              LDR      r0,[r4,#0x4c]
000088  62e0              STR      r0,[r4,#0x2c]
;;;3990   
;;;3991   					/* Reset the event list item value.  It cannot be in use for
;;;3992   					any other purpose if this task is running, and it must be
;;;3993   					running to give back the mutex. */
;;;3994   					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00008a  6ae0              LDR      r0,[r4,#0x2c]
00008c  f1c00005          RSB      r0,r0,#5
000090  61a0              STR      r0,[r4,#0x18]
;;;3995   					prvAddTaskToReadyList( pxTCB );
000092  f894102c          LDRB     r1,[r4,#0x2c]
000096  2001              MOVS     r0,#1
000098  4088              LSLS     r0,r0,r1
00009a  490a              LDR      r1,|L57.196|
00009c  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
00009e  4308              ORRS     r0,r0,r1
0000a0  4908              LDR      r1,|L57.196|
0000a2  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
0000a4  6ae1              LDR      r1,[r4,#0x2c]
0000a6  eb010181          ADD      r1,r1,r1,LSL #2
0000aa  4a05              LDR      r2,|L57.192|
0000ac  eb020081          ADD      r0,r2,r1,LSL #2
0000b0  1d21              ADDS     r1,r4,#4
0000b2  f7fffffe          BL       vListInsertEnd
;;;3996   
;;;3997   					/* Return true to indicate that a context switch is required.
;;;3998   					This is only actually required in the corner case whereby
;;;3999   					multiple mutexes were held and the mutexes were given back
;;;4000   					in an order different to that in which they were taken.
;;;4001   					If a context switch did not occur when the first mutex was
;;;4002   					returned, even if a task was waiting on it, then a context
;;;4003   					switch should occur when the last mutex is returned whether
;;;4004   					a task is waiting on it or not. */
;;;4005   					xReturn = pdTRUE;
0000b6  2601              MOVS     r6,#1
                  |L57.184|
;;;4006   				}
;;;4007   				else
;;;4008   				{
;;;4009   					mtCOVERAGE_TEST_MARKER();
;;;4010   				}
;;;4011   			}
;;;4012   			else
;;;4013   			{
;;;4014   				mtCOVERAGE_TEST_MARKER();
;;;4015   			}
;;;4016   		}
;;;4017   		else
;;;4018   		{
;;;4019   			mtCOVERAGE_TEST_MARKER();
;;;4020   		}
;;;4021   
;;;4022   		return xReturn;
0000b8  4630              MOV      r0,r6
;;;4023   	}
0000ba  bd70              POP      {r4-r6,pc}
;;;4024   
                          ENDP

                  |L57.188|
                          DCD      pxCurrentTCB
                  |L57.192|
                          DCD      pxReadyTasksLists
                  |L57.196|
                          DCD      uxTopReadyPriority

                          AREA ||i.xTaskPriorityInherit||, CODE, READONLY, ALIGN=2

                  xTaskPriorityInherit PROC
;;;3862   
;;;3863   	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
000000  b570              PUSH     {r4-r6,lr}
;;;3864   	{
000002  4605              MOV      r5,r0
;;;3865   	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
000004  462c              MOV      r4,r5
;;;3866   	BaseType_t xReturn = pdFALSE;
000006  2600              MOVS     r6,#0
;;;3867   
;;;3868   		/* If the mutex was given back by an interrupt while the queue was
;;;3869   		locked then the mutex holder might now be NULL.  _RB_ Is this still
;;;3870   		needed as interrupts can no longer use mutexes? */
;;;3871   		if( pxMutexHolder != NULL )
000008  2d00              CMP      r5,#0
00000a  d054              BEQ      |L58.182|
;;;3872   		{
;;;3873   			/* If the holder of the mutex has a priority below the priority of
;;;3874   			the task attempting to obtain the mutex then it will temporarily
;;;3875   			inherit the priority of the task attempting to obtain the mutex. */
;;;3876   			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
00000c  492b              LDR      r1,|L58.188|
00000e  6ae0              LDR      r0,[r4,#0x2c]
000010  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000012  6ac9              LDR      r1,[r1,#0x2c]
000014  4288              CMP      r0,r1
000016  d247              BCS      |L58.168|
;;;3877   			{
;;;3878   				/* Adjust the mutex holder state to account for its new
;;;3879   				priority.  Only reset the event list item value if the value is
;;;3880   				not being used for anything else. */
;;;3881   				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
000018  69a0              LDR      r0,[r4,#0x18]
00001a  f0004000          AND      r0,r0,#0x80000000
00001e  b928              CBNZ     r0,|L58.44|
;;;3882   				{
;;;3883   					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000020  4826              LDR      r0,|L58.188|
000022  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000024  6ac0              LDR      r0,[r0,#0x2c]
000026  f1c00005          RSB      r0,r0,#5
00002a  61a0              STR      r0,[r4,#0x18]
                  |L58.44|
;;;3884   				}
;;;3885   				else
;;;3886   				{
;;;3887   					mtCOVERAGE_TEST_MARKER();
;;;3888   				}
;;;3889   
;;;3890   				/* If the task being modified is in the ready state it will need
;;;3891   				to be moved into a new list. */
;;;3892   				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
00002c  6ae1              LDR      r1,[r4,#0x2c]
00002e  eb010181          ADD      r1,r1,r1,LSL #2
000032  4a23              LDR      r2,|L58.192|
000034  eb020181          ADD      r1,r2,r1,LSL #2
000038  6960              LDR      r0,[r4,#0x14]
00003a  4288              CMP      r0,r1
00003c  d101              BNE      |L58.66|
00003e  2001              MOVS     r0,#1
000040  e000              B        |L58.68|
                  |L58.66|
000042  2000              MOVS     r0,#0
                  |L58.68|
000044  b350              CBZ      r0,|L58.156|
;;;3893   				{
;;;3894   					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000046  1d20              ADDS     r0,r4,#4
000048  f7fffffe          BL       uxListRemove
00004c  b978              CBNZ     r0,|L58.110|
;;;3895   					{
;;;3896   						taskRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority );
00004e  6ae0              LDR      r0,[r4,#0x2c]
000050  eb000080          ADD      r0,r0,r0,LSL #2
000054  491a              LDR      r1,|L58.192|
000056  f8510020          LDR      r0,[r1,r0,LSL #2]
00005a  b940              CBNZ     r0,|L58.110|
00005c  f894102c          LDRB     r1,[r4,#0x2c]
000060  2001              MOVS     r0,#1
000062  4088              LSLS     r0,r0,r1
000064  4917              LDR      r1,|L58.196|
000066  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000068  4381              BICS     r1,r1,r0
00006a  4816              LDR      r0,|L58.196|
00006c  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L58.110|
;;;3897   					}
;;;3898   					else
;;;3899   					{
;;;3900   						mtCOVERAGE_TEST_MARKER();
;;;3901   					}
;;;3902   
;;;3903   					/* Inherit the priority before being moved into the new list. */
;;;3904   					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
00006e  4813              LDR      r0,|L58.188|
000070  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000072  6ac0              LDR      r0,[r0,#0x2c]
000074  62e0              STR      r0,[r4,#0x2c]
;;;3905   					prvAddTaskToReadyList( pxMutexHolderTCB );
000076  f894102c          LDRB     r1,[r4,#0x2c]
00007a  2001              MOVS     r0,#1
00007c  4088              LSLS     r0,r0,r1
00007e  4911              LDR      r1,|L58.196|
000080  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000082  4308              ORRS     r0,r0,r1
000084  490f              LDR      r1,|L58.196|
000086  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
000088  6ae1              LDR      r1,[r4,#0x2c]
00008a  eb010181          ADD      r1,r1,r1,LSL #2
00008e  4a0c              LDR      r2,|L58.192|
000090  eb020081          ADD      r0,r2,r1,LSL #2
000094  1d21              ADDS     r1,r4,#4
000096  f7fffffe          BL       vListInsertEnd
00009a  e003              B        |L58.164|
                  |L58.156|
;;;3906   				}
;;;3907   				else
;;;3908   				{
;;;3909   					/* Just inherit the priority. */
;;;3910   					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
00009c  4807              LDR      r0,|L58.188|
00009e  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
0000a0  6ac0              LDR      r0,[r0,#0x2c]
0000a2  62e0              STR      r0,[r4,#0x2c]
                  |L58.164|
;;;3911   				}
;;;3912   
;;;3913   				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );
;;;3914   
;;;3915   				/* Inheritance occurred. */
;;;3916   				xReturn = pdTRUE;
0000a4  2601              MOVS     r6,#1
0000a6  e006              B        |L58.182|
                  |L58.168|
;;;3917   			}
;;;3918   			else
;;;3919   			{
;;;3920   				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
0000a8  4904              LDR      r1,|L58.188|
0000aa  6ce0              LDR      r0,[r4,#0x4c]
0000ac  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
0000ae  6ac9              LDR      r1,[r1,#0x2c]
0000b0  4288              CMP      r0,r1
0000b2  d200              BCS      |L58.182|
;;;3921   				{
;;;3922   					/* The base priority of the mutex holder is lower than the
;;;3923   					priority of the task attempting to take the mutex, but the
;;;3924   					current priority of the mutex holder is not lower than the
;;;3925   					priority of the task attempting to take the mutex.
;;;3926   					Therefore the mutex holder must have already inherited a
;;;3927   					priority, but inheritance would have occurred if that had
;;;3928   					not been the case. */
;;;3929   					xReturn = pdTRUE;
0000b4  2601              MOVS     r6,#1
                  |L58.182|
;;;3930   				}
;;;3931   				else
;;;3932   				{
;;;3933   					mtCOVERAGE_TEST_MARKER();
;;;3934   				}
;;;3935   			}
;;;3936   		}
;;;3937   		else
;;;3938   		{
;;;3939   			mtCOVERAGE_TEST_MARKER();
;;;3940   		}
;;;3941   
;;;3942   		return xReturn;
0000b6  4630              MOV      r0,r6
;;;3943   	}
0000b8  bd70              POP      {r4-r6,pc}
;;;3944   
                          ENDP

0000ba  0000              DCW      0x0000
                  |L58.188|
                          DCD      pxCurrentTCB
                  |L58.192|
                          DCD      pxReadyTasksLists
                  |L58.196|
                          DCD      uxTopReadyPriority

                          AREA ||i.xTaskRemoveFromEventList||, CODE, READONLY, ALIGN=2

                  xTaskRemoveFromEventList PROC
;;;3045   
;;;3046   BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
000000  b570              PUSH     {r4-r6,lr}
;;;3047   {
000002  4606              MOV      r6,r0
;;;3048   TCB_t *pxUnblockedTCB;
;;;3049   BaseType_t xReturn;
;;;3050   
;;;3051   	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
;;;3052   	called from a critical section within an ISR. */
;;;3053   
;;;3054   	/* The event list is sorted in priority order, so the first in the list can
;;;3055   	be removed as it is known to be the highest priority.  Remove the TCB from
;;;3056   	the delayed list, and add it to the ready list.
;;;3057   
;;;3058   	If an event is for a queue that is locked then this function will never
;;;3059   	get called - the lock count on the queue will get modified instead.  This
;;;3060   	means exclusive access to the event list is guaranteed here.
;;;3061   
;;;3062   	This function assumes that a check has already been made to ensure that
;;;3063   	pxEventList is not empty. */
;;;3064   	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
000004  68f0              LDR      r0,[r6,#0xc]
000006  68c4              LDR      r4,[r0,#0xc]
;;;3065   	configASSERT( pxUnblockedTCB );
000008  b954              CBNZ     r4,|L59.32|
00000a  bf00              NOP      
00000c  2040              MOVS     r0,#0x40
00000e  f3808811          MSR      BASEPRI,r0
000012  f3bf8f4f          DSB      
000016  f3bf8f6f          ISB      
00001a  bf00              NOP      
00001c  bf00              NOP      
                  |L59.30|
00001e  e7fe              B        |L59.30|
                  |L59.32|
;;;3066   	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
000020  f1040018          ADD      r0,r4,#0x18
000024  f7fffffe          BL       uxListRemove
;;;3067   
;;;3068   	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000028  4815              LDR      r0,|L59.128|
00002a  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00002c  b9a8              CBNZ     r0,|L59.90|
;;;3069   	{
;;;3070   		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
00002e  1d20              ADDS     r0,r4,#4
000030  f7fffffe          BL       uxListRemove
;;;3071   		prvAddTaskToReadyList( pxUnblockedTCB );
000034  f894102c          LDRB     r1,[r4,#0x2c]
000038  2001              MOVS     r0,#1
00003a  4088              LSLS     r0,r0,r1
00003c  4911              LDR      r1,|L59.132|
00003e  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000040  4308              ORRS     r0,r0,r1
000042  4910              LDR      r1,|L59.132|
000044  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
000046  6ae1              LDR      r1,[r4,#0x2c]
000048  eb010181          ADD      r1,r1,r1,LSL #2
00004c  4a0e              LDR      r2,|L59.136|
00004e  eb020081          ADD      r0,r2,r1,LSL #2
000052  1d21              ADDS     r1,r4,#4
000054  f7fffffe          BL       vListInsertEnd
000058  e004              B        |L59.100|
                  |L59.90|
;;;3072   	}
;;;3073   	else
;;;3074   	{
;;;3075   		/* The delayed and ready lists cannot be accessed, so hold this task
;;;3076   		pending until the scheduler is resumed. */
;;;3077   		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
00005a  f1040118          ADD      r1,r4,#0x18
00005e  480b              LDR      r0,|L59.140|
000060  f7fffffe          BL       vListInsertEnd
                  |L59.100|
;;;3078   	}
;;;3079   
;;;3080   	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
000064  490a              LDR      r1,|L59.144|
000066  6ae0              LDR      r0,[r4,#0x2c]
000068  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00006a  6ac9              LDR      r1,[r1,#0x2c]
00006c  4288              CMP      r0,r1
00006e  d904              BLS      |L59.122|
;;;3081   	{
;;;3082   		/* Return true if the task removed from the event list has a higher
;;;3083   		priority than the calling task.  This allows the calling task to know if
;;;3084   		it should force a context switch now. */
;;;3085   		xReturn = pdTRUE;
000070  2501              MOVS     r5,#1
;;;3086   
;;;3087   		/* Mark that a yield is pending in case the user is not using the
;;;3088   		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
;;;3089   		xYieldPending = pdTRUE;
000072  2001              MOVS     r0,#1
000074  4907              LDR      r1,|L59.148|
000076  6008              STR      r0,[r1,#0]  ; xYieldPending
000078  e000              B        |L59.124|
                  |L59.122|
;;;3090   	}
;;;3091   	else
;;;3092   	{
;;;3093   		xReturn = pdFALSE;
00007a  2500              MOVS     r5,#0
                  |L59.124|
;;;3094   	}
;;;3095   
;;;3096   	#if( configUSE_TICKLESS_IDLE != 0 )
;;;3097   	{
;;;3098   		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
;;;3099   		might be set to the blocked task's time out time.  If the task is
;;;3100   		unblocked for a reason other than a timeout xNextTaskUnblockTime is
;;;3101   		normally left unchanged, because it is automatically reset to a new
;;;3102   		value when the tick count equals xNextTaskUnblockTime.  However if
;;;3103   		tickless idling is used it might be more important to enter sleep mode
;;;3104   		at the earliest possible time - so reset xNextTaskUnblockTime here to
;;;3105   		ensure it is updated at the earliest possible time. */
;;;3106   		prvResetNextTaskUnblockTime();
;;;3107   	}
;;;3108   	#endif
;;;3109   
;;;3110   	return xReturn;
00007c  4628              MOV      r0,r5
;;;3111   }
00007e  bd70              POP      {r4-r6,pc}
;;;3112   /*-----------------------------------------------------------*/
                          ENDP

                  |L59.128|
                          DCD      uxSchedulerSuspended
                  |L59.132|
                          DCD      uxTopReadyPriority
                  |L59.136|
                          DCD      pxReadyTasksLists
                  |L59.140|
                          DCD      xPendingReadyList
                  |L59.144|
                          DCD      pxCurrentTCB
                  |L59.148|
                          DCD      xYieldPending

                          AREA ||i.xTaskResumeAll||, CODE, READONLY, ALIGN=2

                  xTaskResumeAll PROC
;;;2143   
;;;2144   BaseType_t xTaskResumeAll( void )
000000  b570              PUSH     {r4-r6,lr}
;;;2145   {
;;;2146   TCB_t *pxTCB = NULL;
000002  2400              MOVS     r4,#0
;;;2147   BaseType_t xAlreadyYielded = pdFALSE;
000004  2600              MOVS     r6,#0
;;;2148   
;;;2149   	/* If uxSchedulerSuspended is zero then this function does not match a
;;;2150   	previous call to vTaskSuspendAll(). */
;;;2151   	configASSERT( uxSchedulerSuspended );
000006  4836              LDR      r0,|L60.224|
000008  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00000a  b950              CBNZ     r0,|L60.34|
00000c  bf00              NOP      
00000e  2040              MOVS     r0,#0x40
000010  f3808811          MSR      BASEPRI,r0
000014  f3bf8f4f          DSB      
000018  f3bf8f6f          ISB      
00001c  bf00              NOP      
00001e  bf00              NOP      
                  |L60.32|
000020  e7fe              B        |L60.32|
                  |L60.34|
;;;2152   
;;;2153   	/* It is possible that an ISR caused a task to be removed from an event
;;;2154   	list while the scheduler was suspended.  If this was the case then the
;;;2155   	removed task will have been added to the xPendingReadyList.  Once the
;;;2156   	scheduler has been resumed it is safe to move all the pending ready
;;;2157   	tasks from this list into their appropriate ready list. */
;;;2158   	taskENTER_CRITICAL();
000022  f7fffffe          BL       vPortEnterCritical
;;;2159   	{
;;;2160   		--uxSchedulerSuspended;
000026  482e              LDR      r0,|L60.224|
000028  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00002a  1e40              SUBS     r0,r0,#1
00002c  492c              LDR      r1,|L60.224|
00002e  6008              STR      r0,[r1,#0]  ; uxSchedulerSuspended
;;;2161   
;;;2162   		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000030  4608              MOV      r0,r1
000032  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000034  2800              CMP      r0,#0
000036  d14f              BNE      |L60.216|
;;;2163   		{
;;;2164   			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
000038  482a              LDR      r0,|L60.228|
00003a  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
00003c  2800              CMP      r0,#0
00003e  d04b              BEQ      |L60.216|
;;;2165   			{
;;;2166   				/* Move any readied tasks from the pending list into the
;;;2167   				appropriate ready list. */
;;;2168   				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
000040  e024              B        |L60.140|
                  |L60.66|
;;;2169   				{
;;;2170   					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
000042  4829              LDR      r0,|L60.232|
000044  68c0              LDR      r0,[r0,#0xc]
000046  68c4              LDR      r4,[r0,#0xc]
;;;2171   					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
000048  f1040018          ADD      r0,r4,#0x18
00004c  f7fffffe          BL       uxListRemove
;;;2172   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
000050  1d20              ADDS     r0,r4,#4
000052  f7fffffe          BL       uxListRemove
;;;2173   					prvAddTaskToReadyList( pxTCB );
000056  f894102c          LDRB     r1,[r4,#0x2c]
00005a  2001              MOVS     r0,#1
00005c  4088              LSLS     r0,r0,r1
00005e  4923              LDR      r1,|L60.236|
000060  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000062  4308              ORRS     r0,r0,r1
000064  4921              LDR      r1,|L60.236|
000066  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
000068  6ae1              LDR      r1,[r4,#0x2c]
00006a  eb010181          ADD      r1,r1,r1,LSL #2
00006e  4a20              LDR      r2,|L60.240|
000070  eb020081          ADD      r0,r2,r1,LSL #2
000074  1d21              ADDS     r1,r4,#4
000076  f7fffffe          BL       vListInsertEnd
;;;2174   
;;;2175   					/* If the moved task has a priority higher than the current
;;;2176   					task then a yield must be performed. */
;;;2177   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
00007a  491e              LDR      r1,|L60.244|
00007c  6ae0              LDR      r0,[r4,#0x2c]
00007e  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000080  6ac9              LDR      r1,[r1,#0x2c]
000082  4288              CMP      r0,r1
000084  d302              BCC      |L60.140|
;;;2178   					{
;;;2179   						xYieldPending = pdTRUE;
000086  2001              MOVS     r0,#1
000088  491b              LDR      r1,|L60.248|
00008a  6008              STR      r0,[r1,#0]  ; xYieldPending
                  |L60.140|
00008c  4816              LDR      r0,|L60.232|
00008e  6800              LDR      r0,[r0,#0]            ;2168  ; xPendingReadyList
000090  b908              CBNZ     r0,|L60.150|
000092  2001              MOVS     r0,#1                 ;2168
000094  e000              B        |L60.152|
                  |L60.150|
000096  2000              MOVS     r0,#0                 ;2168
                  |L60.152|
000098  2800              CMP      r0,#0                 ;2168
00009a  d0d2              BEQ      |L60.66|
;;;2180   					}
;;;2181   					else
;;;2182   					{
;;;2183   						mtCOVERAGE_TEST_MARKER();
;;;2184   					}
;;;2185   				}
;;;2186   
;;;2187   				if( pxTCB != NULL )
00009c  b10c              CBZ      r4,|L60.162|
;;;2188   				{
;;;2189   					/* A task was unblocked while the scheduler was suspended,
;;;2190   					which may have prevented the next unblock time from being
;;;2191   					re-calculated, in which case re-calculate it now.  Mainly
;;;2192   					important for low power tickless implementations, where
;;;2193   					this can prevent an unnecessary exit from low power
;;;2194   					state. */
;;;2195   					prvResetNextTaskUnblockTime();
00009e  f7fffffe          BL       prvResetNextTaskUnblockTime
                  |L60.162|
;;;2196   				}
;;;2197   
;;;2198   				/* If any ticks occurred while the scheduler was suspended then
;;;2199   				they should be processed now.  This ensures the tick count does
;;;2200   				not	slip, and that any delayed tasks are resumed at the correct
;;;2201   				time. */
;;;2202   				{
;;;2203   					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
0000a2  4816              LDR      r0,|L60.252|
0000a4  6805              LDR      r5,[r0,#0]  ; uxPendedTicks
;;;2204   
;;;2205   					if( uxPendedCounts > ( UBaseType_t ) 0U )
0000a6  b165              CBZ      r5,|L60.194|
;;;2206   					{
;;;2207   						do
0000a8  bf00              NOP      
                  |L60.170|
;;;2208   						{
;;;2209   							if( xTaskIncrementTick() != pdFALSE )
0000aa  f7fffffe          BL       xTaskIncrementTick
0000ae  b110              CBZ      r0,|L60.182|
;;;2210   							{
;;;2211   								xYieldPending = pdTRUE;
0000b0  2001              MOVS     r0,#1
0000b2  4911              LDR      r1,|L60.248|
0000b4  6008              STR      r0,[r1,#0]  ; xYieldPending
                  |L60.182|
;;;2212   							}
;;;2213   							else
;;;2214   							{
;;;2215   								mtCOVERAGE_TEST_MARKER();
;;;2216   							}
;;;2217   							--uxPendedCounts;
0000b6  1e6d              SUBS     r5,r5,#1
;;;2218   						} while( uxPendedCounts > ( UBaseType_t ) 0U );
0000b8  2d00              CMP      r5,#0
0000ba  d1f6              BNE      |L60.170|
;;;2219   
;;;2220   						uxPendedTicks = 0;
0000bc  2000              MOVS     r0,#0
0000be  490f              LDR      r1,|L60.252|
0000c0  6008              STR      r0,[r1,#0]  ; uxPendedTicks
                  |L60.194|
;;;2221   					}
;;;2222   					else
;;;2223   					{
;;;2224   						mtCOVERAGE_TEST_MARKER();
;;;2225   					}
;;;2226   				}
;;;2227   
;;;2228   				if( xYieldPending != pdFALSE )
0000c2  480d              LDR      r0,|L60.248|
0000c4  6800              LDR      r0,[r0,#0]  ; xYieldPending
0000c6  b138              CBZ      r0,|L60.216|
;;;2229   				{
;;;2230   					#if( configUSE_PREEMPTION != 0 )
;;;2231   					{
;;;2232   						xAlreadyYielded = pdTRUE;
0000c8  2601              MOVS     r6,#1
;;;2233   					}
;;;2234   					#endif
;;;2235   					taskYIELD_IF_USING_PREEMPTION();
0000ca  0730              LSLS     r0,r6,#28
0000cc  490c              LDR      r1,|L60.256|
0000ce  6008              STR      r0,[r1,#0]
0000d0  f3bf8f4f          DSB      
0000d4  f3bf8f6f          ISB      
                  |L60.216|
;;;2236   				}
;;;2237   				else
;;;2238   				{
;;;2239   					mtCOVERAGE_TEST_MARKER();
;;;2240   				}
;;;2241   			}
;;;2242   		}
;;;2243   		else
;;;2244   		{
;;;2245   			mtCOVERAGE_TEST_MARKER();
;;;2246   		}
;;;2247   	}
;;;2248   	taskEXIT_CRITICAL();
0000d8  f7fffffe          BL       vPortExitCritical
;;;2249   
;;;2250   	return xAlreadyYielded;
0000dc  4630              MOV      r0,r6
;;;2251   }
0000de  bd70              POP      {r4-r6,pc}
;;;2252   /*-----------------------------------------------------------*/
                          ENDP

                  |L60.224|
                          DCD      uxSchedulerSuspended
                  |L60.228|
                          DCD      uxCurrentNumberOfTasks
                  |L60.232|
                          DCD      xPendingReadyList
                  |L60.236|
                          DCD      uxTopReadyPriority
                  |L60.240|
                          DCD      pxReadyTasksLists
                  |L60.244|
                          DCD      pxCurrentTCB
                  |L60.248|
                          DCD      xYieldPending
                  |L60.252|
                          DCD      uxPendedTicks
                  |L60.256|
                          DCD      0xe000ed04

                          AREA ||i.xTaskResumeFromISR||, CODE, READONLY, ALIGN=2

                  xTaskResumeFromISR PROC
;;;1867   
;;;1868   	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1869   	{
000004  4606              MOV      r6,r0
;;;1870   	BaseType_t xYieldRequired = pdFALSE;
000006  2700              MOVS     r7,#0
;;;1871   	TCB_t * const pxTCB = xTaskToResume;
000008  4634              MOV      r4,r6
;;;1872   	UBaseType_t uxSavedInterruptStatus;
;;;1873   
;;;1874   		configASSERT( xTaskToResume );
00000a  b956              CBNZ     r6,|L61.34|
00000c  bf00              NOP      
00000e  2040              MOVS     r0,#0x40
000010  f3808811          MSR      BASEPRI,r0
000014  f3bf8f4f          DSB      
000018  f3bf8f6f          ISB      
00001c  bf00              NOP      
00001e  bf00              NOP      
                  |L61.32|
000020  e7fe              B        |L61.32|
                  |L61.34|
;;;1875   
;;;1876   		/* RTOS ports that support interrupt nesting have the concept of a
;;;1877   		maximum	system call (or maximum API call) interrupt priority.
;;;1878   		Interrupts that are	above the maximum system call priority are keep
;;;1879   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;1880   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;1881   		is defined in FreeRTOSConfig.h then
;;;1882   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1883   		failure if a FreeRTOS API function is called from an interrupt that has
;;;1884   		been assigned a priority above the configured maximum system call
;;;1885   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;1886   		from interrupts	that have been assigned a priority at or (logically)
;;;1887   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;1888   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;1889   		simple as possible.  More information (albeit Cortex-M specific) is
;;;1890   		provided on the following link:
;;;1891   		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1892   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000022  f7fffffe          BL       vPortValidateInterruptPriority
;;;1893   
;;;1894   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000026  bf00              NOP      
000028  2140              MOVS     r1,#0x40
00002a  f3ef8011          MRS      r0,BASEPRI
00002e  f3818811          MSR      BASEPRI,r1
000032  f3bf8f4f          DSB      
000036  f3bf8f6f          ISB      
00003a  bf00              NOP      
00003c  4605              MOV      r5,r0
;;;1895   		{
;;;1896   			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       prvTaskIsTaskSuspended
000044  b320              CBZ      r0,|L61.144|
;;;1897   			{
;;;1898   				traceTASK_RESUME_FROM_ISR( pxTCB );
;;;1899   
;;;1900   				/* Check the ready lists can be accessed. */
;;;1901   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000046  4816              LDR      r0,|L61.160|
000048  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00004a  b9e0              CBNZ     r0,|L61.134|
;;;1902   				{
;;;1903   					/* Ready lists can be accessed so move the task from the
;;;1904   					suspended list to the ready list directly. */
;;;1905   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
00004c  4915              LDR      r1,|L61.164|
00004e  6ae0              LDR      r0,[r4,#0x2c]
000050  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000052  6ac9              LDR      r1,[r1,#0x2c]
000054  4288              CMP      r0,r1
000056  d300              BCC      |L61.90|
;;;1906   					{
;;;1907   						xYieldRequired = pdTRUE;
000058  2701              MOVS     r7,#1
                  |L61.90|
;;;1908   					}
;;;1909   					else
;;;1910   					{
;;;1911   						mtCOVERAGE_TEST_MARKER();
;;;1912   					}
;;;1913   
;;;1914   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
00005a  1d20              ADDS     r0,r4,#4
00005c  f7fffffe          BL       uxListRemove
;;;1915   					prvAddTaskToReadyList( pxTCB );
000060  f894102c          LDRB     r1,[r4,#0x2c]
000064  2001              MOVS     r0,#1
000066  4088              LSLS     r0,r0,r1
000068  490f              LDR      r1,|L61.168|
00006a  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
00006c  4308              ORRS     r0,r0,r1
00006e  490e              LDR      r1,|L61.168|
000070  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
000072  6ae1              LDR      r1,[r4,#0x2c]
000074  eb010181          ADD      r1,r1,r1,LSL #2
000078  4a0c              LDR      r2,|L61.172|
00007a  eb020081          ADD      r0,r2,r1,LSL #2
00007e  1d21              ADDS     r1,r4,#4
000080  f7fffffe          BL       vListInsertEnd
000084  e004              B        |L61.144|
                  |L61.134|
;;;1916   				}
;;;1917   				else
;;;1918   				{
;;;1919   					/* The delayed or ready lists cannot be accessed so the task
;;;1920   					is held in the pending ready list until the scheduler is
;;;1921   					unsuspended. */
;;;1922   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
000086  f1040118          ADD      r1,r4,#0x18
00008a  4809              LDR      r0,|L61.176|
00008c  f7fffffe          BL       vListInsertEnd
                  |L61.144|
;;;1923   				}
;;;1924   			}
;;;1925   			else
;;;1926   			{
;;;1927   				mtCOVERAGE_TEST_MARKER();
;;;1928   			}
;;;1929   		}
;;;1930   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000090  bf00              NOP      
000092  f3858811          MSR      BASEPRI,r5
000096  bf00              NOP      
;;;1931   
;;;1932   		return xYieldRequired;
000098  4638              MOV      r0,r7
;;;1933   	}
00009a  e8bd81f0          POP      {r4-r8,pc}
;;;1934   
                          ENDP

00009e  0000              DCW      0x0000
                  |L61.160|
                          DCD      uxSchedulerSuspended
                  |L61.164|
                          DCD      pxCurrentTCB
                  |L61.168|
                          DCD      uxTopReadyPriority
                  |L61.172|
                          DCD      pxReadyTasksLists
                  |L61.176|
                          DCD      xPendingReadyList

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  pxReadyTasksLists
                          %        100
                  xDelayedTaskList1
                          %        20
                  xDelayedTaskList2
                          %        20
                  xPendingReadyList
                          %        20
                  xTasksWaitingTermination
                          %        20
                  xSuspendedTaskList
                          %        20

                          AREA ||.data||, DATA, ALIGN=3

                  FreeRTOSRunTimeTicks
                          %        8
                  pxCurrentTCB
                          DCD      0x00000000
                  pxDelayedTaskList
                          DCD      0x00000000
                  pxOverflowDelayedTaskList
                          DCD      0x00000000
                  uxDeletedTasksWaitingCleanUp
                          DCD      0x00000000
                  uxCurrentNumberOfTasks
                          DCD      0x00000000
                  xTickCount
                          DCD      0x00000000
                  uxTopReadyPriority
                          DCD      0x00000000
                  xSchedulerRunning
                          DCD      0x00000000
                  uxPendedTicks
                          DCD      0x00000000
                  xYieldPending
                          DCD      0x00000000
                  xNumOfOverflows
                          DCD      0x00000000
                  uxTaskNumber
                          DCD      0x00000000
                  xNextTaskUnblockTime
                          DCD      0x00000000
                  xIdleTaskHandle
                          DCD      0x00000000
                  uxSchedulerSuspended
                          DCD      0x00000000
                  ulTaskSwitchedInTime
                          DCD      0x00000000
                  ulTotalRunTime
                          DCD      0x00000000
