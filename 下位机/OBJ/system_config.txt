; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\system_config.o --asm_dir=.\OBJ\ --list_dir=.\OBJ\ --depend=.\obj\system_config.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I.\CORE -I.\USER -I.\HALLIB\STM32F4xx_HAL_Driver\Inc -I.\SYSTEM -I.\Hardware -I.\App -I.\DSP_LIB\Include -I.\FreeRTOS -I.\MPU9250\DMP -I.\MPU9250 -I.\RTE\_Project -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=526 -DSTM32F427xx -DSTM32F4 -DUSE_HAL_DRIVER -DSTM32F427xx -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=.\obj\system_config.crf SYSTEM\System_Config.c]
                          THUMB

                          AREA ||i.ConfigureTimeForRunTimeStats||, CODE, READONLY, ALIGN=2

                  ConfigureTimeForRunTimeStats PROC
;;;10     }
;;;11     void ConfigureTimeForRunTimeStats(void)
000000  b508              PUSH     {r3,lr}
;;;12     {
;;;13     	__HAL_RCC_TIM7_CLK_ENABLE(); 
000002  bf00              NOP      
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
000008  4814              LDR      r0,|L1.92|
00000a  6800              LDR      r0,[r0,#0]
00000c  f0400020          ORR      r0,r0,#0x20
000010  4912              LDR      r1,|L1.92|
000012  6008              STR      r0,[r1,#0]
000014  4608              MOV      r0,r1
000016  6800              LDR      r0,[r0,#0]
000018  f0000020          AND      r0,r0,#0x20
00001c  9000              STR      r0,[sp,#0]
00001e  bf00              NOP      
000020  bf00              NOP      
;;;14      	TIM7->ARR=19;  	//设定计数器自动重装值 
000022  2013              MOVS     r0,#0x13
000024  490e              LDR      r1,|L1.96|
000026  6008              STR      r0,[r1,#0]
;;;15     	TIM7->PSC=89;  	//预分频器	  
000028  2059              MOVS     r0,#0x59
00002a  1f09              SUBS     r1,r1,#4
00002c  6008              STR      r0,[r1,#0]
;;;16     	TIM7->DIER|=1<<0;   //允许更新中断	  
00002e  480c              LDR      r0,|L1.96|
000030  3820              SUBS     r0,r0,#0x20
000032  6800              LDR      r0,[r0,#0]
000034  f0400001          ORR      r0,r0,#1
000038  4909              LDR      r1,|L1.96|
00003a  3920              SUBS     r1,r1,#0x20
00003c  6008              STR      r0,[r1,#0]
;;;17     	TIM7->CR1|=0x01;    //使能定时器7
00003e  4808              LDR      r0,|L1.96|
000040  382c              SUBS     r0,r0,#0x2c
000042  6800              LDR      r0,[r0,#0]
000044  f0400001          ORR      r0,r0,#1
000048  4905              LDR      r1,|L1.96|
00004a  392c              SUBS     r1,r1,#0x2c
00004c  6008              STR      r0,[r1,#0]
;;;18       MY_NVIC_Init(3,0,TIM7_IRQn,4);	//抢占14，子优先级0，组4			
00004e  2304              MOVS     r3,#4
000050  2237              MOVS     r2,#0x37
000052  2100              MOVS     r1,#0
000054  2003              MOVS     r0,#3
000056  f7fffffe          BL       MY_NVIC_Init
;;;19     }
00005a  bd08              POP      {r3,pc}
;;;20     //设置向量表偏移地址
                          ENDP

                  |L1.92|
                          DCD      0x40023840
                  |L1.96|
                          DCD      0x4000142c

                          AREA ||i.DMA1_Init||, CODE, READONLY, ALIGN=2

                  DMA1_Init PROC
;;;135    }
;;;136    void DMA1_Init(void) 
000000  b508              PUSH     {r3,lr}
;;;137    {
;;;138      __HAL_RCC_DMA1_CLK_ENABLE();
000002  bf00              NOP      
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
000008  480a              LDR      r0,|L2.52|
00000a  6800              LDR      r0,[r0,#0]
00000c  f4401000          ORR      r0,r0,#0x200000
000010  4908              LDR      r1,|L2.52|
000012  6008              STR      r0,[r1,#0]
000014  4608              MOV      r0,r1
000016  6800              LDR      r0,[r0,#0]
000018  f4001000          AND      r0,r0,#0x200000
00001c  9000              STR      r0,[sp,#0]
00001e  bf00              NOP      
000020  bf00              NOP      
;;;139      HAL_NVIC_SetPriority(DMA1_Stream5_IRQn, 0, 0);
000022  2200              MOVS     r2,#0
000024  4611              MOV      r1,r2
000026  2010              MOVS     r0,#0x10
000028  f7fffffe          BL       HAL_NVIC_SetPriority
;;;140      HAL_NVIC_EnableIRQ(DMA1_Stream5_IRQn);
00002c  2010              MOVS     r0,#0x10
00002e  f7fffffe          BL       HAL_NVIC_EnableIRQ
;;;141    }
000032  bd08              POP      {r3,pc}
;;;142    void DMA2_Init(void) 
                          ENDP

                  |L2.52|
                          DCD      0x40023830

                          AREA ||i.DMA2_Init||, CODE, READONLY, ALIGN=2

                  DMA2_Init PROC
;;;141    }
;;;142    void DMA2_Init(void) 
000000  b508              PUSH     {r3,lr}
;;;143    {
;;;144      __HAL_RCC_DMA2_CLK_ENABLE();
000002  bf00              NOP      
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
000008  480a              LDR      r0,|L3.52|
00000a  6800              LDR      r0,[r0,#0]
00000c  f4400080          ORR      r0,r0,#0x400000
000010  4908              LDR      r1,|L3.52|
000012  6008              STR      r0,[r1,#0]
000014  4608              MOV      r0,r1
000016  6800              LDR      r0,[r0,#0]
000018  f4000080          AND      r0,r0,#0x400000
00001c  9000              STR      r0,[sp,#0]
00001e  bf00              NOP      
000020  bf00              NOP      
;;;145      HAL_NVIC_SetPriority(DMA2_Stream2_IRQn, 0, 0);
000022  2200              MOVS     r2,#0
000024  4611              MOV      r1,r2
000026  203a              MOVS     r0,#0x3a
000028  f7fffffe          BL       HAL_NVIC_SetPriority
;;;146      HAL_NVIC_EnableIRQ(DMA2_Stream2_IRQn);
00002c  203a              MOVS     r0,#0x3a
00002e  f7fffffe          BL       HAL_NVIC_EnableIRQ
;;;147    }
000032  bd08              POP      {r3,pc}
;;;148    void Delayus(u32 nTimer)
                          ENDP

                  |L3.52|
                          DCD      0x40023830

                          AREA ||i.Delayms||, CODE, READONLY, ALIGN=1

                  Delayms PROC
;;;167    }
;;;168    void Delayms(u32 nTimer)
000000  b510              PUSH     {r4,lr}
;;;169    {	
000002  4603              MOV      r3,r0
;;;170    	u32 i=1000*nTimer;
000004  f44f707a          MOV      r0,#0x3e8
000008  fb03f400          MUL      r4,r3,r0
;;;171    	Delayus(i);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       Delayus
;;;172    }
000012  bd10              POP      {r4,pc}
;;;173    //(180,6,2,4)
                          ENDP


                          AREA ||i.Delayus||, CODE, READONLY, ALIGN=1

                  Delayus PROC
;;;147    }
;;;148    void Delayus(u32 nTimer)
000000  2100              MOVS     r1,#0
;;;149    {
;;;150    	u32 i=0;
;;;151    	for(i=0;i<nTimer;i++)
000002  bf00              NOP      
000004  e0bc              B        |L5.384|
                  |L5.6|
;;;152    	{
;;;153    		__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();
000006  bf00              NOP      
000008  bf00              NOP      
00000a  bf00              NOP      
00000c  bf00              NOP      
00000e  bf00              NOP      
000010  bf00              NOP      
000012  bf00              NOP      
000014  bf00              NOP      
000016  bf00              NOP      
000018  bf00              NOP      
00001a  bf00              NOP      
00001c  bf00              NOP      
00001e  bf00              NOP      
000020  bf00              NOP      
000022  bf00              NOP      
;;;154    		__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();
000024  bf00              NOP      
000026  bf00              NOP      
000028  bf00              NOP      
00002a  bf00              NOP      
00002c  bf00              NOP      
00002e  bf00              NOP      
000030  bf00              NOP      
000032  bf00              NOP      
000034  bf00              NOP      
000036  bf00              NOP      
000038  bf00              NOP      
00003a  bf00              NOP      
00003c  bf00              NOP      
00003e  bf00              NOP      
000040  bf00              NOP      
;;;155    		__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();
000042  bf00              NOP      
000044  bf00              NOP      
000046  bf00              NOP      
000048  bf00              NOP      
00004a  bf00              NOP      
00004c  bf00              NOP      
00004e  bf00              NOP      
000050  bf00              NOP      
000052  bf00              NOP      
000054  bf00              NOP      
000056  bf00              NOP      
000058  bf00              NOP      
00005a  bf00              NOP      
00005c  bf00              NOP      
00005e  bf00              NOP      
;;;156    		__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();
000060  bf00              NOP      
000062  bf00              NOP      
000064  bf00              NOP      
000066  bf00              NOP      
000068  bf00              NOP      
00006a  bf00              NOP      
00006c  bf00              NOP      
00006e  bf00              NOP      
000070  bf00              NOP      
000072  bf00              NOP      
000074  bf00              NOP      
000076  bf00              NOP      
000078  bf00              NOP      
00007a  bf00              NOP      
00007c  bf00              NOP      
;;;157    		__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();
00007e  bf00              NOP      
000080  bf00              NOP      
000082  bf00              NOP      
000084  bf00              NOP      
000086  bf00              NOP      
000088  bf00              NOP      
00008a  bf00              NOP      
00008c  bf00              NOP      
00008e  bf00              NOP      
000090  bf00              NOP      
000092  bf00              NOP      
000094  bf00              NOP      
000096  bf00              NOP      
000098  bf00              NOP      
00009a  bf00              NOP      
;;;158    		__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();
00009c  bf00              NOP      
00009e  bf00              NOP      
0000a0  bf00              NOP      
0000a2  bf00              NOP      
0000a4  bf00              NOP      
0000a6  bf00              NOP      
0000a8  bf00              NOP      
0000aa  bf00              NOP      
0000ac  bf00              NOP      
0000ae  bf00              NOP      
0000b0  bf00              NOP      
0000b2  bf00              NOP      
0000b4  bf00              NOP      
0000b6  bf00              NOP      
0000b8  bf00              NOP      
;;;159    		__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();
0000ba  bf00              NOP      
0000bc  bf00              NOP      
0000be  bf00              NOP      
0000c0  bf00              NOP      
0000c2  bf00              NOP      
0000c4  bf00              NOP      
0000c6  bf00              NOP      
0000c8  bf00              NOP      
0000ca  bf00              NOP      
0000cc  bf00              NOP      
0000ce  bf00              NOP      
0000d0  bf00              NOP      
0000d2  bf00              NOP      
0000d4  bf00              NOP      
0000d6  bf00              NOP      
;;;160    		__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();
0000d8  bf00              NOP      
0000da  bf00              NOP      
0000dc  bf00              NOP      
0000de  bf00              NOP      
0000e0  bf00              NOP      
0000e2  bf00              NOP      
0000e4  bf00              NOP      
0000e6  bf00              NOP      
0000e8  bf00              NOP      
0000ea  bf00              NOP      
0000ec  bf00              NOP      
0000ee  bf00              NOP      
0000f0  bf00              NOP      
0000f2  bf00              NOP      
0000f4  bf00              NOP      
;;;161    		__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();
0000f6  bf00              NOP      
0000f8  bf00              NOP      
0000fa  bf00              NOP      
0000fc  bf00              NOP      
0000fe  bf00              NOP      
000100  bf00              NOP      
000102  bf00              NOP      
000104  bf00              NOP      
000106  bf00              NOP      
000108  bf00              NOP      
00010a  bf00              NOP      
00010c  bf00              NOP      
00010e  bf00              NOP      
000110  bf00              NOP      
000112  bf00              NOP      
;;;162    		__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();
000114  bf00              NOP      
000116  bf00              NOP      
000118  bf00              NOP      
00011a  bf00              NOP      
00011c  bf00              NOP      
00011e  bf00              NOP      
000120  bf00              NOP      
000122  bf00              NOP      
000124  bf00              NOP      
000126  bf00              NOP      
000128  bf00              NOP      
00012a  bf00              NOP      
00012c  bf00              NOP      
00012e  bf00              NOP      
000130  bf00              NOP      
;;;163    		__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();
000132  bf00              NOP      
000134  bf00              NOP      
000136  bf00              NOP      
000138  bf00              NOP      
00013a  bf00              NOP      
00013c  bf00              NOP      
00013e  bf00              NOP      
000140  bf00              NOP      
000142  bf00              NOP      
000144  bf00              NOP      
000146  bf00              NOP      
000148  bf00              NOP      
00014a  bf00              NOP      
00014c  bf00              NOP      
00014e  bf00              NOP      
;;;164    		__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();
000150  bf00              NOP      
000152  bf00              NOP      
000154  bf00              NOP      
000156  bf00              NOP      
000158  bf00              NOP      
00015a  bf00              NOP      
00015c  bf00              NOP      
00015e  bf00              NOP      
000160  bf00              NOP      
000162  bf00              NOP      
000164  bf00              NOP      
000166  bf00              NOP      
000168  bf00              NOP      
00016a  bf00              NOP      
00016c  bf00              NOP      
;;;165    		__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();
00016e  bf00              NOP      
000170  bf00              NOP      
000172  bf00              NOP      
000174  bf00              NOP      
000176  bf00              NOP      
000178  bf00              NOP      
00017a  bf00              NOP      
00017c  bf00              NOP      
00017e  1c49              ADDS     r1,r1,#1              ;151
                  |L5.384|
000180  4281              CMP      r1,r0                 ;151
000182  f4ffaf40          BCC      |L5.6|
;;;166    	}
;;;167    }
000186  4770              BX       lr
;;;168    void Delayms(u32 nTimer)
                          ENDP


                          AREA ||i.Ex_NVIC_Config||, CODE, READONLY, ALIGN=2

                  Ex_NVIC_Config PROC
;;;70     //该函数会自动开启对应中断,以及屏蔽线   	    
;;;71     void Ex_NVIC_Config(u8 GPIOx,u8 BITx,u8 TRIM) 
000000  b5f0              PUSH     {r4-r7,lr}
;;;72     { 
000002  4603              MOV      r3,r0
;;;73     	u8 EXTOFFSET=(BITx%4)*4;  
000004  4608              MOV      r0,r1
000006  17cd              ASRS     r5,r1,#31
000008  eb017595          ADD      r5,r1,r5,LSR #30
00000c  10ad              ASRS     r5,r5,#2
00000e  eba10585          SUB      r5,r1,r5,LSL #2
000012  06ad              LSLS     r5,r5,#26
000014  0e2c              LSRS     r4,r5,#24
;;;74     	RCC->APB2ENR|=1<<14;  						//使能SYSCFG时钟  
000016  4824              LDR      r0,|L6.168|
000018  6800              LDR      r0,[r0,#0]
00001a  f4404080          ORR      r0,r0,#0x4000
00001e  4d22              LDR      r5,|L6.168|
000020  6028              STR      r0,[r5,#0]
;;;75     	SYSCFG->EXTICR[BITx/4]&=~(0x000F<<EXTOFFSET);//清除原来设置！！！
000022  17cd              ASRS     r5,r1,#31
000024  eb017595          ADD      r5,r1,r5,LSR #30
000028  10ae              ASRS     r6,r5,#2
00002a  4d20              LDR      r5,|L6.172|
00002c  f8555026          LDR      r5,[r5,r6,LSL #2]
000030  260f              MOVS     r6,#0xf
000032  40a6              LSLS     r6,r6,r4
000034  43b5              BICS     r5,r5,r6
000036  4608              MOV      r0,r1
000038  17ce              ASRS     r6,r1,#31
00003a  eb017696          ADD      r6,r1,r6,LSR #30
00003e  10b7              ASRS     r7,r6,#2
000040  4e1a              LDR      r6,|L6.172|
000042  f8465027          STR      r5,[r6,r7,LSL #2]
;;;76     	SYSCFG->EXTICR[BITx/4]|=GPIOx<<EXTOFFSET;	//EXTI.BITx映射到GPIOx.BITx 
000046  17cd              ASRS     r5,r1,#31
000048  eb017595          ADD      r5,r1,r5,LSR #30
00004c  10ae              ASRS     r6,r5,#2
00004e  4d17              LDR      r5,|L6.172|
000050  f8555026          LDR      r5,[r5,r6,LSL #2]
000054  fa03f604          LSL      r6,r3,r4
000058  4335              ORRS     r5,r5,r6
00005a  17ce              ASRS     r6,r1,#31
00005c  eb017696          ADD      r6,r1,r6,LSR #30
000060  10b7              ASRS     r7,r6,#2
000062  4e12              LDR      r6,|L6.172|
000064  f8465027          STR      r5,[r6,r7,LSL #2]
;;;77     	//自动设置
;;;78     	EXTI->IMR|=1<<BITx;					//开启line BITx上的中断(如果要禁止中断，则反操作即可)
000068  4811              LDR      r0,|L6.176|
00006a  6800              LDR      r0,[r0,#0]
00006c  2501              MOVS     r5,#1
00006e  408d              LSLS     r5,r5,r1
000070  4328              ORRS     r0,r0,r5
000072  4d0f              LDR      r5,|L6.176|
000074  6028              STR      r0,[r5,#0]
;;;79     	if(TRIM&0x01)EXTI->FTSR|=1<<BITx;	//line BITx上事件下降沿触发
000076  f0020001          AND      r0,r2,#1
00007a  b140              CBZ      r0,|L6.142|
00007c  480c              LDR      r0,|L6.176|
00007e  300c              ADDS     r0,r0,#0xc
000080  6800              LDR      r0,[r0,#0]
000082  2501              MOVS     r5,#1
000084  408d              LSLS     r5,r5,r1
000086  4328              ORRS     r0,r0,r5
000088  4d09              LDR      r5,|L6.176|
00008a  350c              ADDS     r5,r5,#0xc
00008c  6028              STR      r0,[r5,#0]
                  |L6.142|
;;;80     	if(TRIM&0x02)EXTI->RTSR|=1<<BITx;	//line BITx上事件上升降沿触发
00008e  f0020002          AND      r0,r2,#2
000092  b140              CBZ      r0,|L6.166|
000094  4806              LDR      r0,|L6.176|
000096  3008              ADDS     r0,r0,#8
000098  6800              LDR      r0,[r0,#0]
00009a  2501              MOVS     r5,#1
00009c  408d              LSLS     r5,r5,r1
00009e  4328              ORRS     r0,r0,r5
0000a0  4d03              LDR      r5,|L6.176|
0000a2  3508              ADDS     r5,r5,#8
0000a4  6028              STR      r0,[r5,#0]
                  |L6.166|
;;;81     } 	
0000a6  bdf0              POP      {r4-r7,pc}
;;;82     //GPIO复用设置
                          ENDP

                  |L6.168|
                          DCD      0x40023844
                  |L6.172|
                          DCD      0x40013808
                  |L6.176|
                          DCD      0x40013c00

                          AREA ||i.GPIO_AF_Set||, CODE, READONLY, ALIGN=1

                  GPIO_AF_Set PROC
;;;90     //AF12:FMC/SDIO/OTG/HS   		AF13:DCIM                 		AF14:LCD;                  		AF15:EVENTOUT
;;;91     void GPIO_AF_Set(GPIO_TypeDef* GPIOx,u8 BITx,u8 AFx)
000000  b530              PUSH     {r4,r5,lr}
;;;92     {  
;;;93     	GPIOx->AFR[BITx>>3]&=~(0X0F<<((BITx&0X07)*4));
000002  10cc              ASRS     r4,r1,#3
000004  f1000320          ADD      r3,r0,#0x20
000008  f8533024          LDR      r3,[r3,r4,LSL #2]
00000c  074c              LSLS     r4,r1,#29
00000e  0ee5              LSRS     r5,r4,#27
000010  240f              MOVS     r4,#0xf
000012  40ac              LSLS     r4,r4,r5
000014  43a3              BICS     r3,r3,r4
000016  10cd              ASRS     r5,r1,#3
000018  f1000420          ADD      r4,r0,#0x20
00001c  f8443025          STR      r3,[r4,r5,LSL #2]
;;;94     	GPIOx->AFR[BITx>>3]|=(u32)AFx<<((BITx&0X07)*4);
000020  10cc              ASRS     r4,r1,#3
000022  f1000320          ADD      r3,r0,#0x20
000026  f8533024          LDR      r3,[r3,r4,LSL #2]
00002a  074c              LSLS     r4,r1,#29
00002c  0ee4              LSRS     r4,r4,#27
00002e  fa02f404          LSL      r4,r2,r4
000032  4323              ORRS     r3,r3,r4
000034  10cd              ASRS     r5,r1,#3
000036  f1000420          ADD      r4,r0,#0x20
00003a  f8443025          STR      r3,[r4,r5,LSL #2]
;;;95     }   
00003e  bd30              POP      {r4,r5,pc}
;;;96     //GPIO通用设置 
                          ENDP


                          AREA ||i.GPIO_Set||, CODE, READONLY, ALIGN=1

                  GPIO_Set PROC
;;;103    //注意:在输入模式(普通输入/模拟输入)下,OTYPE和OSPEED参数无效!!
;;;104    void GPIO_Set(GPIO_TypeDef* GPIOx,u32 BITx,u32 MODE,u32 OTYPE,u32 OSPEED,u32 PUPD)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;105    {  
000004  460c              MOV      r4,r1
000006  e9dd6708          LDRD     r6,r7,[sp,#0x20]
;;;106    	u32 pinpos=0,pos=0,curpin=0;
00000a  2100              MOVS     r1,#0
00000c  2500              MOVS     r5,#0
00000e  468c              MOV      r12,r1
;;;107    	for(pinpos=0;pinpos<16;pinpos++)
000010  bf00              NOP      
000012  e060              B        |L8.214|
                  |L8.20|
;;;108    	{
;;;109    		pos=1<<pinpos;	//一个个位检查 
000014  f04f0801          MOV      r8,#1
000018  fa08f501          LSL      r5,r8,r1
;;;110    		curpin=BITx&pos;//检查引脚是否要设置
00001c  ea040c05          AND      r12,r4,r5
;;;111    		if(curpin==pos)	//需要设置
000020  45ac              CMP      r12,r5
000022  d157              BNE      |L8.212|
;;;112    		{
;;;113    			GPIOx->MODER&=~(3<<(pinpos*2));	//先清除原来的设置
000024  f8d08000          LDR      r8,[r0,#0]
000028  ea4f0a41          LSL      r10,r1,#1
00002c  f04f0903          MOV      r9,#3
000030  fa09f90a          LSL      r9,r9,r10
000034  ea280809          BIC      r8,r8,r9
000038  f8c08000          STR      r8,[r0,#0]
;;;114    			GPIOx->MODER|=MODE<<(pinpos*2);	//设置新的模式 
00003c  f8d08000          LDR      r8,[r0,#0]
000040  ea4f0941          LSL      r9,r1,#1
000044  fa02f909          LSL      r9,r2,r9
000048  ea480809          ORR      r8,r8,r9
00004c  f8c08000          STR      r8,[r0,#0]
;;;115    			if((MODE==0X01)||(MODE==0X02))	//如果是输出模式/复用功能模式
000050  2a01              CMP      r2,#1
000052  d001              BEQ      |L8.88|
000054  2a02              CMP      r2,#2
000056  d127              BNE      |L8.168|
                  |L8.88|
;;;116    			{  
;;;117    				GPIOx->OSPEEDR&=~(3<<(pinpos*2));	//清除原来的设置
000058  f8d08008          LDR      r8,[r0,#8]
00005c  ea4f0a41          LSL      r10,r1,#1
000060  f04f0903          MOV      r9,#3
000064  fa09f90a          LSL      r9,r9,r10
000068  ea280809          BIC      r8,r8,r9
00006c  f8c08008          STR      r8,[r0,#8]
;;;118    				GPIOx->OSPEEDR|=(OSPEED<<(pinpos*2));//设置新的速度值  
000070  f8d08008          LDR      r8,[r0,#8]
000074  ea4f0941          LSL      r9,r1,#1
000078  fa06f909          LSL      r9,r6,r9
00007c  ea480809          ORR      r8,r8,r9
000080  f8c08008          STR      r8,[r0,#8]
;;;119    				GPIOx->OTYPER&=~(1<<pinpos) ;		//清除原来的设置
000084  f8d09004          LDR      r9,[r0,#4]
000088  f04f0801          MOV      r8,#1
00008c  fa08f801          LSL      r8,r8,r1
000090  ea290908          BIC      r9,r9,r8
000094  f8c09004          STR      r9,[r0,#4]
;;;120    				GPIOx->OTYPER|=OTYPE<<pinpos;		//设置新的输出模式
000098  f8d08004          LDR      r8,[r0,#4]
00009c  fa03f901          LSL      r9,r3,r1
0000a0  ea480809          ORR      r8,r8,r9
0000a4  f8c08004          STR      r8,[r0,#4]
                  |L8.168|
;;;121    			}  
;;;122    			GPIOx->PUPDR&=~(3<<(pinpos*2));	//先清除原来的设置
0000a8  f8d0800c          LDR      r8,[r0,#0xc]
0000ac  ea4f0a41          LSL      r10,r1,#1
0000b0  f04f0903          MOV      r9,#3
0000b4  fa09f90a          LSL      r9,r9,r10
0000b8  ea280809          BIC      r8,r8,r9
0000bc  f8c0800c          STR      r8,[r0,#0xc]
;;;123    			GPIOx->PUPDR|=PUPD<<(pinpos*2);	//设置新的上下拉
0000c0  f8d0800c          LDR      r8,[r0,#0xc]
0000c4  ea4f0941          LSL      r9,r1,#1
0000c8  fa07f909          LSL      r9,r7,r9
0000cc  ea480809          ORR      r8,r8,r9
0000d0  f8c0800c          STR      r8,[r0,#0xc]
                  |L8.212|
0000d4  1c49              ADDS     r1,r1,#1              ;107
                  |L8.214|
0000d6  2910              CMP      r1,#0x10              ;107
0000d8  d39c              BCC      |L8.20|
;;;124    		}
;;;125    	}
;;;126    } 
0000da  e8bd87f0          POP      {r4-r10,pc}
;;;127    void HAL_Systick_Init(void)   //1ms中断一次
                          ENDP


                          AREA ||i.HAL_Systick_Init||, CODE, READONLY, ALIGN=2

                  HAL_Systick_Init PROC
;;;126    } 
;;;127    void HAL_Systick_Init(void)   //1ms中断一次
000000  b500              PUSH     {lr}
;;;128    {
;;;129    	RCC->APB1ENR|=1<<1;	//TIM3时钟使能    
000002  4812              LDR      r0,|L9.76|
000004  6800              LDR      r0,[r0,#0]
000006  f0400002          ORR      r0,r0,#2
00000a  4910              LDR      r1,|L9.76|
00000c  6008              STR      r0,[r1,#0]
;;;130     	TIM3->ARR=999;  	//设定计数器自动重装值 
00000e  f24030e7          MOV      r0,#0x3e7
000012  490f              LDR      r1,|L9.80|
000014  6008              STR      r0,[r1,#0]
;;;131    	TIM3->PSC=89;  	//预分频器	  
000016  2059              MOVS     r0,#0x59
000018  1f09              SUBS     r1,r1,#4
00001a  6008              STR      r0,[r1,#0]
;;;132    	TIM3->DIER|=1<<0;   //允许更新中断	  
00001c  480c              LDR      r0,|L9.80|
00001e  3820              SUBS     r0,r0,#0x20
000020  6800              LDR      r0,[r0,#0]
000022  f0400001          ORR      r0,r0,#1
000026  490a              LDR      r1,|L9.80|
000028  3920              SUBS     r1,r1,#0x20
00002a  6008              STR      r0,[r1,#0]
;;;133    	TIM3->CR1|=0x01;    //使能定时器3
00002c  4808              LDR      r0,|L9.80|
00002e  382c              SUBS     r0,r0,#0x2c
000030  6800              LDR      r0,[r0,#0]
000032  f0400001          ORR      r0,r0,#1
000036  4906              LDR      r1,|L9.80|
000038  392c              SUBS     r1,r1,#0x2c
00003a  6008              STR      r0,[r1,#0]
;;;134      MY_NVIC_Init(14,0,TIM3_IRQn,4);	//抢占14，子优先级0，组4								 
00003c  2304              MOVS     r3,#4
00003e  221d              MOVS     r2,#0x1d
000040  2100              MOVS     r1,#0
000042  200e              MOVS     r0,#0xe
000044  f7fffffe          BL       MY_NVIC_Init
;;;135    }
000048  bd00              POP      {pc}
;;;136    void DMA1_Init(void) 
                          ENDP

00004a  0000              DCW      0x0000
                  |L9.76|
                          DCD      0x40023840
                  |L9.80|
                          DCD      0x4000042c

                          AREA ||i.MY_NVIC_Init||, CODE, READONLY, ALIGN=2

                  MY_NVIC_Init PROC
;;;52     //NVIC_SubPriority和NVIC_PreemptionPriority的原则是,数值越小,越优先	   
;;;53     void MY_NVIC_Init(u8 NVIC_PreemptionPriority,u8 NVIC_SubPriority,u8 NVIC_Channel,u8 NVIC_Group)	 
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;54     { 
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;55     	u32 temp;	  
;;;56     	MY_NVIC_PriorityGroupConfig(NVIC_Group);//设置分组
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       MY_NVIC_PriorityGroupConfig
;;;57     	temp=NVIC_PreemptionPriority<<(4-NVIC_Group);	  
000012  f1c50004          RSB      r0,r5,#4
000016  fa07f600          LSL      r6,r7,r0
;;;58     	temp|=NVIC_SubPriority&(0x0f>>NVIC_Group);
00001a  200f              MOVS     r0,#0xf
00001c  4128              ASRS     r0,r0,r5
00001e  ea000008          AND      r0,r0,r8
000022  4306              ORRS     r6,r6,r0
;;;59     	temp&=0xf;								//取低四位
000024  f006060f          AND      r6,r6,#0xf
;;;60     	NVIC->ISER[NVIC_Channel/32]|=1<<NVIC_Channel%32;//使能中断位(要清除的话,设置ICER对应位为1即可)
000028  17e2              ASRS     r2,r4,#31
00002a  eb0462d2          ADD      r2,r4,r2,LSR #27
00002e  1152              ASRS     r2,r2,#5
000030  0092              LSLS     r2,r2,#2
000032  f10222e0          ADD      r2,r2,#0xe000e000
000036  f8d22100          LDR      r2,[r2,#0x100]
00003a  4621              MOV      r1,r4
00003c  17e3              ASRS     r3,r4,#31
00003e  eb0463d3          ADD      r3,r4,r3,LSR #27
000042  115b              ASRS     r3,r3,#5
000044  eba41c43          SUB      r12,r4,r3,LSL #5
000048  2301              MOVS     r3,#1
00004a  fa03f30c          LSL      r3,r3,r12
00004e  431a              ORRS     r2,r2,r3
000050  4620              MOV      r0,r4
000052  17e3              ASRS     r3,r4,#31
000054  eb0463d3          ADD      r3,r4,r3,LSR #27
000058  115b              ASRS     r3,r3,#5
00005a  009b              LSLS     r3,r3,#2
00005c  f10323e0          ADD      r3,r3,#0xe000e000
000060  f8c32100          STR      r2,[r3,#0x100]
;;;61     	NVIC->IP[NVIC_Channel]|=temp<<4;				//设置响应优先级和抢断优先级   	    	  				   
000064  4803              LDR      r0,|L10.116|
000066  5d00              LDRB     r0,[r0,r4]
000068  ea401006          ORR      r0,r0,r6,LSL #4
00006c  4901              LDR      r1,|L10.116|
00006e  5508              STRB     r0,[r1,r4]
;;;62     } 
000070  e8bd81f0          POP      {r4-r8,pc}
;;;63     //外部中断配置函数
                          ENDP

                  |L10.116|
                          DCD      0xe000e400

                          AREA ||i.MY_NVIC_PriorityGroupConfig||, CODE, READONLY, ALIGN=2

                  MY_NVIC_PriorityGroupConfig PROC
;;;28     //NVIC_Group:NVIC分组 0~4 总共5组 		   
;;;29     void MY_NVIC_PriorityGroupConfig(u8 NVIC_Group)	 
000000  4601              MOV      r1,r0
;;;30     { 
;;;31     	u32 temp,temp1;	  
;;;32     	temp1=(~NVIC_Group)&0x07;//取后三位
000002  2307              MOVS     r3,#7
000004  ea230201          BIC      r2,r3,r1
;;;33     	temp1<<=8;
000008  0212              LSLS     r2,r2,#8
;;;34     	temp=SCB->AIRCR;  //读取先前的设置
00000a  4b05              LDR      r3,|L11.32|
00000c  6818              LDR      r0,[r3,#0]
;;;35     	temp&=0X0000F8FF; //清空先前分组
00000e  f64f03ff          MOV      r3,#0xf8ff
000012  4018              ANDS     r0,r0,r3
;;;36     	temp|=0X05FA0000; //写入钥匙
000014  4b03              LDR      r3,|L11.36|
000016  4318              ORRS     r0,r0,r3
;;;37     	temp|=temp1;	   
000018  4310              ORRS     r0,r0,r2
;;;38     	SCB->AIRCR=temp;  //设置分组	    	  				   
00001a  4b01              LDR      r3,|L11.32|
00001c  6018              STR      r0,[r3,#0]
;;;39     }
00001e  4770              BX       lr
;;;40     //设置NVIC 
                          ENDP

                  |L11.32|
                          DCD      0xe000ed0c
                  |L11.36|
                          DCD      0x05fa0000

                          AREA ||i.MY_NVIC_SetVectorTable||, CODE, READONLY, ALIGN=2

                  MY_NVIC_SetVectorTable PROC
;;;22     //Offset:偏移量		 
;;;23     void MY_NVIC_SetVectorTable(u32 NVIC_VectTab,u32 Offset)	 
000000  0a4a              LSRS     r2,r1,#9
;;;24     { 	   	  
;;;25     	SCB->VTOR=NVIC_VectTab|(Offset&(u32)0xFFFFFE00);//设置NVIC的向量表偏移寄存器,VTOR低9位保留,即[8:0]保留。
000002  0252              LSLS     r2,r2,#9
000004  4302              ORRS     r2,r2,r0
000006  4b01              LDR      r3,|L12.12|
000008  601a              STR      r2,[r3,#0]
;;;26     }
00000a  4770              BX       lr
;;;27     //设置NVIC分组
                          ENDP

                  |L12.12|
                          DCD      0xe000ed08

                          AREA ||i.Stm32_Clock_Init||, CODE, READONLY, ALIGN=2

                  Stm32_Clock_Init PROC
;;;173    //(180,6,2,4)
;;;174    void Stm32_Clock_Init(u32 plln,u32 pllm,u32 pllp,u32 pllq)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;175    {
000004  b092              SUB      sp,sp,#0x48
000006  4605              MOV      r5,r0
000008  4688              MOV      r8,r1
00000a  4616              MOV      r6,r2
00000c  461f              MOV      r7,r3
;;;176        HAL_StatusTypeDef ret = HAL_OK;
00000e  2400              MOVS     r4,#0
;;;177        RCC_OscInitTypeDef RCC_OscInitStructure; 
;;;178        RCC_ClkInitTypeDef RCC_ClkInitStructure;
;;;179        __HAL_RCC_PWR_CLK_ENABLE(); //使能PWR时钟
000010  bf00              NOP      
000012  2000              MOVS     r0,#0
000014  9000              STR      r0,[sp,#0]
000016  4826              LDR      r0,|L13.176|
000018  6800              LDR      r0,[r0,#0]
00001a  f0405080          ORR      r0,r0,#0x10000000
00001e  4924              LDR      r1,|L13.176|
000020  6008              STR      r0,[r1,#0]
000022  4608              MOV      r0,r1
000024  6800              LDR      r0,[r0,#0]
000026  f0005080          AND      r0,r0,#0x10000000
00002a  9000              STR      r0,[sp,#0]
00002c  bf00              NOP      
00002e  bf00              NOP      
;;;180        //下面这个设置用来设置调压器输出电压级别，以便在器件未以最大频率工作
;;;181        //时使性能与功耗实现平衡，此功能只有STM32F42xx和STM32F43xx器件有，
;;;182        __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);//设置调压器输出电压级别1
000030  bf00              NOP      
000032  2000              MOVS     r0,#0
000034  9000              STR      r0,[sp,#0]
000036  481f              LDR      r0,|L13.180|
000038  6800              LDR      r0,[r0,#0]
00003a  f4404040          ORR      r0,r0,#0xc000
00003e  491d              LDR      r1,|L13.180|
000040  6008              STR      r0,[r1,#0]
000042  4608              MOV      r0,r1
000044  6800              LDR      r0,[r0,#0]
000046  f4004040          AND      r0,r0,#0xc000
00004a  9000              STR      r0,[sp,#0]
00004c  bf00              NOP      
00004e  bf00              NOP      
;;;183        RCC_OscInitStructure.OscillatorType=RCC_OSCILLATORTYPE_HSE;    //时钟源为HSE
000050  2001              MOVS     r0,#1
000052  9006              STR      r0,[sp,#0x18]
;;;184        RCC_OscInitStructure.HSEState=RCC_HSE_ON;                      //打开HSE
000054  9007              STR      r0,[sp,#0x1c]
;;;185        RCC_OscInitStructure.PLL.PLLState=RCC_PLL_ON;//打开PLL
000056  2002              MOVS     r0,#2
000058  900c              STR      r0,[sp,#0x30]
;;;186        RCC_OscInitStructure.PLL.PLLSource=RCC_PLLSOURCE_HSE;//PLL时钟源选择HSE
00005a  0541              LSLS     r1,r0,#21
00005c  910d              STR      r1,[sp,#0x34]
;;;187        RCC_OscInitStructure.PLL.PLLM=pllm; //主PLL和音频PLL分频系数(PLL之前的分频),取值范围:2~63.
00005e  f8cd8038          STR      r8,[sp,#0x38]
;;;188        RCC_OscInitStructure.PLL.PLLN=plln; //主PLL倍频系数(PLL倍频),取值范围:64~432.  
000062  950f              STR      r5,[sp,#0x3c]
;;;189        RCC_OscInitStructure.PLL.PLLP=pllp; //系统时钟的主PLL分频系数(PLL之后的分频),取值范围:2,4,6,8.(仅限这4个值!)
000064  9610              STR      r6,[sp,#0x40]
;;;190        RCC_OscInitStructure.PLL.PLLQ=pllq; //USB/SDIO/随机数产生器等的主PLL分频系数(PLL之后的分频),取值范围:2~15.
000066  9711              STR      r7,[sp,#0x44]
;;;191        ret=HAL_RCC_OscConfig(&RCC_OscInitStructure);//初始化
000068  a806              ADD      r0,sp,#0x18
00006a  f7fffffe          BL       HAL_RCC_OscConfig
00006e  4604              MOV      r4,r0
;;;192    	
;;;193        if(ret!=HAL_OK) while(1);
000070  b10c              CBZ      r4,|L13.118|
000072  bf00              NOP      
                  |L13.116|
000074  e7fe              B        |L13.116|
                  |L13.118|
;;;194        
;;;195        ret=HAL_PWREx_EnableOverDrive(); //开启Over-Driver功能
000076  f7fffffe          BL       HAL_PWREx_EnableOverDrive
00007a  4604              MOV      r4,r0
;;;196        if(ret!=HAL_OK) while(1);
00007c  b10c              CBZ      r4,|L13.130|
00007e  bf00              NOP      
                  |L13.128|
000080  e7fe              B        |L13.128|
                  |L13.130|
;;;197        
;;;198        //选中PLL作为系统时钟源并且配置HCLK,PCLK1和PCLK2
;;;199        RCC_ClkInitStructure.ClockType=(RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2);
000082  200f              MOVS     r0,#0xf
000084  9001              STR      r0,[sp,#4]
;;;200        RCC_ClkInitStructure.SYSCLKSource=RCC_SYSCLKSOURCE_PLLCLK;//设置系统时钟时钟源为PLL
000086  2002              MOVS     r0,#2
000088  9002              STR      r0,[sp,#8]
;;;201        RCC_ClkInitStructure.AHBCLKDivider=RCC_SYSCLK_DIV1;//AHB分频系数为1
00008a  2000              MOVS     r0,#0
00008c  9003              STR      r0,[sp,#0xc]
;;;202        RCC_ClkInitStructure.APB1CLKDivider=RCC_HCLK_DIV4; //APB1分频系数为4
00008e  f44f50a0          MOV      r0,#0x1400
000092  9004              STR      r0,[sp,#0x10]
;;;203        RCC_ClkInitStructure.APB2CLKDivider=RCC_HCLK_DIV2; //APB2分频系数为2
000094  f44f5080          MOV      r0,#0x1000
000098  9005              STR      r0,[sp,#0x14]
;;;204        ret=HAL_RCC_ClockConfig(&RCC_ClkInitStructure,FLASH_LATENCY_5);//同时设置FLASH延时周期为5WS，也就是6个CPU周期。
00009a  2105              MOVS     r1,#5
00009c  a801              ADD      r0,sp,#4
00009e  f7fffffe          BL       HAL_RCC_ClockConfig
0000a2  4604              MOV      r4,r0
;;;205    		
;;;206        if(ret!=HAL_OK) while(1);
0000a4  b10c              CBZ      r4,|L13.170|
0000a6  bf00              NOP      
                  |L13.168|
0000a8  e7fe              B        |L13.168|
                  |L13.170|
;;;207    }
0000aa  b012              ADD      sp,sp,#0x48
0000ac  e8bd81f0          POP      {r4-r8,pc}
;;;208    
                          ENDP

                  |L13.176|
                          DCD      0x40023840
                  |L13.180|
                          DCD      0x40007000

                          AREA ||i.TIM7_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM7_IRQHandler PROC
;;;2      extern unsigned long long FreeRTOSRunTimeTicks;
;;;3      void TIM7_IRQHandler(void)
000000  480a              LDR      r0,|L14.44|
;;;4      { 		    		  			    
;;;5      	if(TIM7->SR&0X0001)//溢出中断
000002  6800              LDR      r0,[r0,#0]
000004  f0000001          AND      r0,r0,#1
000008  b140              CBZ      r0,|L14.28|
;;;6      	{
;;;7      		FreeRTOSRunTimeTicks++;
00000a  4809              LDR      r0,|L14.48|
00000c  e9d03000          LDRD     r3,r0,[r0,#0]
000010  1c5a              ADDS     r2,r3,#1
000012  f1400000          ADC      r0,r0,#0
000016  4906              LDR      r1,|L14.48|
000018  e9c12000          STRD     r2,r0,[r1,#0]
                  |L14.28|
;;;8      	}
;;;9      	TIM7->SR&=~(1<<0);//清除中断标志位 	    
00001c  4803              LDR      r0,|L14.44|
00001e  6800              LDR      r0,[r0,#0]
000020  f0200001          BIC      r0,r0,#1
000024  4901              LDR      r1,|L14.44|
000026  6008              STR      r0,[r1,#0]
;;;10     }
000028  4770              BX       lr
;;;11     void ConfigureTimeForRunTimeStats(void)
                          ENDP

00002a  0000              DCW      0x0000
                  |L14.44|
                          DCD      0x40001410
                  |L14.48|
                          DCD      FreeRTOSRunTimeTicks

;*** Start embedded assembler ***

#line 1 "SYSTEM\\System_Config.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_System_Config_c_2b4ec856____REV16|
#line 388 ".\\CORE\\cmsis_armcc.h"
|__asm___15_System_Config_c_2b4ec856____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_System_Config_c_2b4ec856____REVSH|
#line 402
|__asm___15_System_Config_c_2b4ec856____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_System_Config_c_2b4ec856____RRX|
#line 587
|__asm___15_System_Config_c_2b4ec856____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |WFI_SET|
#line 223 "SYSTEM\\System_Config.c"
|WFI_SET| PROC
#line 224

 WFI
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |INTX_DISABLE|
#line 228
|INTX_DISABLE| PROC
#line 229

 CPSID I
 BX LR 
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |INTX_ENABLE|
#line 234
|INTX_ENABLE| PROC
#line 235

 CPSIE I
 BX LR 
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |MSR_MSP|
#line 241
|MSR_MSP| PROC
#line 242

 MSR MSP, r0  
 BX r14
	ENDP

;*** End   embedded assembler ***
