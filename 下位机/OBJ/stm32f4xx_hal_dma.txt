; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\stm32f4xx_hal_dma.o --asm_dir=.\OBJ\ --list_dir=.\OBJ\ --depend=.\obj\stm32f4xx_hal_dma.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I.\CORE -I.\USER -I.\HALLIB\STM32F4xx_HAL_Driver\Inc -I.\SYSTEM -I.\Hardware -I.\App -I.\DSP_LIB\Include -I.\FreeRTOS -I.\MPU9250\DMP -I.\MPU9250 -I.\RTE\_Project -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=526 -DSTM32F427xx -DSTM32F4 -DUSE_HAL_DRIVER -DSTM32F427xx -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=.\obj\stm32f4xx_hal_dma.crf HALLIB\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_dma.c]
                          THUMB

                          AREA ||i.DMA_CalcBaseAndBitshift||, CODE, READONLY, ALIGN=2

                  DMA_CalcBaseAndBitshift PROC
;;;921      */
;;;922    static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
000000  4601              MOV      r1,r0
;;;923    {
;;;924      uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFF) - 16) / 24;
000002  7808              LDRB     r0,[r1,#0]
000004  3810              SUBS     r0,r0,#0x10
000006  2318              MOVS     r3,#0x18
000008  fbb0f2f3          UDIV     r2,r0,r3
;;;925      
;;;926      /* lookup table for necessary bitshift of flags within status registers */
;;;927      static const uint8_t flagBitshiftOffset[8] = {0, 6, 16, 22, 0, 6, 16, 22};
;;;928      hdma->StreamIndex = flagBitshiftOffset[stream_number];
00000c  4808              LDR      r0,|L1.48|
00000e  5c80              LDRB     r0,[r0,r2]
000010  6548              STR      r0,[r1,#0x54]
;;;929      
;;;930      if (stream_number > 3)
000012  2a03              CMP      r2,#3
000014  d905              BLS      |L1.34|
;;;931      {
;;;932        /* return pointer to HISR and HIFCR */
;;;933        hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FF)) + 4);
000016  6808              LDR      r0,[r1,#0]
000018  f36f0009          BFC      r0,#0,#10
00001c  1d00              ADDS     r0,r0,#4
00001e  6508              STR      r0,[r1,#0x50]
000020  e003              B        |L1.42|
                  |L1.34|
;;;934      }
;;;935      else
;;;936      {
;;;937        /* return pointer to LISR and LIFCR */
;;;938        hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FF));
000022  6808              LDR      r0,[r1,#0]
000024  f36f0009          BFC      r0,#0,#10
000028  6508              STR      r0,[r1,#0x50]
                  |L1.42|
;;;939      }
;;;940      
;;;941      return hdma->StreamBaseAddress;
00002a  6d08              LDR      r0,[r1,#0x50]
;;;942    }
00002c  4770              BX       lr
;;;943    /**
                          ENDP

00002e  0000              DCW      0x0000
                  |L1.48|
                          DCD      flagBitshiftOffset

                          AREA ||i.DMA_SetConfig||, CODE, READONLY, ALIGN=1

                  DMA_SetConfig PROC
;;;887      */
;;;888    static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
000000  b530              PUSH     {r4,r5,lr}
;;;889    {
;;;890      /* Clear DBM bit */
;;;891      hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
000002  6804              LDR      r4,[r0,#0]
000004  6824              LDR      r4,[r4,#0]
000006  f4242480          BIC      r4,r4,#0x40000
00000a  6805              LDR      r5,[r0,#0]
00000c  602c              STR      r4,[r5,#0]
;;;892    
;;;893      /* Configure DMA Stream data length */
;;;894      hdma->Instance->NDTR = DataLength;
00000e  6804              LDR      r4,[r0,#0]
000010  6063              STR      r3,[r4,#4]
;;;895    
;;;896      /* Peripheral to Memory */
;;;897      if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
000012  6884              LDR      r4,[r0,#8]
000014  2c40              CMP      r4,#0x40
000016  d104              BNE      |L2.34|
;;;898      {
;;;899        /* Configure DMA Stream destination address */
;;;900        hdma->Instance->PAR = DstAddress;
000018  6804              LDR      r4,[r0,#0]
00001a  60a2              STR      r2,[r4,#8]
;;;901    
;;;902        /* Configure DMA Stream source address */
;;;903        hdma->Instance->M0AR = SrcAddress;
00001c  6804              LDR      r4,[r0,#0]
00001e  60e1              STR      r1,[r4,#0xc]
000020  e003              B        |L2.42|
                  |L2.34|
;;;904      }
;;;905      /* Memory to Peripheral */
;;;906      else
;;;907      {
;;;908        /* Configure DMA Stream source address */
;;;909        hdma->Instance->PAR = SrcAddress;
000022  6804              LDR      r4,[r0,#0]
000024  60a1              STR      r1,[r4,#8]
;;;910        
;;;911        /* Configure DMA Stream destination address */
;;;912        hdma->Instance->M0AR = DstAddress;
000026  6804              LDR      r4,[r0,#0]
000028  60e2              STR      r2,[r4,#0xc]
                  |L2.42|
;;;913      }
;;;914    }
00002a  bd30              POP      {r4,r5,pc}
;;;915    
                          ENDP


                          AREA ||i.HAL_DMA_Abort||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Abort PROC
;;;438      */
;;;439    HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;440    {
000002  4604              MOV      r4,r0
;;;441      uint32_t tickstart = 0;
000004  2500              MOVS     r5,#0
;;;442    
;;;443      /* Disable the stream */
;;;444      __HAL_DMA_DISABLE(hdma);
000006  6820              LDR      r0,[r4,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  f0200001          BIC      r0,r0,#1
00000e  6821              LDR      r1,[r4,#0]
000010  6008              STR      r0,[r1,#0]
;;;445    
;;;446      /* Get tick */
;;;447      tickstart = HAL_GetTick();
000012  f7fffffe          BL       HAL_GetTick
000016  4605              MOV      r5,r0
;;;448    
;;;449      /* Check if the DMA Stream is effectively disabled */
;;;450      while((hdma->Instance->CR & DMA_SxCR_EN) != 0)
000018  e012              B        |L3.64|
                  |L3.26|
;;;451      {
;;;452        /* Check for the Timeout */
;;;453        if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
00001a  f7fffffe          BL       HAL_GetTick
00001e  1b40              SUBS     r0,r0,r5
000020  f5b07f7a          CMP      r0,#0x3e8
000024  d90c              BLS      |L3.64|
;;;454        {
;;;455          /* Update error code */
;;;456          hdma->ErrorCode |= HAL_DMA_ERROR_TIMEOUT;
000026  6ce0              LDR      r0,[r4,#0x4c]
000028  f0400020          ORR      r0,r0,#0x20
00002c  64e0              STR      r0,[r4,#0x4c]
;;;457          
;;;458          /* Process Unlocked */
;;;459          __HAL_UNLOCK(hdma);
00002e  bf00              NOP      
000030  2000              MOVS     r0,#0
000032  f8840034          STRB     r0,[r4,#0x34]
000036  bf00              NOP      
;;;460          
;;;461          /* Change the DMA state */
;;;462          hdma->State = HAL_DMA_STATE_TIMEOUT;
000038  2003              MOVS     r0,#3
00003a  f8840035          STRB     r0,[r4,#0x35]
                  |L3.62|
;;;463          
;;;464          return HAL_TIMEOUT;
;;;465        }
;;;466      }
;;;467      /* Process Unlocked */
;;;468      __HAL_UNLOCK(hdma);
;;;469    
;;;470      /* Change the DMA state*/
;;;471      hdma->State = HAL_DMA_STATE_READY;
;;;472    
;;;473      return HAL_OK;
;;;474    }
00003e  bd70              POP      {r4-r6,pc}
                  |L3.64|
000040  6820              LDR      r0,[r4,#0]            ;450
000042  6800              LDR      r0,[r0,#0]            ;450
000044  f0000001          AND      r0,r0,#1              ;450
000048  2800              CMP      r0,#0                 ;450
00004a  d1e6              BNE      |L3.26|
00004c  bf00              NOP                            ;468
00004e  f8840034          STRB     r0,[r4,#0x34]         ;468
000052  bf00              NOP                            ;468
000054  2001              MOVS     r0,#1                 ;471
000056  f8840035          STRB     r0,[r4,#0x35]         ;471
00005a  2000              MOVS     r0,#0                 ;473
00005c  e7ef              B        |L3.62|
;;;475    
                          ENDP


                          AREA ||i.HAL_DMA_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_DMA_DeInit PROC
;;;281      */
;;;282    HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;283    {
000002  4604              MOV      r4,r0
;;;284      DMA_Base_Registers *regs;
;;;285      
;;;286      /* Check the DMA peripheral state */
;;;287      if(hdma == NULL)
000004  b90c              CBNZ     r4,|L4.10|
;;;288      {
;;;289        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L4.8|
;;;290      }
;;;291      
;;;292      /* Check the DMA peripheral state */
;;;293      if(hdma->State == HAL_DMA_STATE_BUSY)
;;;294      {
;;;295         return HAL_ERROR;
;;;296      }
;;;297    
;;;298      /* Disable the selected DMA Streamx */
;;;299      __HAL_DMA_DISABLE(hdma);
;;;300    
;;;301      /* Reset DMA Streamx control register */
;;;302      hdma->Instance->CR   = 0;
;;;303    
;;;304      /* Reset DMA Streamx number of data to transfer register */
;;;305      hdma->Instance->NDTR = 0;
;;;306    
;;;307      /* Reset DMA Streamx peripheral address register */
;;;308      hdma->Instance->PAR  = 0;
;;;309    
;;;310      /* Reset DMA Streamx memory 0 address register */
;;;311      hdma->Instance->M0AR = 0;
;;;312      
;;;313      /* Reset DMA Streamx memory 1 address register */
;;;314      hdma->Instance->M1AR = 0;
;;;315      
;;;316      /* Reset DMA Streamx FIFO control register */
;;;317      hdma->Instance->FCR  = (uint32_t)0x00000021;
;;;318      
;;;319      /* Get DMA steam Base Address */  
;;;320      regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
;;;321      
;;;322      /* Clear all interrupt flags at correct offset within the register */
;;;323      regs->IFCR = 0x3F << hdma->StreamIndex;
;;;324    
;;;325      /* Initialize the error code */
;;;326      hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;327    
;;;328      /* Initialize the DMA state */
;;;329      hdma->State = HAL_DMA_STATE_RESET;
;;;330    
;;;331      /* Release Lock */
;;;332      __HAL_UNLOCK(hdma);
;;;333    
;;;334      return HAL_OK;
;;;335    }
000008  bd70              POP      {r4-r6,pc}
                  |L4.10|
00000a  f8940035          LDRB     r0,[r4,#0x35]         ;293
00000e  2802              CMP      r0,#2                 ;293
000010  d101              BNE      |L4.22|
000012  2001              MOVS     r0,#1                 ;295
000014  e7f8              B        |L4.8|
                  |L4.22|
000016  6820              LDR      r0,[r4,#0]            ;299
000018  6800              LDR      r0,[r0,#0]            ;299
00001a  f0200001          BIC      r0,r0,#1              ;299
00001e  6821              LDR      r1,[r4,#0]            ;299
000020  6008              STR      r0,[r1,#0]            ;299
000022  2000              MOVS     r0,#0                 ;302
000024  6821              LDR      r1,[r4,#0]            ;302
000026  6008              STR      r0,[r1,#0]            ;302
000028  6821              LDR      r1,[r4,#0]            ;305
00002a  6048              STR      r0,[r1,#4]            ;305
00002c  6821              LDR      r1,[r4,#0]            ;308
00002e  6088              STR      r0,[r1,#8]            ;308
000030  6821              LDR      r1,[r4,#0]            ;311
000032  60c8              STR      r0,[r1,#0xc]          ;311
000034  6821              LDR      r1,[r4,#0]            ;314
000036  6108              STR      r0,[r1,#0x10]         ;314
000038  2021              MOVS     r0,#0x21              ;317
00003a  6821              LDR      r1,[r4,#0]            ;317
00003c  6148              STR      r0,[r1,#0x14]         ;317
00003e  4620              MOV      r0,r4                 ;320
000040  f7fffffe          BL       DMA_CalcBaseAndBitshift
000044  4605              MOV      r5,r0                 ;320
000046  f8941054          LDRB     r1,[r4,#0x54]         ;323
00004a  203f              MOVS     r0,#0x3f              ;323
00004c  4088              LSLS     r0,r0,r1              ;323
00004e  60a8              STR      r0,[r5,#8]            ;323
000050  2000              MOVS     r0,#0                 ;326
000052  64e0              STR      r0,[r4,#0x4c]         ;326
000054  f8840035          STRB     r0,[r4,#0x35]         ;329
000058  bf00              NOP                            ;332
00005a  f8840034          STRB     r0,[r4,#0x34]         ;332
00005e  bf00              NOP                            ;332
000060  bf00              NOP                            ;334
000062  e7d1              B        |L4.8|
;;;336    
                          ENDP


                          AREA ||i.HAL_DMA_GetError||, CODE, READONLY, ALIGN=1

                  HAL_DMA_GetError PROC
;;;861      */
;;;862    uint32_t HAL_DMA_GetError(DMA_HandleTypeDef *hdma)
000000  4601              MOV      r1,r0
;;;863    {
;;;864      return hdma->ErrorCode;
000002  6cc8              LDR      r0,[r1,#0x4c]
;;;865    }
000004  4770              BX       lr
;;;866    
                          ENDP


                          AREA ||i.HAL_DMA_GetState||, CODE, READONLY, ALIGN=1

                  HAL_DMA_GetState PROC
;;;850      */
;;;851    HAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma)
000000  4601              MOV      r1,r0
;;;852    {
;;;853      return hdma->State;
000002  f8910035          LDRB     r0,[r1,#0x35]
;;;854    }
000006  4770              BX       lr
;;;855    
                          ENDP


                          AREA ||i.HAL_DMA_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_DMA_IRQHandler PROC
;;;632      */
;;;633    void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;634    {
000002  4604              MOV      r4,r0
;;;635      /* calculate DMA base and stream number */
;;;636      DMA_Base_Registers *regs;
;;;637    
;;;638      regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
000004  6d25              LDR      r5,[r4,#0x50]
;;;639    
;;;640      /* Transfer Error Interrupt management ***************************************/
;;;641      if ((regs->ISR & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
000006  6828              LDR      r0,[r5,#0]
000008  f8942054          LDRB     r2,[r4,#0x54]
00000c  2108              MOVS     r1,#8
00000e  4091              LSLS     r1,r1,r2
000010  4008              ANDS     r0,r0,r1
000012  b300              CBZ      r0,|L7.86|
;;;642      {
;;;643        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
000014  6820              LDR      r0,[r4,#0]
000016  6800              LDR      r0,[r0,#0]
000018  f0000004          AND      r0,r0,#4
00001c  b1d8              CBZ      r0,|L7.86|
;;;644        {
;;;645          /* Disable the transfer error interrupt */
;;;646          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE);
00001e  6820              LDR      r0,[r4,#0]
000020  6800              LDR      r0,[r0,#0]
000022  f0200004          BIC      r0,r0,#4
000026  6821              LDR      r1,[r4,#0]
000028  6008              STR      r0,[r1,#0]
;;;647    
;;;648          /* Clear the transfer error flag */
;;;649          regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
00002a  f8941054          LDRB     r1,[r4,#0x54]
00002e  2008              MOVS     r0,#8
000030  4088              LSLS     r0,r0,r1
000032  60a8              STR      r0,[r5,#8]
;;;650    
;;;651          /* Update error code */
;;;652          hdma->ErrorCode |= HAL_DMA_ERROR_TE;
000034  6ce0              LDR      r0,[r4,#0x4c]
000036  f0400001          ORR      r0,r0,#1
00003a  64e0              STR      r0,[r4,#0x4c]
;;;653    
;;;654          /* Change the DMA state */
;;;655          hdma->State = HAL_DMA_STATE_ERROR;
00003c  2004              MOVS     r0,#4
00003e  f8840035          STRB     r0,[r4,#0x35]
;;;656    
;;;657          /* Process Unlocked */
;;;658          __HAL_UNLOCK(hdma);
000042  bf00              NOP      
000044  2000              MOVS     r0,#0
000046  f8840034          STRB     r0,[r4,#0x34]
00004a  bf00              NOP      
;;;659    
;;;660          if(hdma->XferErrorCallback != NULL)
00004c  6ca0              LDR      r0,[r4,#0x48]
00004e  b110              CBZ      r0,|L7.86|
;;;661          {
;;;662            /* Transfer error callback */
;;;663            hdma->XferErrorCallback(hdma);
000050  4620              MOV      r0,r4
000052  6ca1              LDR      r1,[r4,#0x48]
000054  4788              BLX      r1
                  |L7.86|
;;;664          }
;;;665        }
;;;666      }
;;;667      /* FIFO Error Interrupt management ******************************************/
;;;668      if ((regs->ISR & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
000056  6828              LDR      r0,[r5,#0]
000058  f8942054          LDRB     r2,[r4,#0x54]
00005c  496d              LDR      r1,|L7.532|
00005e  4091              LSLS     r1,r1,r2
000060  4008              ANDS     r0,r0,r1
000062  b300              CBZ      r0,|L7.166|
;;;669      {
;;;670        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
000064  6820              LDR      r0,[r4,#0]
000066  6940              LDR      r0,[r0,#0x14]
000068  f0000080          AND      r0,r0,#0x80
00006c  b1d8              CBZ      r0,|L7.166|
;;;671        {
;;;672          /* Disable the FIFO Error interrupt */
;;;673          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_FE);
00006e  6820              LDR      r0,[r4,#0]
000070  6940              LDR      r0,[r0,#0x14]
000072  f0200080          BIC      r0,r0,#0x80
000076  6821              LDR      r1,[r4,#0]
000078  6148              STR      r0,[r1,#0x14]
;;;674    
;;;675          /* Clear the FIFO error flag */
;;;676          regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
00007a  f8941054          LDRB     r1,[r4,#0x54]
00007e  4865              LDR      r0,|L7.532|
000080  4088              LSLS     r0,r0,r1
000082  60a8              STR      r0,[r5,#8]
;;;677    
;;;678          /* Update error code */
;;;679          hdma->ErrorCode |= HAL_DMA_ERROR_FE;
000084  6ce0              LDR      r0,[r4,#0x4c]
000086  f0400002          ORR      r0,r0,#2
00008a  64e0              STR      r0,[r4,#0x4c]
;;;680    
;;;681          /* Change the DMA state */
;;;682          hdma->State = HAL_DMA_STATE_ERROR;
00008c  2004              MOVS     r0,#4
00008e  f8840035          STRB     r0,[r4,#0x35]
;;;683    
;;;684          /* Process Unlocked */
;;;685          __HAL_UNLOCK(hdma);
000092  bf00              NOP      
000094  2000              MOVS     r0,#0
000096  f8840034          STRB     r0,[r4,#0x34]
00009a  bf00              NOP      
;;;686    
;;;687          if(hdma->XferErrorCallback != NULL)
00009c  6ca0              LDR      r0,[r4,#0x48]
00009e  b110              CBZ      r0,|L7.166|
;;;688          {
;;;689            /* Transfer error callback */
;;;690            hdma->XferErrorCallback(hdma);
0000a0  4620              MOV      r0,r4
0000a2  6ca1              LDR      r1,[r4,#0x48]
0000a4  4788              BLX      r1
                  |L7.166|
;;;691          }
;;;692        }
;;;693      }
;;;694      /* Direct Mode Error Interrupt management ***********************************/
;;;695      if ((regs->ISR & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
0000a6  6828              LDR      r0,[r5,#0]
0000a8  f8942054          LDRB     r2,[r4,#0x54]
0000ac  4959              LDR      r1,|L7.532|
0000ae  1cc9              ADDS     r1,r1,#3
0000b0  4091              LSLS     r1,r1,r2
0000b2  4008              ANDS     r0,r0,r1
0000b4  b308              CBZ      r0,|L7.250|
;;;696      {
;;;697        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
0000b6  6820              LDR      r0,[r4,#0]
0000b8  6800              LDR      r0,[r0,#0]
0000ba  f0000002          AND      r0,r0,#2
0000be  b1e0              CBZ      r0,|L7.250|
;;;698        {
;;;699          /* Disable the direct mode Error interrupt */
;;;700          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_DME);
0000c0  6820              LDR      r0,[r4,#0]
0000c2  6800              LDR      r0,[r0,#0]
0000c4  f0200002          BIC      r0,r0,#2
0000c8  6821              LDR      r1,[r4,#0]
0000ca  6008              STR      r0,[r1,#0]
;;;701    
;;;702          /* Clear the direct mode error flag */
;;;703          regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
0000cc  f8941054          LDRB     r1,[r4,#0x54]
0000d0  4850              LDR      r0,|L7.532|
0000d2  1cc0              ADDS     r0,r0,#3
0000d4  4088              LSLS     r0,r0,r1
0000d6  60a8              STR      r0,[r5,#8]
;;;704    
;;;705          /* Update error code */
;;;706          hdma->ErrorCode |= HAL_DMA_ERROR_DME;
0000d8  6ce0              LDR      r0,[r4,#0x4c]
0000da  f0400004          ORR      r0,r0,#4
0000de  64e0              STR      r0,[r4,#0x4c]
;;;707    
;;;708          /* Change the DMA state */
;;;709          hdma->State = HAL_DMA_STATE_ERROR;
0000e0  2004              MOVS     r0,#4
0000e2  f8840035          STRB     r0,[r4,#0x35]
;;;710    
;;;711          /* Process Unlocked */
;;;712          __HAL_UNLOCK(hdma);
0000e6  bf00              NOP      
0000e8  2000              MOVS     r0,#0
0000ea  f8840034          STRB     r0,[r4,#0x34]
0000ee  bf00              NOP      
;;;713    
;;;714          if(hdma->XferErrorCallback != NULL)
0000f0  6ca0              LDR      r0,[r4,#0x48]
0000f2  b110              CBZ      r0,|L7.250|
;;;715          {
;;;716            /* Transfer error callback */
;;;717            hdma->XferErrorCallback(hdma);
0000f4  4620              MOV      r0,r4
0000f6  6ca1              LDR      r1,[r4,#0x48]
0000f8  4788              BLX      r1
                  |L7.250|
;;;718          }
;;;719        }
;;;720      }
;;;721      /* Half Transfer Complete Interrupt management ******************************/
;;;722      if ((regs->ISR & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
0000fa  6828              LDR      r0,[r5,#0]
0000fc  f8942054          LDRB     r2,[r4,#0x54]
000100  2110              MOVS     r1,#0x10
000102  4091              LSLS     r1,r1,r2
000104  4008              ANDS     r0,r0,r1
000106  b3c0              CBZ      r0,|L7.378|
;;;723      {
;;;724        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
000108  6820              LDR      r0,[r4,#0]
00010a  6800              LDR      r0,[r0,#0]
00010c  f0000008          AND      r0,r0,#8
000110  b398              CBZ      r0,|L7.378|
;;;725        {
;;;726          /* Multi_Buffering mode enabled */
;;;727          if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0)
000112  6820              LDR      r0,[r4,#0]
000114  6800              LDR      r0,[r0,#0]
000116  f4002080          AND      r0,r0,#0x40000
00011a  b1b0              CBZ      r0,|L7.330|
;;;728          {
;;;729            /* Clear the half transfer complete flag */
;;;730            regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
00011c  f8941054          LDRB     r1,[r4,#0x54]
000120  2010              MOVS     r0,#0x10
000122  4088              LSLS     r0,r0,r1
000124  60a8              STR      r0,[r5,#8]
;;;731    
;;;732            /* Current memory buffer used is Memory 0 */
;;;733            if((hdma->Instance->CR & DMA_SxCR_CT) == 0)
000126  6820              LDR      r0,[r4,#0]
000128  6800              LDR      r0,[r0,#0]
00012a  f4002000          AND      r0,r0,#0x80000
00012e  b918              CBNZ     r0,|L7.312|
;;;734            {
;;;735              /* Change DMA peripheral state */
;;;736              hdma->State = HAL_DMA_STATE_READY_HALF_MEM0;
000130  2031              MOVS     r0,#0x31
000132  f8840035          STRB     r0,[r4,#0x35]
000136  e01b              B        |L7.368|
                  |L7.312|
;;;737            }
;;;738            /* Current memory buffer used is Memory 1 */
;;;739            else if((hdma->Instance->CR & DMA_SxCR_CT) != 0)
000138  6820              LDR      r0,[r4,#0]
00013a  6800              LDR      r0,[r0,#0]
00013c  f4002000          AND      r0,r0,#0x80000
000140  b1b0              CBZ      r0,|L7.368|
;;;740            {
;;;741              /* Change DMA peripheral state */
;;;742              hdma->State = HAL_DMA_STATE_READY_HALF_MEM1;
000142  2041              MOVS     r0,#0x41
000144  f8840035          STRB     r0,[r4,#0x35]
000148  e012              B        |L7.368|
                  |L7.330|
;;;743            }
;;;744          }
;;;745          else
;;;746          {
;;;747            /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
;;;748            if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
00014a  6820              LDR      r0,[r4,#0]
00014c  6800              LDR      r0,[r0,#0]
00014e  f4007080          AND      r0,r0,#0x100
000152  b928              CBNZ     r0,|L7.352|
;;;749            {
;;;750              /* Disable the half transfer interrupt */
;;;751              __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
000154  6820              LDR      r0,[r4,#0]
000156  6800              LDR      r0,[r0,#0]
000158  f0200008          BIC      r0,r0,#8
00015c  6821              LDR      r1,[r4,#0]
00015e  6008              STR      r0,[r1,#0]
                  |L7.352|
;;;752            }
;;;753            /* Clear the half transfer complete flag */
;;;754            regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
000160  f8941054          LDRB     r1,[r4,#0x54]
000164  2010              MOVS     r0,#0x10
000166  4088              LSLS     r0,r0,r1
000168  60a8              STR      r0,[r5,#8]
;;;755    
;;;756            /* Change DMA peripheral state */
;;;757            hdma->State = HAL_DMA_STATE_READY_HALF_MEM0;
00016a  2031              MOVS     r0,#0x31
00016c  f8840035          STRB     r0,[r4,#0x35]
                  |L7.368|
;;;758          }
;;;759    
;;;760          if(hdma->XferHalfCpltCallback != NULL)
000170  6c20              LDR      r0,[r4,#0x40]
000172  b110              CBZ      r0,|L7.378|
;;;761          {
;;;762            /* Half transfer callback */
;;;763            hdma->XferHalfCpltCallback(hdma);
000174  4620              MOV      r0,r4
000176  6c21              LDR      r1,[r4,#0x40]
000178  4788              BLX      r1
                  |L7.378|
;;;764          }
;;;765        }
;;;766      }
;;;767      /* Transfer Complete Interrupt management ***********************************/
;;;768      if ((regs->ISR & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
00017a  6828              LDR      r0,[r5,#0]
00017c  f8942054          LDRB     r2,[r4,#0x54]
000180  2120              MOVS     r1,#0x20
000182  4091              LSLS     r1,r1,r2
000184  4008              ANDS     r0,r0,r1
000186  b318              CBZ      r0,|L7.464|
;;;769      {
;;;770        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
000188  6820              LDR      r0,[r4,#0]
00018a  6800              LDR      r0,[r0,#0]
00018c  f0000010          AND      r0,r0,#0x10
000190  b1f0              CBZ      r0,|L7.464|
;;;771        {
;;;772          if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0)
000192  6820              LDR      r0,[r4,#0]
000194  6800              LDR      r0,[r0,#0]
000196  f4002080          AND      r0,r0,#0x40000
00019a  b1d0              CBZ      r0,|L7.466|
;;;773          {
;;;774            /* Clear the transfer complete flag */
;;;775            regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
00019c  f8941054          LDRB     r1,[r4,#0x54]
0001a0  2020              MOVS     r0,#0x20
0001a2  4088              LSLS     r0,r0,r1
0001a4  60a8              STR      r0,[r5,#8]
;;;776    
;;;777            /* Current memory buffer used is Memory 1 */
;;;778            if((hdma->Instance->CR & DMA_SxCR_CT) == 0)
0001a6  6820              LDR      r0,[r4,#0]
0001a8  6800              LDR      r0,[r0,#0]
0001aa  f4002000          AND      r0,r0,#0x80000
0001ae  b928              CBNZ     r0,|L7.444|
;;;779            {
;;;780              if(hdma->XferM1CpltCallback != NULL)
0001b0  6c60              LDR      r0,[r4,#0x44]
0001b2  b168              CBZ      r0,|L7.464|
;;;781              {
;;;782                /* Transfer complete Callback for memory1 */
;;;783                hdma->XferM1CpltCallback(hdma);
0001b4  4620              MOV      r0,r4
0001b6  6c61              LDR      r1,[r4,#0x44]
0001b8  4788              BLX      r1
0001ba  e029              B        |L7.528|
                  |L7.444|
;;;784              }
;;;785            }
;;;786            /* Current memory buffer used is Memory 0 */
;;;787            else if((hdma->Instance->CR & DMA_SxCR_CT) != 0)
0001bc  6820              LDR      r0,[r4,#0]
0001be  6800              LDR      r0,[r0,#0]
0001c0  f4002000          AND      r0,r0,#0x80000
0001c4  b120              CBZ      r0,|L7.464|
;;;788            {
;;;789              if(hdma->XferCpltCallback != NULL)
0001c6  6be0              LDR      r0,[r4,#0x3c]
0001c8  b110              CBZ      r0,|L7.464|
;;;790              {
;;;791                /* Transfer complete Callback for memory0 */
;;;792                hdma->XferCpltCallback(hdma);
0001ca  4620              MOV      r0,r4
0001cc  6be1              LDR      r1,[r4,#0x3c]
0001ce  4788              BLX      r1
                  |L7.464|
0001d0  e01e              B        |L7.528|
                  |L7.466|
;;;793              }
;;;794            }
;;;795          }
;;;796          /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
;;;797          else
;;;798          {
;;;799            if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
0001d2  6820              LDR      r0,[r4,#0]
0001d4  6800              LDR      r0,[r0,#0]
0001d6  f4007080          AND      r0,r0,#0x100
0001da  b928              CBNZ     r0,|L7.488|
;;;800            {
;;;801              /* Disable the transfer complete interrupt */
;;;802              __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TC);
0001dc  6820              LDR      r0,[r4,#0]
0001de  6800              LDR      r0,[r0,#0]
0001e0  f0200010          BIC      r0,r0,#0x10
0001e4  6821              LDR      r1,[r4,#0]
0001e6  6008              STR      r0,[r1,#0]
                  |L7.488|
;;;803            }
;;;804            /* Clear the transfer complete flag */
;;;805            regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
0001e8  f8941054          LDRB     r1,[r4,#0x54]
0001ec  2020              MOVS     r0,#0x20
0001ee  4088              LSLS     r0,r0,r1
0001f0  60a8              STR      r0,[r5,#8]
;;;806    
;;;807            /* Update error code */
;;;808            hdma->ErrorCode |= HAL_DMA_ERROR_NONE;
0001f2  6ce0              LDR      r0,[r4,#0x4c]
0001f4  64e0              STR      r0,[r4,#0x4c]
;;;809    
;;;810            /* Change the DMA state */
;;;811            hdma->State = HAL_DMA_STATE_READY_MEM0;
0001f6  2011              MOVS     r0,#0x11
0001f8  f8840035          STRB     r0,[r4,#0x35]
;;;812    
;;;813            /* Process Unlocked */
;;;814            __HAL_UNLOCK(hdma);
0001fc  bf00              NOP      
0001fe  2000              MOVS     r0,#0
000200  f8840034          STRB     r0,[r4,#0x34]
000204  bf00              NOP      
;;;815    
;;;816            if(hdma->XferCpltCallback != NULL)
000206  6be0              LDR      r0,[r4,#0x3c]
000208  b110              CBZ      r0,|L7.528|
;;;817            {
;;;818              /* Transfer complete callback */
;;;819              hdma->XferCpltCallback(hdma);
00020a  4620              MOV      r0,r4
00020c  6be1              LDR      r1,[r4,#0x3c]
00020e  4788              BLX      r1
                  |L7.528|
;;;820            }
;;;821          }
;;;822        }
;;;823      }
;;;824    }
000210  bd70              POP      {r4-r6,pc}
;;;825    
                          ENDP

000212  0000              DCW      0x0000
                  |L7.532|
                          DCD      0x00800001

                          AREA ||i.HAL_DMA_Init||, CODE, READONLY, ALIGN=2

                  HAL_DMA_Init PROC
;;;185      */
;;;186    HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;187    {
000002  4604              MOV      r4,r0
;;;188      uint32_t tmp = 0;
000004  2500              MOVS     r5,#0
;;;189    
;;;190      /* Check the DMA peripheral state */
;;;191      if(hdma == NULL)
000006  b90c              CBNZ     r4,|L8.12|
;;;192      {
;;;193        return HAL_ERROR;
000008  2001              MOVS     r0,#1
                  |L8.10|
;;;194      }
;;;195    
;;;196      /* Check the parameters */
;;;197      assert_param(IS_DMA_STREAM_ALL_INSTANCE(hdma->Instance));
;;;198      assert_param(IS_DMA_CHANNEL(hdma->Init.Channel));
;;;199      assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));
;;;200      assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
;;;201      assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
;;;202      assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
;;;203      assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
;;;204      assert_param(IS_DMA_MODE(hdma->Init.Mode));
;;;205      assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
;;;206      assert_param(IS_DMA_FIFO_MODE_STATE(hdma->Init.FIFOMode));
;;;207      /* Check the memory burst, peripheral burst and FIFO threshold parameters only
;;;208         when FIFO mode is enabled */
;;;209      if(hdma->Init.FIFOMode != DMA_FIFOMODE_DISABLE)
;;;210      {
;;;211        assert_param(IS_DMA_FIFO_THRESHOLD(hdma->Init.FIFOThreshold));
;;;212        assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
;;;213        assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
;;;214      }
;;;215    
;;;216      /* Change DMA peripheral state */
;;;217      hdma->State = HAL_DMA_STATE_BUSY;
;;;218    
;;;219      /* Get the CR register value */
;;;220      tmp = hdma->Instance->CR;
;;;221    
;;;222      /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
;;;223      tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
;;;224                          DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
;;;225                          DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
;;;226                          DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));
;;;227    
;;;228      /* Prepare the DMA Stream configuration */
;;;229      tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
;;;230              hdma->Init.PeriphInc           | hdma->Init.MemInc           |
;;;231              hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
;;;232              hdma->Init.Mode                | hdma->Init.Priority;
;;;233    
;;;234      /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
;;;235      if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
;;;236      {
;;;237        /* Get memory burst and peripheral burst */
;;;238        tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
;;;239      }
;;;240      
;;;241      /* Write to DMA Stream CR register */
;;;242      hdma->Instance->CR = tmp;  
;;;243    
;;;244      /* Get the FCR register value */
;;;245      tmp = hdma->Instance->FCR;
;;;246    
;;;247      /* Clear Direct mode and FIFO threshold bits */
;;;248      tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
;;;249    
;;;250      /* Prepare the DMA Stream FIFO configuration */
;;;251      tmp |= hdma->Init.FIFOMode;
;;;252    
;;;253      /* the FIFO threshold is not used when the FIFO mode is disabled */
;;;254      if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
;;;255      {
;;;256        /* Get the FIFO threshold */
;;;257        tmp |= hdma->Init.FIFOThreshold;
;;;258      }
;;;259      
;;;260      /* Write to DMA Stream FCR */
;;;261      hdma->Instance->FCR = tmp;
;;;262    
;;;263      /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
;;;264         DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
;;;265      DMA_CalcBaseAndBitshift(hdma);
;;;266    
;;;267      /* Initialize the error code */
;;;268      hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;269    
;;;270      /* Initialize the DMA state */
;;;271      hdma->State = HAL_DMA_STATE_READY;
;;;272    
;;;273      return HAL_OK;
;;;274    }
00000a  bd70              POP      {r4-r6,pc}
                  |L8.12|
00000c  6a60              LDR      r0,[r4,#0x24]         ;209
00000e  b100              CBZ      r0,|L8.18|
000010  bf00              NOP                            ;213
                  |L8.18|
000012  2002              MOVS     r0,#2                 ;217
000014  f8840035          STRB     r0,[r4,#0x35]         ;217
000018  6820              LDR      r0,[r4,#0]            ;220
00001a  6805              LDR      r5,[r0,#0]            ;220
00001c  4818              LDR      r0,|L8.128|
00001e  4005              ANDS     r5,r5,r0              ;223
000020  e9d40101          LDRD     r0,r1,[r4,#4]         ;229
000024  4308              ORRS     r0,r0,r1              ;229
000026  68e1              LDR      r1,[r4,#0xc]          ;229
000028  4308              ORRS     r0,r0,r1              ;229
00002a  6921              LDR      r1,[r4,#0x10]         ;229
00002c  4308              ORRS     r0,r0,r1              ;229
00002e  6961              LDR      r1,[r4,#0x14]         ;229
000030  4308              ORRS     r0,r0,r1              ;229
000032  69a1              LDR      r1,[r4,#0x18]         ;229
000034  4308              ORRS     r0,r0,r1              ;229
000036  69e1              LDR      r1,[r4,#0x1c]         ;229
000038  4308              ORRS     r0,r0,r1              ;229
00003a  6a21              LDR      r1,[r4,#0x20]         ;229
00003c  4308              ORRS     r0,r0,r1              ;229
00003e  4305              ORRS     r5,r5,r0              ;229
000040  6a60              LDR      r0,[r4,#0x24]         ;235
000042  2804              CMP      r0,#4                 ;235
000044  d103              BNE      |L8.78|
000046  e9d4010b          LDRD     r0,r1,[r4,#0x2c]      ;238
00004a  4308              ORRS     r0,r0,r1              ;238
00004c  4305              ORRS     r5,r5,r0              ;238
                  |L8.78|
00004e  6820              LDR      r0,[r4,#0]            ;242
000050  6005              STR      r5,[r0,#0]            ;242
000052  6820              LDR      r0,[r4,#0]            ;245
000054  6945              LDR      r5,[r0,#0x14]         ;245
000056  f0250507          BIC      r5,r5,#7              ;248
00005a  6a60              LDR      r0,[r4,#0x24]         ;251
00005c  4305              ORRS     r5,r5,r0              ;251
00005e  6a60              LDR      r0,[r4,#0x24]         ;254
000060  2804              CMP      r0,#4                 ;254
000062  d101              BNE      |L8.104|
000064  6aa0              LDR      r0,[r4,#0x28]         ;257
000066  4305              ORRS     r5,r5,r0              ;257
                  |L8.104|
000068  6820              LDR      r0,[r4,#0]            ;261
00006a  6145              STR      r5,[r0,#0x14]         ;261
00006c  4620              MOV      r0,r4                 ;265
00006e  f7fffffe          BL       DMA_CalcBaseAndBitshift
000072  2000              MOVS     r0,#0                 ;268
000074  64e0              STR      r0,[r4,#0x4c]         ;268
000076  2001              MOVS     r0,#1                 ;271
000078  f8840035          STRB     r0,[r4,#0x35]         ;271
00007c  2000              MOVS     r0,#0                 ;273
00007e  e7c4              B        |L8.10|
;;;275    
                          ENDP

                  |L8.128|
                          DCD      0xf010803f

                          AREA ||i.HAL_DMA_PollForTransfer||, CODE, READONLY, ALIGN=2

                  HAL_DMA_PollForTransfer PROC
;;;483      */
;;;484    HAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, uint32_t CompleteLevel, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;485    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;486      uint32_t temp, tmp, tmp1, tmp2;
;;;487      uint32_t tickstart = 0;
00000a  2000              MOVS     r0,#0
00000c  9000              STR      r0,[sp,#0]
;;;488    
;;;489      /* calculate DMA base and stream number */
;;;490      DMA_Base_Registers *regs;
;;;491      
;;;492      regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
00000e  6d25              LDR      r5,[r4,#0x50]
;;;493    
;;;494      /* Get the level transfer complete flag */
;;;495      if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
000010  b92f              CBNZ     r7,|L9.30|
;;;496      {
;;;497        /* Transfer Complete flag */
;;;498        temp = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
000012  f8941054          LDRB     r1,[r4,#0x54]
000016  2020              MOVS     r0,#0x20
000018  fa00f801          LSL      r8,r0,r1
00001c  e004              B        |L9.40|
                  |L9.30|
;;;499      }
;;;500      else
;;;501      {
;;;502        /* Half Transfer Complete flag */
;;;503        temp = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
00001e  f8941054          LDRB     r1,[r4,#0x54]
000022  2010              MOVS     r0,#0x10
000024  fa00f801          LSL      r8,r0,r1
                  |L9.40|
;;;504      }
;;;505    
;;;506      /* Get tick */
;;;507      tickstart = HAL_GetTick();
000028  f7fffffe          BL       HAL_GetTick
00002c  9000              STR      r0,[sp,#0]
;;;508    
;;;509      while((regs->ISR & temp) == RESET)
00002e  e064              B        |L9.250|
                  |L9.48|
;;;510      {
;;;511        tmp  = regs->ISR & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex);
000030  6828              LDR      r0,[r5,#0]
000032  f8142f54          LDRB     r2,[r4,#0x54]!
000036  2108              MOVS     r1,#8
000038  4091              LSLS     r1,r1,r2
00003a  ea000901          AND      r9,r0,r1
;;;512        tmp1 = regs->ISR & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex);
00003e  6828              LDR      r0,[r5,#0]
000040  7822              LDRB     r2,[r4,#0]
000042  4953              LDR      r1,|L9.400|
000044  4091              LSLS     r1,r1,r2
000046  ea000a01          AND      r10,r0,r1
;;;513        tmp2 = regs->ISR & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex);
00004a  6828              LDR      r0,[r5,#0]
00004c  f8142954          LDRB     r2,[r4],#-0x54
000050  494f              LDR      r1,|L9.400|
000052  1cc9              ADDS     r1,r1,#3
000054  4091              LSLS     r1,r1,r2
000056  ea000b01          AND      r11,r0,r1
;;;514        if((tmp != RESET) || (tmp1 != RESET) || (tmp2 != RESET))
00005a  f1b90f00          CMP      r9,#0
00005e  d105              BNE      |L9.108|
000060  f1ba0f00          CMP      r10,#0
000064  d102              BNE      |L9.108|
000066  f1bb0f00          CMP      r11,#0
00006a  d02f              BEQ      |L9.204|
                  |L9.108|
;;;515        {
;;;516          if(tmp != RESET)
00006c  f1b90f00          CMP      r9,#0
000070  d008              BEQ      |L9.132|
;;;517          {
;;;518            /* Update error code */
;;;519            hdma->ErrorCode |= HAL_DMA_ERROR_TE;
000072  6ce0              LDR      r0,[r4,#0x4c]
000074  f0400001          ORR      r0,r0,#1
000078  64e0              STR      r0,[r4,#0x4c]
;;;520    
;;;521            /* Clear the transfer error flag */
;;;522            regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
00007a  f8941054          LDRB     r1,[r4,#0x54]
00007e  2008              MOVS     r0,#8
000080  4088              LSLS     r0,r0,r1
000082  60a8              STR      r0,[r5,#8]
                  |L9.132|
;;;523          }
;;;524          if(tmp1 != RESET)
000084  f1ba0f00          CMP      r10,#0
000088  d008              BEQ      |L9.156|
;;;525          {
;;;526            /* Update error code */
;;;527            hdma->ErrorCode |= HAL_DMA_ERROR_FE;
00008a  6ce0              LDR      r0,[r4,#0x4c]
00008c  f0400002          ORR      r0,r0,#2
000090  64e0              STR      r0,[r4,#0x4c]
;;;528    
;;;529            /* Clear the FIFO error flag */
;;;530            regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
000092  f8941054          LDRB     r1,[r4,#0x54]
000096  483e              LDR      r0,|L9.400|
000098  4088              LSLS     r0,r0,r1
00009a  60a8              STR      r0,[r5,#8]
                  |L9.156|
;;;531          }
;;;532          if(tmp2 != RESET)
00009c  f1bb0f00          CMP      r11,#0
0000a0  d009              BEQ      |L9.182|
;;;533          {
;;;534            /* Update error code */
;;;535            hdma->ErrorCode |= HAL_DMA_ERROR_DME;
0000a2  6ce0              LDR      r0,[r4,#0x4c]
0000a4  f0400004          ORR      r0,r0,#4
0000a8  64e0              STR      r0,[r4,#0x4c]
;;;536    
;;;537            /* Clear the Direct Mode error flag */
;;;538            regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
0000aa  f8941054          LDRB     r1,[r4,#0x54]
0000ae  4838              LDR      r0,|L9.400|
0000b0  1cc0              ADDS     r0,r0,#3
0000b2  4088              LSLS     r0,r0,r1
0000b4  60a8              STR      r0,[r5,#8]
                  |L9.182|
;;;539          }
;;;540          /* Change the DMA state */
;;;541          hdma->State= HAL_DMA_STATE_ERROR;
0000b6  2004              MOVS     r0,#4
0000b8  f8840035          STRB     r0,[r4,#0x35]
;;;542    
;;;543          /* Process Unlocked */
;;;544          __HAL_UNLOCK(hdma);
0000bc  bf00              NOP      
0000be  2000              MOVS     r0,#0
0000c0  f8840034          STRB     r0,[r4,#0x34]
0000c4  bf00              NOP      
;;;545    
;;;546          return HAL_ERROR;
0000c6  2001              MOVS     r0,#1
                  |L9.200|
;;;547        }
;;;548        /* Check for the Timeout */
;;;549        if(Timeout != HAL_MAX_DELAY)
;;;550        {
;;;551          if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
;;;552          {
;;;553            /* Update error code */
;;;554            hdma->ErrorCode |= HAL_DMA_ERROR_TIMEOUT;
;;;555    
;;;556            /* Change the DMA state */
;;;557            hdma->State = HAL_DMA_STATE_TIMEOUT;
;;;558    
;;;559            /* Process Unlocked */
;;;560            __HAL_UNLOCK(hdma);
;;;561    
;;;562            return HAL_TIMEOUT;
;;;563          }
;;;564        }
;;;565      }
;;;566    
;;;567      if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
;;;568      {
;;;569        /* Clear the half transfer and transfer complete flags */
;;;570        regs->IFCR = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << hdma->StreamIndex;
;;;571    
;;;572        /* Multi_Buffering mode enabled */
;;;573        if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0)
;;;574        {
;;;575          /* Current memory buffer used is Memory 0 */
;;;576          if((hdma->Instance->CR & DMA_SxCR_CT) == 0)
;;;577          {
;;;578            /* Change DMA peripheral state */
;;;579            hdma->State = HAL_DMA_STATE_READY_MEM0;
;;;580          }
;;;581          /* Current memory buffer used is Memory 1 */
;;;582          else if((hdma->Instance->CR & DMA_SxCR_CT) != 0)
;;;583          {
;;;584            /* Change DMA peripheral state */
;;;585            hdma->State = HAL_DMA_STATE_READY_MEM1;
;;;586          }
;;;587        }
;;;588        else
;;;589        {
;;;590          /* The selected Streamx EN bit is cleared (DMA is disabled and all transfers
;;;591             are complete) */
;;;592          hdma->State = HAL_DMA_STATE_READY_MEM0;
;;;593        }
;;;594        /* Process Unlocked */
;;;595        __HAL_UNLOCK(hdma);
;;;596      }
;;;597      else
;;;598      {
;;;599        /* Clear the half transfer complete flag */
;;;600        regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
;;;601    
;;;602        /* Multi_Buffering mode enabled */
;;;603        if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0)
;;;604        {
;;;605          /* Current memory buffer used is Memory 0 */
;;;606          if((hdma->Instance->CR & DMA_SxCR_CT) == 0)
;;;607          {
;;;608            /* Change DMA peripheral state */
;;;609            hdma->State = HAL_DMA_STATE_READY_HALF_MEM0;
;;;610          }
;;;611          /* Current memory buffer used is Memory 1 */
;;;612          else if((hdma->Instance->CR & DMA_SxCR_CT) != 0)
;;;613          {
;;;614            /* Change DMA peripheral state */
;;;615            hdma->State = HAL_DMA_STATE_READY_HALF_MEM1;
;;;616          }
;;;617        }
;;;618        else
;;;619        {
;;;620          /* Change DMA peripheral state */
;;;621          hdma->State = HAL_DMA_STATE_READY_HALF_MEM0;
;;;622        }
;;;623      }
;;;624      return HAL_OK;
;;;625    }
0000c8  e8bd8ff8          POP      {r3-r11,pc}
                  |L9.204|
0000cc  1c70              ADDS     r0,r6,#1              ;549
0000ce  b1a0              CBZ      r0,|L9.250|
0000d0  b12e              CBZ      r6,|L9.222|
0000d2  f7fffffe          BL       HAL_GetTick
0000d6  9900              LDR      r1,[sp,#0]            ;551
0000d8  1a40              SUBS     r0,r0,r1              ;551
0000da  42b0              CMP      r0,r6                 ;551
0000dc  d90d              BLS      |L9.250|
                  |L9.222|
0000de  6ce0              LDR      r0,[r4,#0x4c]         ;554
0000e0  f0400020          ORR      r0,r0,#0x20           ;554
0000e4  64e0              STR      r0,[r4,#0x4c]         ;554
0000e6  2003              MOVS     r0,#3                 ;557
0000e8  f8840035          STRB     r0,[r4,#0x35]         ;557
0000ec  bf00              NOP                            ;560
0000ee  2000              MOVS     r0,#0                 ;560
0000f0  f8840034          STRB     r0,[r4,#0x34]         ;560
0000f4  bf00              NOP                            ;560
0000f6  2003              MOVS     r0,#3                 ;562
0000f8  e7e6              B        |L9.200|
                  |L9.250|
0000fa  6828              LDR      r0,[r5,#0]            ;509
0000fc  ea000008          AND      r0,r0,r8              ;509
000100  2800              CMP      r0,#0                 ;509
000102  d095              BEQ      |L9.48|
000104  bb1f              CBNZ     r7,|L9.334|
000106  f8941054          LDRB     r1,[r4,#0x54]         ;570
00010a  2030              MOVS     r0,#0x30              ;570
00010c  4088              LSLS     r0,r0,r1              ;570
00010e  60a8              STR      r0,[r5,#8]            ;570
000110  6820              LDR      r0,[r4,#0]            ;573
000112  6800              LDR      r0,[r0,#0]            ;573
000114  f4002080          AND      r0,r0,#0x40000        ;573
000118  b188              CBZ      r0,|L9.318|
00011a  6820              LDR      r0,[r4,#0]            ;576
00011c  6800              LDR      r0,[r0,#0]            ;576
00011e  f4002000          AND      r0,r0,#0x80000        ;576
000122  b918              CBNZ     r0,|L9.300|
000124  2011              MOVS     r0,#0x11              ;579
000126  f8840035          STRB     r0,[r4,#0x35]         ;579
00012a  e00b              B        |L9.324|
                  |L9.300|
00012c  6820              LDR      r0,[r4,#0]            ;582
00012e  6800              LDR      r0,[r0,#0]            ;582
000130  f4002000          AND      r0,r0,#0x80000        ;582
000134  b130              CBZ      r0,|L9.324|
000136  2021              MOVS     r0,#0x21              ;585
000138  f8840035          STRB     r0,[r4,#0x35]         ;585
00013c  e002              B        |L9.324|
                  |L9.318|
00013e  2011              MOVS     r0,#0x11              ;592
000140  f8840035          STRB     r0,[r4,#0x35]         ;592
                  |L9.324|
000144  bf00              NOP                            ;595
000146  2000              MOVS     r0,#0                 ;595
000148  f8840034          STRB     r0,[r4,#0x34]         ;595
00014c  e01e              B        |L9.396|
                  |L9.334|
00014e  f8941054          LDRB     r1,[r4,#0x54]         ;600
000152  2010              MOVS     r0,#0x10              ;600
000154  4088              LSLS     r0,r0,r1              ;600
000156  60a8              STR      r0,[r5,#8]            ;600
000158  6820              LDR      r0,[r4,#0]            ;603
00015a  6800              LDR      r0,[r0,#0]            ;603
00015c  f4002080          AND      r0,r0,#0x40000        ;603
000160  b188              CBZ      r0,|L9.390|
000162  6820              LDR      r0,[r4,#0]            ;606
000164  6800              LDR      r0,[r0,#0]            ;606
000166  f4002000          AND      r0,r0,#0x80000        ;606
00016a  b918              CBNZ     r0,|L9.372|
00016c  2031              MOVS     r0,#0x31              ;609
00016e  f8840035          STRB     r0,[r4,#0x35]         ;609
000172  e00b              B        |L9.396|
                  |L9.372|
000174  6820              LDR      r0,[r4,#0]            ;612
000176  6800              LDR      r0,[r0,#0]            ;612
000178  f4002000          AND      r0,r0,#0x80000        ;612
00017c  b130              CBZ      r0,|L9.396|
00017e  2041              MOVS     r0,#0x41              ;615
000180  f8840035          STRB     r0,[r4,#0x35]         ;615
000184  e002              B        |L9.396|
                  |L9.390|
000186  2031              MOVS     r0,#0x31              ;621
000188  f8840035          STRB     r0,[r4,#0x35]         ;621
                  |L9.396|
00018c  2000              MOVS     r0,#0                 ;624
00018e  e79b              B        |L9.200|
;;;626    
                          ENDP

                  |L9.400|
                          DCD      0x00800001

                          AREA ||i.HAL_DMA_Start||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Start PROC
;;;367      */
;;;368    HAL_StatusTypeDef HAL_DMA_Start(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;369    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;370      /* Process locked */
;;;371      __HAL_LOCK(hdma);
00000c  bf00              NOP      
00000e  f8940034          LDRB     r0,[r4,#0x34]
000012  2801              CMP      r0,#1
000014  d102              BNE      |L10.28|
000016  2002              MOVS     r0,#2
                  |L10.24|
;;;372    
;;;373      /* Change DMA peripheral state */
;;;374      hdma->State = HAL_DMA_STATE_BUSY;
;;;375    
;;;376       /* Check the parameters */
;;;377      assert_param(IS_DMA_BUFFER_SIZE(DataLength));
;;;378    
;;;379      /* Disable the peripheral */
;;;380      __HAL_DMA_DISABLE(hdma);
;;;381    
;;;382      /* Configure the source, destination address and the data length */
;;;383      DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
;;;384    
;;;385      /* Enable the Peripheral */
;;;386      __HAL_DMA_ENABLE(hdma);
;;;387    
;;;388      return HAL_OK; 
;;;389    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L10.28|
00001c  2001              MOVS     r0,#1                 ;371
00001e  f8840034          STRB     r0,[r4,#0x34]         ;371
000022  bf00              NOP                            ;371
000024  2002              MOVS     r0,#2                 ;374
000026  f8840035          STRB     r0,[r4,#0x35]         ;374
00002a  6820              LDR      r0,[r4,#0]            ;380
00002c  6800              LDR      r0,[r0,#0]            ;380
00002e  f0200001          BIC      r0,r0,#1              ;380
000032  6821              LDR      r1,[r4,#0]            ;380
000034  6008              STR      r0,[r1,#0]            ;380
000036  463b              MOV      r3,r7                 ;383
000038  4632              MOV      r2,r6                 ;383
00003a  4629              MOV      r1,r5                 ;383
00003c  4620              MOV      r0,r4                 ;383
00003e  f7fffffe          BL       DMA_SetConfig
000042  6820              LDR      r0,[r4,#0]            ;386
000044  6800              LDR      r0,[r0,#0]            ;386
000046  f0400001          ORR      r0,r0,#1              ;386
00004a  6821              LDR      r1,[r4,#0]            ;386
00004c  6008              STR      r0,[r1,#0]            ;386
00004e  2000              MOVS     r0,#0                 ;388
000050  e7e2              B        |L10.24|
;;;390    
                          ENDP


                          AREA ||i.HAL_DMA_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Start_IT PROC
;;;399      */
;;;400    HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;401    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;402      /* Process locked */
;;;403      __HAL_LOCK(hdma);
00000c  bf00              NOP      
00000e  f8940034          LDRB     r0,[r4,#0x34]
000012  2801              CMP      r0,#1
000014  d102              BNE      |L11.28|
000016  2002              MOVS     r0,#2
                  |L11.24|
;;;404    
;;;405      /* Change DMA peripheral state */
;;;406      hdma->State = HAL_DMA_STATE_BUSY;
;;;407    
;;;408       /* Check the parameters */
;;;409      assert_param(IS_DMA_BUFFER_SIZE(DataLength));
;;;410    
;;;411      /* Disable the peripheral */
;;;412      __HAL_DMA_DISABLE(hdma);
;;;413    
;;;414      /* Configure the source, destination address and the data length */
;;;415      DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
;;;416    
;;;417      /* Enable all interrupts */
;;;418      hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_HT | DMA_IT_TE | DMA_IT_DME;
;;;419      hdma->Instance->FCR |= DMA_IT_FE;
;;;420    
;;;421       /* Enable the Peripheral */
;;;422      __HAL_DMA_ENABLE(hdma);
;;;423    
;;;424      return HAL_OK;
;;;425    } 
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L11.28|
00001c  2001              MOVS     r0,#1                 ;403
00001e  f8840034          STRB     r0,[r4,#0x34]         ;403
000022  bf00              NOP                            ;403
000024  2002              MOVS     r0,#2                 ;406
000026  f8840035          STRB     r0,[r4,#0x35]         ;406
00002a  6820              LDR      r0,[r4,#0]            ;412
00002c  6800              LDR      r0,[r0,#0]            ;412
00002e  f0200001          BIC      r0,r0,#1              ;412
000032  6821              LDR      r1,[r4,#0]            ;412
000034  6008              STR      r0,[r1,#0]            ;412
000036  463b              MOV      r3,r7                 ;415
000038  4632              MOV      r2,r6                 ;415
00003a  4629              MOV      r1,r5                 ;415
00003c  4620              MOV      r0,r4                 ;415
00003e  f7fffffe          BL       DMA_SetConfig
000042  6820              LDR      r0,[r4,#0]            ;418
000044  6800              LDR      r0,[r0,#0]            ;418
000046  f040001e          ORR      r0,r0,#0x1e           ;418
00004a  6821              LDR      r1,[r4,#0]            ;418
00004c  6008              STR      r0,[r1,#0]            ;418
00004e  6820              LDR      r0,[r4,#0]            ;419
000050  6940              LDR      r0,[r0,#0x14]         ;419
000052  f0400080          ORR      r0,r0,#0x80           ;419
000056  6821              LDR      r1,[r4,#0]            ;419
000058  6148              STR      r0,[r1,#0x14]         ;419
00005a  6820              LDR      r0,[r4,#0]            ;422
00005c  6800              LDR      r0,[r0,#0]            ;422
00005e  f0400001          ORR      r0,r0,#1              ;422
000062  6821              LDR      r1,[r4,#0]            ;422
000064  6008              STR      r0,[r1,#0]            ;422
000066  2000              MOVS     r0,#0                 ;424
000068  e7d6              B        |L11.24|
;;;426    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  flagBitshiftOffset
000000  00061016          DCB      0x00,0x06,0x10,0x16
000004  00061016          DCB      0x00,0x06,0x10,0x16

;*** Start embedded assembler ***

#line 1 "HALLIB\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_dma.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_dma_c_c25f65ec____REV16|
#line 388 ".\\CORE\\cmsis_armcc.h"
|__asm___19_stm32f4xx_hal_dma_c_c25f65ec____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_dma_c_c25f65ec____REVSH|
#line 402
|__asm___19_stm32f4xx_hal_dma_c_c25f65ec____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_dma_c_c25f65ec____RRX|
#line 587
|__asm___19_stm32f4xx_hal_dma_c_c25f65ec____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
