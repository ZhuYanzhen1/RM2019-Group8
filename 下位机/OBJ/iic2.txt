; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\iic2.o --asm_dir=.\OBJ\ --list_dir=.\OBJ\ --depend=.\obj\iic2.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I.\CORE -I.\USER -I.\HALLIB\STM32F4xx_HAL_Driver\Inc -I.\SYSTEM -I.\Hardware -I.\App -I.\DSP_LIB\Include -I.\FreeRTOS -I.\MPU9250\DMP -I.\MPU9250 -I.\RTE\_Project -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=526 -DSTM32F427xx -DSTM32F4 -DUSE_HAL_DRIVER -DSTM32F427xx -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=.\obj\iic2.crf Hardware\IIC2.c]
                          THUMB

                          AREA ||i.IIC2_Ack||, CODE, READONLY, ALIGN=2

                  IIC2_Ack PROC
;;;77     //产生ACK应答
;;;78     void IIC2_Ack(void)
000000  b510              PUSH     {r4,lr}
;;;79     {
;;;80     	IIC2_SCL=0;
000002  2000              MOVS     r0,#0
000004  490a              LDR      r1,|L1.48|
000006  6008              STR      r0,[r1,#0]
;;;81     	SDA2_OUT();
000008  f7fffffe          BL       SDA2_OUT
;;;82     	IIC2_SDA=0;
00000c  2000              MOVS     r0,#0
00000e  4909              LDR      r1,|L1.52|
000010  f8c10280          STR      r0,[r1,#0x280]
;;;83     	Delayus(2);
000014  2002              MOVS     r0,#2
000016  f7fffffe          BL       Delayus
;;;84     	IIC2_SCL=1;
00001a  2001              MOVS     r0,#1
00001c  4904              LDR      r1,|L1.48|
00001e  6008              STR      r0,[r1,#0]
;;;85     	Delayus(2);
000020  2002              MOVS     r0,#2
000022  f7fffffe          BL       Delayus
;;;86     	IIC2_SCL=0;
000026  2000              MOVS     r0,#0
000028  4902              LDR      r1,|L1.52|
00002a  f8c10284          STR      r0,[r1,#0x284]
;;;87     }
00002e  bd10              POP      {r4,pc}
;;;88     //不产生ACK应答		    
                          ENDP

                  |L1.48|
                          DCD      0x42428284
                  |L1.52|
                          DCD      0x42428000

                          AREA ||i.IIC2_Init||, CODE, READONLY, ALIGN=2

                  IIC2_Init PROC
;;;4      
;;;5      void IIC2_Init(void)
000000  b500              PUSH     {lr}
;;;6      {
000002  b087              SUB      sp,sp,#0x1c
;;;7          GPIO_InitTypeDef GPIO_Initure;
;;;8          __HAL_RCC_GPIOF_CLK_ENABLE();
000004  bf00              NOP      
000006  2000              MOVS     r0,#0
000008  9001              STR      r0,[sp,#4]
00000a  4810              LDR      r0,|L2.76|
00000c  6800              LDR      r0,[r0,#0]
00000e  f0400020          ORR      r0,r0,#0x20
000012  490e              LDR      r1,|L2.76|
000014  6008              STR      r0,[r1,#0]
000016  4608              MOV      r0,r1
000018  6800              LDR      r0,[r0,#0]
00001a  f0000020          AND      r0,r0,#0x20
00001e  9001              STR      r0,[sp,#4]
000020  bf00              NOP      
000022  bf00              NOP      
;;;9          GPIO_Initure.Pin=GPIO_PIN_0|GPIO_PIN_1;
000024  2003              MOVS     r0,#3
000026  9002              STR      r0,[sp,#8]
;;;10         GPIO_Initure.Mode=GPIO_MODE_OUTPUT_PP;  //推挽输出
000028  2001              MOVS     r0,#1
00002a  9003              STR      r0,[sp,#0xc]
;;;11         GPIO_Initure.Pull=GPIO_PULLUP;          //上拉
00002c  9004              STR      r0,[sp,#0x10]
;;;12         GPIO_Initure.Speed=GPIO_SPEED_FAST;     //快速
00002e  2002              MOVS     r0,#2
000030  9005              STR      r0,[sp,#0x14]
;;;13         HAL_GPIO_Init(GPIOF,&GPIO_Initure);
000032  a902              ADD      r1,sp,#8
000034  4806              LDR      r0,|L2.80|
000036  f7fffffe          BL       HAL_GPIO_Init
;;;14         IIC2_SDA=1;
00003a  2001              MOVS     r0,#1
00003c  4905              LDR      r1,|L2.84|
00003e  6008              STR      r0,[r1,#0]
;;;15         IIC2_SCL=1;  
000040  4905              LDR      r1,|L2.88|
000042  f8c10284          STR      r0,[r1,#0x284]
;;;16     }
000046  b007              ADD      sp,sp,#0x1c
000048  bd00              POP      {pc}
;;;17     void SDA2_OUT()
                          ENDP

00004a  0000              DCW      0x0000
                  |L2.76|
                          DCD      0x40023830
                  |L2.80|
                          DCD      0x40021400
                  |L2.84|
                          DCD      0x42428280
                  |L2.88|
                          DCD      0x42428000

                          AREA ||i.IIC2_NAck||, CODE, READONLY, ALIGN=2

                  IIC2_NAck PROC
;;;88     //不产生ACK应答		    
;;;89     void IIC2_NAck(void)
000000  b510              PUSH     {r4,lr}
;;;90     {
;;;91     	IIC2_SCL=0;
000002  2000              MOVS     r0,#0
000004  490a              LDR      r1,|L3.48|
000006  6008              STR      r0,[r1,#0]
;;;92     	SDA2_OUT();
000008  f7fffffe          BL       SDA2_OUT
;;;93     	IIC2_SDA=1;
00000c  2001              MOVS     r0,#1
00000e  4909              LDR      r1,|L3.52|
000010  f8c10280          STR      r0,[r1,#0x280]
;;;94     	Delayus(2);
000014  2002              MOVS     r0,#2
000016  f7fffffe          BL       Delayus
;;;95     	IIC2_SCL=1;
00001a  2001              MOVS     r0,#1
00001c  4904              LDR      r1,|L3.48|
00001e  6008              STR      r0,[r1,#0]
;;;96     	Delayus(2);
000020  2002              MOVS     r0,#2
000022  f7fffffe          BL       Delayus
;;;97     	IIC2_SCL=0;
000026  2000              MOVS     r0,#0
000028  4902              LDR      r1,|L3.52|
00002a  f8c10284          STR      r0,[r1,#0x284]
;;;98     }					 				     
00002e  bd10              POP      {r4,pc}
;;;99     //IIC发送一个字节
                          ENDP

                  |L3.48|
                          DCD      0x42428284
                  |L3.52|
                          DCD      0x42428000

                          AREA ||i.IIC2_Read_Byte||, CODE, READONLY, ALIGN=2

                  IIC2_Read_Byte PROC
;;;119    //读1个字节，ack=1时，发送ACK，ack=0，发送nACK   
;;;120    u8 IIC2_Read_Byte(unsigned char ack)
000000  b570              PUSH     {r4-r6,lr}
;;;121    {
000002  4605              MOV      r5,r0
;;;122    		unsigned char i,receive=0;
000004  2400              MOVS     r4,#0
;;;123    		SDA2_IN();//SDA设置为输入
000006  f7fffffe          BL       SDA2_IN
;;;124        for(i=0;i<8;i++ )
00000a  2600              MOVS     r6,#0
00000c  e016              B        |L4.60|
                  |L4.14|
;;;125    		{
;;;126            IIC2_SCL=0; 
00000e  2000              MOVS     r0,#0
000010  490f              LDR      r1,|L4.80|
000012  6008              STR      r0,[r1,#0]
;;;127            Delayus(2);
000014  2002              MOVS     r0,#2
000016  f7fffffe          BL       Delayus
;;;128    				IIC2_SCL=1;
00001a  2001              MOVS     r0,#1
00001c  490d              LDR      r1,|L4.84|
00001e  f8c10284          STR      r0,[r1,#0x284]
;;;129            receive<<=1;
000022  0660              LSLS     r0,r4,#25
000024  0e04              LSRS     r4,r0,#24
;;;130            if(READ_SDA2)
000026  480a              LDR      r0,|L4.80|
000028  3884              SUBS     r0,r0,#0x84
00002a  6800              LDR      r0,[r0,#0]
00002c  b108              CBZ      r0,|L4.50|
;;;131    					receive++;   
00002e  1c60              ADDS     r0,r4,#1
000030  b2c4              UXTB     r4,r0
                  |L4.50|
;;;132    				Delayus(1); 
000032  2001              MOVS     r0,#1
000034  f7fffffe          BL       Delayus
000038  1c70              ADDS     r0,r6,#1              ;124
00003a  b2c6              UXTB     r6,r0                 ;124
                  |L4.60|
00003c  2e08              CMP      r6,#8                 ;124
00003e  dbe6              BLT      |L4.14|
;;;133        }					 
;;;134        if (!ack)
000040  b915              CBNZ     r5,|L4.72|
;;;135            IIC2_NAck();//发送nACK
000042  f7fffffe          BL       IIC2_NAck
000046  e001              B        |L4.76|
                  |L4.72|
;;;136        else
;;;137            IIC2_Ack(); //发送ACK   
000048  f7fffffe          BL       IIC2_Ack
                  |L4.76|
;;;138        return receive;
00004c  4620              MOV      r0,r4
;;;139    }
00004e  bd70              POP      {r4-r6,pc}
;;;140    
                          ENDP

                  |L4.80|
                          DCD      0x42428284
                  |L4.84|
                          DCD      0x42428000

                          AREA ||i.IIC2_Send_Byte||, CODE, READONLY, ALIGN=2

                  IIC2_Send_Byte PROC
;;;102    //0，无应答			  
;;;103    void IIC2_Send_Byte(u8 txd)
000000  b570              PUSH     {r4-r6,lr}
;;;104    {              
000002  4604              MOV      r4,r0
;;;105        u8 t;   
;;;106    		SDA2_OUT(); 	    
000004  f7fffffe          BL       SDA2_OUT
;;;107        IIC2_SCL=0;//拉低时钟开始数据传输
000008  2000              MOVS     r0,#0
00000a  490f              LDR      r1,|L5.72|
00000c  6008              STR      r0,[r1,#0]
;;;108        for(t=0;t<8;t++)
00000e  2500              MOVS     r5,#0
000010  e017              B        |L5.66|
                  |L5.18|
;;;109        {              
;;;110            IIC2_SDA=(txd&0x80)>>7;
000012  09e0              LSRS     r0,r4,#7
000014  490c              LDR      r1,|L5.72|
000016  1f09              SUBS     r1,r1,#4
000018  6008              STR      r0,[r1,#0]
;;;111            txd<<=1; 	  
00001a  0660              LSLS     r0,r4,#25
00001c  0e04              LSRS     r4,r0,#24
;;;112    				Delayus(2);   //对TEA5767这三个延时都是必须的
00001e  2002              MOVS     r0,#2
000020  f7fffffe          BL       Delayus
;;;113    				IIC2_SCL=1;
000024  2001              MOVS     r0,#1
000026  4909              LDR      r1,|L5.76|
000028  f8c10284          STR      r0,[r1,#0x284]
;;;114    				Delayus(2); 
00002c  2002              MOVS     r0,#2
00002e  f7fffffe          BL       Delayus
;;;115    				IIC2_SCL=0;	
000032  2000              MOVS     r0,#0
000034  4904              LDR      r1,|L5.72|
000036  6008              STR      r0,[r1,#0]
;;;116    				Delayus(2);
000038  2002              MOVS     r0,#2
00003a  f7fffffe          BL       Delayus
00003e  1c68              ADDS     r0,r5,#1              ;108
000040  b2c5              UXTB     r5,r0                 ;108
                  |L5.66|
000042  2d08              CMP      r5,#8                 ;108
000044  dbe5              BLT      |L5.18|
;;;117        }	 
;;;118    } 	    
000046  bd70              POP      {r4-r6,pc}
;;;119    //读1个字节，ack=1时，发送ACK，ack=0，发送nACK   
                          ENDP

                  |L5.72|
                          DCD      0x42428284
                  |L5.76|
                          DCD      0x42428000

                          AREA ||i.IIC2_Start||, CODE, READONLY, ALIGN=2

                  IIC2_Start PROC
;;;34     //产生IIC起始信号
;;;35     void IIC2_Start(void)
000000  b510              PUSH     {r4,lr}
;;;36     {
;;;37     	SDA2_OUT();     //sda线输出
000002  f7fffffe          BL       SDA2_OUT
;;;38     	IIC2_SDA=1;	  	  
000006  2001              MOVS     r0,#1
000008  4909              LDR      r1,|L6.48|
00000a  6008              STR      r0,[r1,#0]
;;;39     	IIC2_SCL=1;
00000c  4909              LDR      r1,|L6.52|
00000e  f8c10284          STR      r0,[r1,#0x284]
;;;40     	Delayus(4);
000012  2004              MOVS     r0,#4
000014  f7fffffe          BL       Delayus
;;;41      	IIC2_SDA=0;//START:when CLK is high,DATA change form high to low 
000018  2000              MOVS     r0,#0
00001a  4905              LDR      r1,|L6.48|
00001c  6008              STR      r0,[r1,#0]
;;;42     	Delayus(4);
00001e  2004              MOVS     r0,#4
000020  f7fffffe          BL       Delayus
;;;43     	IIC2_SCL=0;//钳住I2C总线，准备发送或接收数据 
000024  2000              MOVS     r0,#0
000026  4903              LDR      r1,|L6.52|
000028  f8c10284          STR      r0,[r1,#0x284]
;;;44     }	  
00002c  bd10              POP      {r4,pc}
;;;45     //产生IIC停止信号
                          ENDP

00002e  0000              DCW      0x0000
                  |L6.48|
                          DCD      0x42428280
                  |L6.52|
                          DCD      0x42428000

                          AREA ||i.IIC2_Stop||, CODE, READONLY, ALIGN=2

                  IIC2_Stop PROC
;;;45     //产生IIC停止信号
;;;46     void IIC2_Stop(void)
000000  b510              PUSH     {r4,lr}
;;;47     {
;;;48     	SDA2_OUT();//sda线输出
000002  f7fffffe          BL       SDA2_OUT
;;;49     	IIC2_SCL=0;
000006  2000              MOVS     r0,#0
000008  4909              LDR      r1,|L7.48|
00000a  6008              STR      r0,[r1,#0]
;;;50     	IIC2_SDA=0;//STOP:when CLK is high DATA change form low to high
00000c  4909              LDR      r1,|L7.52|
00000e  f8c10280          STR      r0,[r1,#0x280]
;;;51      	Delayus(4);
000012  2004              MOVS     r0,#4
000014  f7fffffe          BL       Delayus
;;;52     	IIC2_SCL=1; 
000018  2001              MOVS     r0,#1
00001a  4905              LDR      r1,|L7.48|
00001c  6008              STR      r0,[r1,#0]
;;;53     	Delayus(4);			
00001e  2004              MOVS     r0,#4
000020  f7fffffe          BL       Delayus
;;;54     	IIC2_SDA=1;//发送I2C总线结束信号				   	
000024  2001              MOVS     r0,#1
000026  4903              LDR      r1,|L7.52|
000028  f8c10280          STR      r0,[r1,#0x280]
;;;55     }
00002c  bd10              POP      {r4,pc}
;;;56     //等待应答信号到来
                          ENDP

00002e  0000              DCW      0x0000
                  |L7.48|
                          DCD      0x42428284
                  |L7.52|
                          DCD      0x42428000

                          AREA ||i.IIC2_Wait_Ack||, CODE, READONLY, ALIGN=2

                  IIC2_Wait_Ack PROC
;;;58     //        0，接收应答成功
;;;59     u8 IIC2_Wait_Ack(void)
000000  b510              PUSH     {r4,lr}
;;;60     {
;;;61     	u8 ucErrTime=0;
000002  2400              MOVS     r4,#0
;;;62     	SDA2_IN();      //SDA设置为输入  
000004  f7fffffe          BL       SDA2_IN
;;;63     	IIC2_SDA=1;Delayus(1);	   
000008  2001              MOVS     r0,#1
00000a  490e              LDR      r1,|L8.68|
00000c  6008              STR      r0,[r1,#0]
00000e  f7fffffe          BL       Delayus
;;;64     	IIC2_SCL=1;Delayus(1);	 
000012  2001              MOVS     r0,#1
000014  490c              LDR      r1,|L8.72|
000016  f8c10284          STR      r0,[r1,#0x284]
00001a  f7fffffe          BL       Delayus
;;;65     	while(READ_SDA2)
00001e  e007              B        |L8.48|
                  |L8.32|
;;;66     	{
;;;67     		ucErrTime++;
000020  1c60              ADDS     r0,r4,#1
000022  b2c4              UXTB     r4,r0
;;;68     		if(ucErrTime>250)
000024  2cfa              CMP      r4,#0xfa
000026  dd03              BLE      |L8.48|
;;;69     		{
;;;70     			IIC2_Stop();
000028  f7fffffe          BL       IIC2_Stop
;;;71     			return 1;
00002c  2001              MOVS     r0,#1
                  |L8.46|
;;;72     		}
;;;73     	}
;;;74     	IIC2_SCL=0;//时钟输出0 	   
;;;75     	return 0;  
;;;76     } 
00002e  bd10              POP      {r4,pc}
                  |L8.48|
000030  4804              LDR      r0,|L8.68|
000032  3880              SUBS     r0,r0,#0x80           ;65
000034  6800              LDR      r0,[r0,#0]            ;65
000036  2800              CMP      r0,#0                 ;65
000038  d1f2              BNE      |L8.32|
00003a  4902              LDR      r1,|L8.68|
00003c  1d09              ADDS     r1,r1,#4              ;74
00003e  6008              STR      r0,[r1,#0]            ;74
000040  bf00              NOP                            ;75
000042  e7f4              B        |L8.46|
;;;77     //产生ACK应答
                          ENDP

                  |L8.68|
                          DCD      0x42428280
                  |L8.72|
                          DCD      0x42428000

                          AREA ||i.SDA2_IN||, CODE, READONLY, ALIGN=2

                  SDA2_IN PROC
;;;25     }
;;;26     void SDA2_IN()
000000  b500              PUSH     {lr}
;;;27     {
000002  b085              SUB      sp,sp,#0x14
;;;28     	GPIO_InitTypeDef GPIO_Initure;
;;;29     	GPIO_Initure.Pin=GPIO_PIN_0;
000004  2001              MOVS     r0,#1
000006  9000              STR      r0,[sp,#0]
;;;30       GPIO_Initure.Mode=GPIO_MODE_INPUT;
000008  2000              MOVS     r0,#0
00000a  9001              STR      r0,[sp,#4]
;;;31     	GPIO_Initure.Pull=GPIO_PULLUP;          //上拉
00000c  2001              MOVS     r0,#1
00000e  9002              STR      r0,[sp,#8]
;;;32       HAL_GPIO_Init(GPIOF,&GPIO_Initure);
000010  4669              MOV      r1,sp
000012  4802              LDR      r0,|L9.28|
000014  f7fffffe          BL       HAL_GPIO_Init
;;;33     }
000018  b005              ADD      sp,sp,#0x14
00001a  bd00              POP      {pc}
;;;34     //产生IIC起始信号
                          ENDP

                  |L9.28|
                          DCD      0x40021400

                          AREA ||i.SDA2_OUT||, CODE, READONLY, ALIGN=2

                  SDA2_OUT PROC
;;;16     }
;;;17     void SDA2_OUT()
000000  b500              PUSH     {lr}
;;;18     {
000002  b085              SUB      sp,sp,#0x14
;;;19     	GPIO_InitTypeDef GPIO_Initure;
;;;20     	GPIO_Initure.Pin=GPIO_PIN_0;
000004  2001              MOVS     r0,#1
000006  9000              STR      r0,[sp,#0]
;;;21       GPIO_Initure.Mode=GPIO_MODE_OUTPUT_PP;  //推挽输出
000008  9001              STR      r0,[sp,#4]
;;;22       GPIO_Initure.Pull=GPIO_PULLUP;          //上拉
00000a  9002              STR      r0,[sp,#8]
;;;23       GPIO_Initure.Speed=GPIO_SPEED_FAST;     //快速
00000c  2002              MOVS     r0,#2
00000e  9003              STR      r0,[sp,#0xc]
;;;24       HAL_GPIO_Init(GPIOF,&GPIO_Initure);
000010  4669              MOV      r1,sp
000012  4802              LDR      r0,|L10.28|
000014  f7fffffe          BL       HAL_GPIO_Init
;;;25     }
000018  b005              ADD      sp,sp,#0x14
00001a  bd00              POP      {pc}
;;;26     void SDA2_IN()
                          ENDP

                  |L10.28|
                          DCD      0x40021400

;*** Start embedded assembler ***

#line 1 "Hardware\\IIC2.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_IIC2_c_63fa7d3a____REV16|
#line 388 ".\\CORE\\cmsis_armcc.h"
|__asm___6_IIC2_c_63fa7d3a____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_IIC2_c_63fa7d3a____REVSH|
#line 402
|__asm___6_IIC2_c_63fa7d3a____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_IIC2_c_63fa7d3a____RRX|
#line 587
|__asm___6_IIC2_c_63fa7d3a____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
